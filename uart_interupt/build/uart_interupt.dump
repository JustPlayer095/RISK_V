
build/uart_interupt.elf:     file format elf32-littleriscv


Disassembly of section .text.startup:

80000000 <_start>:
    .section ".startup.entry","ax",@progbits

    ## Entry point
_start:
    ## reset mstatus
    csrw  mstatus, zero
80000000:	30001073          	csrw	mstatus,zero
li x31, 0
#endif // !__riscv_32e
#endif // PLF_INIT_REGS

    ## setup gp
    load_addrword_abs gp, __global_pointer$
80000004:	400001b7          	lui	gp,0x40000
80000008:	78018193          	addi	gp,gp,1920 # 40000780 <__global_pointer$>
    ## setup MTVEC
    load_addrword_abs t0, trap_entry
8000000c:	800002b7          	lui	t0,0x80000
80000010:	14028293          	addi	t0,t0,320 # 80000140 <__data_source_start+0xffff8fc8>
    csrw  mtvec, t0
80000014:	30529073          	csrw	mtvec,t0
    ## setup MIE, MIP


    csrw  mie, zero
80000018:	30401073          	csrw	mie,zero
    csrw  mip, zero
8000001c:	34401073          	csrw	mip,zero
    load_const_int32 t1, __TEXT_INIT_SIZE__
    cache_flush t0, t1
#endif // PLF_CACHE_CFG

    ## init FPU (if supported)
    csrr  a0, misa
80000020:	30102573          	csrr	a0,misa
    andi  a0, a0, (1 << ('F' - 'A')) | (1 << ('D' - 'A'))
80000024:	02857513          	andi	a0,a0,40
    beqz  a0, 1f
80000028:	00050863          	beqz	a0,80000038 <_start+0x38>
    li    a0, (1 << 13) // mstatus.FS = 1 (initial)
8000002c:	00002537          	lui	a0,0x2
    csrs  mstatus, a0
80000030:	30052073          	csrs	mstatus,a0
    csrw  fcsr, zero
80000034:	00301073          	fscsr	zero
#else
#define slave_hart_start _hart_halt
#endif // PLF_SMP_SUPPORT

    ## park/prep SMP slaves
    csrr  a0, mhartid
80000038:	f1402573          	csrr	a0,mhartid
#if PLF_SMP_MASTER_HARTID > 0
    li    t0, PLF_SMP_MASTER_HARTID
    bne   a0, t0, slave_hart_start
#endif // PLF_SMP_MASTER_HARTID > 0
#else // PLF_SMP_MASTER_HARTID
    bnez  a0, slave_hart_start
8000003c:	04051463          	bnez	a0,80000084 <_hart_halt>
#endif // PLF_SMP_MASTER_HARTID

    ## init HART#0 sp, tp
    load_addrword_abs sp, __TLS0_BASE__
80000040:	40040137          	lui	sp,0x40040
80000044:	00010113          	mv	sp,sp
    mv    tp, sp
80000048:	00010213          	mv	tp,sp
    csrw  mscratch, sp
8000004c:	34011073          	csrw	mscratch,sp
    // reserve trap stack space
    li    t0, PLF_TRAP_STACK
    sub   sp, sp, t0
#endif // PLF_TRAP_STACK
    ## platform init
    load_addrword t0, plf_init
80000050:	800002b7          	lui	t0,0x80000
80000054:	0ae28293          	addi	t0,t0,174 # 800000ae <__data_source_start+0xffff8f36>
    jalr  t0
80000058:	000280e7          	jalr	t0
    ## jal  plf_init
    ## application-specific initialization hook
    load_addrword t0, app_init
8000005c:	800002b7          	lui	t0,0x80000
80000060:	09c28293          	addi	t0,t0,156 # 8000009c <__data_source_start+0xffff8f24>
    jalr  t0
80000064:	000280e7          	jalr	t0
    ## jal  app_init
    ## main() args
    li    a0, 0
80000068:	00000513          	li	a0,0
    li    a1, 0
8000006c:	00000593          	li	a1,0
#if PLF_SMP_NON_COHERENT
    clflush t1
#endif // PLF_SMP_NON_COHERENT
#endif // PLF_SMP_SUPPORT
    ## start main
    load_addrword t0, main
80000070:	800022b7          	lui	t0,0x80002
80000074:	9d428293          	addi	t0,t0,-1580 # 800019d4 <__data_source_start+0xffffa85c>
    load_addrword ra, exit
80000078:	800000b7          	lui	ra,0x80000
8000007c:	09408093          	addi	ra,ra,148 # 80000094 <__data_source_start+0xffff8f1c>
    jr    t0
80000080:	00028067          	jr	t0

80000084 <_hart_halt>:
1:  wfi
    j     1b
#endif // PLF_SMP_SUPPORT
#else // PLF_HTIF_BASE
    ## disable interrupts
    csrci mstatus, 0xf
80000084:	3007f073          	csrci	mstatus,15
    csrw  mie, zero
80000088:	30401073          	csrw	mie,zero
1:  wfi
8000008c:	10500073          	wfi
    j     1b
80000090:	ffdff06f          	j	8000008c <_hart_halt+0x8>

80000094 <exit>:
#endif // PLF_HTIF_BASE

exit:
    nop
80000094:	00000013          	nop

80000098 <abort>:
abort:
    j     _hart_halt
80000098:	fedff06f          	j	80000084 <_hart_halt>

8000009c <app_init>:
    jr    t0
#endif // PLF_SMP_SUPPORT

    ## stubs
app_init:
    ret
8000009c:	00008067          	ret

800000a0 <plf_init_noreloc>:
extern void plf_init_relocate(void) __attribute__((weak));

extern char __bss_start[], __bss_end[];

void __init plf_init_noreloc(void)
{
800000a0:	1141                	addi	sp,sp,-16 # 4003fff0 <__STACK_START__+0x7f0>
800000a2:	c622                	sw	s0,12(sp)
800000a4:	0800                	addi	s0,sp,16
    // do nothing
}
800000a6:	0001                	nop
800000a8:	4432                	lw	s0,12(sp)
800000aa:	0141                	addi	sp,sp,16
800000ac:	8082                	ret

800000ae <plf_init_generic>:

void __init plf_init_generic(void)
{
800000ae:	1141                	addi	sp,sp,-16
800000b0:	c606                	sw	ra,12(sp)
800000b2:	c422                	sw	s0,8(sp)
800000b4:	0800                	addi	s0,sp,16
    // init BSS
    memset(__bss_start, 0, (size_t)(__bss_end - __bss_start));
800000b6:	f7418713          	addi	a4,gp,-140 # 400006f4 <__BSS_END__>
800000ba:	e1018793          	addi	a5,gp,-496 # 40000590 <SystemCoreClock>
800000be:	40f707b3          	sub	a5,a4,a5
800000c2:	863e                	mv	a2,a5
800000c4:	4581                	li	a1,0
800000c6:	e1018513          	addi	a0,gp,-496 # 40000590 <SystemCoreClock>
800000ca:	4e3060ef          	jal	ra,80006dac <memset>

    memcpy((void*)&__data_target_start,
           (const void*)&__data_source_start,
           (&__data_target_end - &__data_target_start));
800000ce:	e1018713          	addi	a4,gp,-496 # 40000590 <SystemCoreClock>
800000d2:	88818793          	addi	a5,gp,-1912 # 40000008 <mach_plic_handler>
800000d6:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__data_target_start,
800000da:	863e                	mv	a2,a5
800000dc:	800077b7          	lui	a5,0x80007
800000e0:	17878593          	addi	a1,a5,376 # 80007178 <__data_source_start+0x0>
800000e4:	88818513          	addi	a0,gp,-1912 # 40000008 <mach_plic_handler>
800000e8:	4af060ef          	jal	ra,80006d96 <memcpy>

    memcpy((void*)&__sdata_target_start,
              (const void*)&__sdata_source_start,
              (&__sdata_target_end - &__sdata_target_start));
800000ec:	88818713          	addi	a4,gp,-1912 # 40000008 <mach_plic_handler>
800000f0:	88018793          	addi	a5,gp,-1920 # 40000000 <prev_btn_state>
800000f4:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__sdata_target_start,
800000f8:	863e                	mv	a2,a5
800000fa:	800077b7          	lui	a5,0x80007
800000fe:	17078593          	addi	a1,a5,368 # 80007170 <__data_source_start+0xfffffff8>
80000102:	88018513          	addi	a0,gp,-1920 # 40000000 <prev_btn_state>
80000106:	491060ef          	jal	ra,80006d96 <memcpy>
}
8000010a:	0001                	nop
8000010c:	40b2                	lw	ra,12(sp)
8000010e:	4422                	lw	s0,8(sp)
80000110:	0141                	addi	sp,sp,16
80000112:	8082                	ret

Disassembly of section .text.crt:

80000140 <trap_entry>:
    .section ".text.crt.trap_entry","ax",@progbits
    .align 6
    .type trap_entry, @function
trap_entry:
    ## save context
    context_save
80000140:	fe512e23          	sw	t0,-4(sp)
80000144:	00010293          	mv	t0,sp
80000148:	f8010113          	addi	sp,sp,-128
8000014c:	ff017113          	andi	sp,sp,-16
80000150:	00112223          	sw	ra,4(sp)
80000154:	00512423          	sw	t0,8(sp)
80000158:	ffc2a283          	lw	t0,-4(t0)
8000015c:	00312623          	sw	gp,12(sp)
80000160:	00412823          	sw	tp,16(sp)
80000164:	00512a23          	sw	t0,20(sp)
80000168:	00612c23          	sw	t1,24(sp)
8000016c:	00712e23          	sw	t2,28(sp)
80000170:	02812023          	sw	s0,32(sp)
80000174:	02912223          	sw	s1,36(sp)
80000178:	02a12423          	sw	a0,40(sp)
8000017c:	02b12623          	sw	a1,44(sp)
80000180:	02c12823          	sw	a2,48(sp)
80000184:	02d12a23          	sw	a3,52(sp)
80000188:	02e12c23          	sw	a4,56(sp)
8000018c:	02f12e23          	sw	a5,60(sp)
80000190:	05012023          	sw	a6,64(sp)
80000194:	05112223          	sw	a7,68(sp)
80000198:	05212423          	sw	s2,72(sp)
8000019c:	05312623          	sw	s3,76(sp)
800001a0:	05412823          	sw	s4,80(sp)
800001a4:	05512a23          	sw	s5,84(sp)
800001a8:	05612c23          	sw	s6,88(sp)
800001ac:	05712e23          	sw	s7,92(sp)
800001b0:	07812023          	sw	s8,96(sp)
800001b4:	07912223          	sw	s9,100(sp)
800001b8:	07a12423          	sw	s10,104(sp)
800001bc:	07b12623          	sw	s11,108(sp)
800001c0:	07c12823          	sw	t3,112(sp)
800001c4:	07d12a23          	sw	t4,116(sp)
800001c8:	07e12c23          	sw	t5,120(sp)
800001cc:	07f12e23          	sw	t6,124(sp)
800001d0:	34002273          	csrr	tp,mscratch
800001d4:	34102373          	csrr	t1,mepc
800001d8:	00612023          	sw	t1,0(sp)
    ## save mstatus priv stack
    csrr s0, mstatus
800001dc:	30002473          	csrr	s0,mstatus
    ## load trap handler args
    csrr a0, mcause
800001e0:	34202573          	csrr	a0,mcause
    csrr a1, mepc
800001e4:	341025f3          	csrr	a1,mepc
    mv   a2, sp
800001e8:	00010613          	mv	a2,sp

    ## setup gp
    load_addrword_abs gp, __global_pointer$
800001ec:	400001b7          	lui	gp,0x40000
800001f0:	78018193          	addi	gp,gp,1920 # 40000780 <__global_pointer$>
    ## call trap handler
    load_addrword t0, trap_handler
800001f4:	800002b7          	lui	t0,0x80000
800001f8:	55028293          	addi	t0,t0,1360 # 80000550 <__data_source_start+0xffff93d8>
    jalr t0
800001fc:	000280e7          	jalr	t0

    ## restore mstatus priv stack
    csrw mstatus, s0
80000200:	30041073          	csrw	mstatus,s0
    ## restore context
    context_restore
80000204:	00012303          	lw	t1,0(sp)
80000208:	34131073          	csrw	mepc,t1
8000020c:	00c12183          	lw	gp,12(sp)
80000210:	01012203          	lw	tp,16(sp)
80000214:	01412283          	lw	t0,20(sp)
80000218:	01812303          	lw	t1,24(sp)
8000021c:	01c12383          	lw	t2,28(sp)
80000220:	02012403          	lw	s0,32(sp)
80000224:	02412483          	lw	s1,36(sp)
80000228:	02812503          	lw	a0,40(sp)
8000022c:	02c12583          	lw	a1,44(sp)
80000230:	03012603          	lw	a2,48(sp)
80000234:	03412683          	lw	a3,52(sp)
80000238:	03812703          	lw	a4,56(sp)
8000023c:	03c12783          	lw	a5,60(sp)
80000240:	04012803          	lw	a6,64(sp)
80000244:	04412883          	lw	a7,68(sp)
80000248:	04812903          	lw	s2,72(sp)
8000024c:	04c12983          	lw	s3,76(sp)
80000250:	05012a03          	lw	s4,80(sp)
80000254:	05412a83          	lw	s5,84(sp)
80000258:	05812b03          	lw	s6,88(sp)
8000025c:	05c12b83          	lw	s7,92(sp)
80000260:	06012c03          	lw	s8,96(sp)
80000264:	06412c83          	lw	s9,100(sp)
80000268:	06812d03          	lw	s10,104(sp)
8000026c:	06c12d83          	lw	s11,108(sp)
80000270:	07012e03          	lw	t3,112(sp)
80000274:	07412e83          	lw	t4,116(sp)
80000278:	07812f03          	lw	t5,120(sp)
8000027c:	07c12f83          	lw	t6,124(sp)
80000280:	00412083          	lw	ra,4(sp)
80000284:	00812103          	lw	sp,8(sp)
    mret
80000288:	30200073          	mret
	...

Disassembly of section .text:

800002c4 <PLIC_SetIrqHandler>:
/*
 * Set PLIC handler function for isr num
 */

void PLIC_SetIrqHandler (uint8_t target, uint32_t isr_num, irqfunc* func)
{
800002c4:	1101                	addi	sp,sp,-32
800002c6:	ce22                	sw	s0,28(sp)
800002c8:	1000                	addi	s0,sp,32
800002ca:	87aa                	mv	a5,a0
800002cc:	feb42423          	sw	a1,-24(s0)
800002d0:	fec42223          	sw	a2,-28(s0)
800002d4:	fef407a3          	sb	a5,-17(s0)
    if(target == Plic_Mach_Target) {
800002d8:	fef44783          	lbu	a5,-17(s0)
800002dc:	ef89                	bnez	a5,800002f6 <PLIC_SetIrqHandler+0x32>
        mach_plic_handler[isr_num] = func;
800002de:	400007b7          	lui	a5,0x40000
800002e2:	00878713          	addi	a4,a5,8 # 40000008 <mach_plic_handler>
800002e6:	fe842783          	lw	a5,-24(s0)
800002ea:	078a                	slli	a5,a5,0x2
800002ec:	97ba                	add	a5,a5,a4
800002ee:	fe442703          	lw	a4,-28(s0)
800002f2:	c398                	sw	a4,0(a5)
    } else {
        supervisor_plic_handler[isr_num] = func;
    }
}
800002f4:	a811                	j	80000308 <PLIC_SetIrqHandler+0x44>
        supervisor_plic_handler[isr_num] = func;
800002f6:	90818713          	addi	a4,gp,-1784 # 40000088 <supervisor_plic_handler>
800002fa:	fe842783          	lw	a5,-24(s0)
800002fe:	078a                	slli	a5,a5,0x2
80000300:	97ba                	add	a5,a5,a4
80000302:	fe442703          	lw	a4,-28(s0)
80000306:	c398                	sw	a4,0(a5)
}
80000308:	0001                	nop
8000030a:	4472                	lw	s0,28(sp)
8000030c:	6105                	addi	sp,sp,32
8000030e:	8082                	ret

80000310 <PLIC_SetPriority>:
/*
 * Set PLIC irq priority
 */

void PLIC_SetPriority (uint32_t isr_num, uint8_t pri)
{
80000310:	1101                	addi	sp,sp,-32
80000312:	ce22                	sw	s0,28(sp)
80000314:	1000                	addi	s0,sp,32
80000316:	fea42623          	sw	a0,-20(s0)
8000031a:	87ae                	mv	a5,a1
8000031c:	fef405a3          	sb	a5,-21(s0)
    PLIC->PRI[isr_num] = pri;
80000320:	0c0006b7          	lui	a3,0xc000
80000324:	feb44703          	lbu	a4,-21(s0)
80000328:	fec42783          	lw	a5,-20(s0)
8000032c:	078a                	slli	a5,a5,0x2
8000032e:	97b6                	add	a5,a5,a3
80000330:	c398                	sw	a4,0(a5)
}
80000332:	0001                	nop
80000334:	4472                	lw	s0,28(sp)
80000336:	6105                	addi	sp,sp,32
80000338:	8082                	ret

8000033a <PLIC_IntEnable>:
/*
 * Enable PLIC irq
 */

void PLIC_IntEnable (uint8_t target, uint32_t isr_num)
{
8000033a:	7179                	addi	sp,sp,-48
8000033c:	d622                	sw	s0,44(sp)
8000033e:	1800                	addi	s0,sp,48
80000340:	87aa                	mv	a5,a0
80000342:	fcb42c23          	sw	a1,-40(s0)
80000346:	fcf40fa3          	sb	a5,-33(s0)
	uint32_t value;

	//read - modify - write operation

    if(target == Plic_Mach_Target) {
8000034a:	fdf44783          	lbu	a5,-33(s0)
8000034e:	eb9d                	bnez	a5,80000384 <PLIC_IntEnable+0x4a>
    	value  = PLIC->MIEM0;
80000350:	0c000737          	lui	a4,0xc000
80000354:	6789                	lui	a5,0x2
80000356:	97ba                	add	a5,a5,a4
80000358:	439c                	lw	a5,0(a5)
8000035a:	fef42623          	sw	a5,-20(s0)
    	value |= (1<<isr_num);
8000035e:	fd842783          	lw	a5,-40(s0)
80000362:	4705                	li	a4,1
80000364:	00f717b3          	sll	a5,a4,a5
80000368:	873e                	mv	a4,a5
8000036a:	fec42783          	lw	a5,-20(s0)
8000036e:	8fd9                	or	a5,a5,a4
80000370:	fef42623          	sw	a5,-20(s0)
    	PLIC->MIEM0 = value;
80000374:	0c000737          	lui	a4,0xc000
80000378:	6789                	lui	a5,0x2
8000037a:	97ba                	add	a5,a5,a4
8000037c:	fec42703          	lw	a4,-20(s0)
80000380:	c398                	sw	a4,0(a5)
    } else {
    	value = PLIC->UIEM0;
    	value |= (1<<isr_num);
    	PLIC->UIEM0 = value;
    }
}
80000382:	a825                	j	800003ba <PLIC_IntEnable+0x80>
    	value = PLIC->UIEM0;
80000384:	0c000737          	lui	a4,0xc000
80000388:	6789                	lui	a5,0x2
8000038a:	97ba                	add	a5,a5,a4
8000038c:	0807a783          	lw	a5,128(a5) # 2080 <STACK_SIZE+0x1880>
80000390:	fef42623          	sw	a5,-20(s0)
    	value |= (1<<isr_num);
80000394:	fd842783          	lw	a5,-40(s0)
80000398:	4705                	li	a4,1
8000039a:	00f717b3          	sll	a5,a4,a5
8000039e:	873e                	mv	a4,a5
800003a0:	fec42783          	lw	a5,-20(s0)
800003a4:	8fd9                	or	a5,a5,a4
800003a6:	fef42623          	sw	a5,-20(s0)
    	PLIC->UIEM0 = value;
800003aa:	0c000737          	lui	a4,0xc000
800003ae:	6789                	lui	a5,0x2
800003b0:	97ba                	add	a5,a5,a4
800003b2:	fec42703          	lw	a4,-20(s0)
800003b6:	08e7a023          	sw	a4,128(a5) # 2080 <STACK_SIZE+0x1880>
}
800003ba:	0001                	nop
800003bc:	5432                	lw	s0,44(sp)
800003be:	6145                	addi	sp,sp,48
800003c0:	8082                	ret

800003c2 <PLIC_IntDisable>:
/*
 * Disable PLIC irq
 */

void PLIC_IntDisable (uint8_t target, uint32_t isr_num)
{
800003c2:	7179                	addi	sp,sp,-48
800003c4:	d622                	sw	s0,44(sp)
800003c6:	1800                	addi	s0,sp,48
800003c8:	87aa                	mv	a5,a0
800003ca:	fcb42c23          	sw	a1,-40(s0)
800003ce:	fcf40fa3          	sb	a5,-33(s0)
	uint32_t value;

	//read - modify - write operation

	if(target == Plic_Mach_Target) {
800003d2:	fdf44783          	lbu	a5,-33(s0)
800003d6:	ef8d                	bnez	a5,80000410 <PLIC_IntDisable+0x4e>
		value  = PLIC->MIEM0;
800003d8:	0c000737          	lui	a4,0xc000
800003dc:	6789                	lui	a5,0x2
800003de:	97ba                	add	a5,a5,a4
800003e0:	439c                	lw	a5,0(a5)
800003e2:	fef42623          	sw	a5,-20(s0)
		value &= ~(1<<isr_num);
800003e6:	fd842783          	lw	a5,-40(s0)
800003ea:	4705                	li	a4,1
800003ec:	00f717b3          	sll	a5,a4,a5
800003f0:	fff7c793          	not	a5,a5
800003f4:	873e                	mv	a4,a5
800003f6:	fec42783          	lw	a5,-20(s0)
800003fa:	8ff9                	and	a5,a5,a4
800003fc:	fef42623          	sw	a5,-20(s0)
		PLIC->MIEM0 = value;
80000400:	0c000737          	lui	a4,0xc000
80000404:	6789                	lui	a5,0x2
80000406:	97ba                	add	a5,a5,a4
80000408:	fec42703          	lw	a4,-20(s0)
8000040c:	c398                	sw	a4,0(a5)
	} else {
		value  = PLIC->UIEM0;
		value &= ~(1<<isr_num);
		PLIC->UIEM0 = value;
	}
}
8000040e:	a835                	j	8000044a <PLIC_IntDisable+0x88>
		value  = PLIC->UIEM0;
80000410:	0c000737          	lui	a4,0xc000
80000414:	6789                	lui	a5,0x2
80000416:	97ba                	add	a5,a5,a4
80000418:	0807a783          	lw	a5,128(a5) # 2080 <STACK_SIZE+0x1880>
8000041c:	fef42623          	sw	a5,-20(s0)
		value &= ~(1<<isr_num);
80000420:	fd842783          	lw	a5,-40(s0)
80000424:	4705                	li	a4,1
80000426:	00f717b3          	sll	a5,a4,a5
8000042a:	fff7c793          	not	a5,a5
8000042e:	873e                	mv	a4,a5
80000430:	fec42783          	lw	a5,-20(s0)
80000434:	8ff9                	and	a5,a5,a4
80000436:	fef42623          	sw	a5,-20(s0)
		PLIC->UIEM0 = value;
8000043a:	0c000737          	lui	a4,0xc000
8000043e:	6789                	lui	a5,0x2
80000440:	97ba                	add	a5,a5,a4
80000442:	fec42703          	lw	a4,-20(s0)
80000446:	08e7a023          	sw	a4,128(a5) # 2080 <STACK_SIZE+0x1880>
}
8000044a:	0001                	nop
8000044c:	5432                	lw	s0,44(sp)
8000044e:	6145                	addi	sp,sp,48
80000450:	8082                	ret

80000452 <PLIC_ClaimIrq>:
/*
 * Get current isr number
 */

uint32_t PLIC_ClaimIrq (uint8_t target)
{
80000452:	1101                	addi	sp,sp,-32
80000454:	ce22                	sw	s0,28(sp)
80000456:	1000                	addi	s0,sp,32
80000458:	87aa                	mv	a5,a0
8000045a:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
8000045e:	fef44783          	lbu	a5,-17(s0)
80000462:	eb81                	bnez	a5,80000472 <PLIC_ClaimIrq+0x20>
		return (uint32_t)(PLIC->MICC);
80000464:	0c000737          	lui	a4,0xc000
80000468:	002007b7          	lui	a5,0x200
8000046c:	97ba                	add	a5,a5,a4
8000046e:	43dc                	lw	a5,4(a5)
80000470:	a039                	j	8000047e <PLIC_ClaimIrq+0x2c>
	} else {
		return (uint32_t)(PLIC->UICC);
80000472:	0c000737          	lui	a4,0xc000
80000476:	002017b7          	lui	a5,0x201
8000047a:	97ba                	add	a5,a5,a4
8000047c:	43dc                	lw	a5,4(a5)
	}
}
8000047e:	853e                	mv	a0,a5
80000480:	4472                	lw	s0,28(sp)
80000482:	6105                	addi	sp,sp,32
80000484:	8082                	ret

80000486 <PLIC_ClaimComplete>:
/*
 * Set current isr as completed
 */

void PLIC_ClaimComplete (uint8_t target, uint32_t isrnum)
{
80000486:	1101                	addi	sp,sp,-32
80000488:	ce22                	sw	s0,28(sp)
8000048a:	1000                	addi	s0,sp,32
8000048c:	87aa                	mv	a5,a0
8000048e:	feb42423          	sw	a1,-24(s0)
80000492:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
80000496:	fef44783          	lbu	a5,-17(s0)
8000049a:	eb91                	bnez	a5,800004ae <PLIC_ClaimComplete+0x28>
		PLIC->MICC = isrnum;
8000049c:	0c000737          	lui	a4,0xc000
800004a0:	002007b7          	lui	a5,0x200
800004a4:	97ba                	add	a5,a5,a4
800004a6:	fe842703          	lw	a4,-24(s0)
800004aa:	c3d8                	sw	a4,4(a5)
	} else {
		PLIC->UICC = isrnum;
	}
}
800004ac:	a809                	j	800004be <PLIC_ClaimComplete+0x38>
		PLIC->UICC = isrnum;
800004ae:	0c000737          	lui	a4,0xc000
800004b2:	002017b7          	lui	a5,0x201
800004b6:	97ba                	add	a5,a5,a4
800004b8:	fe842703          	lw	a4,-24(s0)
800004bc:	c3d8                	sw	a4,4(a5)
}
800004be:	0001                	nop
800004c0:	4472                	lw	s0,28(sp)
800004c2:	6105                	addi	sp,sp,32
800004c4:	8082                	ret

800004c6 <PLIC_SetThreshold>:

/*
 * Set threshold for irqs
 */

void PLIC_SetThreshold(uint8_t target, uint32_t value) {
800004c6:	1101                	addi	sp,sp,-32
800004c8:	ce22                	sw	s0,28(sp)
800004ca:	1000                	addi	s0,sp,32
800004cc:	87aa                	mv	a5,a0
800004ce:	feb42423          	sw	a1,-24(s0)
800004d2:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
800004d6:	fef44783          	lbu	a5,-17(s0)
800004da:	eb91                	bnez	a5,800004ee <PLIC_SetThreshold+0x28>
		PLIC->MTHR = value;
800004dc:	0c000737          	lui	a4,0xc000
800004e0:	002007b7          	lui	a5,0x200
800004e4:	97ba                	add	a5,a5,a4
800004e6:	fe842703          	lw	a4,-24(s0)
800004ea:	c398                	sw	a4,0(a5)
	} else {
		PLIC->UTHR = value;
	}
}
800004ec:	a809                	j	800004fe <PLIC_SetThreshold+0x38>
		PLIC->UTHR = value;
800004ee:	0c000737          	lui	a4,0xc000
800004f2:	002017b7          	lui	a5,0x201
800004f6:	97ba                	add	a5,a5,a4
800004f8:	fe842703          	lw	a4,-24(s0)
800004fc:	c398                	sw	a4,0(a5)
}
800004fe:	0001                	nop
80000500:	4472                	lw	s0,28(sp)
80000502:	6105                	addi	sp,sp,32
80000504:	8082                	ret

80000506 <PLIC_MachHandler>:


void PLIC_MachHandler(void) {
80000506:	1101                	addi	sp,sp,-32
80000508:	ce06                	sw	ra,28(sp)
8000050a:	cc22                	sw	s0,24(sp)
8000050c:	1000                	addi	s0,sp,32

	// handle interrupt
	uint32_t isr_num = PLIC_ClaimIrq(Plic_Mach_Target);
8000050e:	4501                	li	a0,0
80000510:	3789                	jal	80000452 <PLIC_ClaimIrq>
80000512:	fea42623          	sw	a0,-20(s0)
	// check if handler exist
	if(mach_plic_handler[isr_num] != NULL_IRQ) {
80000516:	400007b7          	lui	a5,0x40000
8000051a:	00878713          	addi	a4,a5,8 # 40000008 <mach_plic_handler>
8000051e:	fec42783          	lw	a5,-20(s0)
80000522:	078a                	slli	a5,a5,0x2
80000524:	97ba                	add	a5,a5,a4
80000526:	439c                	lw	a5,0(a5)
80000528:	cf99                	beqz	a5,80000546 <PLIC_MachHandler+0x40>
		// call isr handler
		mach_plic_handler[isr_num]();
8000052a:	400007b7          	lui	a5,0x40000
8000052e:	00878713          	addi	a4,a5,8 # 40000008 <mach_plic_handler>
80000532:	fec42783          	lw	a5,-20(s0)
80000536:	078a                	slli	a5,a5,0x2
80000538:	97ba                	add	a5,a5,a4
8000053a:	439c                	lw	a5,0(a5)
8000053c:	9782                	jalr	a5
		// set isr completes
		PLIC_ClaimComplete(Plic_Mach_Target, isr_num);
8000053e:	fec42583          	lw	a1,-20(s0)
80000542:	4501                	li	a0,0
80000544:	3789                	jal	80000486 <PLIC_ClaimComplete>
	}
}
80000546:	0001                	nop
80000548:	40f2                	lw	ra,28(sp)
8000054a:	4462                	lw	s0,24(sp)
8000054c:	6105                	addi	sp,sp,32
8000054e:	8082                	ret

80000550 <trap_handler>:
#define MCAUSE_EXCEPT_STAMOADDRMISALGN  0x6
#define MCAUSE_EXCEPT_STAMOACCSFAULT    0x7
#define MCAUSE_EXCEPT_ECALLFRM_M_MODE   0xB

void trap_handler (void)
{
80000550:	1101                	addi	sp,sp,-32
80000552:	ce06                	sw	ra,28(sp)
80000554:	cc22                	sw	s0,24(sp)
80000556:	1000                	addi	s0,sp,32
	uint32_t mcause_val = read_csr(mcause);
80000558:	342027f3          	csrr	a5,mcause
8000055c:	fef42623          	sw	a5,-20(s0)
80000560:	fec42783          	lw	a5,-20(s0)
80000564:	fef42423          	sw	a5,-24(s0)

	if((mcause_val & MCAUSE_INTERRUPT_FLAG) == 0) {
80000568:	fe842783          	lw	a5,-24(s0)
8000056c:	0207c463          	bltz	a5,80000594 <trap_handler+0x44>
		// handle exception
		switch (mcause_val & MCAUSE_EXCEPT_MASK)
80000570:	fe842783          	lw	a5,-24(s0)
80000574:	8bbd                	andi	a5,a5,15
80000576:	472d                	li	a4,11
80000578:	00f76b63          	bltu	a4,a5,8000058e <trap_handler+0x3e>
8000057c:	00279713          	slli	a4,a5,0x2
80000580:	800077b7          	lui	a5,0x80007
80000584:	dbc78793          	addi	a5,a5,-580 # 80006dbc <__data_source_start+0xfffffc44>
80000588:	97ba                	add	a5,a5,a4
8000058a:	439c                	lw	a5,0(a5)
8000058c:	8782                	jr	a5
			case MCAUSE_EXCEPT_ECALLFRM_M_MODE:
				break;

			default: // MCAUSE_EXCEPT UNKNOWN

				break;
8000058e:	0001                	nop
		}

		while(1) {}; //TRAP
80000590:	0001                	nop
80000592:	bffd                	j	80000590 <trap_handler+0x40>
	} else {
		// handle interrupt
		PLIC_MachHandler();
80000594:	3f8d                	jal	80000506 <PLIC_MachHandler>
	}
}
80000596:	0001                	nop
80000598:	40f2                	lw	ra,28(sp)
8000059a:	4462                	lw	s0,24(sp)
8000059c:	6105                	addi	sp,sp,32
8000059e:	8082                	ret

800005a0 <PrintChar>:
 *
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
void PrintChar(char c)
{
800005a0:	1101                	addi	sp,sp,-32
800005a2:	ce06                	sw	ra,28(sp)
800005a4:	cc22                	sw	s0,24(sp)
800005a6:	1000                	addi	s0,sp,32
800005a8:	87aa                	mv	a5,a0
800005aa:	fef407a3          	sb	a5,-17(s0)
	retarget_put_char(c);
800005ae:	fef44783          	lbu	a5,-17(s0)
800005b2:	853e                	mv	a0,a5
800005b4:	32d000ef          	jal	ra,800010e0 <retarget_put_char>
}
800005b8:	0001                	nop
800005ba:	40f2                	lw	ra,28(sp)
800005bc:	4462                	lw	s0,24(sp)
800005be:	6105                	addi	sp,sp,32
800005c0:	8082                	ret

800005c2 <PutChar>:
 *
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
signed int PutChar(char *pStr, char c)
{
800005c2:	1101                	addi	sp,sp,-32
800005c4:	ce22                	sw	s0,28(sp)
800005c6:	1000                	addi	s0,sp,32
800005c8:	fea42623          	sw	a0,-20(s0)
800005cc:	87ae                	mv	a5,a1
800005ce:	fef405a3          	sb	a5,-21(s0)
    *pStr = c;
800005d2:	fec42783          	lw	a5,-20(s0)
800005d6:	feb44703          	lbu	a4,-21(s0)
800005da:	00e78023          	sb	a4,0(a5)
    return 1;
800005de:	4785                	li	a5,1
}
800005e0:	853e                	mv	a0,a5
800005e2:	4472                	lw	s0,28(sp)
800005e4:	6105                	addi	sp,sp,32
800005e6:	8082                	ret

800005e8 <PutString>:
 * @param  pStr     Storage string.
 * @param  pSource  Source string.
 * @return  The size of the written
 */
signed int PutString(char *pStr, const char *pSource)
{
800005e8:	7179                	addi	sp,sp,-48
800005ea:	d622                	sw	s0,44(sp)
800005ec:	1800                	addi	s0,sp,48
800005ee:	fca42e23          	sw	a0,-36(s0)
800005f2:	fcb42c23          	sw	a1,-40(s0)
    signed int num = 0;
800005f6:	fe042623          	sw	zero,-20(s0)

    while (*pSource != 0) {
800005fa:	a035                	j	80000626 <PutString+0x3e>

        *pStr++ = *pSource++;
800005fc:	fd842703          	lw	a4,-40(s0)
80000600:	00170793          	addi	a5,a4,1 # c000001 <STACK_SIZE+0xbfff801>
80000604:	fcf42c23          	sw	a5,-40(s0)
80000608:	fdc42783          	lw	a5,-36(s0)
8000060c:	00178693          	addi	a3,a5,1
80000610:	fcd42e23          	sw	a3,-36(s0)
80000614:	00074703          	lbu	a4,0(a4)
80000618:	00e78023          	sb	a4,0(a5)
        num++;
8000061c:	fec42783          	lw	a5,-20(s0)
80000620:	0785                	addi	a5,a5,1
80000622:	fef42623          	sw	a5,-20(s0)
    while (*pSource != 0) {
80000626:	fd842783          	lw	a5,-40(s0)
8000062a:	0007c783          	lbu	a5,0(a5)
8000062e:	f7f9                	bnez	a5,800005fc <PutString+0x14>
    }

    return num;
80000630:	fec42783          	lw	a5,-20(s0)
}
80000634:	853e                	mv	a0,a5
80000636:	5432                	lw	s0,44(sp)
80000638:	6145                	addi	sp,sp,48
8000063a:	8082                	ret

8000063c <PutUnsignedInt>:
signed int PutUnsignedInt(
    char *pStr,
    char fill,
    signed int width,
    unsigned int value)
{
8000063c:	7179                	addi	sp,sp,-48
8000063e:	d606                	sw	ra,44(sp)
80000640:	d422                	sw	s0,40(sp)
80000642:	1800                	addi	s0,sp,48
80000644:	fca42e23          	sw	a0,-36(s0)
80000648:	87ae                	mv	a5,a1
8000064a:	fcc42a23          	sw	a2,-44(s0)
8000064e:	fcd42823          	sw	a3,-48(s0)
80000652:	fcf40da3          	sb	a5,-37(s0)
    signed int num = 0;
80000656:	fe042623          	sw	zero,-20(s0)

    /* Take current digit into account when calculating width */
    width--;
8000065a:	fd442783          	lw	a5,-44(s0)
8000065e:	17fd                	addi	a5,a5,-1
80000660:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively write upper digits */
    if ((value / 10) > 0) {
80000664:	fd042703          	lw	a4,-48(s0)
80000668:	47a5                	li	a5,9
8000066a:	04e7ff63          	bgeu	a5,a4,800006c8 <PutUnsignedInt+0x8c>

        num = PutUnsignedInt(pStr, fill, width, value / 10);
8000066e:	fd042703          	lw	a4,-48(s0)
80000672:	47a9                	li	a5,10
80000674:	02f75733          	divu	a4,a4,a5
80000678:	fdb44783          	lbu	a5,-37(s0)
8000067c:	86ba                	mv	a3,a4
8000067e:	fd442603          	lw	a2,-44(s0)
80000682:	85be                	mv	a1,a5
80000684:	fdc42503          	lw	a0,-36(s0)
80000688:	3f55                	jal	8000063c <PutUnsignedInt>
8000068a:	fea42623          	sw	a0,-20(s0)
        pStr += num;
8000068e:	fec42783          	lw	a5,-20(s0)
80000692:	fdc42703          	lw	a4,-36(s0)
80000696:	97ba                	add	a5,a5,a4
80000698:	fcf42e23          	sw	a5,-36(s0)
8000069c:	a815                	j	800006d0 <PutUnsignedInt+0x94>
    /* Write filler characters */
    else {

        while (width > 0) {

            PutChar(pStr, fill);
8000069e:	fdb44783          	lbu	a5,-37(s0)
800006a2:	85be                	mv	a1,a5
800006a4:	fdc42503          	lw	a0,-36(s0)
800006a8:	3f29                	jal	800005c2 <PutChar>
            pStr++;
800006aa:	fdc42783          	lw	a5,-36(s0)
800006ae:	0785                	addi	a5,a5,1
800006b0:	fcf42e23          	sw	a5,-36(s0)
            num++;
800006b4:	fec42783          	lw	a5,-20(s0)
800006b8:	0785                	addi	a5,a5,1
800006ba:	fef42623          	sw	a5,-20(s0)
            width--;
800006be:	fd442783          	lw	a5,-44(s0)
800006c2:	17fd                	addi	a5,a5,-1
800006c4:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
800006c8:	fd442783          	lw	a5,-44(s0)
800006cc:	fcf049e3          	bgtz	a5,8000069e <PutUnsignedInt+0x62>
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (value % 10) + '0');
800006d0:	fd042703          	lw	a4,-48(s0)
800006d4:	47a9                	li	a5,10
800006d6:	02f777b3          	remu	a5,a4,a5
800006da:	0ff7f793          	zext.b	a5,a5
800006de:	03078793          	addi	a5,a5,48
800006e2:	0ff7f793          	zext.b	a5,a5
800006e6:	85be                	mv	a1,a5
800006e8:	fdc42503          	lw	a0,-36(s0)
800006ec:	3dd9                	jal	800005c2 <PutChar>
800006ee:	872a                	mv	a4,a0
800006f0:	fec42783          	lw	a5,-20(s0)
800006f4:	97ba                	add	a5,a5,a4
800006f6:	fef42623          	sw	a5,-20(s0)

    return num;
800006fa:	fec42783          	lw	a5,-20(s0)
}
800006fe:	853e                	mv	a0,a5
80000700:	50b2                	lw	ra,44(sp)
80000702:	5422                	lw	s0,40(sp)
80000704:	6145                	addi	sp,sp,48
80000706:	8082                	ret

80000708 <PutSignedInt>:
signed int PutSignedInt(
    char *pStr,
    char fill,
    signed int width,
    signed int value)
{
80000708:	7179                	addi	sp,sp,-48
8000070a:	d606                	sw	ra,44(sp)
8000070c:	d422                	sw	s0,40(sp)
8000070e:	1800                	addi	s0,sp,48
80000710:	fca42e23          	sw	a0,-36(s0)
80000714:	87ae                	mv	a5,a1
80000716:	fcc42a23          	sw	a2,-44(s0)
8000071a:	fcd42823          	sw	a3,-48(s0)
8000071e:	fcf40da3          	sb	a5,-37(s0)
    signed int num = 0;
80000722:	fe042623          	sw	zero,-20(s0)
    unsigned int absolute;

    /* Compute absolute value */
    if (value < 0) {
80000726:	fd042783          	lw	a5,-48(s0)
8000072a:	0007d963          	bgez	a5,8000073c <PutSignedInt+0x34>

        absolute = -value;
8000072e:	fd042783          	lw	a5,-48(s0)
80000732:	40f007b3          	neg	a5,a5
80000736:	fef42423          	sw	a5,-24(s0)
8000073a:	a029                	j	80000744 <PutSignedInt+0x3c>
    }
    else {

        absolute = value;
8000073c:	fd042783          	lw	a5,-48(s0)
80000740:	fef42423          	sw	a5,-24(s0)
    }

    /* Take current digit into account when calculating width */
    width--;
80000744:	fd442783          	lw	a5,-44(s0)
80000748:	17fd                	addi	a5,a5,-1
8000074a:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively write upper digits */
    if ((absolute / 10) > 0) {
8000074e:	fe842703          	lw	a4,-24(s0)
80000752:	47a5                	li	a5,9
80000754:	06e7f363          	bgeu	a5,a4,800007ba <PutSignedInt+0xb2>

        if (value < 0) {
80000758:	fd042783          	lw	a5,-48(s0)
8000075c:	0207d663          	bgez	a5,80000788 <PutSignedInt+0x80>

            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
80000760:	fe842703          	lw	a4,-24(s0)
80000764:	47a9                	li	a5,10
80000766:	02f757b3          	divu	a5,a4,a5
8000076a:	40f007b3          	neg	a5,a5
8000076e:	873e                	mv	a4,a5
80000770:	fdb44783          	lbu	a5,-37(s0)
80000774:	86ba                	mv	a3,a4
80000776:	fd442603          	lw	a2,-44(s0)
8000077a:	85be                	mv	a1,a5
8000077c:	fdc42503          	lw	a0,-36(s0)
80000780:	3761                	jal	80000708 <PutSignedInt>
80000782:	fea42623          	sw	a0,-20(s0)
80000786:	a015                	j	800007aa <PutSignedInt+0xa2>
        }
        else {

            num = PutSignedInt(pStr, fill, width, absolute / 10);
80000788:	fe842703          	lw	a4,-24(s0)
8000078c:	47a9                	li	a5,10
8000078e:	02f757b3          	divu	a5,a4,a5
80000792:	873e                	mv	a4,a5
80000794:	fdb44783          	lbu	a5,-37(s0)
80000798:	86ba                	mv	a3,a4
8000079a:	fd442603          	lw	a2,-44(s0)
8000079e:	85be                	mv	a1,a5
800007a0:	fdc42503          	lw	a0,-36(s0)
800007a4:	3795                	jal	80000708 <PutSignedInt>
800007a6:	fea42623          	sw	a0,-20(s0)
        }
        pStr += num;
800007aa:	fec42783          	lw	a5,-20(s0)
800007ae:	fdc42703          	lw	a4,-36(s0)
800007b2:	97ba                	add	a5,a5,a4
800007b4:	fcf42e23          	sw	a5,-36(s0)
800007b8:	a885                	j	80000828 <PutSignedInt+0x120>
    }
    else {

        /* Reserve space for sign */
        if (value < 0) {
800007ba:	fd042783          	lw	a5,-48(s0)
800007be:	0207dd63          	bgez	a5,800007f8 <PutSignedInt+0xf0>

            width--;
800007c2:	fd442783          	lw	a5,-44(s0)
800007c6:	17fd                	addi	a5,a5,-1
800007c8:	fcf42a23          	sw	a5,-44(s0)
        }

        /* Write filler characters */
        while (width > 0) {
800007cc:	a035                	j	800007f8 <PutSignedInt+0xf0>

            PutChar(pStr, fill);
800007ce:	fdb44783          	lbu	a5,-37(s0)
800007d2:	85be                	mv	a1,a5
800007d4:	fdc42503          	lw	a0,-36(s0)
800007d8:	33ed                	jal	800005c2 <PutChar>
            pStr++;
800007da:	fdc42783          	lw	a5,-36(s0)
800007de:	0785                	addi	a5,a5,1
800007e0:	fcf42e23          	sw	a5,-36(s0)
            num++;
800007e4:	fec42783          	lw	a5,-20(s0)
800007e8:	0785                	addi	a5,a5,1
800007ea:	fef42623          	sw	a5,-20(s0)
            width--;
800007ee:	fd442783          	lw	a5,-44(s0)
800007f2:	17fd                	addi	a5,a5,-1
800007f4:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
800007f8:	fd442783          	lw	a5,-44(s0)
800007fc:	fcf049e3          	bgtz	a5,800007ce <PutSignedInt+0xc6>
        }

        /* Write sign */
        if (value < 0) {
80000800:	fd042783          	lw	a5,-48(s0)
80000804:	0207d263          	bgez	a5,80000828 <PutSignedInt+0x120>

            num += PutChar(pStr, '-');
80000808:	02d00593          	li	a1,45
8000080c:	fdc42503          	lw	a0,-36(s0)
80000810:	3b4d                	jal	800005c2 <PutChar>
80000812:	872a                	mv	a4,a0
80000814:	fec42783          	lw	a5,-20(s0)
80000818:	97ba                	add	a5,a5,a4
8000081a:	fef42623          	sw	a5,-20(s0)
            pStr++;
8000081e:	fdc42783          	lw	a5,-36(s0)
80000822:	0785                	addi	a5,a5,1
80000824:	fcf42e23          	sw	a5,-36(s0)
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (absolute % 10) + '0');
80000828:	fe842703          	lw	a4,-24(s0)
8000082c:	47a9                	li	a5,10
8000082e:	02f777b3          	remu	a5,a4,a5
80000832:	0ff7f793          	zext.b	a5,a5
80000836:	03078793          	addi	a5,a5,48
8000083a:	0ff7f793          	zext.b	a5,a5
8000083e:	85be                	mv	a1,a5
80000840:	fdc42503          	lw	a0,-36(s0)
80000844:	3bbd                	jal	800005c2 <PutChar>
80000846:	872a                	mv	a4,a0
80000848:	fec42783          	lw	a5,-20(s0)
8000084c:	97ba                	add	a5,a5,a4
8000084e:	fef42623          	sw	a5,-20(s0)

    return num;
80000852:	fec42783          	lw	a5,-20(s0)
}
80000856:	853e                	mv	a0,a5
80000858:	50b2                	lw	ra,44(sp)
8000085a:	5422                	lw	s0,40(sp)
8000085c:	6145                	addi	sp,sp,48
8000085e:	8082                	ret

80000860 <PutHexa>:
    char *pStr,
    char fill,
    signed int width,
    unsigned char maj,
    unsigned int value)
{
80000860:	7179                	addi	sp,sp,-48
80000862:	d606                	sw	ra,44(sp)
80000864:	d422                	sw	s0,40(sp)
80000866:	1800                	addi	s0,sp,48
80000868:	fca42e23          	sw	a0,-36(s0)
8000086c:	87ae                	mv	a5,a1
8000086e:	fcc42a23          	sw	a2,-44(s0)
80000872:	fce42823          	sw	a4,-48(s0)
80000876:	fcf40da3          	sb	a5,-37(s0)
8000087a:	87b6                	mv	a5,a3
8000087c:	fcf40d23          	sb	a5,-38(s0)
    signed int num = 0;
80000880:	fe042623          	sw	zero,-20(s0)

    /* Decrement width */
    width--;
80000884:	fd442783          	lw	a5,-44(s0)
80000888:	17fd                	addi	a5,a5,-1
8000088a:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively output upper digits */
    if ((value >> 4) > 0) {
8000088e:	fd042783          	lw	a5,-48(s0)
80000892:	8391                	srli	a5,a5,0x4
80000894:	c3b5                	beqz	a5,800008f8 <PutHexa+0x98>

        num += PutHexa(pStr, fill, width, maj, value >> 4);
80000896:	fd042783          	lw	a5,-48(s0)
8000089a:	0047d713          	srli	a4,a5,0x4
8000089e:	fda44683          	lbu	a3,-38(s0)
800008a2:	fdb44783          	lbu	a5,-37(s0)
800008a6:	fd442603          	lw	a2,-44(s0)
800008aa:	85be                	mv	a1,a5
800008ac:	fdc42503          	lw	a0,-36(s0)
800008b0:	3f45                	jal	80000860 <PutHexa>
800008b2:	872a                	mv	a4,a0
800008b4:	fec42783          	lw	a5,-20(s0)
800008b8:	97ba                	add	a5,a5,a4
800008ba:	fef42623          	sw	a5,-20(s0)
        pStr += num;
800008be:	fec42783          	lw	a5,-20(s0)
800008c2:	fdc42703          	lw	a4,-36(s0)
800008c6:	97ba                	add	a5,a5,a4
800008c8:	fcf42e23          	sw	a5,-36(s0)
800008cc:	a815                	j	80000900 <PutHexa+0xa0>
    /* Write filler chars */
    else {

        while (width > 0) {

            PutChar(pStr, fill);
800008ce:	fdb44783          	lbu	a5,-37(s0)
800008d2:	85be                	mv	a1,a5
800008d4:	fdc42503          	lw	a0,-36(s0)
800008d8:	31ed                	jal	800005c2 <PutChar>
            pStr++;
800008da:	fdc42783          	lw	a5,-36(s0)
800008de:	0785                	addi	a5,a5,1
800008e0:	fcf42e23          	sw	a5,-36(s0)
            num++;
800008e4:	fec42783          	lw	a5,-20(s0)
800008e8:	0785                	addi	a5,a5,1
800008ea:	fef42623          	sw	a5,-20(s0)
            width--;
800008ee:	fd442783          	lw	a5,-44(s0)
800008f2:	17fd                	addi	a5,a5,-1
800008f4:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
800008f8:	fd442783          	lw	a5,-44(s0)
800008fc:	fcf049e3          	bgtz	a5,800008ce <PutHexa+0x6e>
        }
    }

    /* Write current digit */
    if ((value & 0xF) < 10) {
80000900:	fd042783          	lw	a5,-48(s0)
80000904:	00f7f713          	andi	a4,a5,15
80000908:	47a5                	li	a5,9
8000090a:	02e7e263          	bltu	a5,a4,8000092e <PutHexa+0xce>

        PutChar(pStr, (value & 0xF) + '0');
8000090e:	fd042783          	lw	a5,-48(s0)
80000912:	0ff7f793          	zext.b	a5,a5
80000916:	8bbd                	andi	a5,a5,15
80000918:	0ff7f793          	zext.b	a5,a5
8000091c:	03078793          	addi	a5,a5,48
80000920:	0ff7f793          	zext.b	a5,a5
80000924:	85be                	mv	a1,a5
80000926:	fdc42503          	lw	a0,-36(s0)
8000092a:	3961                	jal	800005c2 <PutChar>
8000092c:	a099                	j	80000972 <PutHexa+0x112>
    }
    else if (maj) {
8000092e:	fda44783          	lbu	a5,-38(s0)
80000932:	c38d                	beqz	a5,80000954 <PutHexa+0xf4>

        PutChar(pStr, (value & 0xF) - 10 + 'A');
80000934:	fd042783          	lw	a5,-48(s0)
80000938:	0ff7f793          	zext.b	a5,a5
8000093c:	8bbd                	andi	a5,a5,15
8000093e:	0ff7f793          	zext.b	a5,a5
80000942:	03778793          	addi	a5,a5,55
80000946:	0ff7f793          	zext.b	a5,a5
8000094a:	85be                	mv	a1,a5
8000094c:	fdc42503          	lw	a0,-36(s0)
80000950:	398d                	jal	800005c2 <PutChar>
80000952:	a005                	j	80000972 <PutHexa+0x112>
    }
    else {

        PutChar(pStr, (value & 0xF) - 10 + 'a');
80000954:	fd042783          	lw	a5,-48(s0)
80000958:	0ff7f793          	zext.b	a5,a5
8000095c:	8bbd                	andi	a5,a5,15
8000095e:	0ff7f793          	zext.b	a5,a5
80000962:	05778793          	addi	a5,a5,87
80000966:	0ff7f793          	zext.b	a5,a5
8000096a:	85be                	mv	a1,a5
8000096c:	fdc42503          	lw	a0,-36(s0)
80000970:	3989                	jal	800005c2 <PutChar>
    }
    num++;
80000972:	fec42783          	lw	a5,-20(s0)
80000976:	0785                	addi	a5,a5,1
80000978:	fef42623          	sw	a5,-20(s0)

    return num;
8000097c:	fec42783          	lw	a5,-20(s0)
}
80000980:	853e                	mv	a0,a5
80000982:	50b2                	lw	ra,44(sp)
80000984:	5422                	lw	s0,40(sp)
80000986:	6145                	addi	sp,sp,48
80000988:	8082                	ret

8000098a <vsnprintf>:
 * @param ap      Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsnprintf(char *pStr, size_t length, const char *pFormat, va_list ap)
{
8000098a:	7179                	addi	sp,sp,-48
8000098c:	d606                	sw	ra,44(sp)
8000098e:	d422                	sw	s0,40(sp)
80000990:	1800                	addi	s0,sp,48
80000992:	fca42e23          	sw	a0,-36(s0)
80000996:	fcb42c23          	sw	a1,-40(s0)
8000099a:	fcc42a23          	sw	a2,-44(s0)
8000099e:	fcd42823          	sw	a3,-48(s0)
    char          fill;
    unsigned char width;
    signed int    num = 0;
800009a2:	fe042423          	sw	zero,-24(s0)
    signed int    size = 0;
800009a6:	fe042223          	sw	zero,-28(s0)

    /* Clear the string */
    if (pStr) {
800009aa:	fdc42783          	lw	a5,-36(s0)
800009ae:	26078163          	beqz	a5,80000c10 <vsnprintf+0x286>

        *pStr = 0;
800009b2:	fdc42783          	lw	a5,-36(s0)
800009b6:	00078023          	sb	zero,0(a5)
    }

    /* Phase string */
    while (*pFormat != 0 && size < length) {
800009ba:	ac99                	j	80000c10 <vsnprintf+0x286>

        /* Normal character */
        if (*pFormat != '%') {
800009bc:	fd442783          	lw	a5,-44(s0)
800009c0:	0007c703          	lbu	a4,0(a5)
800009c4:	02500793          	li	a5,37
800009c8:	02f70863          	beq	a4,a5,800009f8 <vsnprintf+0x6e>

            *pStr++ = *pFormat++;
800009cc:	fd442703          	lw	a4,-44(s0)
800009d0:	00170793          	addi	a5,a4,1
800009d4:	fcf42a23          	sw	a5,-44(s0)
800009d8:	fdc42783          	lw	a5,-36(s0)
800009dc:	00178693          	addi	a3,a5,1
800009e0:	fcd42e23          	sw	a3,-36(s0)
800009e4:	00074703          	lbu	a4,0(a4)
800009e8:	00e78023          	sb	a4,0(a5)
            size++;
800009ec:	fe442783          	lw	a5,-28(s0)
800009f0:	0785                	addi	a5,a5,1
800009f2:	fef42223          	sw	a5,-28(s0)
800009f6:	ac29                	j	80000c10 <vsnprintf+0x286>
        }
        /* Escaped '%' */
        else if (*(pFormat+1) == '%') {
800009f8:	fd442783          	lw	a5,-44(s0)
800009fc:	0785                	addi	a5,a5,1
800009fe:	0007c703          	lbu	a4,0(a5)
80000a02:	02500793          	li	a5,37
80000a06:	02f71763          	bne	a4,a5,80000a34 <vsnprintf+0xaa>

            *pStr++ = '%';
80000a0a:	fdc42783          	lw	a5,-36(s0)
80000a0e:	00178713          	addi	a4,a5,1
80000a12:	fce42e23          	sw	a4,-36(s0)
80000a16:	02500713          	li	a4,37
80000a1a:	00e78023          	sb	a4,0(a5)
            pFormat += 2;
80000a1e:	fd442783          	lw	a5,-44(s0)
80000a22:	0789                	addi	a5,a5,2
80000a24:	fcf42a23          	sw	a5,-44(s0)
            size++;
80000a28:	fe442783          	lw	a5,-28(s0)
80000a2c:	0785                	addi	a5,a5,1
80000a2e:	fef42223          	sw	a5,-28(s0)
80000a32:	aaf9                	j	80000c10 <vsnprintf+0x286>
        }
        /* Token delimiter */
        else {

            fill = ' ';
80000a34:	02000793          	li	a5,32
80000a38:	fef407a3          	sb	a5,-17(s0)
            width = 0;
80000a3c:	fe040723          	sb	zero,-18(s0)
            pFormat++;
80000a40:	fd442783          	lw	a5,-44(s0)
80000a44:	0785                	addi	a5,a5,1
80000a46:	fcf42a23          	sw	a5,-44(s0)

            /* Parse filler */
            if (*pFormat == '0') {
80000a4a:	fd442783          	lw	a5,-44(s0)
80000a4e:	0007c703          	lbu	a4,0(a5)
80000a52:	03000793          	li	a5,48
80000a56:	04f71563          	bne	a4,a5,80000aa0 <vsnprintf+0x116>

                fill = '0';
80000a5a:	03000793          	li	a5,48
80000a5e:	fef407a3          	sb	a5,-17(s0)
                pFormat++;
80000a62:	fd442783          	lw	a5,-44(s0)
80000a66:	0785                	addi	a5,a5,1
80000a68:	fcf42a23          	sw	a5,-44(s0)
            }

            /* Parse width */
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
80000a6c:	a815                	j	80000aa0 <vsnprintf+0x116>

                width = (width*10) + *pFormat-'0';
80000a6e:	fee44783          	lbu	a5,-18(s0)
80000a72:	873e                	mv	a4,a5
80000a74:	87ba                	mv	a5,a4
80000a76:	078a                	slli	a5,a5,0x2
80000a78:	97ba                	add	a5,a5,a4
80000a7a:	0786                	slli	a5,a5,0x1
80000a7c:	0ff7f713          	zext.b	a4,a5
80000a80:	fd442783          	lw	a5,-44(s0)
80000a84:	0007c783          	lbu	a5,0(a5)
80000a88:	97ba                	add	a5,a5,a4
80000a8a:	0ff7f793          	zext.b	a5,a5
80000a8e:	fd078793          	addi	a5,a5,-48
80000a92:	fef40723          	sb	a5,-18(s0)
                pFormat++;
80000a96:	fd442783          	lw	a5,-44(s0)
80000a9a:	0785                	addi	a5,a5,1
80000a9c:	fcf42a23          	sw	a5,-44(s0)
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
80000aa0:	fd442783          	lw	a5,-44(s0)
80000aa4:	0007c703          	lbu	a4,0(a5)
80000aa8:	02f00793          	li	a5,47
80000aac:	00e7fa63          	bgeu	a5,a4,80000ac0 <vsnprintf+0x136>
80000ab0:	fd442783          	lw	a5,-44(s0)
80000ab4:	0007c703          	lbu	a4,0(a5)
80000ab8:	03900793          	li	a5,57
80000abc:	fae7f9e3          	bgeu	a5,a4,80000a6e <vsnprintf+0xe4>
            }

            /* Check if there is enough space */
            if (size + width > length) {
80000ac0:	fee44703          	lbu	a4,-18(s0)
80000ac4:	fe442783          	lw	a5,-28(s0)
80000ac8:	97ba                	add	a5,a5,a4
80000aca:	873e                	mv	a4,a5
80000acc:	fd842783          	lw	a5,-40(s0)
80000ad0:	00e7fe63          	bgeu	a5,a4,80000aec <vsnprintf+0x162>

                width = length - size;
80000ad4:	fd842783          	lw	a5,-40(s0)
80000ad8:	0ff7f713          	zext.b	a4,a5
80000adc:	fe442783          	lw	a5,-28(s0)
80000ae0:	0ff7f793          	zext.b	a5,a5
80000ae4:	40f707b3          	sub	a5,a4,a5
80000ae8:	fef40723          	sb	a5,-18(s0)
            }

            /* Parse type */
            switch (*pFormat) {
80000aec:	fd442783          	lw	a5,-44(s0)
80000af0:	0007c783          	lbu	a5,0(a5)
80000af4:	fa878793          	addi	a5,a5,-88
80000af8:	02000713          	li	a4,32
80000afc:	0ef76563          	bltu	a4,a5,80000be6 <vsnprintf+0x25c>
80000b00:	00279713          	slli	a4,a5,0x2
80000b04:	800077b7          	lui	a5,0x80007
80000b08:	dec78793          	addi	a5,a5,-532 # 80006dec <__data_source_start+0xfffffc74>
80000b0c:	97ba                	add	a5,a5,a4
80000b0e:	439c                	lw	a5,0(a5)
80000b10:	8782                	jr	a5
            case 'd':
            case 'i': num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int)); break;
80000b12:	fee44603          	lbu	a2,-18(s0)
80000b16:	fd042783          	lw	a5,-48(s0)
80000b1a:	00478713          	addi	a4,a5,4
80000b1e:	fce42823          	sw	a4,-48(s0)
80000b22:	4398                	lw	a4,0(a5)
80000b24:	fef44783          	lbu	a5,-17(s0)
80000b28:	86ba                	mv	a3,a4
80000b2a:	85be                	mv	a1,a5
80000b2c:	fdc42503          	lw	a0,-36(s0)
80000b30:	3ee1                	jal	80000708 <PutSignedInt>
80000b32:	fea42423          	sw	a0,-24(s0)
80000b36:	a855                	j	80000bea <vsnprintf+0x260>
            case 'u': num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned int)); break;
80000b38:	fee44603          	lbu	a2,-18(s0)
80000b3c:	fd042783          	lw	a5,-48(s0)
80000b40:	00478713          	addi	a4,a5,4
80000b44:	fce42823          	sw	a4,-48(s0)
80000b48:	4398                	lw	a4,0(a5)
80000b4a:	fef44783          	lbu	a5,-17(s0)
80000b4e:	86ba                	mv	a3,a4
80000b50:	85be                	mv	a1,a5
80000b52:	fdc42503          	lw	a0,-36(s0)
80000b56:	34dd                	jal	8000063c <PutUnsignedInt>
80000b58:	fea42423          	sw	a0,-24(s0)
80000b5c:	a079                	j	80000bea <vsnprintf+0x260>
            case 'x': num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int)); break;
80000b5e:	fee44603          	lbu	a2,-18(s0)
80000b62:	fd042783          	lw	a5,-48(s0)
80000b66:	00478713          	addi	a4,a5,4
80000b6a:	fce42823          	sw	a4,-48(s0)
80000b6e:	4398                	lw	a4,0(a5)
80000b70:	fef44783          	lbu	a5,-17(s0)
80000b74:	4681                	li	a3,0
80000b76:	85be                	mv	a1,a5
80000b78:	fdc42503          	lw	a0,-36(s0)
80000b7c:	31d5                	jal	80000860 <PutHexa>
80000b7e:	fea42423          	sw	a0,-24(s0)
80000b82:	a0a5                	j	80000bea <vsnprintf+0x260>
            case 'X': num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int)); break;
80000b84:	fee44603          	lbu	a2,-18(s0)
80000b88:	fd042783          	lw	a5,-48(s0)
80000b8c:	00478713          	addi	a4,a5,4
80000b90:	fce42823          	sw	a4,-48(s0)
80000b94:	4398                	lw	a4,0(a5)
80000b96:	fef44783          	lbu	a5,-17(s0)
80000b9a:	4685                	li	a3,1
80000b9c:	85be                	mv	a1,a5
80000b9e:	fdc42503          	lw	a0,-36(s0)
80000ba2:	397d                	jal	80000860 <PutHexa>
80000ba4:	fea42423          	sw	a0,-24(s0)
80000ba8:	a089                	j	80000bea <vsnprintf+0x260>
            case 's': num = PutString(pStr, va_arg(ap, char *)); break;
80000baa:	fd042783          	lw	a5,-48(s0)
80000bae:	00478713          	addi	a4,a5,4
80000bb2:	fce42823          	sw	a4,-48(s0)
80000bb6:	439c                	lw	a5,0(a5)
80000bb8:	85be                	mv	a1,a5
80000bba:	fdc42503          	lw	a0,-36(s0)
80000bbe:	342d                	jal	800005e8 <PutString>
80000bc0:	fea42423          	sw	a0,-24(s0)
80000bc4:	a01d                	j	80000bea <vsnprintf+0x260>
            case 'c': num = PutChar(pStr, va_arg(ap, unsigned int)); break;
80000bc6:	fd042783          	lw	a5,-48(s0)
80000bca:	00478713          	addi	a4,a5,4
80000bce:	fce42823          	sw	a4,-48(s0)
80000bd2:	439c                	lw	a5,0(a5)
80000bd4:	0ff7f793          	zext.b	a5,a5
80000bd8:	85be                	mv	a1,a5
80000bda:	fdc42503          	lw	a0,-36(s0)
80000bde:	32d5                	jal	800005c2 <PutChar>
80000be0:	fea42423          	sw	a0,-24(s0)
80000be4:	a019                	j	80000bea <vsnprintf+0x260>
            default:
                return EOF;
80000be6:	57fd                	li	a5,-1
80000be8:	a895                	j	80000c5c <vsnprintf+0x2d2>
            }

            pFormat++;
80000bea:	fd442783          	lw	a5,-44(s0)
80000bee:	0785                	addi	a5,a5,1
80000bf0:	fcf42a23          	sw	a5,-44(s0)
            pStr += num;
80000bf4:	fe842783          	lw	a5,-24(s0)
80000bf8:	fdc42703          	lw	a4,-36(s0)
80000bfc:	97ba                	add	a5,a5,a4
80000bfe:	fcf42e23          	sw	a5,-36(s0)
            size += num;
80000c02:	fe442703          	lw	a4,-28(s0)
80000c06:	fe842783          	lw	a5,-24(s0)
80000c0a:	97ba                	add	a5,a5,a4
80000c0c:	fef42223          	sw	a5,-28(s0)
    while (*pFormat != 0 && size < length) {
80000c10:	fd442783          	lw	a5,-44(s0)
80000c14:	0007c783          	lbu	a5,0(a5)
80000c18:	c799                	beqz	a5,80000c26 <vsnprintf+0x29c>
80000c1a:	fe442783          	lw	a5,-28(s0)
80000c1e:	fd842703          	lw	a4,-40(s0)
80000c22:	d8e7ede3          	bltu	a5,a4,800009bc <vsnprintf+0x32>
        }
    }

    /* NULL-terminated (final \0 is not counted) */
    if (size < length) {
80000c26:	fe442783          	lw	a5,-28(s0)
80000c2a:	fd842703          	lw	a4,-40(s0)
80000c2e:	00e7f763          	bgeu	a5,a4,80000c3c <vsnprintf+0x2b2>

        *pStr = 0;
80000c32:	fdc42783          	lw	a5,-36(s0)
80000c36:	00078023          	sb	zero,0(a5)
80000c3a:	a839                	j	80000c58 <vsnprintf+0x2ce>
    }
    else {

        *(--pStr) = 0;
80000c3c:	fdc42783          	lw	a5,-36(s0)
80000c40:	17fd                	addi	a5,a5,-1
80000c42:	fcf42e23          	sw	a5,-36(s0)
80000c46:	fdc42783          	lw	a5,-36(s0)
80000c4a:	00078023          	sb	zero,0(a5)
        size--;
80000c4e:	fe442783          	lw	a5,-28(s0)
80000c52:	17fd                	addi	a5,a5,-1
80000c54:	fef42223          	sw	a5,-28(s0)
    }

    return size;
80000c58:	fe442783          	lw	a5,-28(s0)
}
80000c5c:	853e                	mv	a0,a5
80000c5e:	50b2                	lw	ra,44(sp)
80000c60:	5422                	lw	s0,40(sp)
80000c62:	6145                	addi	sp,sp,48
80000c64:	8082                	ret

80000c66 <snprintf>:
 * @param ...     Other arguments
 *
 * @return  The number of characters written.
 */
signed int snprintf(char *pString, size_t length, const char *pFormat, ...)
{
80000c66:	715d                	addi	sp,sp,-80
80000c68:	d606                	sw	ra,44(sp)
80000c6a:	d422                	sw	s0,40(sp)
80000c6c:	1800                	addi	s0,sp,48
80000c6e:	fca42e23          	sw	a0,-36(s0)
80000c72:	fcb42c23          	sw	a1,-40(s0)
80000c76:	fcc42a23          	sw	a2,-44(s0)
80000c7a:	c454                	sw	a3,12(s0)
80000c7c:	c818                	sw	a4,16(s0)
80000c7e:	c85c                	sw	a5,20(s0)
80000c80:	01042c23          	sw	a6,24(s0)
80000c84:	01142e23          	sw	a7,28(s0)
    va_list    ap;
    signed int rc;

    va_start(ap, pFormat);
80000c88:	02040793          	addi	a5,s0,32
80000c8c:	fcf42823          	sw	a5,-48(s0)
80000c90:	fd042783          	lw	a5,-48(s0)
80000c94:	17b1                	addi	a5,a5,-20
80000c96:	fef42423          	sw	a5,-24(s0)
    rc = vsnprintf(pString, length, pFormat, ap);
80000c9a:	fe842783          	lw	a5,-24(s0)
80000c9e:	86be                	mv	a3,a5
80000ca0:	fd442603          	lw	a2,-44(s0)
80000ca4:	fd842583          	lw	a1,-40(s0)
80000ca8:	fdc42503          	lw	a0,-36(s0)
80000cac:	39f9                	jal	8000098a <vsnprintf>
80000cae:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return rc;
80000cb2:	fec42783          	lw	a5,-20(s0)
}
80000cb6:	853e                	mv	a0,a5
80000cb8:	50b2                	lw	ra,44(sp)
80000cba:	5422                	lw	s0,40(sp)
80000cbc:	6161                	addi	sp,sp,80
80000cbe:	8082                	ret

80000cc0 <vsprintf>:
 * @param ap       Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsprintf(char *pString, const char *pFormat, va_list ap)
{
80000cc0:	1101                	addi	sp,sp,-32
80000cc2:	ce06                	sw	ra,28(sp)
80000cc4:	cc22                	sw	s0,24(sp)
80000cc6:	1000                	addi	s0,sp,32
80000cc8:	fea42623          	sw	a0,-20(s0)
80000ccc:	feb42423          	sw	a1,-24(s0)
80000cd0:	fec42223          	sw	a2,-28(s0)
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
80000cd4:	fe442683          	lw	a3,-28(s0)
80000cd8:	fe842603          	lw	a2,-24(s0)
80000cdc:	15e00593          	li	a1,350
80000ce0:	fec42503          	lw	a0,-20(s0)
80000ce4:	315d                	jal	8000098a <vsnprintf>
80000ce6:	87aa                	mv	a5,a0
}
80000ce8:	853e                	mv	a0,a5
80000cea:	40f2                	lw	ra,28(sp)
80000cec:	4462                	lw	s0,24(sp)
80000cee:	6105                	addi	sp,sp,32
80000cf0:	8082                	ret

80000cf2 <vfprintf>:
 * @param pStream  Output stream.
 * @param pFormat  Format string
 * @param ap       Argument list.
 */
signed int vfprintf(FILE *pStream, const char *pFormat, va_list ap)
{
80000cf2:	7161                	addi	sp,sp,-432
80000cf4:	1a112623          	sw	ra,428(sp)
80000cf8:	1a812423          	sw	s0,424(sp)
80000cfc:	1b00                	addi	s0,sp,432
80000cfe:	e4a42e23          	sw	a0,-420(s0)
80000d02:	e4b42c23          	sw	a1,-424(s0)
80000d06:	e4c42a23          	sw	a2,-428(s0)
    char pStr[MAX_STRING_SIZE];
    char pError[] = "stdio.c: increase MAX_STRING_SIZE\n\r";
80000d0a:	800077b7          	lui	a5,0x80007
80000d0e:	e7078793          	addi	a5,a5,-400 # 80006e70 <__data_source_start+0xfffffcf8>
80000d12:	0007a303          	lw	t1,0(a5)
80000d16:	0047a883          	lw	a7,4(a5)
80000d1a:	0087a803          	lw	a6,8(a5)
80000d1e:	47c8                	lw	a0,12(a5)
80000d20:	4b8c                	lw	a1,16(a5)
80000d22:	4bd0                	lw	a2,20(a5)
80000d24:	4f94                	lw	a3,24(a5)
80000d26:	4fd8                	lw	a4,28(a5)
80000d28:	539c                	lw	a5,32(a5)
80000d2a:	e6642623          	sw	t1,-404(s0)
80000d2e:	e7142823          	sw	a7,-400(s0)
80000d32:	e7042a23          	sw	a6,-396(s0)
80000d36:	e6a42c23          	sw	a0,-392(s0)
80000d3a:	e6b42e23          	sw	a1,-388(s0)
80000d3e:	e8c42023          	sw	a2,-384(s0)
80000d42:	e8d42223          	sw	a3,-380(s0)
80000d46:	e8e42423          	sw	a4,-376(s0)
80000d4a:	e8f42623          	sw	a5,-372(s0)

    /* Write formatted string in buffer */
    if (vsprintf(pStr, pFormat, ap) >= MAX_STRING_SIZE) {
80000d4e:	e9040793          	addi	a5,s0,-368
80000d52:	e5442603          	lw	a2,-428(s0)
80000d56:	e5842583          	lw	a1,-424(s0)
80000d5a:	853e                	mv	a0,a5
80000d5c:	3795                	jal	80000cc0 <vsprintf>
80000d5e:	872a                	mv	a4,a0
80000d60:	15d00793          	li	a5,349
80000d64:	00e7dc63          	bge	a5,a4,80000d7c <vfprintf+0x8a>

        fputs(pError, stderr);
80000d68:	8841a783          	lw	a5,-1916(gp) # 40000004 <_impure_ptr>
80000d6c:	47d8                	lw	a4,12(a5)
80000d6e:	e6c40793          	addi	a5,s0,-404
80000d72:	85ba                	mv	a1,a4
80000d74:	853e                	mv	a0,a5
80000d76:	22f1                	jal	80000f42 <fputs>
        while (1); /* Increase MAX_STRING_SIZE */
80000d78:	0001                	nop
80000d7a:	bffd                	j	80000d78 <vfprintf+0x86>
    }

    /* Display string */
    return fputs(pStr, pStream);
80000d7c:	e9040793          	addi	a5,s0,-368
80000d80:	e5c42583          	lw	a1,-420(s0)
80000d84:	853e                	mv	a0,a5
80000d86:	2a75                	jal	80000f42 <fputs>
80000d88:	87aa                	mv	a5,a0
}
80000d8a:	853e                	mv	a0,a5
80000d8c:	1ac12083          	lw	ra,428(sp)
80000d90:	1a812403          	lw	s0,424(sp)
80000d94:	615d                	addi	sp,sp,432
80000d96:	8082                	ret

80000d98 <vprintf>:
 *
 * @param pFormat  Format string.
 * @param ap  Argument list.
 */
signed int vprintf(const char *pFormat, va_list ap)
{
80000d98:	1101                	addi	sp,sp,-32
80000d9a:	ce06                	sw	ra,28(sp)
80000d9c:	cc22                	sw	s0,24(sp)
80000d9e:	1000                	addi	s0,sp,32
80000da0:	fea42623          	sw	a0,-20(s0)
80000da4:	feb42423          	sw	a1,-24(s0)
    return vfprintf(stdout, pFormat, ap);
80000da8:	8841a783          	lw	a5,-1916(gp) # 40000004 <_impure_ptr>
80000dac:	479c                	lw	a5,8(a5)
80000dae:	fe842603          	lw	a2,-24(s0)
80000db2:	fec42583          	lw	a1,-20(s0)
80000db6:	853e                	mv	a0,a5
80000db8:	3f2d                	jal	80000cf2 <vfprintf>
80000dba:	87aa                	mv	a5,a0
}
80000dbc:	853e                	mv	a0,a5
80000dbe:	40f2                	lw	ra,28(sp)
80000dc0:	4462                	lw	s0,24(sp)
80000dc2:	6105                	addi	sp,sp,32
80000dc4:	8082                	ret

80000dc6 <fprintf>:
 *
 * @param pStream  Output stream.
 * @param pFormat  Format string.
 */
signed int fprintf(FILE *pStream, const char *pFormat, ...)
{
80000dc6:	715d                	addi	sp,sp,-80
80000dc8:	d606                	sw	ra,44(sp)
80000dca:	d422                	sw	s0,40(sp)
80000dcc:	1800                	addi	s0,sp,48
80000dce:	fca42e23          	sw	a0,-36(s0)
80000dd2:	fcb42c23          	sw	a1,-40(s0)
80000dd6:	c410                	sw	a2,8(s0)
80000dd8:	c454                	sw	a3,12(s0)
80000dda:	c818                	sw	a4,16(s0)
80000ddc:	c85c                	sw	a5,20(s0)
80000dde:	01042c23          	sw	a6,24(s0)
80000de2:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    /* Forward call to vfprintf */
    va_start(ap, pFormat);
80000de6:	02040793          	addi	a5,s0,32
80000dea:	fcf42a23          	sw	a5,-44(s0)
80000dee:	fd442783          	lw	a5,-44(s0)
80000df2:	17a1                	addi	a5,a5,-24
80000df4:	fef42423          	sw	a5,-24(s0)
    result = vfprintf(pStream, pFormat, ap);
80000df8:	fe842783          	lw	a5,-24(s0)
80000dfc:	863e                	mv	a2,a5
80000dfe:	fd842583          	lw	a1,-40(s0)
80000e02:	fdc42503          	lw	a0,-36(s0)
80000e06:	35f5                	jal	80000cf2 <vfprintf>
80000e08:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
80000e0c:	fec42783          	lw	a5,-20(s0)
}
80000e10:	853e                	mv	a0,a5
80000e12:	50b2                	lw	ra,44(sp)
80000e14:	5422                	lw	s0,40(sp)
80000e16:	6161                	addi	sp,sp,80
80000e18:	8082                	ret

80000e1a <printf>:
 *         arguments.
 *
 * @param  pFormat  Format string.
 */
signed int printf(const char *pFormat, ...)
{
80000e1a:	715d                	addi	sp,sp,-80
80000e1c:	d606                	sw	ra,44(sp)
80000e1e:	d422                	sw	s0,40(sp)
80000e20:	1800                	addi	s0,sp,48
80000e22:	fca42e23          	sw	a0,-36(s0)
80000e26:	c04c                	sw	a1,4(s0)
80000e28:	c410                	sw	a2,8(s0)
80000e2a:	c454                	sw	a3,12(s0)
80000e2c:	c818                	sw	a4,16(s0)
80000e2e:	c85c                	sw	a5,20(s0)
80000e30:	01042c23          	sw	a6,24(s0)
80000e34:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    /* Forward call to vprintf */
    va_start(ap, pFormat);
80000e38:	02040793          	addi	a5,s0,32
80000e3c:	fcf42c23          	sw	a5,-40(s0)
80000e40:	fd842783          	lw	a5,-40(s0)
80000e44:	1791                	addi	a5,a5,-28
80000e46:	fef42423          	sw	a5,-24(s0)
    result = vprintf(pFormat, ap);
80000e4a:	fe842783          	lw	a5,-24(s0)
80000e4e:	85be                	mv	a1,a5
80000e50:	fdc42503          	lw	a0,-36(s0)
80000e54:	3791                	jal	80000d98 <vprintf>
80000e56:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
80000e5a:	fec42783          	lw	a5,-20(s0)
}
80000e5e:	853e                	mv	a0,a5
80000e60:	50b2                	lw	ra,44(sp)
80000e62:	5422                	lw	s0,40(sp)
80000e64:	6161                	addi	sp,sp,80
80000e66:	8082                	ret

80000e68 <sprintf>:
 *
 * @param pStr     torage string.
 * @param pFormat  Format string.
 */
signed int sprintf(char *pStr, const char *pFormat, ...)
{
80000e68:	715d                	addi	sp,sp,-80
80000e6a:	d606                	sw	ra,44(sp)
80000e6c:	d422                	sw	s0,40(sp)
80000e6e:	1800                	addi	s0,sp,48
80000e70:	fca42e23          	sw	a0,-36(s0)
80000e74:	fcb42c23          	sw	a1,-40(s0)
80000e78:	c410                	sw	a2,8(s0)
80000e7a:	c454                	sw	a3,12(s0)
80000e7c:	c818                	sw	a4,16(s0)
80000e7e:	c85c                	sw	a5,20(s0)
80000e80:	01042c23          	sw	a6,24(s0)
80000e84:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    // Forward call to vsprintf
    va_start(ap, pFormat);
80000e88:	02040793          	addi	a5,s0,32
80000e8c:	fcf42a23          	sw	a5,-44(s0)
80000e90:	fd442783          	lw	a5,-44(s0)
80000e94:	17a1                	addi	a5,a5,-24
80000e96:	fef42423          	sw	a5,-24(s0)
    result = vsprintf(pStr, pFormat, ap);
80000e9a:	fe842783          	lw	a5,-24(s0)
80000e9e:	863e                	mv	a2,a5
80000ea0:	fd842583          	lw	a1,-40(s0)
80000ea4:	fdc42503          	lw	a0,-36(s0)
80000ea8:	3d21                	jal	80000cc0 <vsprintf>
80000eaa:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
80000eae:	fec42783          	lw	a5,-20(s0)
}
80000eb2:	853e                	mv	a0,a5
80000eb4:	50b2                	lw	ra,44(sp)
80000eb6:	5422                	lw	s0,40(sp)
80000eb8:	6161                	addi	sp,sp,80
80000eba:	8082                	ret

80000ebc <puts>:
 * @brief  Outputs a string on stdout.
 *
 * @param pStr  String to output.
 */
signed int puts(const char *pStr)
{
80000ebc:	7179                	addi	sp,sp,-48
80000ebe:	d606                	sw	ra,44(sp)
80000ec0:	d422                	sw	s0,40(sp)
80000ec2:	1800                	addi	s0,sp,48
80000ec4:	fca42e23          	sw	a0,-36(s0)
    signed int i = fputs(pStr, stdout);
80000ec8:	8841a783          	lw	a5,-1916(gp) # 40000004 <_impure_ptr>
80000ecc:	479c                	lw	a5,8(a5)
80000ece:	85be                	mv	a1,a5
80000ed0:	fdc42503          	lw	a0,-36(s0)
80000ed4:	20bd                	jal	80000f42 <fputs>
80000ed6:	fea42623          	sw	a0,-20(s0)
    fputc('\n', stdout);
80000eda:	8841a783          	lw	a5,-1916(gp) # 40000004 <_impure_ptr>
80000ede:	479c                	lw	a5,8(a5)
80000ee0:	85be                	mv	a1,a5
80000ee2:	4529                	li	a0,10
80000ee4:	2809                	jal	80000ef6 <fputc>

    return i+1;
80000ee6:	fec42783          	lw	a5,-20(s0)
80000eea:	0785                	addi	a5,a5,1
}
80000eec:	853e                	mv	a0,a5
80000eee:	50b2                	lw	ra,44(sp)
80000ef0:	5422                	lw	s0,40(sp)
80000ef2:	6145                	addi	sp,sp,48
80000ef4:	8082                	ret

80000ef6 <fputc>:
 * @param pStream  Output stream.
 * @param The character written if successful, or -1 if the output stream is
 *        not stdout or stderr.
 */
signed int fputc(signed int c, FILE *pStream)
{
80000ef6:	1101                	addi	sp,sp,-32
80000ef8:	ce06                	sw	ra,28(sp)
80000efa:	cc22                	sw	s0,24(sp)
80000efc:	1000                	addi	s0,sp,32
80000efe:	fea42623          	sw	a0,-20(s0)
80000f02:	feb42423          	sw	a1,-24(s0)
    if ((pStream == stdout) || (pStream == stderr)) {
80000f06:	8841a783          	lw	a5,-1916(gp) # 40000004 <_impure_ptr>
80000f0a:	479c                	lw	a5,8(a5)
80000f0c:	fe842703          	lw	a4,-24(s0)
80000f10:	00f70963          	beq	a4,a5,80000f22 <fputc+0x2c>
80000f14:	8841a783          	lw	a5,-1916(gp) # 40000004 <_impure_ptr>
80000f18:	47dc                	lw	a5,12(a5)
80000f1a:	fe842703          	lw	a4,-24(s0)
80000f1e:	00f71c63          	bne	a4,a5,80000f36 <fputc+0x40>

    	PrintChar(c);
80000f22:	fec42783          	lw	a5,-20(s0)
80000f26:	0ff7f793          	zext.b	a5,a5
80000f2a:	853e                	mv	a0,a5
80000f2c:	e74ff0ef          	jal	ra,800005a0 <PrintChar>

        return c;
80000f30:	fec42783          	lw	a5,-20(s0)
80000f34:	a011                	j	80000f38 <fputc+0x42>
    }
    else {

        return EOF;
80000f36:	57fd                	li	a5,-1
    }
}
80000f38:	853e                	mv	a0,a5
80000f3a:	40f2                	lw	ra,28(sp)
80000f3c:	4462                	lw	s0,24(sp)
80000f3e:	6105                	addi	sp,sp,32
80000f40:	8082                	ret

80000f42 <fputs>:
 *
 * @return  Number of characters written if successful, or -1 if the output
 *          stream is not stdout or stderr.
 */
signed int fputs(const char *pStr, FILE *pStream)
{
80000f42:	7179                	addi	sp,sp,-48
80000f44:	d606                	sw	ra,44(sp)
80000f46:	d422                	sw	s0,40(sp)
80000f48:	1800                	addi	s0,sp,48
80000f4a:	fca42e23          	sw	a0,-36(s0)
80000f4e:	fcb42c23          	sw	a1,-40(s0)
    signed int num = 0;
80000f52:	fe042623          	sw	zero,-20(s0)

    while (*pStr != 0) {
80000f56:	a80d                	j	80000f88 <fputs+0x46>

        if (fputc(*pStr, pStream) == -1) {
80000f58:	fdc42783          	lw	a5,-36(s0)
80000f5c:	0007c783          	lbu	a5,0(a5)
80000f60:	fd842583          	lw	a1,-40(s0)
80000f64:	853e                	mv	a0,a5
80000f66:	3f41                	jal	80000ef6 <fputc>
80000f68:	872a                	mv	a4,a0
80000f6a:	57fd                	li	a5,-1
80000f6c:	00f71463          	bne	a4,a5,80000f74 <fputs+0x32>

            return -1;
80000f70:	57fd                	li	a5,-1
80000f72:	a015                	j	80000f96 <fputs+0x54>
        }
        num++;
80000f74:	fec42783          	lw	a5,-20(s0)
80000f78:	0785                	addi	a5,a5,1
80000f7a:	fef42623          	sw	a5,-20(s0)
        pStr++;
80000f7e:	fdc42783          	lw	a5,-36(s0)
80000f82:	0785                	addi	a5,a5,1
80000f84:	fcf42e23          	sw	a5,-36(s0)
    while (*pStr != 0) {
80000f88:	fdc42783          	lw	a5,-36(s0)
80000f8c:	0007c783          	lbu	a5,0(a5)
80000f90:	f7e1                	bnez	a5,80000f58 <fputs+0x16>
    }

    return num;
80000f92:	fec42783          	lw	a5,-20(s0)
}
80000f96:	853e                	mv	a0,a5
80000f98:	50b2                	lw	ra,44(sp)
80000f9a:	5422                	lw	s0,40(sp)
80000f9c:	6145                	addi	sp,sp,48
80000f9e:	8082                	ret

80000fa0 <retarget_init>:
#include "../Include/retarget.h"
// #include "../Include/system_k1921vg015.h"
#define SystemCoreClock_uart	SystemCoreClock
//-- Functions -----------------------------------------------------------------
void retarget_init()
{
80000fa0:	1101                	addi	sp,sp,-32
80000fa2:	ce22                	sw	s0,28(sp)
80000fa4:	1000                	addi	s0,sp,32
#if defined RETARGET
    uint32_t baud_icoef = HSECLK_VAL / (16 * RETARGET_UART_BAUD);
80000fa6:	47a1                	li	a5,8
80000fa8:	fef42623          	sw	a5,-20(s0)
    uint32_t baud_fcoef = ((HSECLK_VAL / (16.0f * RETARGET_UART_BAUD) - baud_icoef) * 64 + 0.5f);
80000fac:	fec42783          	lw	a5,-20(s0)
80000fb0:	d017f7d3          	fcvt.s.wu	fa5,a5
80000fb4:	800077b7          	lui	a5,0x80007
80000fb8:	e947a707          	flw	fa4,-364(a5) # 80006e94 <__data_source_start+0xfffffd1c>
80000fbc:	08f77753          	fsub.s	fa4,fa4,fa5
80000fc0:	800077b7          	lui	a5,0x80007
80000fc4:	e987a787          	flw	fa5,-360(a5) # 80006e98 <__data_source_start+0xfffffd20>
80000fc8:	10f77753          	fmul.s	fa4,fa4,fa5
80000fcc:	800077b7          	lui	a5,0x80007
80000fd0:	e9c7a787          	flw	fa5,-356(a5) # 80006e9c <__data_source_start+0xfffffd24>
80000fd4:	00f777d3          	fadd.s	fa5,fa4,fa5
80000fd8:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80000fdc:	fef42423          	sw	a5,-24(s0)

    //  GPIO
    RCU->CGCFGAHB_bit.GPIOAEN = 1;
80000fe0:	3000e7b7          	lui	a5,0x3000e
80000fe4:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80000fe8:	10076713          	ori	a4,a4,256
80000fec:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOAEN = 1;
80000ff0:	3000e7b7          	lui	a5,0x3000e
80000ff4:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80000ff8:	10076713          	ori	a4,a4,256
80000ffc:	00e79823          	sh	a4,16(a5)
    #if (RETARGET_UART_NUM == 0)
    RCU->CGCFGAPB_bit.UART0EN = 1;
    RCU->RSTDISAPB_bit.UART0EN = 1;
    #elif (RETARGET_UART_NUM == 1)
    RCU->CGCFGAPB_bit.UART1EN = 1;
80001000:	3000e7b7          	lui	a5,0x3000e
80001004:	4798                	lw	a4,8(a5)
80001006:	08076713          	ori	a4,a4,128
8000100a:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.UART1EN = 1;
8000100c:	3000e7b7          	lui	a5,0x3000e
80001010:	4f98                	lw	a4,24(a5)
80001012:	08076713          	ori	a4,a4,128
80001016:	cf98                	sw	a4,24(a5)
    #elif (RETARGET_UART_NUM == 3)
    RCU->CGCFGAPB_bit.UART3EN = 1;
    RCU->RSTDISAPB_bit.UART3EN = 1;
    #endif

    RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN2 = 1;
80001018:	280007b7          	lui	a5,0x28000
8000101c:	5fd8                	lw	a4,60(a5)
8000101e:	fcf77713          	andi	a4,a4,-49
80001022:	01076713          	ori	a4,a4,16
80001026:	dfd8                	sw	a4,60(a5)
    RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN3 = 1;
80001028:	280007b7          	lui	a5,0x28000
8000102c:	5fd8                	lw	a4,60(a5)
8000102e:	f3f77713          	andi	a4,a4,-193
80001032:	04076713          	ori	a4,a4,64
80001036:	dfd8                	sw	a4,60(a5)
    RETARGET_UART_PORT->ALTFUNCSET = (1 << RETARGET_UART_PIN_TX_POS) | (1 << RETARGET_UART_PIN_RX_POS);
80001038:	280007b7          	lui	a5,0x28000
8000103c:	4731                	li	a4,12
8000103e:	dbd8                	sw	a4,52(a5)

    //  UART0    
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.CLKSEL = RCU_UARTCLKCFG_CLKSEL_HSE;
80001040:	3000e7b7          	lui	a5,0x3000e
80001044:	5bf4                	lw	a3,116(a5)
80001046:	fffd0737          	lui	a4,0xfffd0
8000104a:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc8e87>
8000104c:	8ef9                	and	a3,a3,a4
8000104e:	6741                	lui	a4,0x10
80001050:	8f55                	or	a4,a4,a3
80001052:	dbf8                	sw	a4,116(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.DIVEN = 0;
80001054:	3000e7b7          	lui	a5,0x3000e
80001058:	5bf4                	lw	a3,116(a5)
8000105a:	fff00737          	lui	a4,0xfff00
8000105e:	177d                	addi	a4,a4,-1 # ffefffff <__data_source_start+0x7fef8e87>
80001060:	8f75                	and	a4,a4,a3
80001062:	dbf8                	sw	a4,116(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.RSTDIS = 1;
80001064:	3000e7b7          	lui	a5,0x3000e
80001068:	5bf8                	lw	a4,116(a5)
8000106a:	10076713          	ori	a4,a4,256
8000106e:	dbf8                	sw	a4,116(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.CLKEN = 1;
80001070:	3000e7b7          	lui	a5,0x3000e
80001074:	5bf8                	lw	a4,116(a5)
80001076:	00176713          	ori	a4,a4,1
8000107a:	dbf8                	sw	a4,116(a5)

    RETARGET_UART->IBRD = baud_icoef;
8000107c:	300077b7          	lui	a5,0x30007
80001080:	fec42703          	lw	a4,-20(s0)
80001084:	d3d8                	sw	a4,36(a5)
    RETARGET_UART->FBRD = baud_fcoef;
80001086:	300077b7          	lui	a5,0x30007
8000108a:	fe842703          	lw	a4,-24(s0)
8000108e:	d798                	sw	a4,40(a5)
    RETARGET_UART->LCRH = UART_LCRH_FEN_Msk | (3 << UART_LCRH_WLEN_Pos);
80001090:	300077b7          	lui	a5,0x30007
80001094:	07000713          	li	a4,112
80001098:	d7d8                	sw	a4,44(a5)
    RETARGET_UART->IFLS = 0;  //   
8000109a:	300077b7          	lui	a5,0x30007
8000109e:	0207aa23          	sw	zero,52(a5) # 30007034 <STACK_SIZE+0x30006834>
    RETARGET_UART->CR = UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
800010a2:	300077b7          	lui	a5,0x30007
800010a6:	30100713          	li	a4,769
800010aa:	db98                	sw	a4,48(a5)
#endif //RETARGET
}
800010ac:	0001                	nop
800010ae:	4472                	lw	s0,28(sp)
800010b0:	6105                	addi	sp,sp,32
800010b2:	8082                	ret

800010b4 <retarget_get_char>:

int retarget_get_char()
{
800010b4:	1141                	addi	sp,sp,-16
800010b6:	c622                	sw	s0,12(sp)
800010b8:	0800                	addi	s0,sp,16
#if defined RETARGET
    while (RETARGET_UART->FR_bit.RXFE) {
800010ba:	0001                	nop
800010bc:	300077b7          	lui	a5,0x30007
800010c0:	4f9c                	lw	a5,24(a5)
800010c2:	8391                	srli	a5,a5,0x4
800010c4:	8b85                	andi	a5,a5,1
800010c6:	0ff7f793          	zext.b	a5,a5
800010ca:	fbed                	bnez	a5,800010bc <retarget_get_char+0x8>
    };
    return (int)RETARGET_UART->DR_bit.DATA;
800010cc:	300077b7          	lui	a5,0x30007
800010d0:	0007c783          	lbu	a5,0(a5) # 30007000 <STACK_SIZE+0x30006800>
800010d4:	0ff7f793          	zext.b	a5,a5
#endif //RETARGET
    return -1;
}
800010d8:	853e                	mv	a0,a5
800010da:	4432                	lw	s0,12(sp)
800010dc:	0141                	addi	sp,sp,16
800010de:	8082                	ret

800010e0 <retarget_put_char>:

int retarget_put_char(int ch)
{
800010e0:	1101                	addi	sp,sp,-32
800010e2:	ce22                	sw	s0,28(sp)
800010e4:	1000                	addi	s0,sp,32
800010e6:	fea42623          	sw	a0,-20(s0)
#if defined RETARGET
    while (RETARGET_UART->FR_bit.BUSY) {
800010ea:	0001                	nop
800010ec:	300077b7          	lui	a5,0x30007
800010f0:	4f9c                	lw	a5,24(a5)
800010f2:	838d                	srli	a5,a5,0x3
800010f4:	8b85                	andi	a5,a5,1
800010f6:	0ff7f793          	zext.b	a5,a5
800010fa:	fbed                	bnez	a5,800010ec <retarget_put_char+0xc>
    };
    RETARGET_UART->DR = ch;
800010fc:	300077b7          	lui	a5,0x30007
80001100:	fec42703          	lw	a4,-20(s0)
80001104:	c398                	sw	a4,0(a5)
#endif //RETARGET
    return 0;
80001106:	4781                	li	a5,0
}
80001108:	853e                	mv	a0,a5
8000110a:	4472                	lw	s0,28(sp)
8000110c:	6105                	addi	sp,sp,32
8000110e:	8082                	ret

80001110 <SystemCoreClockUpdate>:
uint32_t SystemPll1Clock; // System PLL1Clock Frequency
uint32_t USBClock; 		  // USB Clock Frequency (USB PLL Clock)

//-- Functions -----------------------------------------------------------------
void SystemCoreClockUpdate(void)
{
80001110:	7139                	addi	sp,sp,-64
80001112:	de22                	sw	s0,60(sp)
80001114:	0080                	addi	s0,sp,64
    uint32_t current_sysclk;
    uint32_t pll_refclk, pll_refdiv, pll_frac, pll_fbdiv, pll_pd0a, pll_pd0b, pll_pd1a, pll_pd1b = 1;
80001116:	4785                	li	a5,1
80001118:	fef42423          	sw	a5,-24(s0)
    current_sysclk = RCU->CLKSTAT_bit.SRC;
8000111c:	3000e7b7          	lui	a5,0x3000e
80001120:	5fdc                	lw	a5,60(a5)
80001122:	8b8d                	andi	a5,a5,3
80001124:	0ff7f793          	zext.b	a5,a5
80001128:	fef42223          	sw	a5,-28(s0)
  	pll_refclk = HSECLK_VAL;
8000112c:	00f427b7          	lui	a5,0xf42
80001130:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80001134:	fef42023          	sw	a5,-32(s0)
   	pll_fbdiv = RCU->PLLSYSCFG2_bit.FBDIV;
80001138:	3000e7b7          	lui	a5,0x3000e
8000113c:	4fbc                	lw	a5,88(a5)
8000113e:	873e                	mv	a4,a5
80001140:	6785                	lui	a5,0x1
80001142:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80001144:	8ff9                	and	a5,a5,a4
80001146:	07c2                	slli	a5,a5,0x10
80001148:	83c1                	srli	a5,a5,0x10
8000114a:	fcf42e23          	sw	a5,-36(s0)
   	pll_refdiv = RCU->PLLSYSCFG0_bit.REFDIV;
8000114e:	3000e7b7          	lui	a5,0x3000e
80001152:	4bbc                	lw	a5,80(a5)
80001154:	839d                	srli	a5,a5,0x7
80001156:	03f7f793          	andi	a5,a5,63
8000115a:	0ff7f793          	zext.b	a5,a5
8000115e:	fcf42c23          	sw	a5,-40(s0)
   	pll_pd0a = RCU->PLLSYSCFG0_bit.PD0A;
80001162:	3000e7b7          	lui	a5,0x3000e
80001166:	4bbc                	lw	a5,80(a5)
80001168:	83b5                	srli	a5,a5,0xd
8000116a:	8b9d                	andi	a5,a5,7
8000116c:	0ff7f793          	zext.b	a5,a5
80001170:	fcf42a23          	sw	a5,-44(s0)
   	pll_pd0b = RCU->PLLSYSCFG0_bit.PD0B;
80001174:	3000e7b7          	lui	a5,0x3000e
80001178:	4bbc                	lw	a5,80(a5)
8000117a:	83c1                	srli	a5,a5,0x10
8000117c:	03f7f793          	andi	a5,a5,63
80001180:	0ff7f793          	zext.b	a5,a5
80001184:	fcf42823          	sw	a5,-48(s0)
   	pll_pd1a = RCU->PLLSYSCFG0_bit.PD1A;
80001188:	3000e7b7          	lui	a5,0x3000e
8000118c:	4bbc                	lw	a5,80(a5)
8000118e:	83d9                	srli	a5,a5,0x16
80001190:	8b9d                	andi	a5,a5,7
80001192:	0ff7f793          	zext.b	a5,a5
80001196:	fcf42623          	sw	a5,-52(s0)
   	pll_pd1b = RCU->PLLSYSCFG0_bit.PD1B;
8000119a:	3000e7b7          	lui	a5,0x3000e
8000119e:	4bbc                	lw	a5,80(a5)
800011a0:	83e5                	srli	a5,a5,0x19
800011a2:	03f7f793          	andi	a5,a5,63
800011a6:	0ff7f793          	zext.b	a5,a5
800011aa:	fef42423          	sw	a5,-24(s0)
   	if (RCU->PLLSYSCFG0_bit.DSMEN) pll_frac = RCU->PLLSYSCFG1_bit.FRAC;
800011ae:	3000e7b7          	lui	a5,0x3000e
800011b2:	4bbc                	lw	a5,80(a5)
800011b4:	8391                	srli	a5,a5,0x4
800011b6:	8b85                	andi	a5,a5,1
800011b8:	0ff7f793          	zext.b	a5,a5
800011bc:	cb99                	beqz	a5,800011d2 <SystemCoreClockUpdate+0xc2>
800011be:	3000e7b7          	lui	a5,0x3000e
800011c2:	4bf8                	lw	a4,84(a5)
800011c4:	010007b7          	lui	a5,0x1000
800011c8:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
800011ca:	8ff9                	and	a5,a5,a4
800011cc:	fef42623          	sw	a5,-20(s0)
800011d0:	a019                	j	800011d6 <SystemCoreClockUpdate+0xc6>
   	else pll_frac = 0;
800011d2:	fe042623          	sw	zero,-20(s0)

   	SystemPll0Clock = (pll_refclk * (pll_fbdiv+pll_frac/(1 << 24))) / (pll_refdiv * (1+pll_pd0a) * (1+pll_pd0b));
800011d6:	fec42783          	lw	a5,-20(s0)
800011da:	0187d713          	srli	a4,a5,0x18
800011de:	fdc42783          	lw	a5,-36(s0)
800011e2:	973e                	add	a4,a4,a5
800011e4:	fe042783          	lw	a5,-32(s0)
800011e8:	02f70733          	mul	a4,a4,a5
800011ec:	fd442783          	lw	a5,-44(s0)
800011f0:	00178693          	addi	a3,a5,1
800011f4:	fd842783          	lw	a5,-40(s0)
800011f8:	02f686b3          	mul	a3,a3,a5
800011fc:	fd042783          	lw	a5,-48(s0)
80001200:	0785                	addi	a5,a5,1
80001202:	02f687b3          	mul	a5,a3,a5
80001206:	02f75733          	divu	a4,a4,a5
8000120a:	e0e1aa23          	sw	a4,-492(gp) # 40000594 <SystemPll0Clock>
   	SystemPll1Clock = (pll_refclk * (pll_fbdiv+pll_frac/(1 << 24))) / (pll_refdiv * (1+pll_pd1a) * (1+pll_pd1b));
8000120e:	fec42783          	lw	a5,-20(s0)
80001212:	0187d713          	srli	a4,a5,0x18
80001216:	fdc42783          	lw	a5,-36(s0)
8000121a:	973e                	add	a4,a4,a5
8000121c:	fe042783          	lw	a5,-32(s0)
80001220:	02f70733          	mul	a4,a4,a5
80001224:	fcc42783          	lw	a5,-52(s0)
80001228:	00178693          	addi	a3,a5,1
8000122c:	fd842783          	lw	a5,-40(s0)
80001230:	02f686b3          	mul	a3,a3,a5
80001234:	fe842783          	lw	a5,-24(s0)
80001238:	0785                	addi	a5,a5,1
8000123a:	02f687b3          	mul	a5,a3,a5
8000123e:	02f75733          	divu	a4,a4,a5
80001242:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemPll1Clock>
    switch (current_sysclk) {
80001246:	fe442703          	lw	a4,-28(s0)
8000124a:	478d                	li	a5,3
8000124c:	04f70d63          	beq	a4,a5,800012a6 <SystemCoreClockUpdate+0x196>
80001250:	fe442703          	lw	a4,-28(s0)
80001254:	478d                	li	a5,3
80001256:	04e7ec63          	bltu	a5,a4,800012ae <SystemCoreClockUpdate+0x19e>
8000125a:	fe442703          	lw	a4,-28(s0)
8000125e:	4789                	li	a5,2
80001260:	02f70e63          	beq	a4,a5,8000129c <SystemCoreClockUpdate+0x18c>
80001264:	fe442703          	lw	a4,-28(s0)
80001268:	4789                	li	a5,2
8000126a:	04e7e263          	bltu	a5,a4,800012ae <SystemCoreClockUpdate+0x19e>
8000126e:	fe442783          	lw	a5,-28(s0)
80001272:	c799                	beqz	a5,80001280 <SystemCoreClockUpdate+0x170>
80001274:	fe442703          	lw	a4,-28(s0)
80001278:	4785                	li	a5,1
8000127a:	00f70a63          	beq	a4,a5,8000128e <SystemCoreClockUpdate+0x17e>
    case RCU_CLKSTAT_SRC_LSICLK:
    	SystemCoreClock = LSICLK_VAL;
        break;
    }

}
8000127e:	a805                	j	800012ae <SystemCoreClockUpdate+0x19e>
        SystemCoreClock = HSICLK_VAL;
80001280:	000f4737          	lui	a4,0xf4
80001284:	24070713          	addi	a4,a4,576 # f4240 <STACK_SIZE+0xf3a40>
80001288:	e0e1a823          	sw	a4,-496(gp) # 40000590 <SystemCoreClock>
        break;
8000128c:	a00d                	j	800012ae <SystemCoreClockUpdate+0x19e>
        SystemCoreClock = HSECLK_VAL;
8000128e:	00f42737          	lui	a4,0xf42
80001292:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
80001296:	e0e1a823          	sw	a4,-496(gp) # 40000590 <SystemCoreClock>
        break;
8000129a:	a811                	j	800012ae <SystemCoreClockUpdate+0x19e>
    	SystemCoreClock = SystemPll0Clock;
8000129c:	e141a703          	lw	a4,-492(gp) # 40000594 <SystemPll0Clock>
800012a0:	e0e1a823          	sw	a4,-496(gp) # 40000590 <SystemCoreClock>
    	break;
800012a4:	a029                	j	800012ae <SystemCoreClockUpdate+0x19e>
    	SystemCoreClock = LSICLK_VAL;
800012a6:	6721                	lui	a4,0x8
800012a8:	e0e1a823          	sw	a4,-496(gp) # 40000590 <SystemCoreClock>
        break;
800012ac:	0001                	nop
}
800012ae:	0001                	nop
800012b0:	5472                	lw	s0,60(sp)
800012b2:	6121                	addi	sp,sp,64
800012b4:	8082                	ret

800012b6 <ClkInit>:

void ClkInit()
{
800012b6:	1101                	addi	sp,sp,-32
800012b8:	ce22                	sw	s0,28(sp)
800012ba:	1000                	addi	s0,sp,32
    uint32_t timeout_counter = 0;
800012bc:	fe042623          	sw	zero,-20(s0)
    uint32_t sysclk_source;

    //clockout control
    #ifndef CKO_NONE
        //C7 clockout
        RCU->CGCFGAHB_bit.GPIOCEN = 1;
800012c0:	3000e7b7          	lui	a5,0x3000e
800012c4:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
800012c8:	40076713          	ori	a4,a4,1024
800012cc:	00e79023          	sh	a4,0(a5)
        RCU->RSTDISAHB_bit.GPIOCEN = 1;
800012d0:	3000e7b7          	lui	a5,0x3000e
800012d4:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
800012d8:	40076713          	ori	a4,a4,1024
800012dc:	00e79823          	sh	a4,16(a5)
        GPIOC->ALTFUNCNUM_bit.PIN7 = 3;
800012e0:	280027b7          	lui	a5,0x28002
800012e4:	5fd4                	lw	a3,60(a5)
800012e6:	6731                	lui	a4,0xc
800012e8:	8f55                	or	a4,a4,a3
800012ea:	dfd8                	sw	a4,60(a5)
        GPIOC->ALTFUNCSET_bit.PIN7 = 1;
800012ec:	280027b7          	lui	a5,0x28002
800012f0:	0347d703          	lhu	a4,52(a5) # 28002034 <STACK_SIZE+0x28001834>
800012f4:	08076713          	ori	a4,a4,128
800012f8:	02e79a23          	sh	a4,52(a5)
        RCU->CLKOUTCFG = (RCU_CLKOUTCFG_CLKSEL_HSE << RCU_CLKOUTCFG_CLKSEL_Pos) |
				  	  	  (1 << RCU_CLKOUTCFG_DIVN_Pos) |
						  (0 << RCU_CLKOUTCFG_DIVEN_Pos) |
						  RCU_CLKOUTCFG_RSTDIS_Msk | RCU_CLKOUTCFG_CLKEN_Msk; //CKO = HSECLK
    #elif defined CKO_PLL0
        RCU->CLKOUTCFG = (RCU_CLKOUTCFG_CLKSEL_PLL0 << RCU_CLKOUTCFG_CLKSEL_Pos) |
800012fc:	3000e7b7          	lui	a5,0x3000e
80001300:	6745                	lui	a4,0x11
80001302:	12170713          	addi	a4,a4,289 # 11121 <STACK_SIZE+0x10921>
80001306:	0ae7ae23          	sw	a4,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
	RCU->PLLSYSCFG2 = 100;         //FBDIV
#elif (HSECLK_VAL == 16000000)
// Fout0 = 50 000 000 Hz
// Fout1 = 12 500 000 Hz
	RCU->PLLSYSCFG0 =( 7 << RCU_PLLSYSCFG0_PD1B_Pos) |  //PD1B
8000130a:	3000e7b7          	lui	a5,0x3000e
8000130e:	0fc16737          	lui	a4,0xfc16
80001312:	10770713          	addi	a4,a4,263 # fc16107 <STACK_SIZE+0xfc15907>
80001316:	cbb8                	sw	a4,80(a5)
					 ( 0 << RCU_PLLSYSCFG0_FOUTEN_Pos)    |  //fouten
					 ( 0 << RCU_PLLSYSCFG0_DSMEN_Pos)     |  //dsmen
					 ( 0 << RCU_PLLSYSCFG0_DACEN_Pos)     |  //dacen
					 ( 3 << RCU_PLLSYSCFG0_BYP_Pos)       |  //bypass
					 ( 1 << RCU_PLLSYSCFG0_PLLEN_Pos);       //en
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
80001318:	3000e7b7          	lui	a5,0x3000e
8000131c:	0407aa23          	sw	zero,84(a5) # 3000e054 <STACK_SIZE+0x3000d854>
	RCU->PLLSYSCFG2 = 50;         //FBDIV
80001320:	3000e7b7          	lui	a5,0x3000e
80001324:	03200713          	li	a4,50
80001328:	cfb8                	sw	a4,88(a5)
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
	RCU->PLLSYSCFG2 = 65;         //FBDIV
#else
#error "Please define HSECLK_VAL with correct values!"
#endif
	RCU->PLLSYSCFG0_bit.FOUTEN = 1; 	// Fout0 Enable
8000132a:	3000e7b7          	lui	a5,0x3000e
8000132e:	4bb8                	lw	a4,80(a5)
80001330:	f9f77713          	andi	a4,a4,-97
80001334:	02076713          	ori	a4,a4,32
80001338:	cbb8                	sw	a4,80(a5)
	timeout_counter = 1000;
8000133a:	3e800793          	li	a5,1000
8000133e:	fef42623          	sw	a5,-20(s0)
	while(timeout_counter) timeout_counter--;
80001342:	a031                	j	8000134e <ClkInit+0x98>
80001344:	fec42783          	lw	a5,-20(s0)
80001348:	17fd                	addi	a5,a5,-1 # 3000dfff <STACK_SIZE+0x3000d7ff>
8000134a:	fef42623          	sw	a5,-20(s0)
8000134e:	fec42783          	lw	a5,-20(s0)
80001352:	fbed                	bnez	a5,80001344 <ClkInit+0x8e>
	while((RCU->PLLSYSSTAT_bit.LOCK) != 1)
80001354:	0001                	nop
80001356:	3000e7b7          	lui	a5,0x3000e
8000135a:	53bc                	lw	a5,96(a5)
8000135c:	8b85                	andi	a5,a5,1
8000135e:	0ff7f713          	zext.b	a4,a5
80001362:	4785                	li	a5,1
80001364:	fef719e3          	bne	a4,a5,80001356 <ClkInit+0xa0>
	{}; 								// wait lock signal
	RCU->PLLSYSCFG0_bit.BYP = 2; 		// Bypass for Fout1
80001368:	3000e7b7          	lui	a5,0x3000e
8000136c:	4bb8                	lw	a4,80(a5)
8000136e:	9b65                	andi	a4,a4,-7
80001370:	00476713          	ori	a4,a4,4
80001374:	cbb8                	sw	a4,80(a5)
	//select PLL as source system clock
	sysclk_source = RCU_SYSCLKCFG_SRC_SYSPLL0CLK;
80001376:	4789                	li	a5,2
80001378:	fef42423          	sw	a5,-24(s0)
    // FLASH control settings
    FLASH->CTRL_bit.LAT = 3;
8000137c:	3000d7b7          	lui	a5,0x3000d
80001380:	47f4                	lw	a3,76(a5)
80001382:	fff10737          	lui	a4,0xfff10
80001386:	177d                	addi	a4,a4,-1 # fff0ffff <__data_source_start+0x7ff08e87>
80001388:	8ef9                	and	a3,a3,a4
8000138a:	00030737          	lui	a4,0x30
8000138e:	8f55                	or	a4,a4,a3
80001390:	c7f8                	sw	a4,76(a5)
    FLASH->CTRL_bit.CEN = 1;
80001392:	3000d7b7          	lui	a5,0x3000d
80001396:	47f8                	lw	a4,76(a5)
80001398:	00276713          	ori	a4,a4,2
8000139c:	c7f8                	sw	a4,76(a5)
#else
#error "Please define SYSCLK source (SYSCLK_PLL | SYSCLK_HSE | SYSCLK_HSI | SYSCLK_LSI)!"
#endif

    //switch sysclk
    RCU->SYSCLKCFG = (sysclk_source << RCU_SYSCLKCFG_SRC_Pos);
8000139e:	3000e7b7          	lui	a5,0x3000e
800013a2:	fe842703          	lw	a4,-24(s0)
800013a6:	db98                	sw	a4,48(a5)
    // Wait switching done
    timeout_counter = 0;
800013a8:	fe042623          	sw	zero,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)) //SYSCLK_SWITCH_TIMEOUT))
800013ac:	a031                	j	800013b8 <ClkInit+0x102>
        timeout_counter++;
800013ae:	fec42783          	lw	a5,-20(s0)
800013b2:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
800013b4:	fef42623          	sw	a5,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)) //SYSCLK_SWITCH_TIMEOUT))
800013b8:	3000e7b7          	lui	a5,0x3000e
800013bc:	5fdc                	lw	a5,60(a5)
800013be:	8b8d                	andi	a5,a5,3
800013c0:	0ff7f713          	zext.b	a4,a5
800013c4:	3000e7b7          	lui	a5,0x3000e
800013c8:	5b9c                	lw	a5,48(a5)
800013ca:	8b8d                	andi	a5,a5,3
800013cc:	0ff7f793          	zext.b	a5,a5
800013d0:	00f70863          	beq	a4,a5,800013e0 <ClkInit+0x12a>
800013d4:	fec42703          	lw	a4,-20(s0)
800013d8:	06300793          	li	a5,99
800013dc:	fce7f9e3          	bgeu	a5,a4,800013ae <ClkInit+0xf8>
/*    if (timeout_counter == SYSCLK_SWITCH_TIMEOUT) //SYSCLK failed to switch
        while (1) {
        };*/

}
800013e0:	0001                	nop
800013e2:	4472                	lw	s0,28(sp)
800013e4:	6105                	addi	sp,sp,32
800013e6:	8082                	ret

800013e8 <InterruptEnable>:

void InterruptEnable()
{
800013e8:	1101                	addi	sp,sp,-32
800013ea:	ce06                	sw	ra,28(sp)
800013ec:	cc22                	sw	s0,24(sp)
800013ee:	1000                	addi	s0,sp,32
	//allow all interrupts in machine mode
	PLIC_SetThreshold (Plic_Mach_Target, 0); //allow all interrupts in machine mode
800013f0:	4581                	li	a1,0
800013f2:	4501                	li	a0,0
800013f4:	8d2ff0ef          	jal	ra,800004c6 <PLIC_SetThreshold>
    // disable timer interrupt
//    clear_csr(mie, MIE_MTIMER);
    // enable machine external interrupt
    set_csr(mie, MIE_MEXTERNAL);
800013f8:	6785                	lui	a5,0x1
800013fa:	80078793          	addi	a5,a5,-2048 # 800 <STACK_SIZE>
800013fe:	fef42623          	sw	a5,-20(s0)
80001402:	fec42783          	lw	a5,-20(s0)
80001406:	3047a7f3          	csrrs	a5,mie,a5
8000140a:	fef42623          	sw	a5,-20(s0)
    // enable global interrupts
    set_csr(mstatus, MSTATUS_MIE);
8000140e:	47a1                	li	a5,8
80001410:	fef42423          	sw	a5,-24(s0)
80001414:	fe842783          	lw	a5,-24(s0)
80001418:	3007a7f3          	csrrs	a5,mstatus,a5
8000141c:	fef42423          	sw	a5,-24(s0)
}
80001420:	0001                	nop
80001422:	40f2                	lw	ra,28(sp)
80001424:	4462                	lw	s0,24(sp)
80001426:	6105                	addi	sp,sp,32
80001428:	8082                	ret

8000142a <SystemInit>:

void SystemInit(void)
{
8000142a:	1141                	addi	sp,sp,-16
8000142c:	c606                	sw	ra,12(sp)
8000142e:	c422                	sw	s0,8(sp)
80001430:	0800                	addi	s0,sp,16
//	clear_csr(mie, MIE_MTIMER);
	// enable machine external interrupt
//	set_csr(mie, MIE_MEXTERNAL);
	// enable global interrupts
//	set_csr(mstatus, MSTATUS_MIE);
	ClkInit();
80001432:	3551                	jal	800012b6 <ClkInit>
}
80001434:	0001                	nop
80001436:	40b2                	lw	ra,12(sp)
80001438:	4422                	lw	s0,8(sp)
8000143a:	0141                	addi	sp,sp,16
8000143c:	8082                	ret

8000143e <TMR32_SetMode>:
  * @brief     
  * @param   mode  
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetMode(TMR32_Mode_TypeDef mode)
{
8000143e:	1101                	addi	sp,sp,-32
80001440:	ce22                	sw	s0,28(sp)
80001442:	1000                	addi	s0,sp,32
80001444:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_MODE(mode));

    MODIFY_REG(TMR32->CTRL, TMR32_CTRL_MODE_Msk, (uint32_t) mode << TMR32_CTRL_MODE_Pos);
80001448:	300007b7          	lui	a5,0x30000
8000144c:	439c                	lw	a5,0(a5)
8000144e:	fcf7f693          	andi	a3,a5,-49
80001452:	fec42783          	lw	a5,-20(s0)
80001456:	00479713          	slli	a4,a5,0x4
8000145a:	300007b7          	lui	a5,0x30000
8000145e:	8f55                	or	a4,a4,a3
80001460:	c398                	sw	a4,0(a5)
}
80001462:	0001                	nop
80001464:	4472                	lw	s0,28(sp)
80001466:	6105                	addi	sp,sp,32
80001468:	8082                	ret

8000146a <TMR32_SetDivider>:
  * @brief       
  * @param   div  
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetDivider(TMR32_Div_TypeDef div)
{
8000146a:	1101                	addi	sp,sp,-32
8000146c:	ce22                	sw	s0,28(sp)
8000146e:	1000                	addi	s0,sp,32
80001470:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_DIV(div));

    MODIFY_REG(TMR32->CTRL, TMR32_CTRL_DIV_Msk, (uint32_t) div << TMR32_CTRL_DIV_Pos);
80001474:	300007b7          	lui	a5,0x30000
80001478:	439c                	lw	a5,0(a5)
8000147a:	f3f7f693          	andi	a3,a5,-193
8000147e:	fec42783          	lw	a5,-20(s0)
80001482:	00679713          	slli	a4,a5,0x6
80001486:	300007b7          	lui	a5,0x30000
8000148a:	8f55                	or	a4,a4,a3
8000148c:	c398                	sw	a4,0(a5)
}
8000148e:	0001                	nop
80001490:	4472                	lw	s0,28(sp)
80001492:	6105                	addi	sp,sp,32
80001494:	8082                	ret

80001496 <TMR32_SetClksel>:
  * @brief      
  * @param   sel  
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetClksel(TMR32_Clksel_TypeDef sel)
{
80001496:	1101                	addi	sp,sp,-32
80001498:	ce22                	sw	s0,28(sp)
8000149a:	1000                	addi	s0,sp,32
8000149c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_CLKSEL(sel));

    MODIFY_REG(TMR32->CTRL, TMR32_CTRL_CLKSEL_Msk, (uint32_t) sel << TMR32_CTRL_CLKSEL_Pos);
800014a0:	300007b7          	lui	a5,0x30000
800014a4:	439c                	lw	a5,0(a5)
800014a6:	eff7f693          	andi	a3,a5,-257
800014aa:	fec42783          	lw	a5,-20(s0)
800014ae:	00879713          	slli	a4,a5,0x8
800014b2:	300007b7          	lui	a5,0x30000
800014b6:	8f55                	or	a4,a4,a3
800014b8:	c398                	sw	a4,0(a5)
}
800014ba:	0001                	nop
800014bc:	4472                	lw	s0,28(sp)
800014be:	6105                	addi	sp,sp,32
800014c0:	8082                	ret

800014c2 <TMR32_SetCounter>:
  * @brief     
  * @param   CountVal   
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetCounter(uint32_t CountVal)
{
800014c2:	1101                	addi	sp,sp,-32
800014c4:	ce22                	sw	s0,28(sp)
800014c6:	1000                	addi	s0,sp,32
800014c8:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(TMR32->COUNT, CountVal);
800014cc:	300007b7          	lui	a5,0x30000
800014d0:	fec42703          	lw	a4,-20(s0)
800014d4:	c3d8                	sw	a4,4(a5)
}
800014d6:	0001                	nop
800014d8:	4472                	lw	s0,28(sp)
800014da:	6105                	addi	sp,sp,32
800014dc:	8082                	ret

800014de <TMR32_ITCmd>:
  * @param   it     @ref TMR32_IT_TypeDef
  * @param   state     
  * @retval  void
  */
__STATIC_INLINE void TMR32_ITCmd(TMR32_IT_TypeDef it, FunctionalState state)
{
800014de:	1101                	addi	sp,sp,-32
800014e0:	ce22                	sw	s0,28(sp)
800014e2:	1000                	addi	s0,sp,32
800014e4:	fea42623          	sw	a0,-20(s0)
800014e8:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_TMR32_IT(it));
    assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(TMR32->IM, it, (uint32_t) state * (uint32_t) it);
800014ec:	300007b7          	lui	a5,0x30000
800014f0:	4798                	lw	a4,8(a5)
800014f2:	fec42783          	lw	a5,-20(s0)
800014f6:	fff7c793          	not	a5,a5
800014fa:	00f776b3          	and	a3,a4,a5
800014fe:	fe842703          	lw	a4,-24(s0)
80001502:	fec42783          	lw	a5,-20(s0)
80001506:	02f70733          	mul	a4,a4,a5
8000150a:	300007b7          	lui	a5,0x30000
8000150e:	8f55                	or	a4,a4,a3
80001510:	c798                	sw	a4,8(a5)
}
80001512:	0001                	nop
80001514:	4472                	lw	s0,28(sp)
80001516:	6105                	addi	sp,sp,32
80001518:	8082                	ret

8000151a <TMR32_ITClear>:
  * @brief    
  * @param   it     @ref TMR32_IT_TypeDef
  * @retval  void
  */
__STATIC_INLINE void TMR32_ITClear(TMR32_IT_TypeDef it)
{
8000151a:	1101                	addi	sp,sp,-32
8000151c:	ce22                	sw	s0,28(sp)
8000151e:	1000                	addi	s0,sp,32
80001520:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_TMR32_IT(it));

    SET_BIT(TMR32->IC, it);
80001524:	300007b7          	lui	a5,0x30000
80001528:	4bd4                	lw	a3,20(a5)
8000152a:	300007b7          	lui	a5,0x30000
8000152e:	fec42703          	lw	a4,-20(s0)
80001532:	8f55                	or	a4,a4,a3
80001534:	cbd8                	sw	a4,20(a5)
}
80001536:	0001                	nop
80001538:	4472                	lw	s0,28(sp)
8000153a:	6105                	addi	sp,sp,32
8000153c:	8082                	ret

8000153e <TMR32_CAPCOM_SetComparator>:
  * @param   capcomx   capcom @ref TMR32_CAPCOM_Num_TypeDef.
  * @param   CapComVal    
  * @retval  void
  */
__STATIC_INLINE void TMR32_CAPCOM_SetComparator(TMR32_CAPCOM_Num_TypeDef capcomx, uint32_t capcomVal)
{
8000153e:	1101                	addi	sp,sp,-32
80001540:	ce22                	sw	s0,28(sp)
80001542:	1000                	addi	s0,sp,32
80001544:	fea42623          	sw	a0,-20(s0)
80001548:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_TMR32_CAPCOM(capcomx));

    WRITE_REG(TMR32->CAPCOM[capcomx].VAL, capcomVal);
8000154c:	30000737          	lui	a4,0x30000
80001550:	fec42783          	lw	a5,-20(s0)
80001554:	0789                	addi	a5,a5,2 # 30000002 <STACK_SIZE+0x2ffff802>
80001556:	078e                	slli	a5,a5,0x3
80001558:	97ba                	add	a5,a5,a4
8000155a:	fe842703          	lw	a4,-24(s0)
8000155e:	c7d8                	sw	a4,12(a5)
}
80001560:	0001                	nop
80001562:	4472                	lw	s0,28(sp)
80001564:	6105                	addi	sp,sp,32
80001566:	8082                	ret

80001568 <GPIO_ReadBit>:
  * @param   GPIOx   ,  x=A|B|C
  * @param   Pin   
  * @retval  State      ,       .
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80001568:	1101                	addi	sp,sp,-32
8000156a:	ce22                	sw	s0,28(sp)
8000156c:	1000                	addi	s0,sp,32
8000156e:	fea42623          	sw	a0,-20(s0)
80001572:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
80001576:	fec42783          	lw	a5,-20(s0)
8000157a:	4398                	lw	a4,0(a5)
8000157c:	fe842783          	lw	a5,-24(s0)
80001580:	8ff9                	and	a5,a5,a4
80001582:	c399                	beqz	a5,80001588 <GPIO_ReadBit+0x20>
80001584:	4785                	li	a5,1
80001586:	a011                	j	8000158a <GPIO_ReadBit+0x22>
80001588:	4781                	li	a5,0
}
8000158a:	853e                	mv	a0,a5
8000158c:	4472                	lw	s0,28(sp)
8000158e:	6105                	addi	sp,sp,32
80001590:	8082                	ret

80001592 <GPIO_SetBits>:
  * @param   GPIOx   ,  x=A|B|C
  * @param   Pin   
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80001592:	1101                	addi	sp,sp,-32
80001594:	ce22                	sw	s0,28(sp)
80001596:	1000                	addi	s0,sp,32
80001598:	fea42623          	sw	a0,-20(s0)
8000159c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
800015a0:	fec42783          	lw	a5,-20(s0)
800015a4:	fe842703          	lw	a4,-24(s0)
800015a8:	c798                	sw	a4,8(a5)
}
800015aa:	0001                	nop
800015ac:	4472                	lw	s0,28(sp)
800015ae:	6105                	addi	sp,sp,32
800015b0:	8082                	ret

800015b2 <GPIO_ClearBits>:
  * @param   GPIOx   ,  x=A|B|C
  * @param   Pin   
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
800015b2:	1101                	addi	sp,sp,-32
800015b4:	ce22                	sw	s0,28(sp)
800015b6:	1000                	addi	s0,sp,32
800015b8:	fea42623          	sw	a0,-20(s0)
800015bc:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
800015c0:	fec42783          	lw	a5,-20(s0)
800015c4:	fe842703          	lw	a4,-24(s0)
800015c8:	c7d8                	sw	a4,12(a5)
}
800015ca:	0001                	nop
800015cc:	4472                	lw	s0,28(sp)
800015ce:	6105                	addi	sp,sp,32
800015d0:	8082                	ret

800015d2 <GPIO_QualModeConfig>:
  * @param   Pin   .     GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   Mode   
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_QualMode_TypeDef Mode)
{
800015d2:	1101                	addi	sp,sp,-32
800015d4:	ce22                	sw	s0,28(sp)
800015d6:	1000                	addi	s0,sp,32
800015d8:	fea42623          	sw	a0,-20(s0)
800015dc:	feb42423          	sw	a1,-24(s0)
800015e0:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_QUAL_MODE(Mode));

    if (Mode == GPIO_QualMode_6Sample)
800015e4:	fe442703          	lw	a4,-28(s0)
800015e8:	4785                	li	a5,1
800015ea:	00f71863          	bne	a4,a5,800015fa <GPIO_QualModeConfig+0x28>
        WRITE_REG(GPIOx->QUALMODESET, Pin);
800015ee:	fec42783          	lw	a5,-20(s0)
800015f2:	fe842703          	lw	a4,-24(s0)
800015f6:	cbf8                	sw	a4,84(a5)
    else
        WRITE_REG(GPIOx->QUALMODECLR, Pin);
}
800015f8:	a031                	j	80001604 <GPIO_QualModeConfig+0x32>
        WRITE_REG(GPIOx->QUALMODECLR, Pin);
800015fa:	fec42783          	lw	a5,-20(s0)
800015fe:	fe842703          	lw	a4,-24(s0)
80001602:	cfb8                	sw	a4,88(a5)
}
80001604:	0001                	nop
80001606:	4472                	lw	s0,28(sp)
80001608:	6105                	addi	sp,sp,32
8000160a:	8082                	ret

8000160c <GPIO_QualSampleConfig>:
  * @param   GPIOx   ,  x=A|B|C
  * @param   SamplePerod        
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualSampleConfig(GPIO_TypeDef* GPIOx, uint32_t SamplePerod)
{
8000160c:	1101                	addi	sp,sp,-32
8000160e:	ce22                	sw	s0,28(sp)
80001610:	1000                	addi	s0,sp,32
80001612:	fea42623          	sw	a0,-20(s0)
80001616:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_QUAL_PERIOD(SamplePerod));

    WRITE_REG(GPIOx->QUALSAMPLE, SamplePerod);
8000161a:	fec42783          	lw	a5,-20(s0)
8000161e:	fe842703          	lw	a4,-24(s0)
80001622:	cff8                	sw	a4,92(a5)
}
80001624:	0001                	nop
80001626:	4472                	lw	s0,28(sp)
80001628:	6105                	addi	sp,sp,32
8000162a:	8082                	ret

8000162c <GPIO_QualCmd>:
  * @param   Pin   .     GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
8000162c:	1101                	addi	sp,sp,-32
8000162e:	ce22                	sw	s0,28(sp)
80001630:	1000                	addi	s0,sp,32
80001632:	fea42623          	sw	a0,-20(s0)
80001636:	feb42423          	sw	a1,-24(s0)
8000163a:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000163e:	fe442703          	lw	a4,-28(s0)
80001642:	4785                	li	a5,1
80001644:	00f71863          	bne	a4,a5,80001654 <GPIO_QualCmd+0x28>
        WRITE_REG(GPIOx->QUALSET, Pin);
80001648:	fec42783          	lw	a5,-20(s0)
8000164c:	fe842703          	lw	a4,-24(s0)
80001650:	c7f8                	sw	a4,76(a5)
    else
        WRITE_REG(GPIOx->QUALCLR, Pin);
}
80001652:	a031                	j	8000165e <GPIO_QualCmd+0x32>
        WRITE_REG(GPIOx->QUALCLR, Pin);
80001654:	fec42783          	lw	a5,-20(s0)
80001658:	fe842703          	lw	a4,-24(s0)
8000165c:	cbb8                	sw	a4,80(a5)
}
8000165e:	0001                	nop
80001660:	4472                	lw	s0,28(sp)
80001662:	6105                	addi	sp,sp,32
80001664:	8082                	ret

80001666 <GPIO_SyncCmd>:
  * @param   Pin   .     GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void GPIO_SyncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80001666:	1101                	addi	sp,sp,-32
80001668:	ce22                	sw	s0,28(sp)
8000166a:	1000                	addi	s0,sp,32
8000166c:	fea42623          	sw	a0,-20(s0)
80001670:	feb42423          	sw	a1,-24(s0)
80001674:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80001678:	fe442703          	lw	a4,-28(s0)
8000167c:	4785                	li	a5,1
8000167e:	00f71863          	bne	a4,a5,8000168e <GPIO_SyncCmd+0x28>
        WRITE_REG(GPIOx->SYNCSET, Pin);
80001682:	fec42783          	lw	a5,-20(s0)
80001686:	fe842703          	lw	a4,-24(s0)
8000168a:	c3f8                	sw	a4,68(a5)
    else
        WRITE_REG(GPIOx->SYNCCLR, Pin);
}
8000168c:	a031                	j	80001698 <GPIO_SyncCmd+0x32>
        WRITE_REG(GPIOx->SYNCCLR, Pin);
8000168e:	fec42783          	lw	a5,-20(s0)
80001692:	fe842703          	lw	a4,-24(s0)
80001696:	c7b8                	sw	a4,72(a5)
}
80001698:	0001                	nop
8000169a:	4472                	lw	s0,28(sp)
8000169c:	6105                	addi	sp,sp,32
8000169e:	8082                	ret

800016a0 <UART1_init>:
static void tmr32_init(void);
static void tmr32_irq_handler(void);
 

void UART1_init()
{
800016a0:	1101                	addi	sp,sp,-32
800016a2:	ce22                	sw	s0,28(sp)
800016a4:	1000                	addi	s0,sp,32
    uint32_t baud_icoef = HSECLK_VAL / (16 * UART1_BAUD);
800016a6:	47a1                	li	a5,8
800016a8:	fef42623          	sw	a5,-20(s0)
    uint32_t baud_fcoef = ((HSECLK_VAL / (16.0f * UART1_BAUD) - baud_icoef) * 64 + 0.5f);
800016ac:	fec42783          	lw	a5,-20(s0)
800016b0:	d017f7d3          	fcvt.s.wu	fa5,a5
800016b4:	800077b7          	lui	a5,0x80007
800016b8:	ec47a707          	flw	fa4,-316(a5) # 80006ec4 <__data_source_start+0xfffffd4c>
800016bc:	08f77753          	fsub.s	fa4,fa4,fa5
800016c0:	800077b7          	lui	a5,0x80007
800016c4:	ec87a787          	flw	fa5,-312(a5) # 80006ec8 <__data_source_start+0xfffffd50>
800016c8:	10f77753          	fmul.s	fa4,fa4,fa5
800016cc:	800077b7          	lui	a5,0x80007
800016d0:	ecc7a787          	flw	fa5,-308(a5) # 80006ecc <__data_source_start+0xfffffd54>
800016d4:	00f777d3          	fadd.s	fa5,fa4,fa5
800016d8:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
800016dc:	fef42423          	sw	a5,-24(s0)
    //  GPIO
    RCU->CGCFGAHB_bit.GPIOAEN = 1;
800016e0:	3000e7b7          	lui	a5,0x3000e
800016e4:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
800016e8:	10076713          	ori	a4,a4,256
800016ec:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOAEN = 1;
800016f0:	3000e7b7          	lui	a5,0x3000e
800016f4:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
800016f8:	10076713          	ori	a4,a4,256
800016fc:	00e79823          	sh	a4,16(a5)
    RCU->CGCFGAPB_bit.UART1EN = 1;
80001700:	3000e7b7          	lui	a5,0x3000e
80001704:	4798                	lw	a4,8(a5)
80001706:	08076713          	ori	a4,a4,128
8000170a:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.UART1EN = 1;
8000170c:	3000e7b7          	lui	a5,0x3000e
80001710:	4f98                	lw	a4,24(a5)
80001712:	08076713          	ori	a4,a4,128
80001716:	cf98                	sw	a4,24(a5)

    GPIOA->ALTFUNCNUM_bit.PIN2 = 1;
80001718:	280007b7          	lui	a5,0x28000
8000171c:	5fd8                	lw	a4,60(a5)
8000171e:	fcf77713          	andi	a4,a4,-49
80001722:	01076713          	ori	a4,a4,16
80001726:	dfd8                	sw	a4,60(a5)
    GPIOA->ALTFUNCNUM_bit.PIN3 = 1;
80001728:	280007b7          	lui	a5,0x28000
8000172c:	5fd8                	lw	a4,60(a5)
8000172e:	f3f77713          	andi	a4,a4,-193
80001732:	04076713          	ori	a4,a4,64
80001736:	dfd8                	sw	a4,60(a5)
    GPIOA->ALTFUNCSET = GPIO_ALTFUNCSET_PIN2_Msk | GPIO_ALTFUNCSET_PIN3_Msk;
80001738:	280007b7          	lui	a5,0x28000
8000173c:	4731                	li	a4,12
8000173e:	dbd8                	sw	a4,52(a5)

    //  UART1
    RCU->UARTCLKCFG[1].UARTCLKCFG_bit.CLKSEL = RCU_UARTCLKCFG_CLKSEL_HSE;
80001740:	3000e7b7          	lui	a5,0x3000e
80001744:	5bf4                	lw	a3,116(a5)
80001746:	fffd0737          	lui	a4,0xfffd0
8000174a:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc8e87>
8000174c:	8ef9                	and	a3,a3,a4
8000174e:	6741                	lui	a4,0x10
80001750:	8f55                	or	a4,a4,a3
80001752:	dbf8                	sw	a4,116(a5)
    RCU->UARTCLKCFG[1].UARTCLKCFG_bit.DIVEN = 0;
80001754:	3000e7b7          	lui	a5,0x3000e
80001758:	5bf4                	lw	a3,116(a5)
8000175a:	fff00737          	lui	a4,0xfff00
8000175e:	177d                	addi	a4,a4,-1 # ffefffff <__data_source_start+0x7fef8e87>
80001760:	8f75                	and	a4,a4,a3
80001762:	dbf8                	sw	a4,116(a5)
    RCU->UARTCLKCFG[1].UARTCLKCFG_bit.RSTDIS = 1;
80001764:	3000e7b7          	lui	a5,0x3000e
80001768:	5bf8                	lw	a4,116(a5)
8000176a:	10076713          	ori	a4,a4,256
8000176e:	dbf8                	sw	a4,116(a5)
    RCU->UARTCLKCFG[1].UARTCLKCFG_bit.CLKEN = 1;
80001770:	3000e7b7          	lui	a5,0x3000e
80001774:	5bf8                	lw	a4,116(a5)
80001776:	00176713          	ori	a4,a4,1
8000177a:	dbf8                	sw	a4,116(a5)

    UART1->IBRD = baud_icoef;
8000177c:	300077b7          	lui	a5,0x30007
80001780:	fec42703          	lw	a4,-20(s0)
80001784:	d3d8                	sw	a4,36(a5)
    UART1->FBRD = baud_fcoef;
80001786:	300077b7          	lui	a5,0x30007
8000178a:	fe842703          	lw	a4,-24(s0)
8000178e:	d798                	sw	a4,40(a5)
    UART1->LCRH = UART_LCRH_FEN_Msk | (3 << UART_LCRH_WLEN_Pos);
80001790:	300077b7          	lui	a5,0x30007
80001794:	07000713          	li	a4,112
80001798:	d7d8                	sw	a4,44(a5)
    UART1->IFLS = 0;
8000179a:	300077b7          	lui	a5,0x30007
8000179e:	0207aa23          	sw	zero,52(a5) # 30007034 <STACK_SIZE+0x30006834>
    UART1->CR = UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
800017a2:	300077b7          	lui	a5,0x30007
800017a6:	30100713          	li	a4,769
800017aa:	db98                	sw	a4,48(a5)
}
800017ac:	0001                	nop
800017ae:	4472                	lw	s0,28(sp)
800017b0:	6105                	addi	sp,sp,32
800017b2:	8082                	ret

800017b4 <periph_init>:



//-- Peripheral init functions -------------------------------------------------
void periph_init()
{
800017b4:	1141                	addi	sp,sp,-16
800017b6:	c606                	sw	ra,12(sp)
800017b8:	c422                	sw	s0,8(sp)
800017ba:	0800                	addi	s0,sp,16
  SystemInit();
800017bc:	31bd                	jal	8000142a <SystemInit>
  SystemCoreClockUpdate();
800017be:	3a89                	jal	80001110 <SystemCoreClockUpdate>
  retarget_init();
800017c0:	fe0ff0ef          	jal	ra,80000fa0 <retarget_init>
  UART1_init();
800017c4:	3df1                	jal	800016a0 <UART1_init>
  //  OSDP   PD = 0x01
  osdp_init(0x01);
800017c6:	4505                	li	a0,1
800017c8:	2b0010ef          	jal	ra,80002a78 <osdp_init>
  gpio_init();
800017cc:	207d                	jal	8000187a <gpio_init>
  tmr32_init();
800017ce:	2aa9                	jal	80001928 <tmr32_init>
  uart_irq_init();
800017d0:	2829                	jal	800017ea <uart_irq_init>
  InterruptEnable();
800017d2:	3919                	jal	800013e8 <InterruptEnable>
  printf("Hello World!\r\n");
800017d4:	800077b7          	lui	a5,0x80007
800017d8:	ea078513          	addi	a0,a5,-352 # 80006ea0 <__data_source_start+0xfffffd28>
800017dc:	ee0ff0ef          	jal	ra,80000ebc <puts>
}
800017e0:	0001                	nop
800017e2:	40b2                	lw	ra,12(sp)
800017e4:	4422                	lw	s0,8(sp)
800017e6:	0141                	addi	sp,sp,16
800017e8:	8082                	ret

800017ea <uart_irq_init>:

//--- USER FUNCTIONS ----------------------------------------------------------------------

//   UART1     PLIC
static void uart_irq_init(void)
{
800017ea:	1141                	addi	sp,sp,-16
800017ec:	c606                	sw	ra,12(sp)
800017ee:	c422                	sw	s0,8(sp)
800017f0:	0800                	addi	s0,sp,16
  //     
  RETARGET_UART->ICR = UART_ICR_RXIC_Msk |
800017f2:	300077b7          	lui	a5,0x30007
800017f6:	7d000713          	li	a4,2000
800017fa:	c3f8                	sw	a4,68(a5)
                       UART_ICR_FEIC_Msk |
                       UART_ICR_PEIC_Msk |
                       UART_ICR_BEIC_Msk;

  //       
  RETARGET_UART->IMSC |= (UART_IMSC_RXIM_Msk |
800017fc:	300077b7          	lui	a5,0x30007
80001800:	5f98                	lw	a4,56(a5)
80001802:	300077b7          	lui	a5,0x30007
80001806:	7d076713          	ori	a4,a4,2000
8000180a:	df98                	sw	a4,56(a5)
                          UART_IMSC_FERIM_Msk |
                          UART_IMSC_PERIM_Msk |
                          UART_IMSC_BERIM_Msk);

  //    PLIC     UART1
  PLIC_SetPriority(PLIC_UART1_VECTNUM, 1);
8000180c:	4585                	li	a1,1
8000180e:	455d                	li	a0,23
80001810:	b01fe0ef          	jal	ra,80000310 <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_UART1_VECTNUM, uart1_irq_handler);
80001814:	800027b7          	lui	a5,0x80002
80001818:	83678613          	addi	a2,a5,-1994 # 80001836 <__data_source_start+0xffffa6be>
8000181c:	45dd                	li	a1,23
8000181e:	4501                	li	a0,0
80001820:	aa5fe0ef          	jal	ra,800002c4 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_UART1_VECTNUM);
80001824:	45dd                	li	a1,23
80001826:	4501                	li	a0,0
80001828:	b13fe0ef          	jal	ra,8000033a <PLIC_IntEnable>
}
8000182c:	0001                	nop
8000182e:	40b2                	lw	ra,12(sp)
80001830:	4422                	lw	s0,8(sp)
80001832:	0141                	addi	sp,sp,16
80001834:	8082                	ret

80001836 <uart1_irq_handler>:

//   UART1 ( PLIC)
static void uart1_irq_handler(void)
{
80001836:	1101                	addi	sp,sp,-32
80001838:	ce06                	sw	ra,28(sp)
8000183a:	cc22                	sw	s0,24(sp)
8000183c:	1000                	addi	s0,sp,32
  while (!RETARGET_UART->FR_bit.RXFE) {
8000183e:	a821                	j	80001856 <uart1_irq_handler+0x20>
    uint8_t ch = (uint8_t)RETARGET_UART->DR_bit.DATA;
80001840:	300077b7          	lui	a5,0x30007
80001844:	0007c783          	lbu	a5,0(a5) # 30007000 <STACK_SIZE+0x30006800>
80001848:	fef407a3          	sb	a5,-17(s0)
    osdp_on_rx_byte(ch);
8000184c:	fef44783          	lbu	a5,-17(s0)
80001850:	853e                	mv	a0,a5
80001852:	256010ef          	jal	ra,80002aa8 <osdp_on_rx_byte>
  while (!RETARGET_UART->FR_bit.RXFE) {
80001856:	300077b7          	lui	a5,0x30007
8000185a:	4f9c                	lw	a5,24(a5)
8000185c:	8391                	srli	a5,a5,0x4
8000185e:	8b85                	andi	a5,a5,1
80001860:	0ff7f793          	zext.b	a5,a5
80001864:	dff1                	beqz	a5,80001840 <uart1_irq_handler+0xa>
  }

  //    
  RETARGET_UART->ICR = UART_ICR_RXIC_Msk |
80001866:	300077b7          	lui	a5,0x30007
8000186a:	7d000713          	li	a4,2000
8000186e:	c3f8                	sw	a4,68(a5)
                       UART_ICR_RTIC_Msk |
                       UART_ICR_OEIC_Msk |
                       UART_ICR_FEIC_Msk |
                       UART_ICR_PEIC_Msk |
                       UART_ICR_BEIC_Msk;
}
80001870:	0001                	nop
80001872:	40f2                	lw	ra,28(sp)
80001874:	4462                	lw	s0,24(sp)
80001876:	6105                	addi	sp,sp,32
80001878:	8082                	ret

8000187a <gpio_init>:

 

static void gpio_init(void)
{
8000187a:	7179                	addi	sp,sp,-48
8000187c:	d606                	sw	ra,44(sp)
8000187e:	d422                	sw	s0,40(sp)
80001880:	1800                	addi	s0,sp,48
  //  GPIOA    UART1_init()

  GPIO_Init_TypeDef gpio;

  // LED  PA0
  GPIO_StructInit(&gpio);
80001882:	fd040793          	addi	a5,s0,-48
80001886:	853e                	mv	a0,a5
80001888:	3cb030ef          	jal	ra,80005452 <GPIO_StructInit>
  gpio.Pin = GPIO_Pin_0;
8000188c:	4785                	li	a5,1
8000188e:	fcf42823          	sw	a5,-48(s0)
  gpio.Out = ENABLE;                //  
80001892:	4785                	li	a5,1
80001894:	fcf42a23          	sw	a5,-44(s0)
  gpio.AltFunc = DISABLE;           //  GPIO
80001898:	fc042c23          	sw	zero,-40(s0)
  gpio.AltFuncNum = GPIO_AltFuncNum_None;
8000189c:	fc042e23          	sw	zero,-36(s0)
  gpio.OutMode = GPIO_OutMode_PP;   // push-pull
800018a0:	fe042223          	sw	zero,-28(s0)
  gpio.InMode = GPIO_InMode_Schmitt;
800018a4:	fe042423          	sw	zero,-24(s0)
  gpio.PullMode = GPIO_PullMode_Disable;
800018a8:	fe042623          	sw	zero,-20(s0)
  GPIO_Init(GPIOA, &gpio);
800018ac:	fd040793          	addi	a5,s0,-48
800018b0:	85be                	mv	a1,a5
800018b2:	28000537          	lui	a0,0x28000
800018b6:	2ff030ef          	jal	ra,800053b4 <GPIO_Init>
  GPIO_ClearBits(GPIOA, GPIO_Pin_0); // LED 
800018ba:	4585                	li	a1,1
800018bc:	28000537          	lui	a0,0x28000
800018c0:	39cd                	jal	800015b2 <GPIO_ClearBits>

  //   PA1 (,    )
  GPIO_StructInit(&gpio);
800018c2:	fd040793          	addi	a5,s0,-48
800018c6:	853e                	mv	a0,a5
800018c8:	38b030ef          	jal	ra,80005452 <GPIO_StructInit>
  gpio.Pin = GPIO_Pin_1;
800018cc:	4789                	li	a5,2
800018ce:	fcf42823          	sw	a5,-48(s0)
  gpio.Out = DISABLE;               // 
800018d2:	fc042a23          	sw	zero,-44(s0)
  gpio.AltFunc = DISABLE;
800018d6:	fc042c23          	sw	zero,-40(s0)
  gpio.AltFuncNum = GPIO_AltFuncNum_None;
800018da:	fc042e23          	sw	zero,-36(s0)
  gpio.InMode = GPIO_InMode_Schmitt;
800018de:	fe042423          	sw	zero,-24(s0)
  gpio.PullMode = GPIO_PullMode_PU; //   VDD
800018e2:	4785                	li	a5,1
800018e4:	fef42623          	sw	a5,-20(s0)
  GPIO_Init(GPIOA, &gpio);
800018e8:	fd040793          	addi	a5,s0,-48
800018ec:	85be                	mv	a1,a5
800018ee:	28000537          	lui	a0,0x28000
800018f2:	2c3030ef          	jal	ra,800053b4 <GPIO_Init>

  //   :  +  
  GPIO_SyncCmd(GPIOA, GPIO_Pin_1, ENABLE);
800018f6:	4605                	li	a2,1
800018f8:	4589                	li	a1,2
800018fa:	28000537          	lui	a0,0x28000
800018fe:	33a5                	jal	80001666 <GPIO_SyncCmd>
  GPIO_QualSampleConfig(GPIOA, 1000); //    ( HCLK)
80001900:	3e800593          	li	a1,1000
80001904:	28000537          	lui	a0,0x28000
80001908:	3311                	jal	8000160c <GPIO_QualSampleConfig>
  GPIO_QualModeConfig(GPIOA, GPIO_Pin_1, GPIO_QualMode_6Sample); //   
8000190a:	4605                	li	a2,1
8000190c:	4589                	li	a1,2
8000190e:	28000537          	lui	a0,0x28000
80001912:	31c1                	jal	800015d2 <GPIO_QualModeConfig>
  GPIO_QualCmd(GPIOA, GPIO_Pin_1, ENABLE);
80001914:	4605                	li	a2,1
80001916:	4589                	li	a1,2
80001918:	28000537          	lui	a0,0x28000
8000191c:	3b01                	jal	8000162c <GPIO_QualCmd>
}
8000191e:	0001                	nop
80001920:	50b2                	lw	ra,44(sp)
80001922:	5422                	lw	s0,40(sp)
80001924:	6145                	addi	sp,sp,48
80001926:	8082                	ret

80001928 <tmr32_init>:

//  1   TMR32: 
static volatile uint32_t ms_ticks = 0;

static void tmr32_init(void) 
{
80001928:	1101                	addi	sp,sp,-32
8000192a:	ce06                	sw	ra,28(sp)
8000192c:	cc22                	sw	s0,24(sp)
8000192e:	1000                	addi	s0,sp,32
  //  TMR32
  RCU->CGCFGAPB_bit.TMR32EN = 1;
80001930:	3000e7b7          	lui	a5,0x3000e
80001934:	4798                	lw	a4,8(a5)
80001936:	00176713          	ori	a4,a4,1
8000193a:	c798                	sw	a4,8(a5)
  RCU->RSTDISAPB_bit.TMR32EN = 1;
8000193c:	3000e7b7          	lui	a5,0x3000e
80001940:	4f98                	lw	a4,24(a5)
80001942:	00176713          	ori	a4,a4,1
80001946:	cf98                	sw	a4,24(a5)

  //  : SYSCLK / 8,  Up  CAPCOM0,  ~1 
  TMR32_SetClksel(TMR32_Clksel_SysClk);
80001948:	4501                	li	a0,0
8000194a:	36b1                	jal	80001496 <TMR32_SetClksel>
  TMR32_SetDivider(TMR32_Div_8);
8000194c:	450d                	li	a0,3
8000194e:	3e31                	jal	8000146a <TMR32_SetDivider>
  TMR32_SetMode(TMR32_Mode_Capcom_Up);
80001950:	4505                	li	a0,1
80001952:	34f5                	jal	8000143e <TMR32_SetMode>
  uint32_t cmp = (SystemCoreClock / 8u) / 1000u; // 1 
80001954:	e101a703          	lw	a4,-496(gp) # 40000590 <SystemCoreClock>
80001958:	6789                	lui	a5,0x2
8000195a:	f4078793          	addi	a5,a5,-192 # 1f40 <STACK_SIZE+0x1740>
8000195e:	02f757b3          	divu	a5,a4,a5
80001962:	fef42623          	sw	a5,-20(s0)
  if (cmp == 0) cmp = 1;
80001966:	fec42783          	lw	a5,-20(s0)
8000196a:	e781                	bnez	a5,80001972 <tmr32_init+0x4a>
8000196c:	4785                	li	a5,1
8000196e:	fef42623          	sw	a5,-20(s0)
  TMR32_CAPCOM_SetComparator(TMR32_CAPCOM_0, cmp);
80001972:	fec42583          	lw	a1,-20(s0)
80001976:	4501                	li	a0,0
80001978:	36d9                	jal	8000153e <TMR32_CAPCOM_SetComparator>
  TMR32_SetCounter(0);
8000197a:	4501                	li	a0,0
8000197c:	3699                	jal	800014c2 <TMR32_SetCounter>

  //     ()
  TMR32_ITCmd(TMR32_IT_TimerUpdate, ENABLE);
8000197e:	4585                	li	a1,1
80001980:	4505                	li	a0,1
80001982:	3eb1                	jal	800014de <TMR32_ITCmd>

  //    PLIC
  PLIC_SetPriority(PLIC_TMR32_VECTNUM, 1);
80001984:	4585                	li	a1,1
80001986:	4519                	li	a0,6
80001988:	989fe0ef          	jal	ra,80000310 <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_TMR32_VECTNUM, tmr32_irq_handler);
8000198c:	800027b7          	lui	a5,0x80002
80001990:	9ae78613          	addi	a2,a5,-1618 # 800019ae <__data_source_start+0xffffa836>
80001994:	4599                	li	a1,6
80001996:	4501                	li	a0,0
80001998:	92dfe0ef          	jal	ra,800002c4 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_TMR32_VECTNUM);
8000199c:	4599                	li	a1,6
8000199e:	4501                	li	a0,0
800019a0:	99bfe0ef          	jal	ra,8000033a <PLIC_IntEnable>
}
800019a4:	0001                	nop
800019a6:	40f2                	lw	ra,28(sp)
800019a8:	4462                	lw	s0,24(sp)
800019aa:	6105                	addi	sp,sp,32
800019ac:	8082                	ret

800019ae <tmr32_irq_handler>:

static void tmr32_irq_handler(void)
{
800019ae:	1141                	addi	sp,sp,-16
800019b0:	c606                	sw	ra,12(sp)
800019b2:	c422                	sw	s0,8(sp)
800019b4:	0800                	addi	s0,sp,16
  //  ,  
  ms_ticks++;
800019b6:	e441a783          	lw	a5,-444(gp) # 400005c4 <ms_ticks>
800019ba:	00178713          	addi	a4,a5,1
800019be:	e4e1a223          	sw	a4,-444(gp) # 400005c4 <ms_ticks>
  // 1    OSDP (  LED)
  osdp_tick_1ms();
800019c2:	32f000ef          	jal	ra,800024f0 <osdp_tick_1ms>
  TMR32_ITClear(TMR32_IT_TimerUpdate);
800019c6:	4505                	li	a0,1
800019c8:	3e89                	jal	8000151a <TMR32_ITClear>
}
800019ca:	0001                	nop
800019cc:	40b2                	lw	ra,12(sp)
800019ce:	4422                	lw	s0,8(sp)
800019d0:	0141                	addi	sp,sp,16
800019d2:	8082                	ret

800019d4 <main>:



//-- Main ----------------------------------------------------------------------
int main(void)
{
800019d4:	1101                	addi	sp,sp,-32
800019d6:	ce06                	sw	ra,28(sp)
800019d8:	cc22                	sw	s0,24(sp)
800019da:	1000                	addi	s0,sp,32
  periph_init();
800019dc:	3be1                	jal	800017b4 <periph_init>
  while(1)
  {

    // :   LED    ( 1->0)
    uint8_t btn_now = GPIO_ReadBit(GPIOA, GPIO_Pin_1) ? 1 : 0;
800019de:	4589                	li	a1,2
800019e0:	28000537          	lui	a0,0x28000
800019e4:	3651                	jal	80001568 <GPIO_ReadBit>
800019e6:	87aa                	mv	a5,a0
800019e8:	00f037b3          	snez	a5,a5
800019ec:	0ff7f793          	zext.b	a5,a5
800019f0:	fef407a3          	sb	a5,-17(s0)
    //    1  
    static uint32_t last_event_ms = 0;
    const uint32_t debounce_ms = 100;
800019f4:	06400793          	li	a5,100
800019f8:	fef42423          	sw	a5,-24(s0)

    if (!pressed_lock) {
800019fc:	e411c783          	lbu	a5,-447(gp) # 400005c1 <pressed_lock>
80001a00:	e3d9                	bnez	a5,80001a86 <main+0xb2>
      if (prev_btn_state == 1 && btn_now == 0) {
80001a02:	8801c703          	lbu	a4,-1920(gp) # 40000000 <prev_btn_state>
80001a06:	4785                	li	a5,1
80001a08:	0af71b63          	bne	a4,a5,80001abe <main+0xea>
80001a0c:	fef44783          	lbu	a5,-17(s0)
80001a10:	e7dd                	bnez	a5,80001abe <main+0xea>
        uint32_t now = ms_ticks;
80001a12:	e441a783          	lw	a5,-444(gp) # 400005c4 <ms_ticks>
80001a16:	fef42023          	sw	a5,-32(s0)
        if ((now - last_event_ms) >= debounce_ms) {
80001a1a:	e481a783          	lw	a5,-440(gp) # 400005c8 <last_event_ms.0>
80001a1e:	fe042703          	lw	a4,-32(s0)
80001a22:	40f707b3          	sub	a5,a4,a5
80001a26:	fe842703          	lw	a4,-24(s0)
80001a2a:	08e7ea63          	bltu	a5,a4,80001abe <main+0xea>
          led_state ^= 1u; //   
80001a2e:	e401c783          	lbu	a5,-448(gp) # 400005c0 <led_state>
80001a32:	0ff7f793          	zext.b	a5,a5
80001a36:	0017c793          	xori	a5,a5,1
80001a3a:	0ff7f713          	zext.b	a4,a5
80001a3e:	e4e18023          	sb	a4,-448(gp) # 400005c0 <led_state>
          if (led_state) {
80001a42:	e401c783          	lbu	a5,-448(gp) # 400005c0 <led_state>
80001a46:	0ff7f793          	zext.b	a5,a5
80001a4a:	cf81                	beqz	a5,80001a62 <main+0x8e>
            GPIO_SetBits(GPIOA, GPIO_Pin_0);
80001a4c:	4585                	li	a1,1
80001a4e:	28000537          	lui	a0,0x28000
80001a52:	3681                	jal	80001592 <GPIO_SetBits>
            printf("LED ON\r\n");
80001a54:	800077b7          	lui	a5,0x80007
80001a58:	eb078513          	addi	a0,a5,-336 # 80006eb0 <__data_source_start+0xfffffd38>
80001a5c:	c60ff0ef          	jal	ra,80000ebc <puts>
80001a60:	a819                	j	80001a76 <main+0xa2>
          } else {
            GPIO_ClearBits(GPIOA, GPIO_Pin_0);
80001a62:	4585                	li	a1,1
80001a64:	28000537          	lui	a0,0x28000
80001a68:	36a9                	jal	800015b2 <GPIO_ClearBits>
            printf("LED OFF\r\n");
80001a6a:	800077b7          	lui	a5,0x80007
80001a6e:	eb878513          	addi	a0,a5,-328 # 80006eb8 <__data_source_start+0xfffffd40>
80001a72:	c4aff0ef          	jal	ra,80000ebc <puts>
          }
          pressed_lock = 1; //    
80001a76:	4705                	li	a4,1
80001a78:	e4e180a3          	sb	a4,-447(gp) # 400005c1 <pressed_lock>
          last_event_ms = now;
80001a7c:	fe042703          	lw	a4,-32(s0)
80001a80:	e4e1a423          	sw	a4,-440(gp) # 400005c8 <last_event_ms.0>
80001a84:	a82d                	j	80001abe <main+0xea>
        }
      }
    } else {
      if (prev_btn_state == 0 && btn_now == 1) {
80001a86:	8801c783          	lbu	a5,-1920(gp) # 40000000 <prev_btn_state>
80001a8a:	eb95                	bnez	a5,80001abe <main+0xea>
80001a8c:	fef44703          	lbu	a4,-17(s0)
80001a90:	4785                	li	a5,1
80001a92:	02f71663          	bne	a4,a5,80001abe <main+0xea>
        uint32_t now = ms_ticks;
80001a96:	e441a783          	lw	a5,-444(gp) # 400005c4 <ms_ticks>
80001a9a:	fef42223          	sw	a5,-28(s0)
        if ((now - last_event_ms) >= debounce_ms) {
80001a9e:	e481a783          	lw	a5,-440(gp) # 400005c8 <last_event_ms.0>
80001aa2:	fe442703          	lw	a4,-28(s0)
80001aa6:	40f707b3          	sub	a5,a4,a5
80001aaa:	fe842703          	lw	a4,-24(s0)
80001aae:	00e7e863          	bltu	a5,a4,80001abe <main+0xea>
          pressed_lock = 0;
80001ab2:	e40180a3          	sb	zero,-447(gp) # 400005c1 <pressed_lock>
          last_event_ms = now;
80001ab6:	fe442703          	lw	a4,-28(s0)
80001aba:	e4e1a423          	sw	a4,-440(gp) # 400005c8 <last_event_ms.0>
        }
      }
    }
    prev_btn_state = btn_now;
80001abe:	fef44703          	lbu	a4,-17(s0)
80001ac2:	88e18023          	sb	a4,-1920(gp) # 40000000 <prev_btn_state>
  {
80001ac6:	bf21                	j	800019de <main+0xa>

80001ac8 <ccitt_crc16_update>:
0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};

uint16_t ccitt_crc16_update(uint16_t crc, uint8_t byte)
{
80001ac8:	1101                	addi	sp,sp,-32
80001aca:	ce22                	sw	s0,28(sp)
80001acc:	1000                	addi	s0,sp,32
80001ace:	87aa                	mv	a5,a0
80001ad0:	872e                	mv	a4,a1
80001ad2:	fef41723          	sh	a5,-18(s0)
80001ad6:	87ba                	mv	a5,a4
80001ad8:	fef406a3          	sb	a5,-19(s0)
	crc = (crc << 8) ^ crc_table[((crc >> 8) ^ byte) & 0x00FF];
80001adc:	fee45783          	lhu	a5,-18(s0)
80001ae0:	07a2                	slli	a5,a5,0x8
80001ae2:	01079713          	slli	a4,a5,0x10
80001ae6:	8741                	srai	a4,a4,0x10
80001ae8:	fee45783          	lhu	a5,-18(s0)
80001aec:	83a1                	srli	a5,a5,0x8
80001aee:	07c2                	slli	a5,a5,0x10
80001af0:	83c1                	srli	a5,a5,0x10
80001af2:	86be                	mv	a3,a5
80001af4:	fed44783          	lbu	a5,-19(s0)
80001af8:	8fb5                	xor	a5,a5,a3
80001afa:	0ff7f793          	zext.b	a5,a5
80001afe:	800076b7          	lui	a3,0x80007
80001b02:	ed068693          	addi	a3,a3,-304 # 80006ed0 <__data_source_start+0xfffffd58>
80001b06:	0786                	slli	a5,a5,0x1
80001b08:	97b6                	add	a5,a5,a3
80001b0a:	0007d783          	lhu	a5,0(a5)
80001b0e:	07c2                	slli	a5,a5,0x10
80001b10:	87c1                	srai	a5,a5,0x10
80001b12:	8fb9                	xor	a5,a5,a4
80001b14:	07c2                	slli	a5,a5,0x10
80001b16:	87c1                	srai	a5,a5,0x10
80001b18:	fef41723          	sh	a5,-18(s0)
	return crc;
80001b1c:	fee45783          	lhu	a5,-18(s0)
}
80001b20:	853e                	mv	a0,a5
80001b22:	4472                	lw	s0,28(sp)
80001b24:	6105                	addi	sp,sp,32
80001b26:	8082                	ret

80001b28 <ccitt_crc16_calc>:

uint16_t ccitt_crc16_calc(uint16_t initcrc, const uint8_t *data, uint16_t len)
{
80001b28:	7179                	addi	sp,sp,-48
80001b2a:	d622                	sw	s0,44(sp)
80001b2c:	1800                	addi	s0,sp,48
80001b2e:	87aa                	mv	a5,a0
80001b30:	fcb42c23          	sw	a1,-40(s0)
80001b34:	8732                	mv	a4,a2
80001b36:	fcf41f23          	sh	a5,-34(s0)
80001b3a:	87ba                	mv	a5,a4
80001b3c:	fcf41e23          	sh	a5,-36(s0)
	uint16_t crc = initcrc;
80001b40:	fde45783          	lhu	a5,-34(s0)
80001b44:	fef41723          	sh	a5,-18(s0)
	for (uint16_t i = 0; i < len; i++) {
80001b48:	fe041623          	sh	zero,-20(s0)
80001b4c:	a899                	j	80001ba2 <ccitt_crc16_calc+0x7a>
		crc = (crc << 8) ^ crc_table[((crc >> 8) ^ data[i]) & 0x00FF];
80001b4e:	fee45783          	lhu	a5,-18(s0)
80001b52:	07a2                	slli	a5,a5,0x8
80001b54:	01079713          	slli	a4,a5,0x10
80001b58:	8741                	srai	a4,a4,0x10
80001b5a:	fee45783          	lhu	a5,-18(s0)
80001b5e:	83a1                	srli	a5,a5,0x8
80001b60:	07c2                	slli	a5,a5,0x10
80001b62:	83c1                	srli	a5,a5,0x10
80001b64:	863e                	mv	a2,a5
80001b66:	fec45783          	lhu	a5,-20(s0)
80001b6a:	fd842683          	lw	a3,-40(s0)
80001b6e:	97b6                	add	a5,a5,a3
80001b70:	0007c783          	lbu	a5,0(a5)
80001b74:	8fb1                	xor	a5,a5,a2
80001b76:	0ff7f793          	zext.b	a5,a5
80001b7a:	800076b7          	lui	a3,0x80007
80001b7e:	ed068693          	addi	a3,a3,-304 # 80006ed0 <__data_source_start+0xfffffd58>
80001b82:	0786                	slli	a5,a5,0x1
80001b84:	97b6                	add	a5,a5,a3
80001b86:	0007d783          	lhu	a5,0(a5)
80001b8a:	07c2                	slli	a5,a5,0x10
80001b8c:	87c1                	srai	a5,a5,0x10
80001b8e:	8fb9                	xor	a5,a5,a4
80001b90:	07c2                	slli	a5,a5,0x10
80001b92:	87c1                	srai	a5,a5,0x10
80001b94:	fef41723          	sh	a5,-18(s0)
	for (uint16_t i = 0; i < len; i++) {
80001b98:	fec45783          	lhu	a5,-20(s0)
80001b9c:	0785                	addi	a5,a5,1
80001b9e:	fef41623          	sh	a5,-20(s0)
80001ba2:	fec45703          	lhu	a4,-20(s0)
80001ba6:	fdc45783          	lhu	a5,-36(s0)
80001baa:	faf762e3          	bltu	a4,a5,80001b4e <ccitt_crc16_calc+0x26>
	}
	return crc;
80001bae:	fee45783          	lhu	a5,-18(s0)
}
80001bb2:	853e                	mv	a0,a5
80001bb4:	5432                	lw	s0,44(sp)
80001bb6:	6145                	addi	sp,sp,48
80001bb8:	8082                	ret

80001bba <osdp_crc_is_ok>:

int osdp_crc_is_ok(const uint8_t *data, uint16_t len)
{
80001bba:	7179                	addi	sp,sp,-48
80001bbc:	d606                	sw	ra,44(sp)
80001bbe:	d422                	sw	s0,40(sp)
80001bc0:	1800                	addi	s0,sp,48
80001bc2:	fca42e23          	sw	a0,-36(s0)
80001bc6:	87ae                	mv	a5,a1
80001bc8:	fcf41d23          	sh	a5,-38(s0)
	if (len < 2) return 0;
80001bcc:	fda45703          	lhu	a4,-38(s0)
80001bd0:	4785                	li	a5,1
80001bd2:	00e7e463          	bltu	a5,a4,80001bda <osdp_crc_is_ok+0x20>
80001bd6:	4781                	li	a5,0
80001bd8:	a0ad                	j	80001c42 <osdp_crc_is_ok+0x88>
	uint16_t src_crc = ((uint16_t)data[len - 1] << 8) | data[len - 2];
80001bda:	fda45783          	lhu	a5,-38(s0)
80001bde:	17fd                	addi	a5,a5,-1
80001be0:	fdc42703          	lw	a4,-36(s0)
80001be4:	97ba                	add	a5,a5,a4
80001be6:	0007c783          	lbu	a5,0(a5)
80001bea:	07a2                	slli	a5,a5,0x8
80001bec:	01079713          	slli	a4,a5,0x10
80001bf0:	8741                	srai	a4,a4,0x10
80001bf2:	fda45783          	lhu	a5,-38(s0)
80001bf6:	17f9                	addi	a5,a5,-2
80001bf8:	fdc42683          	lw	a3,-36(s0)
80001bfc:	97b6                	add	a5,a5,a3
80001bfe:	0007c783          	lbu	a5,0(a5)
80001c02:	07c2                	slli	a5,a5,0x10
80001c04:	87c1                	srai	a5,a5,0x10
80001c06:	8fd9                	or	a5,a5,a4
80001c08:	07c2                	slli	a5,a5,0x10
80001c0a:	87c1                	srai	a5,a5,0x10
80001c0c:	fef41723          	sh	a5,-18(s0)
	uint16_t calc = ccitt_crc16_calc(OSDP_INIT_CRC16, data, (uint16_t)(len - 2));
80001c10:	fda45783          	lhu	a5,-38(s0)
80001c14:	17f9                	addi	a5,a5,-2
80001c16:	07c2                	slli	a5,a5,0x10
80001c18:	83c1                	srli	a5,a5,0x10
80001c1a:	863e                	mv	a2,a5
80001c1c:	fdc42583          	lw	a1,-36(s0)
80001c20:	6789                	lui	a5,0x2
80001c22:	d0f78513          	addi	a0,a5,-753 # 1d0f <STACK_SIZE+0x150f>
80001c26:	3709                	jal	80001b28 <ccitt_crc16_calc>
80001c28:	87aa                	mv	a5,a0
80001c2a:	fef41623          	sh	a5,-20(s0)
	return (src_crc == calc) ? 1 : 0;
80001c2e:	fee45703          	lhu	a4,-18(s0)
80001c32:	fec45783          	lhu	a5,-20(s0)
80001c36:	40f707b3          	sub	a5,a4,a5
80001c3a:	0017b793          	seqz	a5,a5
80001c3e:	0ff7f793          	zext.b	a5,a5
}
80001c42:	853e                	mv	a0,a5
80001c44:	50b2                	lw	ra,44(sp)
80001c46:	5422                	lw	s0,40(sp)
80001c48:	6145                	addi	sp,sp,48
80001c4a:	8082                	ret

80001c4c <GPIO_ReadBit>:
  * @param   GPIOx   ,  x=A|B|C
  * @param   Pin   
  * @retval  State      ,       .
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80001c4c:	1101                	addi	sp,sp,-32
80001c4e:	ce22                	sw	s0,28(sp)
80001c50:	1000                	addi	s0,sp,32
80001c52:	fea42623          	sw	a0,-20(s0)
80001c56:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
80001c5a:	fec42783          	lw	a5,-20(s0)
80001c5e:	4398                	lw	a4,0(a5)
80001c60:	fe842783          	lw	a5,-24(s0)
80001c64:	8ff9                	and	a5,a5,a4
80001c66:	c399                	beqz	a5,80001c6c <GPIO_ReadBit+0x20>
80001c68:	4785                	li	a5,1
80001c6a:	a011                	j	80001c6e <GPIO_ReadBit+0x22>
80001c6c:	4781                	li	a5,0
}
80001c6e:	853e                	mv	a0,a5
80001c70:	4472                	lw	s0,28(sp)
80001c72:	6105                	addi	sp,sp,32
80001c74:	8082                	ret

80001c76 <GPIO_SetBits>:
  * @param   GPIOx   ,  x=A|B|C
  * @param   Pin   
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80001c76:	1101                	addi	sp,sp,-32
80001c78:	ce22                	sw	s0,28(sp)
80001c7a:	1000                	addi	s0,sp,32
80001c7c:	fea42623          	sw	a0,-20(s0)
80001c80:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
80001c84:	fec42783          	lw	a5,-20(s0)
80001c88:	fe842703          	lw	a4,-24(s0)
80001c8c:	c798                	sw	a4,8(a5)
}
80001c8e:	0001                	nop
80001c90:	4472                	lw	s0,28(sp)
80001c92:	6105                	addi	sp,sp,32
80001c94:	8082                	ret

80001c96 <GPIO_ClearBits>:
  * @param   GPIOx   ,  x=A|B|C
  * @param   Pin   
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80001c96:	1101                	addi	sp,sp,-32
80001c98:	ce22                	sw	s0,28(sp)
80001c9a:	1000                	addi	s0,sp,32
80001c9c:	fea42623          	sw	a0,-20(s0)
80001ca0:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
80001ca4:	fec42783          	lw	a5,-20(s0)
80001ca8:	fe842703          	lw	a4,-24(s0)
80001cac:	c7d8                	sw	a4,12(a5)
}
80001cae:	0001                	nop
80001cb0:	4472                	lw	s0,28(sp)
80001cb2:	6105                	addi	sp,sp,32
80001cb4:	8082                	ret

80001cb6 <osdp_send_blocking>:
static uint16_t   rx_expected_len = 0;
static uint16_t   rx_pos = 0;
static uint8_t    rx_buf[256];

static void osdp_send_blocking(const uint8_t *data, uint16_t len)
{
80001cb6:	7179                	addi	sp,sp,-48
80001cb8:	d622                	sw	s0,44(sp)
80001cba:	1800                	addi	s0,sp,48
80001cbc:	fca42e23          	sw	a0,-36(s0)
80001cc0:	87ae                	mv	a5,a1
80001cc2:	fcf41d23          	sh	a5,-38(s0)
	for (uint16_t i = 0; i < len; i++) {
80001cc6:	fe041723          	sh	zero,-18(s0)
80001cca:	a815                	j	80001cfe <osdp_send_blocking+0x48>
		while (RETARGET_UART->FR_bit.TXFF) { }
80001ccc:	0001                	nop
80001cce:	300077b7          	lui	a5,0x30007
80001cd2:	4f9c                	lw	a5,24(a5)
80001cd4:	8395                	srli	a5,a5,0x5
80001cd6:	8b85                	andi	a5,a5,1
80001cd8:	0ff7f793          	zext.b	a5,a5
80001cdc:	fbed                	bnez	a5,80001cce <osdp_send_blocking+0x18>
		RETARGET_UART->DR_bit.DATA = data[i];
80001cde:	fee45783          	lhu	a5,-18(s0)
80001ce2:	fdc42703          	lw	a4,-36(s0)
80001ce6:	973e                	add	a4,a4,a5
80001ce8:	300077b7          	lui	a5,0x30007
80001cec:	00074703          	lbu	a4,0(a4)
80001cf0:	00e78023          	sb	a4,0(a5) # 30007000 <STACK_SIZE+0x30006800>
	for (uint16_t i = 0; i < len; i++) {
80001cf4:	fee45783          	lhu	a5,-18(s0)
80001cf8:	0785                	addi	a5,a5,1
80001cfa:	fef41723          	sh	a5,-18(s0)
80001cfe:	fee45703          	lhu	a4,-18(s0)
80001d02:	fda45783          	lhu	a5,-38(s0)
80001d06:	fcf763e3          	bltu	a4,a5,80001ccc <osdp_send_blocking+0x16>
	}
	while (!RETARGET_UART->FR_bit.TXFE) { }
80001d0a:	0001                	nop
80001d0c:	300077b7          	lui	a5,0x30007
80001d10:	4f9c                	lw	a5,24(a5)
80001d12:	839d                	srli	a5,a5,0x7
80001d14:	8b85                	andi	a5,a5,1
80001d16:	0ff7f793          	zext.b	a5,a5
80001d1a:	dbed                	beqz	a5,80001d0c <osdp_send_blocking+0x56>
}
80001d1c:	0001                	nop
80001d1e:	0001                	nop
80001d20:	5432                	lw	s0,44(sp)
80001d22:	6145                	addi	sp,sp,48
80001d24:	8082                	ret

80001d26 <osdp_build_header>:

//      .
static uint16_t osdp_build_header(uint8_t *tx, uint16_t dlen, uint8_t seq)
{
80001d26:	7179                	addi	sp,sp,-48
80001d28:	d622                	sw	s0,44(sp)
80001d2a:	1800                	addi	s0,sp,48
80001d2c:	fca42e23          	sw	a0,-36(s0)
80001d30:	87ae                	mv	a5,a1
80001d32:	8732                	mv	a4,a2
80001d34:	fcf41d23          	sh	a5,-38(s0)
80001d38:	87ba                	mv	a5,a4
80001d3a:	fcf40ca3          	sb	a5,-39(s0)
	uint16_t i = 0;
80001d3e:	fe041723          	sh	zero,-18(s0)
	tx[i++] = OSDP_SOM;
80001d42:	fee45783          	lhu	a5,-18(s0)
80001d46:	00178713          	addi	a4,a5,1 # 30007001 <STACK_SIZE+0x30006801>
80001d4a:	fee41723          	sh	a4,-18(s0)
80001d4e:	873e                	mv	a4,a5
80001d50:	fdc42783          	lw	a5,-36(s0)
80001d54:	97ba                	add	a5,a5,a4
80001d56:	05300713          	li	a4,83
80001d5a:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)(g_addr | 0x80);
80001d5e:	8811c703          	lbu	a4,-1919(gp) # 40000001 <g_addr>
80001d62:	fee45783          	lhu	a5,-18(s0)
80001d66:	00178693          	addi	a3,a5,1
80001d6a:	fed41723          	sh	a3,-18(s0)
80001d6e:	86be                	mv	a3,a5
80001d70:	fdc42783          	lw	a5,-36(s0)
80001d74:	97b6                	add	a5,a5,a3
80001d76:	f8076713          	ori	a4,a4,-128
80001d7a:	0ff77713          	zext.b	a4,a4
80001d7e:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)(dlen & 0xFF);
80001d82:	fee45783          	lhu	a5,-18(s0)
80001d86:	00178713          	addi	a4,a5,1
80001d8a:	fee41723          	sh	a4,-18(s0)
80001d8e:	873e                	mv	a4,a5
80001d90:	fdc42783          	lw	a5,-36(s0)
80001d94:	97ba                	add	a5,a5,a4
80001d96:	fda45703          	lhu	a4,-38(s0)
80001d9a:	0ff77713          	zext.b	a4,a4
80001d9e:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)((dlen >> 8) & 0xFF);
80001da2:	fda45783          	lhu	a5,-38(s0)
80001da6:	83a1                	srli	a5,a5,0x8
80001da8:	01079693          	slli	a3,a5,0x10
80001dac:	82c1                	srli	a3,a3,0x10
80001dae:	fee45783          	lhu	a5,-18(s0)
80001db2:	00178713          	addi	a4,a5,1
80001db6:	fee41723          	sh	a4,-18(s0)
80001dba:	873e                	mv	a4,a5
80001dbc:	fdc42783          	lw	a5,-36(s0)
80001dc0:	97ba                	add	a5,a5,a4
80001dc2:	0ff6f713          	zext.b	a4,a3
80001dc6:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)((seq & 0x03) | 0x04);
80001dca:	fd940783          	lb	a5,-39(s0)
80001dce:	8b8d                	andi	a5,a5,3
80001dd0:	07e2                	slli	a5,a5,0x18
80001dd2:	87e1                	srai	a5,a5,0x18
80001dd4:	0047e793          	ori	a5,a5,4
80001dd8:	01879693          	slli	a3,a5,0x18
80001ddc:	86e1                	srai	a3,a3,0x18
80001dde:	fee45783          	lhu	a5,-18(s0)
80001de2:	00178713          	addi	a4,a5,1
80001de6:	fee41723          	sh	a4,-18(s0)
80001dea:	873e                	mv	a4,a5
80001dec:	fdc42783          	lw	a5,-36(s0)
80001df0:	97ba                	add	a5,a5,a4
80001df2:	0ff6f713          	zext.b	a4,a3
80001df6:	00e78023          	sb	a4,0(a5)
	return i;
80001dfa:	fee45783          	lhu	a5,-18(s0)
}
80001dfe:	853e                	mv	a0,a5
80001e00:	5432                	lw	s0,44(sp)
80001e02:	6145                	addi	sp,sp,48
80001e04:	8082                	ret

80001e06 <osdp_build_crc_and_send>:

//   :  CRC  
static void osdp_build_crc_and_send(uint8_t *tx, uint16_t dlen)
{
80001e06:	7179                	addi	sp,sp,-48
80001e08:	d606                	sw	ra,44(sp)
80001e0a:	d422                	sw	s0,40(sp)
80001e0c:	1800                	addi	s0,sp,48
80001e0e:	fca42e23          	sw	a0,-36(s0)
80001e12:	87ae                	mv	a5,a1
80001e14:	fcf41d23          	sh	a5,-38(s0)
	uint16_t crc = ccitt_crc16_calc(OSDP_INIT_CRC16, tx, dlen);
80001e18:	fda45783          	lhu	a5,-38(s0)
80001e1c:	863e                	mv	a2,a5
80001e1e:	fdc42583          	lw	a1,-36(s0)
80001e22:	6789                	lui	a5,0x2
80001e24:	d0f78513          	addi	a0,a5,-753 # 1d0f <STACK_SIZE+0x150f>
80001e28:	3301                	jal	80001b28 <ccitt_crc16_calc>
80001e2a:	87aa                	mv	a5,a0
80001e2c:	fef41723          	sh	a5,-18(s0)
	tx[dlen++] = (uint8_t)(crc & 0xFF);
80001e30:	fda45783          	lhu	a5,-38(s0)
80001e34:	00178713          	addi	a4,a5,1
80001e38:	fce41d23          	sh	a4,-38(s0)
80001e3c:	873e                	mv	a4,a5
80001e3e:	fdc42783          	lw	a5,-36(s0)
80001e42:	97ba                	add	a5,a5,a4
80001e44:	fee45703          	lhu	a4,-18(s0)
80001e48:	0ff77713          	zext.b	a4,a4
80001e4c:	00e78023          	sb	a4,0(a5)
	tx[dlen++] = (uint8_t)((crc >> 8) & 0xFF);
80001e50:	fee45783          	lhu	a5,-18(s0)
80001e54:	83a1                	srli	a5,a5,0x8
80001e56:	01079693          	slli	a3,a5,0x10
80001e5a:	82c1                	srli	a3,a3,0x10
80001e5c:	fda45783          	lhu	a5,-38(s0)
80001e60:	00178713          	addi	a4,a5,1
80001e64:	fce41d23          	sh	a4,-38(s0)
80001e68:	873e                	mv	a4,a5
80001e6a:	fdc42783          	lw	a5,-36(s0)
80001e6e:	97ba                	add	a5,a5,a4
80001e70:	0ff6f713          	zext.b	a4,a3
80001e74:	00e78023          	sb	a4,0(a5)
	osdp_send_blocking(tx, dlen);
80001e78:	fda45783          	lhu	a5,-38(s0)
80001e7c:	85be                	mv	a1,a5
80001e7e:	fdc42503          	lw	a0,-36(s0)
80001e82:	3d15                	jal	80001cb6 <osdp_send_blocking>
}
80001e84:	0001                	nop
80001e86:	50b2                	lw	ra,44(sp)
80001e88:	5422                	lw	s0,40(sp)
80001e8a:	6145                	addi	sp,sp,48
80001e8c:	8082                	ret

80001e8e <osdp_build_and_send_ack>:

static void osdp_build_and_send_ack(uint8_t seq)
{
80001e8e:	7139                	addi	sp,sp,-64
80001e90:	de06                	sw	ra,60(sp)
80001e92:	dc22                	sw	s0,56(sp)
80001e94:	0080                	addi	s0,sp,64
80001e96:	87aa                	mv	a5,a0
80001e98:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t dlen = OSDP_HEADER_LEN; // (5) + (1) + crc(2)
80001e9c:	47a1                	li	a5,8
80001e9e:	fef41723          	sh	a5,-18(s0)
	uint16_t i = 0;
80001ea2:	fe041623          	sh	zero,-20(s0)
	// 
	i = osdp_build_header(tx, dlen, seq);
80001ea6:	fcf44683          	lbu	a3,-49(s0)
80001eaa:	fee45703          	lhu	a4,-18(s0)
80001eae:	fdc40793          	addi	a5,s0,-36
80001eb2:	8636                	mv	a2,a3
80001eb4:	85ba                	mv	a1,a4
80001eb6:	853e                	mv	a0,a5
80001eb8:	35bd                	jal	80001d26 <osdp_build_header>
80001eba:	87aa                	mv	a5,a0
80001ebc:	fef41623          	sh	a5,-20(s0)
	// 
	tx[i++] = osdp_ACK;
80001ec0:	fec45783          	lhu	a5,-20(s0)
80001ec4:	00178713          	addi	a4,a5,1
80001ec8:	fee41623          	sh	a4,-20(s0)
80001ecc:	17c1                	addi	a5,a5,-16
80001ece:	97a2                	add	a5,a5,s0
80001ed0:	04000713          	li	a4,64
80001ed4:	fee78623          	sb	a4,-20(a5)
	// CRC + 
	osdp_build_crc_and_send(tx, i);
80001ed8:	fec45703          	lhu	a4,-20(s0)
80001edc:	fdc40793          	addi	a5,s0,-36
80001ee0:	85ba                	mv	a1,a4
80001ee2:	853e                	mv	a0,a5
80001ee4:	370d                	jal	80001e06 <osdp_build_crc_and_send>
}
80001ee6:	0001                	nop
80001ee8:	50f2                	lw	ra,60(sp)
80001eea:	5462                	lw	s0,56(sp)
80001eec:	6121                	addi	sp,sp,64
80001eee:	8082                	ret

80001ef0 <osdp_build_and_send_nak>:

static void osdp_build_and_send_nak(uint8_t seq, uint8_t reason)
{
80001ef0:	7139                	addi	sp,sp,-64
80001ef2:	de06                	sw	ra,60(sp)
80001ef4:	dc22                	sw	s0,56(sp)
80001ef6:	0080                	addi	s0,sp,64
80001ef8:	87aa                	mv	a5,a0
80001efa:	872e                	mv	a4,a1
80001efc:	fcf407a3          	sb	a5,-49(s0)
80001f00:	87ba                	mv	a5,a4
80001f02:	fcf40723          	sb	a5,-50(s0)
	uint8_t tx[16];
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1); // +1  
80001f06:	47a5                	li	a5,9
80001f08:	fef41723          	sh	a5,-18(s0)
	uint16_t i = 0;
80001f0c:	fe041623          	sh	zero,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80001f10:	fcf44683          	lbu	a3,-49(s0)
80001f14:	fee45703          	lhu	a4,-18(s0)
80001f18:	fdc40793          	addi	a5,s0,-36
80001f1c:	8636                	mv	a2,a3
80001f1e:	85ba                	mv	a1,a4
80001f20:	853e                	mv	a0,a5
80001f22:	3511                	jal	80001d26 <osdp_build_header>
80001f24:	87aa                	mv	a5,a0
80001f26:	fef41623          	sh	a5,-20(s0)
	tx[i++] = osdp_NAK;
80001f2a:	fec45783          	lhu	a5,-20(s0)
80001f2e:	00178713          	addi	a4,a5,1
80001f32:	fee41623          	sh	a4,-20(s0)
80001f36:	17c1                	addi	a5,a5,-16
80001f38:	97a2                	add	a5,a5,s0
80001f3a:	04100713          	li	a4,65
80001f3e:	fee78623          	sb	a4,-20(a5)
	tx[i++] = reason; //  NAK
80001f42:	fec45783          	lhu	a5,-20(s0)
80001f46:	00178713          	addi	a4,a5,1
80001f4a:	fee41623          	sh	a4,-20(s0)
80001f4e:	17c1                	addi	a5,a5,-16
80001f50:	97a2                	add	a5,a5,s0
80001f52:	fce44703          	lbu	a4,-50(s0)
80001f56:	fee78623          	sb	a4,-20(a5)
	osdp_build_crc_and_send(tx, i);
80001f5a:	fec45703          	lhu	a4,-20(s0)
80001f5e:	fdc40793          	addi	a5,s0,-36
80001f62:	85ba                	mv	a1,a4
80001f64:	853e                	mv	a0,a5
80001f66:	3545                	jal	80001e06 <osdp_build_crc_and_send>
}
80001f68:	0001                	nop
80001f6a:	50f2                	lw	ra,60(sp)
80001f6c:	5462                	lw	s0,56(sp)
80001f6e:	6121                	addi	sp,sp,64
80001f70:	8082                	ret

80001f72 <osdp_build_and_send_pdid>:

static void osdp_build_and_send_pdid(uint8_t seq)
{
80001f72:	7159                	addi	sp,sp,-112
80001f74:	d686                	sw	ra,108(sp)
80001f76:	d4a2                	sw	s0,104(sp)
80001f78:	1880                	addi	s0,sp,112
80001f7a:	87aa                	mv	a5,a0
80001f7c:	f8f40fa3          	sb	a5,-97(s0)
	uint8_t tx[64];
	uint16_t i = 0;
80001f80:	fe041723          	sh	zero,-18(s0)
	uint8_t pdid[12] = {
80001f84:	014347b7          	lui	a5,0x1434
80001f88:	24178793          	addi	a5,a5,577 # 1434241 <STACK_SIZE+0x1433a41>
80001f8c:	faf42023          	sw	a5,-96(s0)
80001f90:	111117b7          	lui	a5,0x11111
80001f94:	10178793          	addi	a5,a5,257 # 11111101 <STACK_SIZE+0x11110901>
80001f98:	faf42223          	sw	a5,-92(s0)
80001f9c:	010107b7          	lui	a5,0x1010
80001fa0:	11178793          	addi	a5,a5,273 # 1010111 <STACK_SIZE+0x100f911>
80001fa4:	faf42423          	sw	a5,-88(s0)
		1,                       // 
		1,                       // 
		0x11,0x11,0x11,0x11,     // 
		1,1,1                    // 1.0.0
	};
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + sizeof(pdid));
80001fa8:	47d1                	li	a5,20
80001faa:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80001fae:	f9f44683          	lbu	a3,-97(s0)
80001fb2:	fec45703          	lhu	a4,-20(s0)
80001fb6:	fac40793          	addi	a5,s0,-84
80001fba:	8636                	mv	a2,a3
80001fbc:	85ba                	mv	a1,a4
80001fbe:	853e                	mv	a0,a5
80001fc0:	339d                	jal	80001d26 <osdp_build_header>
80001fc2:	87aa                	mv	a5,a0
80001fc4:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_PDID;
80001fc8:	fee45783          	lhu	a5,-18(s0)
80001fcc:	00178713          	addi	a4,a5,1
80001fd0:	fee41723          	sh	a4,-18(s0)
80001fd4:	17c1                	addi	a5,a5,-16
80001fd6:	97a2                	add	a5,a5,s0
80001fd8:	04500713          	li	a4,69
80001fdc:	fae78e23          	sb	a4,-68(a5)
	memcpy(&tx[i], pdid, sizeof(pdid));             //        i, ..    ctrl
80001fe0:	fee45783          	lhu	a5,-18(s0)
80001fe4:	fac40713          	addi	a4,s0,-84
80001fe8:	97ba                	add	a5,a5,a4
80001fea:	fa044703          	lbu	a4,-96(s0)
80001fee:	8fba                	mv	t6,a4
80001ff0:	fa144703          	lbu	a4,-95(s0)
80001ff4:	8f3a                	mv	t5,a4
80001ff6:	fa244703          	lbu	a4,-94(s0)
80001ffa:	8eba                	mv	t4,a4
80001ffc:	fa344703          	lbu	a4,-93(s0)
80002000:	8e3a                	mv	t3,a4
80002002:	fa444703          	lbu	a4,-92(s0)
80002006:	833a                	mv	t1,a4
80002008:	fa544703          	lbu	a4,-91(s0)
8000200c:	88ba                	mv	a7,a4
8000200e:	fa644703          	lbu	a4,-90(s0)
80002012:	883a                	mv	a6,a4
80002014:	fa744703          	lbu	a4,-89(s0)
80002018:	853a                	mv	a0,a4
8000201a:	fa844703          	lbu	a4,-88(s0)
8000201e:	85ba                	mv	a1,a4
80002020:	fa944703          	lbu	a4,-87(s0)
80002024:	863a                	mv	a2,a4
80002026:	faa44703          	lbu	a4,-86(s0)
8000202a:	86ba                	mv	a3,a4
8000202c:	fab44703          	lbu	a4,-85(s0)
80002030:	01f78023          	sb	t6,0(a5)
80002034:	01e780a3          	sb	t5,1(a5)
80002038:	01d78123          	sb	t4,2(a5)
8000203c:	01c781a3          	sb	t3,3(a5)
80002040:	00678223          	sb	t1,4(a5)
80002044:	011782a3          	sb	a7,5(a5)
80002048:	01078323          	sb	a6,6(a5)
8000204c:	00a783a3          	sb	a0,7(a5)
80002050:	00b78423          	sb	a1,8(a5)
80002054:	00c784a3          	sb	a2,9(a5)
80002058:	00d78523          	sb	a3,10(a5)
8000205c:	00e785a3          	sb	a4,11(a5)
	i += (uint16_t)sizeof(pdid);
80002060:	fee45783          	lhu	a5,-18(s0)
80002064:	07b1                	addi	a5,a5,12
80002066:	fef41723          	sh	a5,-18(s0)
	osdp_build_crc_and_send(tx, i);
8000206a:	fee45703          	lhu	a4,-18(s0)
8000206e:	fac40793          	addi	a5,s0,-84
80002072:	85ba                	mv	a1,a4
80002074:	853e                	mv	a0,a5
80002076:	3b41                	jal	80001e06 <osdp_build_crc_and_send>
}
80002078:	0001                	nop
8000207a:	50b6                	lw	ra,108(sp)
8000207c:	5426                	lw	s0,104(sp)
8000207e:	6165                	addi	sp,sp,112
80002080:	8082                	ret

80002082 <osdp_build_and_send_pdcap>:

static void osdp_build_and_send_pdcap(uint8_t seq)
{
80002082:	7135                	addi	sp,sp,-160
80002084:	cf06                	sw	ra,156(sp)
80002086:	cd22                	sw	s0,152(sp)
80002088:	1100                	addi	s0,sp,160
8000208a:	87aa                	mv	a5,a0
8000208c:	f6f407a3          	sb	a5,-145(s0)
	uint8_t tx[64];
	uint16_t i = 0;
80002090:	fe041723          	sh	zero,-18(s0)
	// [Function][Compliance/LSB][NumberOf/MSB]  IEC 60839-11-5 (Annex B)
	//   0x01..0x10;   CL=0  Number=0.
	uint8_t caps[] = {
80002094:	800077b7          	lui	a5,0x80007
80002098:	0d078793          	addi	a5,a5,208 # 800070d0 <__data_source_start+0xffffff58>
8000209c:	0007af03          	lw	t5,0(a5)
800020a0:	0047ae83          	lw	t4,4(a5)
800020a4:	0087ae03          	lw	t3,8(a5)
800020a8:	00c7a303          	lw	t1,12(a5)
800020ac:	0107a883          	lw	a7,16(a5)
800020b0:	0147a803          	lw	a6,20(a5)
800020b4:	4f88                	lw	a0,24(a5)
800020b6:	4fcc                	lw	a1,28(a5)
800020b8:	5390                	lw	a2,32(a5)
800020ba:	53d4                	lw	a3,36(a5)
800020bc:	5798                	lw	a4,40(a5)
800020be:	57dc                	lw	a5,44(a5)
800020c0:	f7e42e23          	sw	t5,-132(s0)
800020c4:	f9d42023          	sw	t4,-128(s0)
800020c8:	f9c42223          	sw	t3,-124(s0)
800020cc:	f8642423          	sw	t1,-120(s0)
800020d0:	f9142623          	sw	a7,-116(s0)
800020d4:	f9042823          	sw	a6,-112(s0)
800020d8:	f8a42a23          	sw	a0,-108(s0)
800020dc:	f8b42c23          	sw	a1,-104(s0)
800020e0:	f8c42e23          	sw	a2,-100(s0)
800020e4:	fad42023          	sw	a3,-96(s0)
800020e8:	fae42223          	sw	a4,-92(s0)
800020ec:	faf42423          	sw	a5,-88(s0)
		0x0D, 0x00, 0x00, // 13 Readers: none
		0x0E, 0x00, 0x00, // 14 Biometrics: none
		0x0F, 0x00, 0x00, // 15 Secure PIN entry: not supported
		0x10, 0x01, 0x00  // 16 OSDP version: IEC 60839-11-5
	};
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + sizeof(caps));
800020f0:	03800793          	li	a5,56
800020f4:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
800020f8:	f6f44683          	lbu	a3,-145(s0)
800020fc:	fec45703          	lhu	a4,-20(s0)
80002100:	fac40793          	addi	a5,s0,-84
80002104:	8636                	mv	a2,a3
80002106:	85ba                	mv	a1,a4
80002108:	853e                	mv	a0,a5
8000210a:	3931                	jal	80001d26 <osdp_build_header>
8000210c:	87aa                	mv	a5,a0
8000210e:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_PDCAP;
80002112:	fee45783          	lhu	a5,-18(s0)
80002116:	00178713          	addi	a4,a5,1
8000211a:	fee41723          	sh	a4,-18(s0)
8000211e:	17c1                	addi	a5,a5,-16
80002120:	97a2                	add	a5,a5,s0
80002122:	04600713          	li	a4,70
80002126:	fae78e23          	sb	a4,-68(a5)
	memcpy(&tx[i], caps, sizeof(caps));
8000212a:	fee45783          	lhu	a5,-18(s0)
8000212e:	fac40713          	addi	a4,s0,-84
80002132:	97ba                	add	a5,a5,a4
80002134:	86be                	mv	a3,a5
80002136:	f7c40793          	addi	a5,s0,-132
8000213a:	03000713          	li	a4,48
8000213e:	863a                	mv	a2,a4
80002140:	85be                	mv	a1,a5
80002142:	8536                	mv	a0,a3
80002144:	453040ef          	jal	ra,80006d96 <memcpy>
	i += (uint16_t)sizeof(caps);
80002148:	fee45783          	lhu	a5,-18(s0)
8000214c:	03078793          	addi	a5,a5,48
80002150:	fef41723          	sh	a5,-18(s0)
	osdp_build_crc_and_send(tx, i);
80002154:	fee45703          	lhu	a4,-18(s0)
80002158:	fac40793          	addi	a5,s0,-84
8000215c:	85ba                	mv	a1,a4
8000215e:	853e                	mv	a0,a5
80002160:	315d                	jal	80001e06 <osdp_build_crc_and_send>
}
80002162:	0001                	nop
80002164:	40fa                	lw	ra,156(sp)
80002166:	446a                	lw	s0,152(sp)
80002168:	610d                	addi	sp,sp,160
8000216a:	8082                	ret

8000216c <osdp_build_and_send_com>:

static void osdp_build_and_send_com(uint8_t seq, uint8_t new_addr, uint32_t new_baud)
{
8000216c:	7139                	addi	sp,sp,-64
8000216e:	de06                	sw	ra,60(sp)
80002170:	dc22                	sw	s0,56(sp)
80002172:	0080                	addi	s0,sp,64
80002174:	87aa                	mv	a5,a0
80002176:	872e                	mv	a4,a1
80002178:	fcc42423          	sw	a2,-56(s0)
8000217c:	fcf407a3          	sb	a5,-49(s0)
80002180:	87ba                	mv	a5,a4
80002182:	fcf40723          	sb	a5,-50(s0)
	uint8_t tx[16];
	uint16_t i = 0;
80002186:	fe041723          	sh	zero,-18(s0)
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 5); 
8000218a:	47b5                	li	a5,13
8000218c:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80002190:	fcf44683          	lbu	a3,-49(s0)
80002194:	fec45703          	lhu	a4,-20(s0)
80002198:	fdc40793          	addi	a5,s0,-36
8000219c:	8636                	mv	a2,a3
8000219e:	85ba                	mv	a1,a4
800021a0:	853e                	mv	a0,a5
800021a2:	3651                	jal	80001d26 <osdp_build_header>
800021a4:	87aa                	mv	a5,a0
800021a6:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_COM;
800021aa:	fee45783          	lhu	a5,-18(s0)
800021ae:	00178713          	addi	a4,a5,1
800021b2:	fee41723          	sh	a4,-18(s0)
800021b6:	17c1                	addi	a5,a5,-16
800021b8:	97a2                	add	a5,a5,s0
800021ba:	06500713          	li	a4,101
800021be:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)(new_addr & 0x7F);
800021c2:	fee45783          	lhu	a5,-18(s0)
800021c6:	00178713          	addi	a4,a5,1
800021ca:	fee41723          	sh	a4,-18(s0)
800021ce:	fce44703          	lbu	a4,-50(s0)
800021d2:	07f77713          	andi	a4,a4,127
800021d6:	0ff77713          	zext.b	a4,a4
800021da:	17c1                	addi	a5,a5,-16
800021dc:	97a2                	add	a5,a5,s0
800021de:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)(new_baud & 0xFF);
800021e2:	fee45783          	lhu	a5,-18(s0)
800021e6:	00178713          	addi	a4,a5,1
800021ea:	fee41723          	sh	a4,-18(s0)
800021ee:	fc842703          	lw	a4,-56(s0)
800021f2:	0ff77713          	zext.b	a4,a4
800021f6:	17c1                	addi	a5,a5,-16
800021f8:	97a2                	add	a5,a5,s0
800021fa:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 8) & 0xFF);
800021fe:	fc842783          	lw	a5,-56(s0)
80002202:	0087d693          	srli	a3,a5,0x8
80002206:	fee45783          	lhu	a5,-18(s0)
8000220a:	00178713          	addi	a4,a5,1
8000220e:	fee41723          	sh	a4,-18(s0)
80002212:	0ff6f713          	zext.b	a4,a3
80002216:	17c1                	addi	a5,a5,-16
80002218:	97a2                	add	a5,a5,s0
8000221a:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 16) & 0xFF);
8000221e:	fc842783          	lw	a5,-56(s0)
80002222:	0107d693          	srli	a3,a5,0x10
80002226:	fee45783          	lhu	a5,-18(s0)
8000222a:	00178713          	addi	a4,a5,1
8000222e:	fee41723          	sh	a4,-18(s0)
80002232:	0ff6f713          	zext.b	a4,a3
80002236:	17c1                	addi	a5,a5,-16
80002238:	97a2                	add	a5,a5,s0
8000223a:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 24) & 0xFF);
8000223e:	fc842783          	lw	a5,-56(s0)
80002242:	0187d693          	srli	a3,a5,0x18
80002246:	fee45783          	lhu	a5,-18(s0)
8000224a:	00178713          	addi	a4,a5,1
8000224e:	fee41723          	sh	a4,-18(s0)
80002252:	0ff6f713          	zext.b	a4,a3
80002256:	17c1                	addi	a5,a5,-16
80002258:	97a2                	add	a5,a5,s0
8000225a:	fee78623          	sb	a4,-20(a5)
	osdp_build_crc_and_send(tx, i);
8000225e:	fee45703          	lhu	a4,-18(s0)
80002262:	fdc40793          	addi	a5,s0,-36
80002266:	85ba                	mv	a1,a4
80002268:	853e                	mv	a0,a5
8000226a:	3e71                	jal	80001e06 <osdp_build_crc_and_send>
}
8000226c:	0001                	nop
8000226e:	50f2                	lw	ra,60(sp)
80002270:	5462                	lw	s0,56(sp)
80002272:	6121                	addi	sp,sp,64
80002274:	8082                	ret

80002276 <set_led_state>:

static void set_led_state(uint8_t on)
{
80002276:	1101                	addi	sp,sp,-32
80002278:	ce06                	sw	ra,28(sp)
8000227a:	cc22                	sw	s0,24(sp)
8000227c:	1000                	addi	s0,sp,32
8000227e:	87aa                	mv	a5,a0
80002280:	fef407a3          	sb	a5,-17(s0)
	// LED  PA0    main.c
	if (on) {
80002284:	fef44783          	lbu	a5,-17(s0)
80002288:	c791                	beqz	a5,80002294 <set_led_state+0x1e>
		GPIO_SetBits(GPIOA, GPIO_Pin_0);
8000228a:	4585                	li	a1,1
8000228c:	28000537          	lui	a0,0x28000
80002290:	32dd                	jal	80001c76 <GPIO_SetBits>
	} else {
		GPIO_ClearBits(GPIOA, GPIO_Pin_0);
	}
}
80002292:	a029                	j	8000229c <set_led_state+0x26>
		GPIO_ClearBits(GPIOA, GPIO_Pin_0);
80002294:	4585                	li	a1,1
80002296:	28000537          	lui	a0,0x28000
8000229a:	3af5                	jal	80001c96 <GPIO_ClearBits>
}
8000229c:	0001                	nop
8000229e:	40f2                	lw	ra,28(sp)
800022a0:	4462                	lw	s0,24(sp)
800022a2:	6105                	addi	sp,sp,32
800022a4:	8082                	ret

800022a6 <osdp_build_and_send_istat>:

static void osdp_build_and_send_istat(uint8_t seq)
{
800022a6:	7139                	addi	sp,sp,-64
800022a8:	de06                	sw	ra,60(sp)
800022aa:	dc22                	sw	s0,56(sp)
800022ac:	0080                	addi	s0,sp,64
800022ae:	87aa                	mv	a5,a0
800022b0:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t i = 0;
800022b4:	fe041723          	sh	zero,-18(s0)
	//   1 : 0 =   0 (  PA1, 1=)
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1);
800022b8:	47a5                	li	a5,9
800022ba:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
800022be:	fcf44683          	lbu	a3,-49(s0)
800022c2:	fec45703          	lhu	a4,-20(s0)
800022c6:	fd840793          	addi	a5,s0,-40
800022ca:	8636                	mv	a2,a3
800022cc:	85ba                	mv	a1,a4
800022ce:	853e                	mv	a0,a5
800022d0:	3c99                	jal	80001d26 <osdp_build_header>
800022d2:	87aa                	mv	a5,a0
800022d4:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_ISTATR;
800022d8:	fee45783          	lhu	a5,-18(s0)
800022dc:	00178713          	addi	a4,a5,1
800022e0:	fee41723          	sh	a4,-18(s0)
800022e4:	17c1                	addi	a5,a5,-16
800022e6:	97a2                	add	a5,a5,s0
800022e8:	04900713          	li	a4,73
800022ec:	fee78423          	sb	a4,-24(a5)
	uint8_t inputs = 0;
800022f0:	fe0405a3          	sb	zero,-21(s0)
	//   PU   0  ,  1  "/"
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_1) ? 0u : 1u) << 0;
800022f4:	4589                	li	a1,2
800022f6:	28000537          	lui	a0,0x28000
800022fa:	3a89                	jal	80001c4c <GPIO_ReadBit>
800022fc:	87aa                	mv	a5,a0
800022fe:	0017b793          	seqz	a5,a5
80002302:	0ff7f793          	zext.b	a5,a5
80002306:	0ff7f793          	zext.b	a5,a5
8000230a:	feb44703          	lbu	a4,-21(s0)
8000230e:	8fd9                	or	a5,a5,a4
80002310:	fef405a3          	sb	a5,-21(s0)
	tx[i++] = inputs;
80002314:	fee45783          	lhu	a5,-18(s0)
80002318:	00178713          	addi	a4,a5,1
8000231c:	fee41723          	sh	a4,-18(s0)
80002320:	17c1                	addi	a5,a5,-16
80002322:	97a2                	add	a5,a5,s0
80002324:	feb44703          	lbu	a4,-21(s0)
80002328:	fee78423          	sb	a4,-24(a5)
	osdp_build_crc_and_send(tx, i);
8000232c:	fee45703          	lhu	a4,-18(s0)
80002330:	fd840793          	addi	a5,s0,-40
80002334:	85ba                	mv	a1,a4
80002336:	853e                	mv	a0,a5
80002338:	34f9                	jal	80001e06 <osdp_build_crc_and_send>
}
8000233a:	0001                	nop
8000233c:	50f2                	lw	ra,60(sp)
8000233e:	5462                	lw	s0,56(sp)
80002340:	6121                	addi	sp,sp,64
80002342:	8082                	ret

80002344 <osdp_build_and_send_ostat>:

static void osdp_build_and_send_ostat(uint8_t seq)
{
80002344:	7139                	addi	sp,sp,-64
80002346:	de06                	sw	ra,60(sp)
80002348:	dc22                	sw	s0,56(sp)
8000234a:	0080                	addi	s0,sp,64
8000234c:	87aa                	mv	a5,a0
8000234e:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t i = 0;
80002352:	fe041723          	sh	zero,-18(s0)
	//   1 : 0 =   0 (LED  PA0, 1=)
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1);
80002356:	47a5                	li	a5,9
80002358:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
8000235c:	fcf44683          	lbu	a3,-49(s0)
80002360:	fec45703          	lhu	a4,-20(s0)
80002364:	fd840793          	addi	a5,s0,-40
80002368:	8636                	mv	a2,a3
8000236a:	85ba                	mv	a1,a4
8000236c:	853e                	mv	a0,a5
8000236e:	3a65                	jal	80001d26 <osdp_build_header>
80002370:	87aa                	mv	a5,a0
80002372:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_OSTATR;
80002376:	fee45783          	lhu	a5,-18(s0)
8000237a:	00178713          	addi	a4,a5,1
8000237e:	fee41723          	sh	a4,-18(s0)
80002382:	17c1                	addi	a5,a5,-16
80002384:	97a2                	add	a5,a5,s0
80002386:	04a00713          	li	a4,74
8000238a:	fee78423          	sb	a4,-24(a5)
	uint8_t outputs = 0;
8000238e:	fe0405a3          	sb	zero,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_0) ? 1u : 0u) << 0;
80002392:	4585                	li	a1,1
80002394:	28000537          	lui	a0,0x28000
80002398:	3855                	jal	80001c4c <GPIO_ReadBit>
8000239a:	87aa                	mv	a5,a0
8000239c:	c399                	beqz	a5,800023a2 <osdp_build_and_send_ostat+0x5e>
8000239e:	4785                	li	a5,1
800023a0:	a011                	j	800023a4 <osdp_build_and_send_ostat+0x60>
800023a2:	4781                	li	a5,0
800023a4:	0ff7f793          	zext.b	a5,a5
800023a8:	feb44703          	lbu	a4,-21(s0)
800023ac:	8fd9                	or	a5,a5,a4
800023ae:	fef405a3          	sb	a5,-21(s0)
	tx[i++] = outputs;
800023b2:	fee45783          	lhu	a5,-18(s0)
800023b6:	00178713          	addi	a4,a5,1
800023ba:	fee41723          	sh	a4,-18(s0)
800023be:	17c1                	addi	a5,a5,-16
800023c0:	97a2                	add	a5,a5,s0
800023c2:	feb44703          	lbu	a4,-21(s0)
800023c6:	fee78423          	sb	a4,-24(a5)
	osdp_build_crc_and_send(tx, i);
800023ca:	fee45703          	lhu	a4,-18(s0)
800023ce:	fd840793          	addi	a5,s0,-40
800023d2:	85ba                	mv	a1,a4
800023d4:	853e                	mv	a0,a5
800023d6:	3c05                	jal	80001e06 <osdp_build_crc_and_send>
}
800023d8:	0001                	nop
800023da:	50f2                	lw	ra,60(sp)
800023dc:	5462                	lw	s0,56(sp)
800023de:	6121                	addi	sp,sp,64
800023e0:	8082                	ret

800023e2 <set_uart_baud>:

static void set_uart_baud(uint32_t baud)
{
800023e2:	7139                	addi	sp,sp,-64
800023e4:	de22                	sw	s0,60(sp)
800023e6:	0080                	addi	s0,sp,64
800023e8:	fca42623          	sw	a0,-52(s0)
	//   UART1    UART1_init()
	//    HSE,   init
	uint32_t baud_icoef = HSECLK_VAL / (16u * baud);
800023ec:	fcc42783          	lw	a5,-52(s0)
800023f0:	0792                	slli	a5,a5,0x4
800023f2:	00f42737          	lui	a4,0xf42
800023f6:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
800023fa:	02f757b3          	divu	a5,a4,a5
800023fe:	fef42623          	sw	a5,-20(s0)
	float    f = (float)HSECLK_VAL / (16.0f * (float)baud) - (float)baud_icoef;
80002402:	fcc42783          	lw	a5,-52(s0)
80002406:	d017f753          	fcvt.s.wu	fa4,a5
8000240a:	800077b7          	lui	a5,0x80007
8000240e:	1507a787          	flw	fa5,336(a5) # 80007150 <__data_source_start+0xffffffd8>
80002412:	10f777d3          	fmul.s	fa5,fa4,fa5
80002416:	800077b7          	lui	a5,0x80007
8000241a:	1547a707          	flw	fa4,340(a5) # 80007154 <__data_source_start+0xffffffdc>
8000241e:	18f77753          	fdiv.s	fa4,fa4,fa5
80002422:	fec42783          	lw	a5,-20(s0)
80002426:	d017f7d3          	fcvt.s.wu	fa5,a5
8000242a:	08f777d3          	fsub.s	fa5,fa4,fa5
8000242e:	fef42427          	fsw	fa5,-24(s0)
	uint32_t baud_fcoef = (uint32_t)(f * 64.0f + 0.5f);
80002432:	fe842707          	flw	fa4,-24(s0)
80002436:	800077b7          	lui	a5,0x80007
8000243a:	1587a787          	flw	fa5,344(a5) # 80007158 <__data_source_start+0xffffffe0>
8000243e:	10f77753          	fmul.s	fa4,fa4,fa5
80002442:	800077b7          	lui	a5,0x80007
80002446:	15c7a787          	flw	fa5,348(a5) # 8000715c <__data_source_start+0xffffffe4>
8000244a:	00f777d3          	fadd.s	fa5,fa4,fa5
8000244e:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80002452:	fef42223          	sw	a5,-28(s0)
	uint32_t cr_saved   = UART1->CR;
80002456:	300077b7          	lui	a5,0x30007
8000245a:	5b9c                	lw	a5,48(a5)
8000245c:	fef42023          	sw	a5,-32(s0)
	uint32_t lcrh_saved = UART1->LCRH;
80002460:	300077b7          	lui	a5,0x30007
80002464:	57dc                	lw	a5,44(a5)
80002466:	fcf42e23          	sw	a5,-36(s0)
	uint32_t imsc_saved = UART1->IMSC;
8000246a:	300077b7          	lui	a5,0x30007
8000246e:	5f9c                	lw	a5,56(a5)
80002470:	fcf42c23          	sw	a5,-40(s0)
	//    /,    
	while (UART1->FR_bit.BUSY) { }
80002474:	0001                	nop
80002476:	300077b7          	lui	a5,0x30007
8000247a:	4f9c                	lw	a5,24(a5)
8000247c:	838d                	srli	a5,a5,0x3
8000247e:	8b85                	andi	a5,a5,1
80002480:	0ff7f793          	zext.b	a5,a5
80002484:	fbed                	bnez	a5,80002476 <set_uart_baud+0x94>
	//  UART
	UART1->CR = 0;
80002486:	300077b7          	lui	a5,0x30007
8000248a:	0207a823          	sw	zero,48(a5) # 30007030 <STACK_SIZE+0x30006830>
	UART1->IBRD = baud_icoef;
8000248e:	300077b7          	lui	a5,0x30007
80002492:	fec42703          	lw	a4,-20(s0)
80002496:	d3d8                	sw	a4,36(a5)
	UART1->FBRD = baud_fcoef;
80002498:	300077b7          	lui	a5,0x30007
8000249c:	fe442703          	lw	a4,-28(s0)
800024a0:	d798                	sw	a4,40(a5)
	//      FIFO   init (8N1, FIFO EN)
	UART1->LCRH = UART_LCRH_FEN_Msk | (3u << UART_LCRH_WLEN_Pos);
800024a2:	300077b7          	lui	a5,0x30007
800024a6:	07000713          	li	a4,112
800024aa:	d7d8                	sw	a4,44(a5)
	//    
	UART1->ICR = 0x7FF;
800024ac:	300077b7          	lui	a5,0x30007
800024b0:	7ff00713          	li	a4,2047
800024b4:	c3f8                	sw	a4,68(a5)
	while (!UART1->FR_bit.RXFE) { (void)UART1->DR_bit.DATA; }
800024b6:	a029                	j	800024c0 <set_uart_baud+0xde>
800024b8:	300077b7          	lui	a5,0x30007
800024bc:	0007c783          	lbu	a5,0(a5) # 30007000 <STACK_SIZE+0x30006800>
800024c0:	300077b7          	lui	a5,0x30007
800024c4:	4f9c                	lw	a5,24(a5)
800024c6:	8391                	srli	a5,a5,0x4
800024c8:	8b85                	andi	a5,a5,1
800024ca:	0ff7f793          	zext.b	a5,a5
800024ce:	d7ed                	beqz	a5,800024b8 <set_uart_baud+0xd6>
	//    ( ,   )
	UART1->IMSC = imsc_saved;
800024d0:	300077b7          	lui	a5,0x30007
800024d4:	fd842703          	lw	a4,-40(s0)
800024d8:	df98                	sw	a4,56(a5)
	//   (TX, RX, UARTEN)
	UART1->CR = cr_saved | UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
800024da:	300077b7          	lui	a5,0x30007
800024de:	fe042703          	lw	a4,-32(s0)
800024e2:	30176713          	ori	a4,a4,769
800024e6:	db98                	sw	a4,48(a5)
}
800024e8:	0001                	nop
800024ea:	5472                	lw	s0,60(sp)
800024ec:	6121                	addi	sp,sp,64
800024ee:	8082                	ret

800024f0 <osdp_tick_1ms>:
} led_ctrl_t;

static led_ctrl_t led_ctrl;

void osdp_tick_1ms(void)
{
800024f0:	1141                	addi	sp,sp,-16
800024f2:	c606                	sw	ra,12(sp)
800024f4:	c422                	sw	s0,8(sp)
800024f6:	0800                	addi	s0,sp,16
	if (led_ctrl.phase_ms_left > 0) {
800024f8:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800024fc:	4b9c                	lw	a5,16(a5)
800024fe:	cb91                	beqz	a5,80002512 <osdp_tick_1ms+0x22>
		--led_ctrl.phase_ms_left;
80002500:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002504:	4b9c                	lw	a5,16(a5)
80002506:	fff78713          	addi	a4,a5,-1 # 30006fff <STACK_SIZE+0x300067ff>
8000250a:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000250e:	cb98                	sw	a4,16(a5)
		return;
80002510:	a295                	j	80002674 <osdp_tick_1ms+0x184>
	}

	if (led_ctrl.temp_active) {
80002512:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002516:	0007c783          	lbu	a5,0(a5)
8000251a:	0e078663          	beqz	a5,80002606 <osdp_tick_1ms+0x116>
		//  temp 
		if (led_ctrl.current_state) {
8000251e:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002522:	0027c783          	lbu	a5,2(a5)
80002526:	c795                	beqz	a5,80002552 <osdp_tick_1ms+0x62>
			// ON -> OFF
			led_ctrl.current_state = 0;
80002528:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000252c:	00078123          	sb	zero,2(a5)
			set_led_state(led_ctrl.temp_off_color_is_on ? 1 : 0);
80002530:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002534:	01d7c783          	lbu	a5,29(a5)
80002538:	00f037b3          	snez	a5,a5
8000253c:	0ff7f793          	zext.b	a5,a5
80002540:	853e                	mv	a0,a5
80002542:	3b15                	jal	80002276 <set_led_state>
			led_ctrl.phase_ms_left = (led_ctrl.off_ms > 0) ? led_ctrl.off_ms : 0;
80002544:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002548:	4798                	lw	a4,8(a5)
8000254a:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000254e:	cb98                	sw	a4,16(a5)
80002550:	a215                	j	80002674 <osdp_tick_1ms+0x184>
		} else {
			// OFF -> ON
			led_ctrl.current_state = 1;
80002552:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002556:	4705                	li	a4,1
80002558:	00e78123          	sb	a4,2(a5)
			set_led_state(led_ctrl.temp_on_color_is_on ? 1 : 0);
8000255c:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002560:	01c7c783          	lbu	a5,28(a5)
80002564:	00f037b3          	snez	a5,a5
80002568:	0ff7f793          	zext.b	a5,a5
8000256c:	853e                	mv	a0,a5
8000256e:	3321                	jal	80002276 <set_led_state>
			led_ctrl.phase_ms_left = (led_ctrl.on_ms > 0) ? led_ctrl.on_ms : 0;
80002570:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002574:	43d8                	lw	a4,4(a5)
80002576:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000257a:	cb98                	sw	a4,16(a5)
			//     
			if (led_ctrl.cycles_left > 0) {
8000257c:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002580:	00c7d783          	lhu	a5,12(a5)
80002584:	0e078863          	beqz	a5,80002674 <osdp_tick_1ms+0x184>
				--led_ctrl.cycles_left;
80002588:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000258c:	00c7d783          	lhu	a5,12(a5)
80002590:	17fd                	addi	a5,a5,-1
80002592:	01079713          	slli	a4,a5,0x10
80002596:	8341                	srli	a4,a4,0x10
80002598:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000259c:	00e79623          	sh	a4,12(a5)
				if (led_ctrl.cycles_left == 0) {
800025a0:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025a4:	00c7d783          	lhu	a5,12(a5)
800025a8:	0c079663          	bnez	a5,80002674 <osdp_tick_1ms+0x184>
					//      
					led_ctrl.temp_active = 0;
800025ac:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025b0:	00078023          	sb	zero,0(a5)
					//   :  ,  
					if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
800025b4:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025b8:	4bdc                	lw	a5,20(a5)
800025ba:	cb9d                	beqz	a5,800025f0 <osdp_tick_1ms+0x100>
800025bc:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025c0:	4f9c                	lw	a5,24(a5)
800025c2:	c79d                	beqz	a5,800025f0 <osdp_tick_1ms+0x100>
						led_ctrl.current_state = 1;
800025c4:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025c8:	4705                	li	a4,1
800025ca:	00e78123          	sb	a4,2(a5)
						set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
800025ce:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025d2:	01e7c783          	lbu	a5,30(a5)
800025d6:	00f037b3          	snez	a5,a5
800025da:	0ff7f793          	zext.b	a5,a5
800025de:	853e                	mv	a0,a5
800025e0:	3959                	jal	80002276 <set_led_state>
						led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
800025e2:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025e6:	4bd8                	lw	a4,20(a5)
800025e8:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025ec:	cb98                	sw	a4,16(a5)
800025ee:	a059                	j	80002674 <osdp_tick_1ms+0x184>
					} else {
						set_led_state(led_ctrl.perm_state);
800025f0:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800025f4:	0017c783          	lbu	a5,1(a5)
800025f8:	853e                	mv	a0,a5
800025fa:	39b5                	jal	80002276 <set_led_state>
						led_ctrl.phase_ms_left = 0;
800025fc:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002600:	0007a823          	sw	zero,16(a5)
80002604:	a885                	j	80002674 <osdp_tick_1ms+0x184>
				}
			}
		}
	} else {
		//  : ,   perm_on/off
		if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
80002606:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000260a:	4bdc                	lw	a5,20(a5)
8000260c:	c7a5                	beqz	a5,80002674 <osdp_tick_1ms+0x184>
8000260e:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002612:	4f9c                	lw	a5,24(a5)
80002614:	c3a5                	beqz	a5,80002674 <osdp_tick_1ms+0x184>
			if (led_ctrl.current_state) {
80002616:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000261a:	0027c783          	lbu	a5,2(a5)
8000261e:	c795                	beqz	a5,8000264a <osdp_tick_1ms+0x15a>
				led_ctrl.current_state = 0;
80002620:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002624:	00078123          	sb	zero,2(a5)
				set_led_state(led_ctrl.perm_off_color_is_on ? 1 : 0);
80002628:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000262c:	01f7c783          	lbu	a5,31(a5)
80002630:	00f037b3          	snez	a5,a5
80002634:	0ff7f793          	zext.b	a5,a5
80002638:	853e                	mv	a0,a5
8000263a:	3935                	jal	80002276 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_off_ms;
8000263c:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002640:	4f98                	lw	a4,24(a5)
80002642:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002646:	cb98                	sw	a4,16(a5)
80002648:	a035                	j	80002674 <osdp_tick_1ms+0x184>
			} else {
				led_ctrl.current_state = 1;
8000264a:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000264e:	4705                	li	a4,1
80002650:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
80002654:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002658:	01e7c783          	lbu	a5,30(a5)
8000265c:	00f037b3          	snez	a5,a5
80002660:	0ff7f793          	zext.b	a5,a5
80002664:	853e                	mv	a0,a5
80002666:	3901                	jal	80002276 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
80002668:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000266c:	4bd8                	lw	a4,20(a5)
8000266e:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002672:	cb98                	sw	a4,16(a5)
			}
		}
	}
}
80002674:	40b2                	lw	ra,12(sp)
80002676:	4422                	lw	s0,8(sp)
80002678:	0141                	addi	sp,sp,16
8000267a:	8082                	ret

8000267c <handle_osdp_led>:

static void handle_osdp_led(uint8_t *data, uint16_t data_len)
{
8000267c:	711d                	addi	sp,sp,-96
8000267e:	ce86                	sw	ra,92(sp)
80002680:	cca2                	sw	s0,88(sp)
80002682:	1080                	addi	s0,sp,96
80002684:	faa42623          	sw	a0,-84(s0)
80002688:	87ae                	mv	a5,a1
8000268a:	faf41523          	sh	a5,-86(s0)
	//  : 14     (Temporary+Permanent)
	// Temporary: code, on, off, on_color, off_color, timerLSB, timerMSB
	// Permanent: code, on, off, on_color, off_color
	if (data_len < 14) return;
8000268e:	faa45703          	lhu	a4,-86(s0)
80002692:	47b5                	li	a5,13
80002694:	3ce7fd63          	bgeu	a5,a4,80002a6e <handle_osdp_led+0x3f2>
	uint16_t count = (uint16_t)(data_len / 14u);
80002698:	faa45703          	lhu	a4,-86(s0)
8000269c:	47b9                	li	a5,14
8000269e:	02f757b3          	divu	a5,a4,a5
800026a2:	fef41123          	sh	a5,-30(s0)
	for (uint16_t rec = 0; rec < count; rec++) {
800026a6:	fe041723          	sh	zero,-18(s0)
800026aa:	ae5d                	j	80002a60 <handle_osdp_led+0x3e4>
		uint8_t *p = &data[rec * 14u];
800026ac:	fee45703          	lhu	a4,-18(s0)
800026b0:	87ba                	mv	a5,a4
800026b2:	078e                	slli	a5,a5,0x3
800026b4:	8f99                	sub	a5,a5,a4
800026b6:	0786                	slli	a5,a5,0x1
800026b8:	873e                	mv	a4,a5
800026ba:	fac42783          	lw	a5,-84(s0)
800026be:	97ba                	add	a5,a5,a4
800026c0:	fcf42e23          	sw	a5,-36(s0)
		uint8_t reader = p[0];
800026c4:	fdc42783          	lw	a5,-36(s0)
800026c8:	0007c783          	lbu	a5,0(a5)
800026cc:	fcf40da3          	sb	a5,-37(s0)
		uint8_t lednum  = p[1];
800026d0:	fdc42783          	lw	a5,-36(s0)
800026d4:	0017c783          	lbu	a5,1(a5)
800026d8:	fcf40d23          	sb	a5,-38(s0)
		if (!(reader == 0 && lednum == 0)) continue; //    LED: reader0, led0
800026dc:	fdb44783          	lbu	a5,-37(s0)
800026e0:	36079a63          	bnez	a5,80002a54 <handle_osdp_led+0x3d8>
800026e4:	fda44783          	lbu	a5,-38(s0)
800026e8:	36079663          	bnez	a5,80002a54 <handle_osdp_led+0x3d8>

		uint8_t tcode  = p[2];
800026ec:	fdc42783          	lw	a5,-36(s0)
800026f0:	0027c783          	lbu	a5,2(a5)
800026f4:	fcf40ca3          	sb	a5,-39(s0)
		uint8_t tOn100ms = p[3];
800026f8:	fdc42783          	lw	a5,-36(s0)
800026fc:	0037c783          	lbu	a5,3(a5)
80002700:	fcf40c23          	sb	a5,-40(s0)
		uint8_t tOff100ms = p[4];
80002704:	fdc42783          	lw	a5,-36(s0)
80002708:	0047c783          	lbu	a5,4(a5)
8000270c:	fcf40ba3          	sb	a5,-41(s0)
		uint8_t tOnColor  = p[5];
80002710:	fdc42783          	lw	a5,-36(s0)
80002714:	0057c783          	lbu	a5,5(a5)
80002718:	fcf40b23          	sb	a5,-42(s0)
		uint8_t tOffColor = p[6];
8000271c:	fdc42783          	lw	a5,-36(s0)
80002720:	0067c783          	lbu	a5,6(a5)
80002724:	fcf40aa3          	sb	a5,-43(s0)
		uint16_t timer100ms = (uint16_t)p[7] | ((uint16_t)p[8] << 8);
80002728:	fdc42783          	lw	a5,-36(s0)
8000272c:	079d                	addi	a5,a5,7
8000272e:	0007c783          	lbu	a5,0(a5)
80002732:	01079713          	slli	a4,a5,0x10
80002736:	8741                	srai	a4,a4,0x10
80002738:	fdc42783          	lw	a5,-36(s0)
8000273c:	07a1                	addi	a5,a5,8
8000273e:	0007c783          	lbu	a5,0(a5)
80002742:	07a2                	slli	a5,a5,0x8
80002744:	07c2                	slli	a5,a5,0x10
80002746:	87c1                	srai	a5,a5,0x10
80002748:	8fd9                	or	a5,a5,a4
8000274a:	07c2                	slli	a5,a5,0x10
8000274c:	87c1                	srai	a5,a5,0x10
8000274e:	fcf41923          	sh	a5,-46(s0)

		uint8_t pcode  = p[9];
80002752:	fdc42783          	lw	a5,-36(s0)
80002756:	0097c783          	lbu	a5,9(a5)
8000275a:	fcf408a3          	sb	a5,-47(s0)
		uint8_t pOn100ms = p[10];
8000275e:	fdc42783          	lw	a5,-36(s0)
80002762:	00a7c783          	lbu	a5,10(a5)
80002766:	fcf40823          	sb	a5,-48(s0)
		uint8_t pOff100ms= p[11];
8000276a:	fdc42783          	lw	a5,-36(s0)
8000276e:	00b7c783          	lbu	a5,11(a5)
80002772:	fcf407a3          	sb	a5,-49(s0)
		uint8_t pOnColor  = p[12];
80002776:	fdc42783          	lw	a5,-36(s0)
8000277a:	00c7c783          	lbu	a5,12(a5)
8000277e:	fcf40723          	sb	a5,-50(s0)
		uint8_t pOffColor = p[13];
80002782:	fdc42783          	lw	a5,-36(s0)
80002786:	00d7c783          	lbu	a5,13(a5)
8000278a:	fcf406a3          	sb	a5,-51(s0)

		//   ,  
		if (pcode == 0x01) {
8000278e:	fd144703          	lbu	a4,-47(s0)
80002792:	4785                	li	a5,1
80002794:	0ef71b63          	bne	a4,a5,8000288a <handle_osdp_led+0x20e>
			uint32_t pon_ms  = (uint32_t)pOn100ms  * 100u;
80002798:	fd044703          	lbu	a4,-48(s0)
8000279c:	06400793          	li	a5,100
800027a0:	02f707b3          	mul	a5,a4,a5
800027a4:	fcf42423          	sw	a5,-56(s0)
			uint32_t poff_ms = (uint32_t)pOff100ms * 100u;
800027a8:	fcf44703          	lbu	a4,-49(s0)
800027ac:	06400793          	li	a5,100
800027b0:	02f707b3          	mul	a5,a4,a5
800027b4:	fcf42223          	sw	a5,-60(s0)
			led_ctrl.perm_on_ms  = pon_ms;
800027b8:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800027bc:	fc842703          	lw	a4,-56(s0)
800027c0:	cbd8                	sw	a4,20(a5)
			led_ctrl.perm_off_ms = poff_ms;
800027c2:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800027c6:	fc442703          	lw	a4,-60(s0)
800027ca:	cf98                	sw	a4,24(a5)
			led_ctrl.perm_on_color_is_on  = (pOnColor  != 0);
800027cc:	fce44783          	lbu	a5,-50(s0)
800027d0:	00f037b3          	snez	a5,a5
800027d4:	0ff7f793          	zext.b	a5,a5
800027d8:	873e                	mv	a4,a5
800027da:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800027de:	00e78f23          	sb	a4,30(a5)
			led_ctrl.perm_off_color_is_on = (pOffColor != 0);
800027e2:	fcd44783          	lbu	a5,-51(s0)
800027e6:	00f037b3          	snez	a5,a5
800027ea:	0ff7f793          	zext.b	a5,a5
800027ee:	873e                	mv	a4,a5
800027f0:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800027f4:	00e78fa3          	sb	a4,31(a5)
			if (pon_ms > 0 && poff_ms == 0) {
800027f8:	fc842783          	lw	a5,-56(s0)
800027fc:	c385                	beqz	a5,8000281c <handle_osdp_led+0x1a0>
800027fe:	fc442783          	lw	a5,-60(s0)
80002802:	ef89                	bnez	a5,8000281c <handle_osdp_led+0x1a0>
				led_ctrl.perm_state = (pOnColor != 0) ? 1 : 0; //   ""
80002804:	fce44783          	lbu	a5,-50(s0)
80002808:	00f037b3          	snez	a5,a5
8000280c:	0ff7f793          	zext.b	a5,a5
80002810:	873e                	mv	a4,a5
80002812:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002816:	00e780a3          	sb	a4,1(a5)
8000281a:	a015                	j	8000283e <handle_osdp_led+0x1c2>
			} else if (pon_ms == 0 && poff_ms > 0) {
8000281c:	fc842783          	lw	a5,-56(s0)
80002820:	ef99                	bnez	a5,8000283e <handle_osdp_led+0x1c2>
80002822:	fc442783          	lw	a5,-60(s0)
80002826:	cf81                	beqz	a5,8000283e <handle_osdp_led+0x1c2>
				led_ctrl.perm_state = (pOffColor != 0) ? 1 : 0;
80002828:	fcd44783          	lbu	a5,-51(s0)
8000282c:	00f037b3          	snez	a5,a5
80002830:	0ff7f793          	zext.b	a5,a5
80002834:	873e                	mv	a4,a5
80002836:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000283a:	00e780a3          	sb	a4,1(a5)
			}
			//  temp     
			if (!led_ctrl.temp_active) {
8000283e:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002842:	0007c783          	lbu	a5,0(a5)
80002846:	e3b1                	bnez	a5,8000288a <handle_osdp_led+0x20e>
				if (pon_ms > 0 && poff_ms > 0) {
80002848:	fc842783          	lw	a5,-56(s0)
8000284c:	cb8d                	beqz	a5,8000287e <handle_osdp_led+0x202>
8000284e:	fc442783          	lw	a5,-60(s0)
80002852:	c795                	beqz	a5,8000287e <handle_osdp_led+0x202>
					led_ctrl.current_state = 1;
80002854:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002858:	4705                	li	a4,1
8000285a:	00e78123          	sb	a4,2(a5)
					set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
8000285e:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002862:	01e7c783          	lbu	a5,30(a5)
80002866:	00f037b3          	snez	a5,a5
8000286a:	0ff7f793          	zext.b	a5,a5
8000286e:	853e                	mv	a0,a5
80002870:	3419                	jal	80002276 <set_led_state>
					led_ctrl.phase_ms_left = pon_ms;
80002872:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002876:	fc842703          	lw	a4,-56(s0)
8000287a:	cb98                	sw	a4,16(a5)
8000287c:	a039                	j	8000288a <handle_osdp_led+0x20e>
				} else {
					set_led_state(led_ctrl.perm_state);
8000287e:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002882:	0017c783          	lbu	a5,1(a5)
80002886:	853e                	mv	a0,a5
80002888:	32fd                	jal	80002276 <set_led_state>
		} else if (pcode == 0x00) {
			// Not use: NOP       
		}

		// Temporary    
		if (tcode == 0x00) {
8000288a:	fd944783          	lbu	a5,-39(s0)
8000288e:	1c078463          	beqz	a5,80002a56 <handle_osdp_led+0x3da>
			// NOP      
		} else if (tcode == 0x01) {
80002892:	fd944703          	lbu	a4,-39(s0)
80002896:	4785                	li	a5,1
80002898:	06f71763          	bne	a4,a5,80002906 <handle_osdp_led+0x28a>
			//  temp   permanent 
			led_ctrl.temp_active = 0;
8000289c:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028a0:	00078023          	sb	zero,0(a5)
			if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
800028a4:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028a8:	4bdc                	lw	a5,20(a5)
800028aa:	cb9d                	beqz	a5,800028e0 <handle_osdp_led+0x264>
800028ac:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028b0:	4f9c                	lw	a5,24(a5)
800028b2:	c79d                	beqz	a5,800028e0 <handle_osdp_led+0x264>
				led_ctrl.current_state = 1;
800028b4:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028b8:	4705                	li	a4,1
800028ba:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
800028be:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028c2:	01e7c783          	lbu	a5,30(a5)
800028c6:	00f037b3          	snez	a5,a5
800028ca:	0ff7f793          	zext.b	a5,a5
800028ce:	853e                	mv	a0,a5
800028d0:	325d                	jal	80002276 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
800028d2:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028d6:	4bd8                	lw	a4,20(a5)
800028d8:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028dc:	cb98                	sw	a4,16(a5)
800028de:	aaa5                	j	80002a56 <handle_osdp_led+0x3da>
			} else {
				led_ctrl.current_state = led_ctrl.perm_state;
800028e0:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028e4:	0017c703          	lbu	a4,1(a5)
800028e8:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028ec:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_state);
800028f0:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800028f4:	0017c783          	lbu	a5,1(a5)
800028f8:	853e                	mv	a0,a5
800028fa:	3ab5                	jal	80002276 <set_led_state>
				led_ctrl.phase_ms_left = 0;
800028fc:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002900:	0007a823          	sw	zero,16(a5)
80002904:	aa89                	j	80002a56 <handle_osdp_led+0x3da>
			}
		} else if (tcode == 0x02) {
80002906:	fd944703          	lbu	a4,-39(s0)
8000290a:	4789                	li	a5,2
8000290c:	14f71563          	bne	a4,a5,80002a56 <handle_osdp_led+0x3da>
			//       
			uint32_t on_ms  = (uint32_t)tOn100ms  * 100u;
80002910:	fd844703          	lbu	a4,-40(s0)
80002914:	06400793          	li	a5,100
80002918:	02f707b3          	mul	a5,a4,a5
8000291c:	fcf42023          	sw	a5,-64(s0)
			uint32_t off_ms = (uint32_t)tOff100ms  * 100u;
80002920:	fd744703          	lbu	a4,-41(s0)
80002924:	06400793          	li	a5,100
80002928:	02f707b3          	mul	a5,a4,a5
8000292c:	faf42e23          	sw	a5,-68(s0)
			led_ctrl.on_ms  = (on_ms  > 0) ? on_ms  : 0;
80002930:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002934:	fc042703          	lw	a4,-64(s0)
80002938:	c3d8                	sw	a4,4(a5)
			led_ctrl.off_ms = (off_ms > 0) ? off_ms : 0;
8000293a:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000293e:	fbc42703          	lw	a4,-68(s0)
80002942:	c798                	sw	a4,8(a5)
			led_ctrl.temp_on_color_is_on  = (tOnColor  != 0);
80002944:	fd644783          	lbu	a5,-42(s0)
80002948:	00f037b3          	snez	a5,a5
8000294c:	0ff7f793          	zext.b	a5,a5
80002950:	873e                	mv	a4,a5
80002952:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002956:	00e78e23          	sb	a4,28(a5)
			led_ctrl.temp_off_color_is_on = (tOffColor != 0);
8000295a:	fd544783          	lbu	a5,-43(s0)
8000295e:	00f037b3          	snez	a5,a5
80002962:	0ff7f793          	zext.b	a5,a5
80002966:	873e                	mv	a4,a5
80002968:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000296c:	00e78ea3          	sb	a4,29(a5)
			//     ,  
			if (timer100ms == 0) {
80002970:	fd245783          	lhu	a5,-46(s0)
80002974:	e791                	bnez	a5,80002980 <handle_osdp_led+0x304>
				led_ctrl.cycles_left = 0; // 
80002976:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000297a:	00079623          	sh	zero,12(a5)
8000297e:	a0bd                	j	800029ec <handle_osdp_led+0x370>
			} else {
				uint32_t period = (led_ctrl.on_ms + led_ctrl.off_ms);
80002980:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002984:	43d8                	lw	a4,4(a5)
80002986:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
8000298a:	479c                	lw	a5,8(a5)
8000298c:	97ba                	add	a5,a5,a4
8000298e:	fef42423          	sw	a5,-24(s0)
				if (period == 0) period = 100; //     0
80002992:	fe842783          	lw	a5,-24(s0)
80002996:	e789                	bnez	a5,800029a0 <handle_osdp_led+0x324>
80002998:	06400793          	li	a5,100
8000299c:	fef42423          	sw	a5,-24(s0)
				uint32_t total_ms = (uint32_t)timer100ms * 100u;
800029a0:	fd245703          	lhu	a4,-46(s0)
800029a4:	06400793          	li	a5,100
800029a8:	02f707b3          	mul	a5,a4,a5
800029ac:	faf42c23          	sw	a5,-72(s0)
				uint32_t cycles = total_ms / period;
800029b0:	fb842703          	lw	a4,-72(s0)
800029b4:	fe842783          	lw	a5,-24(s0)
800029b8:	02f757b3          	divu	a5,a4,a5
800029bc:	fef42223          	sw	a5,-28(s0)
				if (cycles == 0) cycles = 1;
800029c0:	fe442783          	lw	a5,-28(s0)
800029c4:	e781                	bnez	a5,800029cc <handle_osdp_led+0x350>
800029c6:	4785                	li	a5,1
800029c8:	fef42223          	sw	a5,-28(s0)
				led_ctrl.cycles_left = (uint16_t)((cycles > 0xFFFFu) ? 0xFFFFu : cycles);
800029cc:	fe442703          	lw	a4,-28(s0)
800029d0:	67c1                	lui	a5,0x10
800029d2:	00f77763          	bgeu	a4,a5,800029e0 <handle_osdp_led+0x364>
800029d6:	fe442783          	lw	a5,-28(s0)
800029da:	07c2                	slli	a5,a5,0x10
800029dc:	83c1                	srli	a5,a5,0x10
800029de:	a019                	j	800029e4 <handle_osdp_led+0x368>
800029e0:	67c1                	lui	a5,0x10
800029e2:	17fd                	addi	a5,a5,-1 # ffff <STACK_SIZE+0xf7ff>
800029e4:	f5418713          	addi	a4,gp,-172 # 400006d4 <led_ctrl>
800029e8:	00f71623          	sh	a5,12(a4)
			}
			//    ,  on_ms > 0,   
			if (led_ctrl.on_ms > 0) {
800029ec:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800029f0:	43dc                	lw	a5,4(a5)
800029f2:	c79d                	beqz	a5,80002a20 <handle_osdp_led+0x3a4>
				led_ctrl.current_state = 1;
800029f4:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
800029f8:	4705                	li	a4,1
800029fa:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.temp_on_color_is_on ? 1 : 0);
800029fe:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a02:	01c7c783          	lbu	a5,28(a5)
80002a06:	00f037b3          	snez	a5,a5
80002a0a:	0ff7f793          	zext.b	a5,a5
80002a0e:	853e                	mv	a0,a5
80002a10:	309d                	jal	80002276 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.on_ms;
80002a12:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a16:	43d8                	lw	a4,4(a5)
80002a18:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a1c:	cb98                	sw	a4,16(a5)
80002a1e:	a02d                	j	80002a48 <handle_osdp_led+0x3cc>
			} else {
				led_ctrl.current_state = 0;
80002a20:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a24:	00078123          	sb	zero,2(a5)
				set_led_state(led_ctrl.temp_off_color_is_on ? 1 : 0);
80002a28:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a2c:	01d7c783          	lbu	a5,29(a5)
80002a30:	00f037b3          	snez	a5,a5
80002a34:	0ff7f793          	zext.b	a5,a5
80002a38:	853e                	mv	a0,a5
80002a3a:	3835                	jal	80002276 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.off_ms;
80002a3c:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a40:	4798                	lw	a4,8(a5)
80002a42:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a46:	cb98                	sw	a4,16(a5)
			}
			led_ctrl.temp_active = 1;
80002a48:	f5418793          	addi	a5,gp,-172 # 400006d4 <led_ctrl>
80002a4c:	4705                	li	a4,1
80002a4e:	00e78023          	sb	a4,0(a5)
80002a52:	a011                	j	80002a56 <handle_osdp_led+0x3da>
		if (!(reader == 0 && lednum == 0)) continue; //    LED: reader0, led0
80002a54:	0001                	nop
	for (uint16_t rec = 0; rec < count; rec++) {
80002a56:	fee45783          	lhu	a5,-18(s0)
80002a5a:	0785                	addi	a5,a5,1
80002a5c:	fef41723          	sh	a5,-18(s0)
80002a60:	fee45703          	lhu	a4,-18(s0)
80002a64:	fe245783          	lhu	a5,-30(s0)
80002a68:	c4f762e3          	bltu	a4,a5,800026ac <handle_osdp_led+0x30>
80002a6c:	a011                	j	80002a70 <handle_osdp_led+0x3f4>
	if (data_len < 14) return;
80002a6e:	0001                	nop
		}
	}
}
80002a70:	40f6                	lw	ra,92(sp)
80002a72:	4466                	lw	s0,88(sp)
80002a74:	6125                	addi	sp,sp,96
80002a76:	8082                	ret

80002a78 <osdp_init>:

void osdp_init(uint8_t device_address)
{
80002a78:	1101                	addi	sp,sp,-32
80002a7a:	ce22                	sw	s0,28(sp)
80002a7c:	1000                	addi	s0,sp,32
80002a7e:	87aa                	mv	a5,a0
80002a80:	fef407a3          	sb	a5,-17(s0)
	g_addr = (uint8_t)(device_address & 0x7F);
80002a84:	fef44783          	lbu	a5,-17(s0)
80002a88:	07f7f793          	andi	a5,a5,127
80002a8c:	0ff7f713          	zext.b	a4,a5
80002a90:	88e180a3          	sb	a4,-1919(gp) # 40000001 <g_addr>
	rx_state = st_wait_som;
80002a94:	e401a623          	sw	zero,-436(gp) # 400005cc <rx_state>
	rx_expected_len = 0;
80002a98:	e4019823          	sh	zero,-432(gp) # 400005d0 <rx_expected_len>
	rx_pos = 0;
80002a9c:	e4019923          	sh	zero,-430(gp) # 400005d2 <rx_pos>
}
80002aa0:	0001                	nop
80002aa2:	4472                	lw	s0,28(sp)
80002aa4:	6105                	addi	sp,sp,32
80002aa6:	8082                	ret

80002aa8 <osdp_on_rx_byte>:

void osdp_on_rx_byte(uint8_t byte) //   
{
80002aa8:	7139                	addi	sp,sp,-64
80002aaa:	de06                	sw	ra,60(sp)
80002aac:	dc22                	sw	s0,56(sp)
80002aae:	0080                	addi	s0,sp,64
80002ab0:	87aa                	mv	a5,a0
80002ab2:	fcf407a3          	sb	a5,-49(s0)
	switch (rx_state) {
80002ab6:	e4c1a783          	lw	a5,-436(gp) # 400005cc <rx_state>
80002aba:	4711                	li	a4,4
80002abc:	3af76763          	bltu	a4,a5,80002e6a <osdp_on_rx_byte+0x3c2>
80002ac0:	00279713          	slli	a4,a5,0x2
80002ac4:	800077b7          	lui	a5,0x80007
80002ac8:	10078793          	addi	a5,a5,256 # 80007100 <__data_source_start+0xffffff88>
80002acc:	97ba                	add	a5,a5,a4
80002ace:	439c                	lw	a5,0(a5)
80002ad0:	8782                	jr	a5
	case st_wait_som:
		if (byte == OSDP_SOM) {
80002ad2:	fcf44703          	lbu	a4,-49(s0)
80002ad6:	05300793          	li	a5,83
80002ada:	38f71b63          	bne	a4,a5,80002e70 <osdp_on_rx_byte+0x3c8>
			rx_pos = 0;
80002ade:	e4019923          	sh	zero,-430(gp) # 400005d2 <rx_pos>
			rx_buf[rx_pos++] = byte;
80002ae2:	e521d783          	lhu	a5,-430(gp) # 400005d2 <rx_pos>
80002ae6:	00178713          	addi	a4,a5,1
80002aea:	01071693          	slli	a3,a4,0x10
80002aee:	82c1                	srli	a3,a3,0x10
80002af0:	e4d19923          	sh	a3,-430(gp) # 400005d2 <rx_pos>
80002af4:	873e                	mv	a4,a5
80002af6:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002afa:	97ba                	add	a5,a5,a4
80002afc:	fcf44703          	lbu	a4,-49(s0)
80002b00:	00e78023          	sb	a4,0(a5)
			rx_state = st_wait_addr;
80002b04:	4705                	li	a4,1
80002b06:	e4e1a623          	sw	a4,-436(gp) # 400005cc <rx_state>
		}
		break;
80002b0a:	a69d                	j	80002e70 <osdp_on_rx_byte+0x3c8>
	case st_wait_addr:
		rx_buf[rx_pos++] = byte;
80002b0c:	e521d783          	lhu	a5,-430(gp) # 400005d2 <rx_pos>
80002b10:	00178713          	addi	a4,a5,1
80002b14:	01071693          	slli	a3,a4,0x10
80002b18:	82c1                	srli	a3,a3,0x10
80002b1a:	e4d19923          	sh	a3,-430(gp) # 400005d2 <rx_pos>
80002b1e:	873e                	mv	a4,a5
80002b20:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002b24:	97ba                	add	a5,a5,a4
80002b26:	fcf44703          	lbu	a4,-49(s0)
80002b2a:	00e78023          	sb	a4,0(a5)
		rx_state = st_wait_len_l;
80002b2e:	4709                	li	a4,2
80002b30:	e4e1a623          	sw	a4,-436(gp) # 400005cc <rx_state>
		break;
80002b34:	a689                	j	80002e76 <osdp_on_rx_byte+0x3ce>
	case st_wait_len_l:
		rx_buf[rx_pos++] = byte;
80002b36:	e521d783          	lhu	a5,-430(gp) # 400005d2 <rx_pos>
80002b3a:	00178713          	addi	a4,a5,1
80002b3e:	01071693          	slli	a3,a4,0x10
80002b42:	82c1                	srli	a3,a3,0x10
80002b44:	e4d19923          	sh	a3,-430(gp) # 400005d2 <rx_pos>
80002b48:	873e                	mv	a4,a5
80002b4a:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002b4e:	97ba                	add	a5,a5,a4
80002b50:	fcf44703          	lbu	a4,-49(s0)
80002b54:	00e78023          	sb	a4,0(a5)
		rx_expected_len = byte;
80002b58:	fcf44783          	lbu	a5,-49(s0)
80002b5c:	01079713          	slli	a4,a5,0x10
80002b60:	8341                	srli	a4,a4,0x10
80002b62:	e4e19823          	sh	a4,-432(gp) # 400005d0 <rx_expected_len>
		rx_state = st_wait_len_m;
80002b66:	470d                	li	a4,3
80002b68:	e4e1a623          	sw	a4,-436(gp) # 400005cc <rx_state>
		break;
80002b6c:	a629                	j	80002e76 <osdp_on_rx_byte+0x3ce>
	case st_wait_len_m:
		rx_buf[rx_pos++] = byte;
80002b6e:	e521d783          	lhu	a5,-430(gp) # 400005d2 <rx_pos>
80002b72:	00178713          	addi	a4,a5,1
80002b76:	01071693          	slli	a3,a4,0x10
80002b7a:	82c1                	srli	a3,a3,0x10
80002b7c:	e4d19923          	sh	a3,-430(gp) # 400005d2 <rx_pos>
80002b80:	873e                	mv	a4,a5
80002b82:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002b86:	97ba                	add	a5,a5,a4
80002b88:	fcf44703          	lbu	a4,-49(s0)
80002b8c:	00e78023          	sb	a4,0(a5)
		rx_expected_len |= ((uint16_t)byte << 8);
80002b90:	fcf44783          	lbu	a5,-49(s0)
80002b94:	07a2                	slli	a5,a5,0x8
80002b96:	01079713          	slli	a4,a5,0x10
80002b9a:	8741                	srai	a4,a4,0x10
80002b9c:	e501d783          	lhu	a5,-432(gp) # 400005d0 <rx_expected_len>
80002ba0:	07c2                	slli	a5,a5,0x10
80002ba2:	87c1                	srai	a5,a5,0x10
80002ba4:	8fd9                	or	a5,a5,a4
80002ba6:	07c2                	slli	a5,a5,0x10
80002ba8:	87c1                	srai	a5,a5,0x10
80002baa:	01079713          	slli	a4,a5,0x10
80002bae:	8341                	srli	a4,a4,0x10
80002bb0:	e4e19823          	sh	a4,-432(gp) # 400005d0 <rx_expected_len>
		if (rx_expected_len < 8 || rx_expected_len > sizeof(rx_buf)) {
80002bb4:	e501d703          	lhu	a4,-432(gp) # 400005d0 <rx_expected_len>
80002bb8:	479d                	li	a5,7
80002bba:	00e7f863          	bgeu	a5,a4,80002bca <osdp_on_rx_byte+0x122>
80002bbe:	e501d703          	lhu	a4,-432(gp) # 400005d0 <rx_expected_len>
80002bc2:	10000793          	li	a5,256
80002bc6:	00e7f563          	bgeu	a5,a4,80002bd0 <osdp_on_rx_byte+0x128>
			//    
			rx_state = st_wait_som;
80002bca:	e401a623          	sw	zero,-436(gp) # 400005cc <rx_state>
			break;
80002bce:	a465                	j	80002e76 <osdp_on_rx_byte+0x3ce>
		}
		rx_state = st_receive_bytes;
80002bd0:	4711                	li	a4,4
80002bd2:	e4e1a623          	sw	a4,-436(gp) # 400005cc <rx_state>
		break;
80002bd6:	a445                	j	80002e76 <osdp_on_rx_byte+0x3ce>
	case st_receive_bytes:
		rx_buf[rx_pos++] = byte;
80002bd8:	e521d783          	lhu	a5,-430(gp) # 400005d2 <rx_pos>
80002bdc:	00178713          	addi	a4,a5,1
80002be0:	01071693          	slli	a3,a4,0x10
80002be4:	82c1                	srli	a3,a3,0x10
80002be6:	e4d19923          	sh	a3,-430(gp) # 400005d2 <rx_pos>
80002bea:	873e                	mv	a4,a5
80002bec:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002bf0:	97ba                	add	a5,a5,a4
80002bf2:	fcf44703          	lbu	a4,-49(s0)
80002bf6:	00e78023          	sb	a4,0(a5)
		if (rx_pos >= rx_expected_len) {
80002bfa:	e521d703          	lhu	a4,-430(gp) # 400005d2 <rx_pos>
80002bfe:	e501d783          	lhu	a5,-432(gp) # 400005d0 <rx_expected_len>
80002c02:	26f76963          	bltu	a4,a5,80002e74 <osdp_on_rx_byte+0x3cc>
			//  CRC
			if (osdp_crc_is_ok(rx_buf, rx_expected_len)) {
80002c06:	e501d783          	lhu	a5,-432(gp) # 400005d0 <rx_expected_len>
80002c0a:	85be                	mv	a1,a5
80002c0c:	e5418513          	addi	a0,gp,-428 # 400005d4 <rx_buf>
80002c10:	fabfe0ef          	jal	ra,80001bba <osdp_crc_is_ok>
80002c14:	87aa                	mv	a5,a0
80002c16:	1e078863          	beqz	a5,80002e06 <osdp_on_rx_byte+0x35e>
				uint8_t addr = (uint8_t)(rx_buf[1] & 0x7F);
80002c1a:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002c1e:	0017c783          	lbu	a5,1(a5)
80002c22:	07f7f793          	andi	a5,a5,127
80002c26:	fef40623          	sb	a5,-20(s0)
				if (addr == g_addr || addr == 0x7F || addr == 0x00) {
80002c2a:	8811c783          	lbu	a5,-1919(gp) # 40000001 <g_addr>
80002c2e:	fec44703          	lbu	a4,-20(s0)
80002c32:	00f70c63          	beq	a4,a5,80002c4a <osdp_on_rx_byte+0x1a2>
80002c36:	fec44703          	lbu	a4,-20(s0)
80002c3a:	07f00793          	li	a5,127
80002c3e:	00f70663          	beq	a4,a5,80002c4a <osdp_on_rx_byte+0x1a2>
80002c42:	fec44783          	lbu	a5,-20(s0)
80002c46:	20079f63          	bnez	a5,80002e64 <osdp_on_rx_byte+0x3bc>
					uint8_t ctrl = rx_buf[4];
80002c4a:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002c4e:	0047c783          	lbu	a5,4(a5)
80002c52:	fef405a3          	sb	a5,-21(s0)
					uint8_t seq = (uint8_t)(ctrl & 0x03);
80002c56:	feb44783          	lbu	a5,-21(s0)
80002c5a:	8b8d                	andi	a5,a5,3
80002c5c:	fef40523          	sb	a5,-22(s0)
					uint8_t cmd = rx_buf[5];
80002c60:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002c64:	0057c783          	lbu	a5,5(a5)
80002c68:	fef404a3          	sb	a5,-23(s0)
					//   (0x7F)  
					char should_reply = (addr != 0x7F);
80002c6c:	fec44783          	lbu	a5,-20(s0)
80002c70:	f8178793          	addi	a5,a5,-127
80002c74:	00f037b3          	snez	a5,a5
80002c78:	0ff7f793          	zext.b	a5,a5
80002c7c:	fef40423          	sb	a5,-24(s0)
					switch (cmd) {
80002c80:	fe944783          	lbu	a5,-23(s0)
80002c84:	fa078793          	addi	a5,a5,-96
80002c88:	4739                	li	a4,14
80002c8a:	16f76463          	bltu	a4,a5,80002df2 <osdp_on_rx_byte+0x34a>
80002c8e:	00279713          	slli	a4,a5,0x2
80002c92:	800077b7          	lui	a5,0x80007
80002c96:	11478793          	addi	a5,a5,276 # 80007114 <__data_source_start+0xffffff9c>
80002c9a:	97ba                	add	a5,a5,a4
80002c9c:	439c                	lw	a5,0(a5)
80002c9e:	8782                	jr	a5
					case osdp_POLL:
						if (should_reply) osdp_build_and_send_ack(seq);
80002ca0:	fe844783          	lbu	a5,-24(s0)
80002ca4:	1a078163          	beqz	a5,80002e46 <osdp_on_rx_byte+0x39e>
80002ca8:	fea44783          	lbu	a5,-22(s0)
80002cac:	853e                	mv	a0,a5
80002cae:	9e0ff0ef          	jal	ra,80001e8e <osdp_build_and_send_ack>
						break;
80002cb2:	aa51                	j	80002e46 <osdp_on_rx_byte+0x39e>
					case osdp_ID:
						if (should_reply) osdp_build_and_send_pdid(seq);
80002cb4:	fe844783          	lbu	a5,-24(s0)
80002cb8:	18078963          	beqz	a5,80002e4a <osdp_on_rx_byte+0x3a2>
80002cbc:	fea44783          	lbu	a5,-22(s0)
80002cc0:	853e                	mv	a0,a5
80002cc2:	ab0ff0ef          	jal	ra,80001f72 <osdp_build_and_send_pdid>
						break;
80002cc6:	a251                	j	80002e4a <osdp_on_rx_byte+0x3a2>
					case osdp_CAP:
						if (should_reply) osdp_build_and_send_pdcap(seq);
80002cc8:	fe844783          	lbu	a5,-24(s0)
80002ccc:	18078163          	beqz	a5,80002e4e <osdp_on_rx_byte+0x3a6>
80002cd0:	fea44783          	lbu	a5,-22(s0)
80002cd4:	853e                	mv	a0,a5
80002cd6:	bacff0ef          	jal	ra,80002082 <osdp_build_and_send_pdcap>
						break;
80002cda:	aa95                	j	80002e4e <osdp_on_rx_byte+0x3a6>
					case osdp_ISTAT:
						if (should_reply) osdp_build_and_send_istat(seq);
80002cdc:	fe844783          	lbu	a5,-24(s0)
80002ce0:	16078963          	beqz	a5,80002e52 <osdp_on_rx_byte+0x3aa>
80002ce4:	fea44783          	lbu	a5,-22(s0)
80002ce8:	853e                	mv	a0,a5
80002cea:	dbcff0ef          	jal	ra,800022a6 <osdp_build_and_send_istat>
						break;
80002cee:	a295                	j	80002e52 <osdp_on_rx_byte+0x3aa>
					case osdp_OSTAT:
						if (should_reply) osdp_build_and_send_ostat(seq);
80002cf0:	fe844783          	lbu	a5,-24(s0)
80002cf4:	16078163          	beqz	a5,80002e56 <osdp_on_rx_byte+0x3ae>
80002cf8:	fea44783          	lbu	a5,-22(s0)
80002cfc:	853e                	mv	a0,a5
80002cfe:	e46ff0ef          	jal	ra,80002344 <osdp_build_and_send_ostat>
						break;
80002d02:	aa91                	j	80002e56 <osdp_on_rx_byte+0x3ae>
					case osdp_COMSET: {
						//  5  : [addr][baud L][baud H][baud HH][baud HHH]
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
80002d04:	e501d783          	lhu	a5,-432(gp) # 400005d0 <rx_expected_len>
80002d08:	17e1                	addi	a5,a5,-8
80002d0a:	fef41323          	sh	a5,-26(s0)
						if (data_len == 5) {
80002d0e:	fe645703          	lhu	a4,-26(s0)
80002d12:	4795                	li	a5,5
80002d14:	08f71d63          	bne	a4,a5,80002dae <osdp_on_rx_byte+0x306>
							uint8_t *data = &rx_buf[6];
80002d18:	e5a18793          	addi	a5,gp,-422 # 400005da <rx_buf+0x6>
80002d1c:	fef42023          	sw	a5,-32(s0)
							uint8_t new_addr = (uint8_t)(data[0] & 0x7F);
80002d20:	fe042783          	lw	a5,-32(s0)
80002d24:	0007c783          	lbu	a5,0(a5)
80002d28:	07f7f793          	andi	a5,a5,127
80002d2c:	fcf40fa3          	sb	a5,-33(s0)
							uint32_t new_baud = (uint32_t)data[1] |
80002d30:	fe042783          	lw	a5,-32(s0)
80002d34:	0785                	addi	a5,a5,1
80002d36:	0007c783          	lbu	a5,0(a5)
80002d3a:	873e                	mv	a4,a5
							                    ((uint32_t)data[2] << 8) |
80002d3c:	fe042783          	lw	a5,-32(s0)
80002d40:	0789                	addi	a5,a5,2
80002d42:	0007c783          	lbu	a5,0(a5)
80002d46:	07a2                	slli	a5,a5,0x8
							uint32_t new_baud = (uint32_t)data[1] |
80002d48:	8f5d                	or	a4,a4,a5
							                    ((uint32_t)data[3] << 16) |
80002d4a:	fe042783          	lw	a5,-32(s0)
80002d4e:	078d                	addi	a5,a5,3
80002d50:	0007c783          	lbu	a5,0(a5)
80002d54:	07c2                	slli	a5,a5,0x10
							                    ((uint32_t)data[2] << 8) |
80002d56:	8f5d                	or	a4,a4,a5
							                    ((uint32_t)data[4] << 24);
80002d58:	fe042783          	lw	a5,-32(s0)
80002d5c:	0791                	addi	a5,a5,4
80002d5e:	0007c783          	lbu	a5,0(a5)
80002d62:	07e2                	slli	a5,a5,0x18
							uint32_t new_baud = (uint32_t)data[1] |
80002d64:	8fd9                	or	a5,a5,a4
80002d66:	fcf42c23          	sw	a5,-40(s0)
							//   osdp_COM    
							if (should_reply) osdp_build_and_send_com(seq, new_addr, new_baud);
80002d6a:	fe844783          	lbu	a5,-24(s0)
80002d6e:	cb99                	beqz	a5,80002d84 <osdp_on_rx_byte+0x2dc>
80002d70:	fdf44703          	lbu	a4,-33(s0)
80002d74:	fea44783          	lbu	a5,-22(s0)
80002d78:	fd842603          	lw	a2,-40(s0)
80002d7c:	85ba                	mv	a1,a4
80002d7e:	853e                	mv	a0,a5
80002d80:	becff0ef          	jal	ra,8000216c <osdp_build_and_send_com>
							//  :    UART
							g_addr = new_addr;
80002d84:	fdf44703          	lbu	a4,-33(s0)
80002d88:	88e180a3          	sb	a4,-1919(gp) # 40000001 <g_addr>
							if (new_baud >= 1200 && new_baud <= 921600) {
80002d8c:	fd842703          	lw	a4,-40(s0)
80002d90:	4af00793          	li	a5,1199
80002d94:	0ce7f363          	bgeu	a5,a4,80002e5a <osdp_on_rx_byte+0x3b2>
80002d98:	fd842703          	lw	a4,-40(s0)
80002d9c:	000e17b7          	lui	a5,0xe1
80002da0:	0ae7ed63          	bltu	a5,a4,80002e5a <osdp_on_rx_byte+0x3b2>
								set_uart_baud(new_baud);
80002da4:	fd842503          	lw	a0,-40(s0)
80002da8:	e3aff0ef          	jal	ra,800023e2 <set_uart_baud>
							}
						} else {
							//    NAK (reason 0x02: invalid length)
							if (should_reply) osdp_build_and_send_nak(seq, 0x02);
						}
						break;
80002dac:	a07d                	j	80002e5a <osdp_on_rx_byte+0x3b2>
							if (should_reply) osdp_build_and_send_nak(seq, 0x02);
80002dae:	fe844783          	lbu	a5,-24(s0)
80002db2:	c7c5                	beqz	a5,80002e5a <osdp_on_rx_byte+0x3b2>
80002db4:	fea44783          	lbu	a5,-22(s0)
80002db8:	4589                	li	a1,2
80002dba:	853e                	mv	a0,a5
80002dbc:	934ff0ef          	jal	ra,80001ef0 <osdp_build_and_send_nak>
						break;
80002dc0:	a869                	j	80002e5a <osdp_on_rx_byte+0x3b2>
					}
					case osdp_LED: {
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
80002dc2:	e501d783          	lhu	a5,-432(gp) # 400005d0 <rx_expected_len>
80002dc6:	17e1                	addi	a5,a5,-8 # e0ff8 <STACK_SIZE+0xe07f8>
80002dc8:	fcf41b23          	sh	a5,-42(s0)
						uint8_t *data = &rx_buf[6];
80002dcc:	e5a18793          	addi	a5,gp,-422 # 400005da <rx_buf+0x6>
80002dd0:	fcf42823          	sw	a5,-48(s0)
						handle_osdp_led(data, data_len);
80002dd4:	fd645783          	lhu	a5,-42(s0)
80002dd8:	85be                	mv	a1,a5
80002dda:	fd042503          	lw	a0,-48(s0)
80002dde:	3879                	jal	8000267c <handle_osdp_led>
						if (should_reply) osdp_build_and_send_ack(seq);
80002de0:	fe844783          	lbu	a5,-24(s0)
80002de4:	cfad                	beqz	a5,80002e5e <osdp_on_rx_byte+0x3b6>
80002de6:	fea44783          	lbu	a5,-22(s0)
80002dea:	853e                	mv	a0,a5
80002dec:	8a2ff0ef          	jal	ra,80001e8e <osdp_build_and_send_ack>
						break;
80002df0:	a0bd                	j	80002e5e <osdp_on_rx_byte+0x3b6>
					}
					default:
						//    NAK (reason 0x03: unknown command)
						if (should_reply) osdp_build_and_send_nak(seq, 0x03);
80002df2:	fe844783          	lbu	a5,-24(s0)
80002df6:	c7b5                	beqz	a5,80002e62 <osdp_on_rx_byte+0x3ba>
80002df8:	fea44783          	lbu	a5,-22(s0)
80002dfc:	458d                	li	a1,3
80002dfe:	853e                	mv	a0,a5
80002e00:	8f0ff0ef          	jal	ra,80001ef0 <osdp_build_and_send_nak>
						break;
80002e04:	a8b9                	j	80002e62 <osdp_on_rx_byte+0x3ba>
					}
				}
			} else {
				//  CRC  NAK (reason 0x01),     
				uint8_t addr = (uint8_t)(rx_buf[1] & 0x7F);
80002e06:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002e0a:	0017c783          	lbu	a5,1(a5)
80002e0e:	07f7f793          	andi	a5,a5,127
80002e12:	fef407a3          	sb	a5,-17(s0)
				if (addr != 0x7F) {
80002e16:	fef44703          	lbu	a4,-17(s0)
80002e1a:	07f00793          	li	a5,127
80002e1e:	04f70363          	beq	a4,a5,80002e64 <osdp_on_rx_byte+0x3bc>
					uint8_t ctrl = rx_buf[4];
80002e22:	e5418793          	addi	a5,gp,-428 # 400005d4 <rx_buf>
80002e26:	0047c783          	lbu	a5,4(a5)
80002e2a:	fef40723          	sb	a5,-18(s0)
					uint8_t seq = (uint8_t)(ctrl & 0x03);
80002e2e:	fee44783          	lbu	a5,-18(s0)
80002e32:	8b8d                	andi	a5,a5,3
80002e34:	fef406a3          	sb	a5,-19(s0)
					osdp_build_and_send_nak(seq, 0x01);
80002e38:	fed44783          	lbu	a5,-19(s0)
80002e3c:	4585                	li	a1,1
80002e3e:	853e                	mv	a0,a5
80002e40:	8b0ff0ef          	jal	ra,80001ef0 <osdp_build_and_send_nak>
80002e44:	a005                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e46:	0001                	nop
80002e48:	a831                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e4a:	0001                	nop
80002e4c:	a821                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e4e:	0001                	nop
80002e50:	a811                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e52:	0001                	nop
80002e54:	a801                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e56:	0001                	nop
80002e58:	a031                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e5a:	0001                	nop
80002e5c:	a021                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e5e:	0001                	nop
80002e60:	a011                	j	80002e64 <osdp_on_rx_byte+0x3bc>
						break;
80002e62:	0001                	nop
				}
			}
			//    
			rx_state = st_wait_som;
80002e64:	e401a623          	sw	zero,-436(gp) # 400005cc <rx_state>
		}
		break;
80002e68:	a031                	j	80002e74 <osdp_on_rx_byte+0x3cc>
	default:
		rx_state = st_wait_som;
80002e6a:	e401a623          	sw	zero,-436(gp) # 400005cc <rx_state>
		break;
80002e6e:	a021                	j	80002e76 <osdp_on_rx_byte+0x3ce>
		break;
80002e70:	0001                	nop
80002e72:	a011                	j	80002e76 <osdp_on_rx_byte+0x3ce>
		break;
80002e74:	0001                	nop
	}
}
80002e76:	0001                	nop
80002e78:	50f2                	lw	ra,60(sp)
80002e7a:	5462                	lw	s0,56(sp)
80002e7c:	6121                	addi	sp,sp,64
80002e7e:	8082                	ret

80002e80 <RCU_ADCSARRstCmd>:
  * @brief   C  
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void RCU_ADCSARRstCmd(FunctionalState State)
{
80002e80:	1101                	addi	sp,sp,-32
80002e82:	ce22                	sw	s0,28(sp)
80002e84:	1000                	addi	s0,sp,32
80002e86:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(RCU->ADCSARCLKCFG_bit.RSTDIS, State);
80002e8a:	3000e7b7          	lui	a5,0x3000e
80002e8e:	fec42703          	lw	a4,-20(s0)
80002e92:	8b05                	andi	a4,a4,1
80002e94:	0ff77713          	zext.b	a4,a4
80002e98:	8b05                	andi	a4,a4,1
80002e9a:	0722                	slli	a4,a4,0x8
80002e9c:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80002ea0:	eff6f693          	andi	a3,a3,-257
80002ea4:	8f55                	or	a4,a4,a3
80002ea6:	0ae7a823          	sw	a4,176(a5)
}
80002eaa:	0001                	nop
80002eac:	4472                	lw	s0,28(sp)
80002eae:	6105                	addi	sp,sp,32
80002eb0:	8082                	ret

80002eb2 <ADCSAR_SEQ_SwStartEnCmd>:
  * @param   SEQ_Num   
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SwStartEnCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80002eb2:	1101                	addi	sp,sp,-32
80002eb4:	ce22                	sw	s0,28(sp)
80002eb6:	1000                	addi	s0,sp,32
80002eb8:	fea42623          	sw	a0,-20(s0)
80002ebc:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQSYNC, 1 << (uint32_t)SEQ_Num, State << (uint32_t)SEQ_Num);
80002ec0:	300107b7          	lui	a5,0x30010
80002ec4:	43dc                	lw	a5,4(a5)
80002ec6:	fec42703          	lw	a4,-20(s0)
80002eca:	4685                	li	a3,1
80002ecc:	00e69733          	sll	a4,a3,a4
80002ed0:	fff74713          	not	a4,a4
80002ed4:	00e7f6b3          	and	a3,a5,a4
80002ed8:	fec42783          	lw	a5,-20(s0)
80002edc:	fe842703          	lw	a4,-24(s0)
80002ee0:	00f71733          	sll	a4,a4,a5
80002ee4:	300107b7          	lui	a5,0x30010
80002ee8:	8f55                	or	a4,a4,a3
80002eea:	c3d8                	sw	a4,4(a5)
}
80002eec:	0001                	nop
80002eee:	4472                	lw	s0,28(sp)
80002ef0:	6105                	addi	sp,sp,32
80002ef2:	8082                	ret

80002ef4 <ADCSAR_SEQ_StartEventConfig>:
  * @param   SEQ_Num   
  * @param   StartEvent   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_StartEventConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_StartEvent_TypeDef StartEvent)
{
80002ef4:	1101                	addi	sp,sp,-32
80002ef6:	ce22                	sw	s0,28(sp)
80002ef8:	1000                	addi	s0,sp,32
80002efa:	fea42623          	sw	a0,-20(s0)
80002efe:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    MODIFY_REG(ADCSAR->EMUX, 0xF << ((uint32_t)SEQ_Num * 4), StartEvent << ((uint32_t)SEQ_Num * 4));
80002f02:	300107b7          	lui	a5,0x30010
80002f06:	4fdc                	lw	a5,28(a5)
80002f08:	fec42703          	lw	a4,-20(s0)
80002f0c:	070a                	slli	a4,a4,0x2
80002f0e:	46bd                	li	a3,15
80002f10:	00e69733          	sll	a4,a3,a4
80002f14:	fff74713          	not	a4,a4
80002f18:	00e7f6b3          	and	a3,a5,a4
80002f1c:	fec42783          	lw	a5,-20(s0)
80002f20:	078a                	slli	a5,a5,0x2
80002f22:	fe842703          	lw	a4,-24(s0)
80002f26:	00f71733          	sll	a4,a4,a5
80002f2a:	300107b7          	lui	a5,0x30010
80002f2e:	8f55                	or	a4,a4,a3
80002f30:	cfd8                	sw	a4,28(a5)
}
80002f32:	0001                	nop
80002f34:	4472                	lw	s0,28(sp)
80002f36:	6105                	addi	sp,sp,32
80002f38:	8082                	ret

80002f3a <ADCSAR_SEQ_ReqMaxConfig>:
  * @param   SEQ_Num   
  * @param   ReqNumMax    
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqMaxConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_ReqNum_TypeDef ReqNumMax)
{
80002f3a:	1101                	addi	sp,sp,-32
80002f3c:	ce22                	sw	s0,28(sp)
80002f3e:	1000                	addi	s0,sp,32
80002f40:	fea42623          	sw	a0,-20(s0)
80002f44:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_REQ_NUM(ReqNumMax));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.RQMAX, ReqNumMax);
80002f48:	300106b7          	lui	a3,0x30010
80002f4c:	fe842783          	lw	a5,-24(s0)
80002f50:	8b9d                	andi	a5,a5,7
80002f52:	0ff7f713          	zext.b	a4,a5
80002f56:	fec42783          	lw	a5,-20(s0)
80002f5a:	079a                	slli	a5,a5,0x6
80002f5c:	97b6                	add	a5,a5,a3
80002f5e:	8b1d                	andi	a4,a4,7
80002f60:	0587d683          	lhu	a3,88(a5) # 30010058 <STACK_SIZE+0x3000f858>
80002f64:	9ae1                	andi	a3,a3,-8
80002f66:	8f55                	or	a4,a4,a3
80002f68:	04e79c23          	sh	a4,88(a5)
}
80002f6c:	0001                	nop
80002f6e:	4472                	lw	s0,28(sp)
80002f70:	6105                	addi	sp,sp,32
80002f72:	8082                	ret

80002f74 <ADCSAR_SEQ_ReqAverageConfig>:
  * @param   SEQ_Num   
  * @param   Average    
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqAverageConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_Average_TypeDef Average)
{
80002f74:	1101                	addi	sp,sp,-32
80002f76:	ce22                	sw	s0,28(sp)
80002f78:	1000                	addi	s0,sp,32
80002f7a:	fea42623          	sw	a0,-20(s0)
80002f7e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_AVERAGE(Average));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.QAVGVAL, Average);
80002f82:	300106b7          	lui	a3,0x30010
80002f86:	fe842783          	lw	a5,-24(s0)
80002f8a:	8b9d                	andi	a5,a5,7
80002f8c:	0ff7f713          	zext.b	a4,a5
80002f90:	fec42783          	lw	a5,-20(s0)
80002f94:	079a                	slli	a5,a5,0x6
80002f96:	97b6                	add	a5,a5,a3
80002f98:	8b1d                	andi	a4,a4,7
80002f9a:	00971613          	slli	a2,a4,0x9
80002f9e:	0587d703          	lhu	a4,88(a5)
80002fa2:	86ba                	mv	a3,a4
80002fa4:	777d                	lui	a4,0xfffff
80002fa6:	1ff70713          	addi	a4,a4,511 # fffff1ff <__data_source_start+0x7fff8087>
80002faa:	8f75                	and	a4,a4,a3
80002fac:	86ba                	mv	a3,a4
80002fae:	8732                	mv	a4,a2
80002fb0:	8f55                	or	a4,a4,a3
80002fb2:	04e79c23          	sh	a4,88(a5)
}
80002fb6:	0001                	nop
80002fb8:	4472                	lw	s0,28(sp)
80002fba:	6105                	addi	sp,sp,32
80002fbc:	8082                	ret

80002fbe <ADCSAR_SEQ_ReqAverageCmd>:
  * @param   SEQ_Num   
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqAverageCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80002fbe:	1101                	addi	sp,sp,-32
80002fc0:	ce22                	sw	s0,28(sp)
80002fc2:	1000                	addi	s0,sp,32
80002fc4:	fea42623          	sw	a0,-20(s0)
80002fc8:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.QAVGEN, State);
80002fcc:	300106b7          	lui	a3,0x30010
80002fd0:	fe842783          	lw	a5,-24(s0)
80002fd4:	8b85                	andi	a5,a5,1
80002fd6:	0ff7f713          	zext.b	a4,a5
80002fda:	fec42783          	lw	a5,-20(s0)
80002fde:	079a                	slli	a5,a5,0x6
80002fe0:	97b6                	add	a5,a5,a3
80002fe2:	8b05                	andi	a4,a4,1
80002fe4:	0722                	slli	a4,a4,0x8
80002fe6:	0587d683          	lhu	a3,88(a5)
80002fea:	eff6f693          	andi	a3,a3,-257
80002fee:	8f55                	or	a4,a4,a3
80002ff0:	04e79c23          	sh	a4,88(a5)
}
80002ff4:	0001                	nop
80002ff6:	4472                	lw	s0,28(sp)
80002ff8:	6105                	addi	sp,sp,32
80002ffa:	8082                	ret

80002ffc <ADCSAR_SEQ_DMAConfig>:
  * @param   SEQ_Num   
  * @param   DMAFIFOLevel         DMA
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DMAConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_DMAFIFOLevel_TypeDef DMAFIFOLevel)
{
80002ffc:	1101                	addi	sp,sp,-32
80002ffe:	ce22                	sw	s0,28(sp)
80003000:	1000                	addi	s0,sp,32
80003002:	fea42623          	sw	a0,-20(s0)
80003006:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_DMA_FIFO_LEVEL(DMAFIFOLevel));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SDMACTL_bit.WMARK, DMAFIFOLevel);
8000300a:	300106b7          	lui	a3,0x30010
8000300e:	fe842783          	lw	a5,-24(s0)
80003012:	8b9d                	andi	a5,a5,7
80003014:	0ff7f713          	zext.b	a4,a5
80003018:	fec42783          	lw	a5,-20(s0)
8000301c:	079a                	slli	a5,a5,0x6
8000301e:	97b6                	add	a5,a5,a3
80003020:	8b1d                	andi	a4,a4,7
80003022:	0722                	slli	a4,a4,0x8
80003024:	0607d683          	lhu	a3,96(a5)
80003028:	8ff6f693          	andi	a3,a3,-1793
8000302c:	8f55                	or	a4,a4,a3
8000302e:	06e79023          	sh	a4,96(a5)
}
80003032:	0001                	nop
80003034:	4472                	lw	s0,28(sp)
80003036:	6105                	addi	sp,sp,32
80003038:	8082                	ret

8000303a <ADCSAR_SEQ_DMACmd>:
  * @param   SEQ_Num   
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DMACmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
8000303a:	1101                	addi	sp,sp,-32
8000303c:	ce22                	sw	s0,28(sp)
8000303e:	1000                	addi	s0,sp,32
80003040:	fea42623          	sw	a0,-20(s0)
80003044:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SDMACTL_bit.DMAEN, State);
80003048:	300106b7          	lui	a3,0x30010
8000304c:	fe842783          	lw	a5,-24(s0)
80003050:	8b85                	andi	a5,a5,1
80003052:	0ff7f713          	zext.b	a4,a5
80003056:	fec42783          	lw	a5,-20(s0)
8000305a:	079a                	slli	a5,a5,0x6
8000305c:	97b6                	add	a5,a5,a3
8000305e:	8b05                	andi	a4,a4,1
80003060:	0607d683          	lhu	a3,96(a5)
80003064:	9af9                	andi	a3,a3,-2
80003066:	8f55                	or	a4,a4,a3
80003068:	06e79023          	sh	a4,96(a5)
}
8000306c:	0001                	nop
8000306e:	4472                	lw	s0,28(sp)
80003070:	6105                	addi	sp,sp,32
80003072:	8082                	ret

80003074 <ADCSAR_SEQ_RestartConfig>:
  * @param   RestartVal  . 0x00 -  ,
  *                      0x01 - 1 , 0xFF - 255 .
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_RestartConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t RestartVal)
{
80003074:	1101                	addi	sp,sp,-32
80003076:	ce22                	sw	s0,28(sp)
80003078:	1000                	addi	s0,sp,32
8000307a:	fea42623          	sw	a0,-20(s0)
8000307e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_RESTART_VAL(RestartVal));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.RCNT, RestartVal);
80003082:	300106b7          	lui	a3,0x30010
80003086:	fe842783          	lw	a5,-24(s0)
8000308a:	0ff7f713          	zext.b	a4,a5
8000308e:	fec42783          	lw	a5,-20(s0)
80003092:	079a                	slli	a5,a5,0x6
80003094:	97b6                	add	a5,a5,a3
80003096:	06e78223          	sb	a4,100(a5)
}
8000309a:	0001                	nop
8000309c:	4472                	lw	s0,28(sp)
8000309e:	6105                	addi	sp,sp,32
800030a0:	8082                	ret

800030a2 <ADCSAR_SEQ_RestartAverageCmd>:
  * @param   SEQ_Num   
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_RestartAverageCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
800030a2:	1101                	addi	sp,sp,-32
800030a4:	ce22                	sw	s0,28(sp)
800030a6:	1000                	addi	s0,sp,32
800030a8:	fea42623          	sw	a0,-20(s0)
800030ac:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.RAVGEN, State);
800030b0:	300106b7          	lui	a3,0x30010
800030b4:	fe842783          	lw	a5,-24(s0)
800030b8:	8b85                	andi	a5,a5,1
800030ba:	0ff7f713          	zext.b	a4,a5
800030be:	fec42783          	lw	a5,-20(s0)
800030c2:	079a                	slli	a5,a5,0x6
800030c4:	97b6                	add	a5,a5,a3
800030c6:	8b05                	andi	a4,a4,1
800030c8:	0722                	slli	a4,a4,0x8
800030ca:	53f4                	lw	a3,100(a5)
800030cc:	eff6f693          	andi	a3,a3,-257
800030d0:	8f55                	or	a4,a4,a3
800030d2:	d3f8                	sw	a4,100(a5)
}
800030d4:	0001                	nop
800030d6:	4472                	lw	s0,28(sp)
800030d8:	6105                	addi	sp,sp,32
800030da:	8082                	ret

800030dc <ADCSAR_SEQ_DCEnableCmd>:
  * @param   DC_Num   
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DCEnableCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_DC_Num_TypeDef DC_Num, FunctionalState State)
{
800030dc:	1101                	addi	sp,sp,-32
800030de:	ce22                	sw	s0,28(sp)
800030e0:	1000                	addi	s0,sp,32
800030e2:	fea42623          	sw	a0,-20(s0)
800030e6:	feb42423          	sw	a1,-24(s0)
800030ea:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SDC, 1 << ((uint32_t)DC_Num), State << ((uint32_t)DC_Num));
800030ee:	30010737          	lui	a4,0x30010
800030f2:	fec42783          	lw	a5,-20(s0)
800030f6:	079a                	slli	a5,a5,0x6
800030f8:	97ba                	add	a5,a5,a4
800030fa:	57fc                	lw	a5,108(a5)
800030fc:	fe842703          	lw	a4,-24(s0)
80003100:	4685                	li	a3,1
80003102:	00e69733          	sll	a4,a3,a4
80003106:	fff74713          	not	a4,a4
8000310a:	8f7d                	and	a4,a4,a5
8000310c:	fe842783          	lw	a5,-24(s0)
80003110:	fe442683          	lw	a3,-28(s0)
80003114:	00f697b3          	sll	a5,a3,a5
80003118:	300106b7          	lui	a3,0x30010
8000311c:	8f5d                	or	a4,a4,a5
8000311e:	fec42783          	lw	a5,-20(s0)
80003122:	079a                	slli	a5,a5,0x6
80003124:	97b6                	add	a5,a5,a3
80003126:	d7f8                	sw	a4,108(a5)
}
80003128:	0001                	nop
8000312a:	4472                	lw	s0,28(sp)
8000312c:	6105                	addi	sp,sp,32
8000312e:	8082                	ret

80003130 <ADCSAR_SEQ_SetRestartTimer>:
  * @param   SEQ_Num   
  * @param   TimerVal  . 0 -       ( ).
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SetRestartTimer(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t TimerVal)
{
80003130:	1101                	addi	sp,sp,-32
80003132:	ce22                	sw	s0,28(sp)
80003134:	1000                	addi	s0,sp,32
80003136:	fea42623          	sw	a0,-20(s0)
8000313a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_RESTART_TIMER_VAL(TimerVal));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRTMR_bit.VAL, TimerVal);
8000313e:	30010737          	lui	a4,0x30010
80003142:	fe842683          	lw	a3,-24(s0)
80003146:	010007b7          	lui	a5,0x1000
8000314a:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
8000314c:	8efd                	and	a3,a3,a5
8000314e:	fec42783          	lw	a5,-20(s0)
80003152:	079a                	slli	a5,a5,0x6
80003154:	97ba                	add	a5,a5,a4
80003156:	01000737          	lui	a4,0x1000
8000315a:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
8000315c:	8f75                	and	a4,a4,a3
8000315e:	5bb0                	lw	a2,112(a5)
80003160:	ff0006b7          	lui	a3,0xff000
80003164:	8ef1                	and	a3,a3,a2
80003166:	8f55                	or	a4,a4,a3
80003168:	dbb8                	sw	a4,112(a5)
}
8000316a:	0001                	nop
8000316c:	4472                	lw	s0,28(sp)
8000316e:	6105                	addi	sp,sp,32
80003170:	8082                	ret

80003172 <ADCSAR_DC_OutputCmd>:
  * @param   DC_Num   
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_OutputCmd(ADCSAR_DC_Num_TypeDef DC_Num, FunctionalState State)
{
80003172:	1101                	addi	sp,sp,-32
80003174:	ce22                	sw	s0,28(sp)
80003176:	1000                	addi	s0,sp,32
80003178:	fea42623          	sw	a0,-20(s0)
8000317c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.CTE, State);
80003180:	30010637          	lui	a2,0x30010
80003184:	fe842783          	lw	a5,-24(s0)
80003188:	8b85                	andi	a5,a5,1
8000318a:	0ff7f693          	zext.b	a3,a5
8000318e:	fec42703          	lw	a4,-20(s0)
80003192:	87ba                	mv	a5,a4
80003194:	0786                	slli	a5,a5,0x1
80003196:	97ba                	add	a5,a5,a4
80003198:	078a                	slli	a5,a5,0x2
8000319a:	97b2                	add	a5,a5,a2
8000319c:	0016f713          	andi	a4,a3,1
800031a0:	0732                	slli	a4,a4,0xc
800031a2:	4007a603          	lw	a2,1024(a5)
800031a6:	76fd                	lui	a3,0xfffff
800031a8:	16fd                	addi	a3,a3,-1 # ffffefff <__data_source_start+0x7fff7e87>
800031aa:	8ef1                	and	a3,a3,a2
800031ac:	8f55                	or	a4,a4,a3
800031ae:	40e7a023          	sw	a4,1024(a5)
}
800031b2:	0001                	nop
800031b4:	4472                	lw	s0,28(sp)
800031b6:	6105                	addi	sp,sp,32
800031b8:	8082                	ret

800031ba <ADCSAR_DC_SourceConfig>:
  * @param   DC_Num   
  * @param   Source   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SourceConfig(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Source_TypeDef Source)
{
800031ba:	1101                	addi	sp,sp,-32
800031bc:	ce22                	sw	s0,28(sp)
800031be:	1000                	addi	s0,sp,32
800031c0:	fea42623          	sw	a0,-20(s0)
800031c4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_SOURCE(Source));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.SRC, Source);
800031c8:	30010637          	lui	a2,0x30010
800031cc:	fe842783          	lw	a5,-24(s0)
800031d0:	8b85                	andi	a5,a5,1
800031d2:	0ff7f693          	zext.b	a3,a5
800031d6:	fec42703          	lw	a4,-20(s0)
800031da:	87ba                	mv	a5,a4
800031dc:	0786                	slli	a5,a5,0x1
800031de:	97ba                	add	a5,a5,a4
800031e0:	078a                	slli	a5,a5,0x2
800031e2:	97b2                	add	a5,a5,a2
800031e4:	0016f713          	andi	a4,a3,1
800031e8:	0762                	slli	a4,a4,0x18
800031ea:	4007a603          	lw	a2,1024(a5)
800031ee:	ff0006b7          	lui	a3,0xff000
800031f2:	16fd                	addi	a3,a3,-1 # feffffff <__data_source_start+0x7eff8e87>
800031f4:	8ef1                	and	a3,a3,a2
800031f6:	8f55                	or	a4,a4,a3
800031f8:	40e7a023          	sw	a4,1024(a5)
}
800031fc:	0001                	nop
800031fe:	4472                	lw	s0,28(sp)
80003200:	6105                	addi	sp,sp,32
80003202:	8082                	ret

80003204 <ADCSAR_DC_ChannelConfig>:
  * @param   DC_Num   
  * @param   Source   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_ChannelConfig(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_CH_Num_TypeDef Channel_Num)
{
80003204:	1101                	addi	sp,sp,-32
80003206:	ce22                	sw	s0,28(sp)
80003208:	1000                	addi	s0,sp,32
8000320a:	fea42623          	sw	a0,-20(s0)
8000320e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_CH_NUM(Channel_Num));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.CHNL, Channel_Num);
80003212:	30010637          	lui	a2,0x30010
80003216:	fe842783          	lw	a5,-24(s0)
8000321a:	8b9d                	andi	a5,a5,7
8000321c:	0ff7f693          	zext.b	a3,a5
80003220:	fec42703          	lw	a4,-20(s0)
80003224:	87ba                	mv	a5,a4
80003226:	0786                	slli	a5,a5,0x1
80003228:	97ba                	add	a5,a5,a4
8000322a:	078a                	slli	a5,a5,0x2
8000322c:	97b2                	add	a5,a5,a2
8000322e:	0076f713          	andi	a4,a3,7
80003232:	0742                	slli	a4,a4,0x10
80003234:	4007a603          	lw	a2,1024(a5)
80003238:	fff906b7          	lui	a3,0xfff90
8000323c:	16fd                	addi	a3,a3,-1 # fff8ffff <__data_source_start+0x7ff88e87>
8000323e:	8ef1                	and	a3,a3,a2
80003240:	8f55                	or	a4,a4,a3
80003242:	40e7a023          	sw	a4,1024(a5)
}
80003246:	0001                	nop
80003248:	4472                	lw	s0,28(sp)
8000324a:	6105                	addi	sp,sp,32
8000324c:	8082                	ret

8000324e <ADCSAR_DC_Config>:
  * @param   Mode   
  * @param   Condition   
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_Config(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Mode_TypeDef Mode, ADCSAR_DC_Condition_TypeDef Condition)
{
8000324e:	1101                	addi	sp,sp,-32
80003250:	ce22                	sw	s0,28(sp)
80003252:	1000                	addi	s0,sp,32
80003254:	fea42623          	sw	a0,-20(s0)
80003258:	feb42423          	sw	a1,-24(s0)
8000325c:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_MODE(Mode));
    assert_param(IS_ADCSAR_DC_CONDITION(Condition));

    MODIFY_REG(ADCSAR->DC[DC_Num].DCTL, ADCSAR_DC_DCTL_CTC_Msk | ADCSAR_DC_DCTL_CTM_Msk,
80003260:	300106b7          	lui	a3,0x30010
80003264:	fec42703          	lw	a4,-20(s0)
80003268:	87ba                	mv	a5,a4
8000326a:	0786                	slli	a5,a5,0x1
8000326c:	97ba                	add	a5,a5,a4
8000326e:	078a                	slli	a5,a5,0x2
80003270:	97b6                	add	a5,a5,a3
80003272:	4007a703          	lw	a4,1024(a5)
80003276:	77fd                	lui	a5,0xfffff
80003278:	0ff78793          	addi	a5,a5,255 # fffff0ff <__data_source_start+0x7fff7f87>
8000327c:	8f7d                	and	a4,a4,a5
8000327e:	fe842783          	lw	a5,-24(s0)
80003282:	00879693          	slli	a3,a5,0x8
80003286:	fe442783          	lw	a5,-28(s0)
8000328a:	07aa                	slli	a5,a5,0xa
8000328c:	8fd5                	or	a5,a5,a3
8000328e:	30010637          	lui	a2,0x30010
80003292:	00f766b3          	or	a3,a4,a5
80003296:	fec42703          	lw	a4,-20(s0)
8000329a:	87ba                	mv	a5,a4
8000329c:	0786                	slli	a5,a5,0x1
8000329e:	97ba                	add	a5,a5,a4
800032a0:	078a                	slli	a5,a5,0x2
800032a2:	97b2                	add	a5,a5,a2
800032a4:	40d7a023          	sw	a3,1024(a5)
               ((Mode << ADCSAR_DC_DCTL_CTM_Pos) |
                (Condition << ADCSAR_DC_DCTL_CTC_Pos)));
}
800032a8:	0001                	nop
800032aa:	4472                	lw	s0,28(sp)
800032ac:	6105                	addi	sp,sp,32
800032ae:	8082                	ret

800032b0 <ADCSAR_DC_SetThresholdLow>:
  * @param   DC_Num   
  * @param   Val  .  0-0xFFF.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SetThresholdLow(ADCSAR_DC_Num_TypeDef DC_Num, uint32_t Val)
{
800032b0:	1101                	addi	sp,sp,-32
800032b2:	ce22                	sw	s0,28(sp)
800032b4:	1000                	addi	s0,sp,32
800032b6:	fea42623          	sw	a0,-20(s0)
800032ba:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_THRESHOLD(Val));

    WRITE_REG(ADCSAR->DC[DC_Num].DCMP_bit.CMPL, Val);
800032be:	30010637          	lui	a2,0x30010
800032c2:	fe842783          	lw	a5,-24(s0)
800032c6:	873e                	mv	a4,a5
800032c8:	6785                	lui	a5,0x1
800032ca:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
800032cc:	8ff9                	and	a5,a5,a4
800032ce:	01079693          	slli	a3,a5,0x10
800032d2:	82c1                	srli	a3,a3,0x10
800032d4:	fec42703          	lw	a4,-20(s0)
800032d8:	87ba                	mv	a5,a4
800032da:	0786                	slli	a5,a5,0x1
800032dc:	97ba                	add	a5,a5,a4
800032de:	078a                	slli	a5,a5,0x2
800032e0:	97b2                	add	a5,a5,a2
800032e2:	6705                	lui	a4,0x1
800032e4:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
800032e6:	8f75                	and	a4,a4,a3
800032e8:	4047a603          	lw	a2,1028(a5)
800032ec:	76fd                	lui	a3,0xfffff
800032ee:	8ef1                	and	a3,a3,a2
800032f0:	8f55                	or	a4,a4,a3
800032f2:	40e7a223          	sw	a4,1028(a5)
}
800032f6:	0001                	nop
800032f8:	4472                	lw	s0,28(sp)
800032fa:	6105                	addi	sp,sp,32
800032fc:	8082                	ret

800032fe <ADCSAR_DC_SetThresholdHigh>:
  * @param   DC_Num   
  * @param   Val  .  0-0xFFF.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SetThresholdHigh(ADCSAR_DC_Num_TypeDef DC_Num, uint32_t Val)
{
800032fe:	1101                	addi	sp,sp,-32
80003300:	ce22                	sw	s0,28(sp)
80003302:	1000                	addi	s0,sp,32
80003304:	fea42623          	sw	a0,-20(s0)
80003308:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_THRESHOLD(Val));

    WRITE_REG(ADCSAR->DC[DC_Num].DCMP_bit.CMPH, Val);
8000330c:	30010637          	lui	a2,0x30010
80003310:	fe842783          	lw	a5,-24(s0)
80003314:	873e                	mv	a4,a5
80003316:	6785                	lui	a5,0x1
80003318:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
8000331a:	8ff9                	and	a5,a5,a4
8000331c:	01079693          	slli	a3,a5,0x10
80003320:	82c1                	srli	a3,a3,0x10
80003322:	fec42703          	lw	a4,-20(s0)
80003326:	87ba                	mv	a5,a4
80003328:	0786                	slli	a5,a5,0x1
8000332a:	97ba                	add	a5,a5,a4
8000332c:	078a                	slli	a5,a5,0x2
8000332e:	97b2                	add	a5,a5,a2
80003330:	6705                	lui	a4,0x1
80003332:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80003334:	8f75                	and	a4,a4,a3
80003336:	0742                	slli	a4,a4,0x10
80003338:	4047a603          	lw	a2,1028(a5)
8000333c:	f00106b7          	lui	a3,0xf0010
80003340:	16fd                	addi	a3,a3,-1 # f000ffff <__data_source_start+0x70008e87>
80003342:	8ef1                	and	a3,a3,a2
80003344:	8f55                	or	a4,a4,a3
80003346:	40e7a223          	sw	a4,1028(a5)
}
8000334a:	0001                	nop
8000334c:	4472                	lw	s0,28(sp)
8000334e:	6105                	addi	sp,sp,32
80003350:	8082                	ret

80003352 <ADCSAR_SEQ_ReqConfig>:
  * @param   ReqNum   
  * @param   Channel_Num   
  * @retval  void
  */
void ADCSAR_SEQ_ReqConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_ReqNum_TypeDef ReqNum, ADCSAR_CH_Num_TypeDef Channel_Num)
{
80003352:	7179                	addi	sp,sp,-48
80003354:	d622                	sw	s0,44(sp)
80003356:	1800                	addi	s0,sp,48
80003358:	fca42e23          	sw	a0,-36(s0)
8000335c:	fcb42c23          	sw	a1,-40(s0)
80003360:	fcc42a23          	sw	a2,-44(s0)

    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_REQ_NUM(ReqNum));
    assert_param(IS_ADCSAR_CH_NUM(Channel_Num));

    req_pos = ((uint32_t)ReqNum % 4) * 8;
80003364:	fd842783          	lw	a5,-40(s0)
80003368:	8b8d                	andi	a5,a5,3
8000336a:	078e                	slli	a5,a5,0x3
8000336c:	fef42623          	sw	a5,-20(s0)

    if (ReqNum > ADCSAR_SEQ_ReqNum_7)
80003370:	fd842703          	lw	a4,-40(s0)
80003374:	479d                	li	a5,7
80003376:	04e7f363          	bgeu	a5,a4,800033bc <ADCSAR_SEQ_ReqConfig+0x6a>
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel2
8000337a:	30010737          	lui	a4,0x30010
8000337e:	fdc42783          	lw	a5,-36(s0)
80003382:	0785                	addi	a5,a5,1
80003384:	079a                	slli	a5,a5,0x6
80003386:	97ba                	add	a5,a5,a4
80003388:	439c                	lw	a5,0(a5)
8000338a:	fec42703          	lw	a4,-20(s0)
8000338e:	03f00693          	li	a3,63
80003392:	00e69733          	sll	a4,a3,a4
80003396:	fff74713          	not	a4,a4
8000339a:	8f7d                	and	a4,a4,a5
8000339c:	fec42783          	lw	a5,-20(s0)
800033a0:	fd442683          	lw	a3,-44(s0)
800033a4:	00f697b3          	sll	a5,a3,a5
800033a8:	300106b7          	lui	a3,0x30010
800033ac:	8f5d                	or	a4,a4,a5
800033ae:	fdc42783          	lw	a5,-36(s0)
800033b2:	0785                	addi	a5,a5,1
800033b4:	079a                	slli	a5,a5,0x6
800033b6:	97b6                	add	a5,a5,a3
800033b8:	c398                	sw	a4,0(a5)
    else if (ReqNum > ADCSAR_SEQ_ReqNum_3)
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel1
    else
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel0
}
800033ba:	a079                	j	80003448 <ADCSAR_SEQ_ReqConfig+0xf6>
    else if (ReqNum > ADCSAR_SEQ_ReqNum_3)
800033bc:	fd842703          	lw	a4,-40(s0)
800033c0:	478d                	li	a5,3
800033c2:	04e7f363          	bgeu	a5,a4,80003408 <ADCSAR_SEQ_ReqConfig+0xb6>
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel1
800033c6:	30010737          	lui	a4,0x30010
800033ca:	fdc42783          	lw	a5,-36(s0)
800033ce:	0785                	addi	a5,a5,1
800033d0:	079a                	slli	a5,a5,0x6
800033d2:	97ba                	add	a5,a5,a4
800033d4:	439c                	lw	a5,0(a5)
800033d6:	fec42703          	lw	a4,-20(s0)
800033da:	03f00693          	li	a3,63
800033de:	00e69733          	sll	a4,a3,a4
800033e2:	fff74713          	not	a4,a4
800033e6:	8f7d                	and	a4,a4,a5
800033e8:	fec42783          	lw	a5,-20(s0)
800033ec:	fd442683          	lw	a3,-44(s0)
800033f0:	00f697b3          	sll	a5,a3,a5
800033f4:	300106b7          	lui	a3,0x30010
800033f8:	8f5d                	or	a4,a4,a5
800033fa:	fdc42783          	lw	a5,-36(s0)
800033fe:	0785                	addi	a5,a5,1
80003400:	079a                	slli	a5,a5,0x6
80003402:	97b6                	add	a5,a5,a3
80003404:	c398                	sw	a4,0(a5)
}
80003406:	a089                	j	80003448 <ADCSAR_SEQ_ReqConfig+0xf6>
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel0
80003408:	30010737          	lui	a4,0x30010
8000340c:	fdc42783          	lw	a5,-36(s0)
80003410:	0785                	addi	a5,a5,1
80003412:	079a                	slli	a5,a5,0x6
80003414:	97ba                	add	a5,a5,a4
80003416:	439c                	lw	a5,0(a5)
80003418:	fec42703          	lw	a4,-20(s0)
8000341c:	03f00693          	li	a3,63
80003420:	00e69733          	sll	a4,a3,a4
80003424:	fff74713          	not	a4,a4
80003428:	8f7d                	and	a4,a4,a5
8000342a:	fec42783          	lw	a5,-20(s0)
8000342e:	fd442683          	lw	a3,-44(s0)
80003432:	00f697b3          	sll	a5,a3,a5
80003436:	300106b7          	lui	a3,0x30010
8000343a:	8f5d                	or	a4,a4,a5
8000343c:	fdc42783          	lw	a5,-36(s0)
80003440:	0785                	addi	a5,a5,1
80003442:	079a                	slli	a5,a5,0x6
80003444:	97b6                	add	a5,a5,a3
80003446:	c398                	sw	a4,0(a5)
}
80003448:	0001                	nop
8000344a:	5432                	lw	s0,44(sp)
8000344c:	6145                	addi	sp,sp,48
8000344e:	8082                	ret

80003450 <ADCSAR_DeInit>:
/**
  * @brief      ADCSAR   
  * @retval  void
  */
void ADCSAR_DeInit()
{
80003450:	1141                	addi	sp,sp,-16
80003452:	c606                	sw	ra,12(sp)
80003454:	c422                	sw	s0,8(sp)
80003456:	0800                	addi	s0,sp,16
    RCU_ADCSARRstCmd(DISABLE);
80003458:	4501                	li	a0,0
8000345a:	341d                	jal	80002e80 <RCU_ADCSARRstCmd>
    RCU_ADCSARRstCmd(ENABLE);
8000345c:	4505                	li	a0,1
8000345e:	340d                	jal	80002e80 <RCU_ADCSARRstCmd>
}
80003460:	0001                	nop
80003462:	40b2                	lw	ra,12(sp)
80003464:	4422                	lw	s0,8(sp)
80003466:	0141                	addi	sp,sp,16
80003468:	8082                	ret

8000346a <ADCSAR_SEQ_Init>:
  * @param   InitStruct      @ref ADCSAR_SEQ_Init_TypeDef,
  *                         
  * @retval  void
  */
void ADCSAR_SEQ_Init(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_Init_TypeDef* InitStruct)
{
8000346a:	7179                	addi	sp,sp,-48
8000346c:	d606                	sw	ra,44(sp)
8000346e:	d422                	sw	s0,40(sp)
80003470:	1800                	addi	s0,sp,48
80003472:	fca42e23          	sw	a0,-36(s0)
80003476:	fcb42c23          	sw	a1,-40(s0)
    ADCSAR_SEQ_StartEventConfig(SEQ_Num, InitStruct->StartEvent);
8000347a:	fd842783          	lw	a5,-40(s0)
8000347e:	439c                	lw	a5,0(a5)
80003480:	85be                	mv	a1,a5
80003482:	fdc42503          	lw	a0,-36(s0)
80003486:	34bd                	jal	80002ef4 <ADCSAR_SEQ_StartEventConfig>
    ADCSAR_SEQ_SwStartEnCmd(SEQ_Num, InitStruct->SWStartEn);
80003488:	fd842783          	lw	a5,-40(s0)
8000348c:	43dc                	lw	a5,4(a5)
8000348e:	85be                	mv	a1,a5
80003490:	fdc42503          	lw	a0,-36(s0)
80003494:	3c39                	jal	80002eb2 <ADCSAR_SEQ_SwStartEnCmd>
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80003496:	fe042623          	sw	zero,-20(s0)
8000349a:	a01d                	j	800034c0 <ADCSAR_SEQ_Init+0x56>
        ADCSAR_SEQ_ReqConfig(SEQ_Num, (ADCSAR_SEQ_ReqNum_TypeDef)i, InitStruct->Req[i]);
8000349c:	fd842703          	lw	a4,-40(s0)
800034a0:	fec42783          	lw	a5,-20(s0)
800034a4:	078a                	slli	a5,a5,0x2
800034a6:	97ba                	add	a5,a5,a4
800034a8:	479c                	lw	a5,8(a5)
800034aa:	863e                	mv	a2,a5
800034ac:	fec42583          	lw	a1,-20(s0)
800034b0:	fdc42503          	lw	a0,-36(s0)
800034b4:	3d79                	jal	80003352 <ADCSAR_SEQ_ReqConfig>
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
800034b6:	fec42783          	lw	a5,-20(s0)
800034ba:	0785                	addi	a5,a5,1
800034bc:	fef42623          	sw	a5,-20(s0)
800034c0:	fec42703          	lw	a4,-20(s0)
800034c4:	479d                	li	a5,7
800034c6:	fce7fbe3          	bgeu	a5,a4,8000349c <ADCSAR_SEQ_Init+0x32>
    }
    ADCSAR_SEQ_ReqMaxConfig(SEQ_Num, InitStruct->ReqMax);
800034ca:	fd842783          	lw	a5,-40(s0)
800034ce:	579c                	lw	a5,40(a5)
800034d0:	85be                	mv	a1,a5
800034d2:	fdc42503          	lw	a0,-36(s0)
800034d6:	3495                	jal	80002f3a <ADCSAR_SEQ_ReqMaxConfig>
    ADCSAR_SEQ_ReqAverageConfig(SEQ_Num, InitStruct->ReqAverage);
800034d8:	fd842783          	lw	a5,-40(s0)
800034dc:	57dc                	lw	a5,44(a5)
800034de:	85be                	mv	a1,a5
800034e0:	fdc42503          	lw	a0,-36(s0)
800034e4:	3c41                	jal	80002f74 <ADCSAR_SEQ_ReqAverageConfig>
    ADCSAR_SEQ_ReqAverageCmd(SEQ_Num, InitStruct->ReqAverageEn);
800034e6:	fd842783          	lw	a5,-40(s0)
800034ea:	5b9c                	lw	a5,48(a5)
800034ec:	85be                	mv	a1,a5
800034ee:	fdc42503          	lw	a0,-36(s0)
800034f2:	34f1                	jal	80002fbe <ADCSAR_SEQ_ReqAverageCmd>
    ADCSAR_SEQ_RestartConfig(SEQ_Num, InitStruct->RestartCount);
800034f4:	fd842783          	lw	a5,-40(s0)
800034f8:	5bdc                	lw	a5,52(a5)
800034fa:	85be                	mv	a1,a5
800034fc:	fdc42503          	lw	a0,-36(s0)
80003500:	3e95                	jal	80003074 <ADCSAR_SEQ_RestartConfig>
    ADCSAR_SEQ_RestartAverageCmd(SEQ_Num, InitStruct->RestartAverageEn);
80003502:	fd842783          	lw	a5,-40(s0)
80003506:	5f9c                	lw	a5,56(a5)
80003508:	85be                	mv	a1,a5
8000350a:	fdc42503          	lw	a0,-36(s0)
8000350e:	3e51                	jal	800030a2 <ADCSAR_SEQ_RestartAverageCmd>
    ADCSAR_SEQ_SetRestartTimer(SEQ_Num, InitStruct->RestartTimer);
80003510:	fd842783          	lw	a5,-40(s0)
80003514:	5fdc                	lw	a5,60(a5)
80003516:	85be                	mv	a1,a5
80003518:	fdc42503          	lw	a0,-36(s0)
8000351c:	3911                	jal	80003130 <ADCSAR_SEQ_SetRestartTimer>
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
8000351e:	fe042423          	sw	zero,-24(s0)
80003522:	a025                	j	8000354a <ADCSAR_SEQ_Init+0xe0>
        ADCSAR_SEQ_DCEnableCmd(SEQ_Num, (ADCSAR_DC_Num_TypeDef)i, InitStruct->DCEn[i]);
80003524:	fd842703          	lw	a4,-40(s0)
80003528:	fe842783          	lw	a5,-24(s0)
8000352c:	07c1                	addi	a5,a5,16
8000352e:	078a                	slli	a5,a5,0x2
80003530:	97ba                	add	a5,a5,a4
80003532:	439c                	lw	a5,0(a5)
80003534:	863e                	mv	a2,a5
80003536:	fe842583          	lw	a1,-24(s0)
8000353a:	fdc42503          	lw	a0,-36(s0)
8000353e:	3e79                	jal	800030dc <ADCSAR_SEQ_DCEnableCmd>
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
80003540:	fe842783          	lw	a5,-24(s0)
80003544:	0785                	addi	a5,a5,1
80003546:	fef42423          	sw	a5,-24(s0)
8000354a:	fe842703          	lw	a4,-24(s0)
8000354e:	479d                	li	a5,7
80003550:	fce7fae3          	bgeu	a5,a4,80003524 <ADCSAR_SEQ_Init+0xba>
    }
    ADCSAR_SEQ_DMAConfig(SEQ_Num, InitStruct->DMAFIFOLevel);
80003554:	fd842783          	lw	a5,-40(s0)
80003558:	53bc                	lw	a5,96(a5)
8000355a:	85be                	mv	a1,a5
8000355c:	fdc42503          	lw	a0,-36(s0)
80003560:	3c71                	jal	80002ffc <ADCSAR_SEQ_DMAConfig>
    ADCSAR_SEQ_DMACmd(SEQ_Num, InitStruct->DMAEn);
80003562:	fd842783          	lw	a5,-40(s0)
80003566:	53fc                	lw	a5,100(a5)
80003568:	85be                	mv	a1,a5
8000356a:	fdc42503          	lw	a0,-36(s0)
8000356e:	34f1                	jal	8000303a <ADCSAR_SEQ_DMACmd>
}
80003570:	0001                	nop
80003572:	50b2                	lw	ra,44(sp)
80003574:	5422                	lw	s0,40(sp)
80003576:	6145                	addi	sp,sp,48
80003578:	8082                	ret

8000357a <ADCSAR_SEQ_StructInit>:
  * @param   InitStruct      @ref ADCSAR_SEQ_Init_TypeDef,
  *                        
  * @retval  void
  */
void ADCSAR_SEQ_StructInit(ADCSAR_SEQ_Init_TypeDef* InitStruct)
{
8000357a:	7179                	addi	sp,sp,-48
8000357c:	d622                	sw	s0,44(sp)
8000357e:	1800                	addi	s0,sp,48
80003580:	fca42e23          	sw	a0,-36(s0)
    InitStruct->StartEvent = ADCSAR_SEQ_StartEvent_SwReq;
80003584:	fdc42783          	lw	a5,-36(s0)
80003588:	0007a023          	sw	zero,0(a5)
    InitStruct->SWStartEn = DISABLE;
8000358c:	fdc42783          	lw	a5,-36(s0)
80003590:	0007a223          	sw	zero,4(a5)
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80003594:	fe042623          	sw	zero,-20(s0)
80003598:	a831                	j	800035b4 <ADCSAR_SEQ_StructInit+0x3a>
        InitStruct->Req[i] = ADCSAR_CH_Num_0;
8000359a:	fdc42703          	lw	a4,-36(s0)
8000359e:	fec42783          	lw	a5,-20(s0)
800035a2:	078a                	slli	a5,a5,0x2
800035a4:	97ba                	add	a5,a5,a4
800035a6:	0007a423          	sw	zero,8(a5)
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
800035aa:	fec42783          	lw	a5,-20(s0)
800035ae:	0785                	addi	a5,a5,1
800035b0:	fef42623          	sw	a5,-20(s0)
800035b4:	fec42703          	lw	a4,-20(s0)
800035b8:	479d                	li	a5,7
800035ba:	fee7f0e3          	bgeu	a5,a4,8000359a <ADCSAR_SEQ_StructInit+0x20>
    }
    InitStruct->ReqMax = ADCSAR_SEQ_ReqNum_0;
800035be:	fdc42783          	lw	a5,-36(s0)
800035c2:	0207a423          	sw	zero,40(a5)
    InitStruct->ReqAverage = ADCSAR_SEQ_Average_2;
800035c6:	fdc42783          	lw	a5,-36(s0)
800035ca:	4705                	li	a4,1
800035cc:	d7d8                	sw	a4,44(a5)
    InitStruct->ReqAverageEn = DISABLE;
800035ce:	fdc42783          	lw	a5,-36(s0)
800035d2:	0207a823          	sw	zero,48(a5)
    InitStruct->RestartCount = 0;
800035d6:	fdc42783          	lw	a5,-36(s0)
800035da:	0207aa23          	sw	zero,52(a5)
    InitStruct->RestartAverageEn = DISABLE;
800035de:	fdc42783          	lw	a5,-36(s0)
800035e2:	0207ac23          	sw	zero,56(a5)
    InitStruct->RestartTimer = 0;
800035e6:	fdc42783          	lw	a5,-36(s0)
800035ea:	0207ae23          	sw	zero,60(a5)
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
800035ee:	fe042423          	sw	zero,-24(s0)
800035f2:	a839                	j	80003610 <ADCSAR_SEQ_StructInit+0x96>
        InitStruct->DCEn[i] = DISABLE;
800035f4:	fdc42703          	lw	a4,-36(s0)
800035f8:	fe842783          	lw	a5,-24(s0)
800035fc:	07c1                	addi	a5,a5,16
800035fe:	078a                	slli	a5,a5,0x2
80003600:	97ba                	add	a5,a5,a4
80003602:	0007a023          	sw	zero,0(a5)
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
80003606:	fe842783          	lw	a5,-24(s0)
8000360a:	0785                	addi	a5,a5,1
8000360c:	fef42423          	sw	a5,-24(s0)
80003610:	fe842703          	lw	a4,-24(s0)
80003614:	479d                	li	a5,7
80003616:	fce7ffe3          	bgeu	a5,a4,800035f4 <ADCSAR_SEQ_StructInit+0x7a>
    }
    InitStruct->DMAFIFOLevel = ADCSAR_SEQ_DMAFIFOLevel_1;
8000361a:	fdc42783          	lw	a5,-36(s0)
8000361e:	4705                	li	a4,1
80003620:	d3b8                	sw	a4,96(a5)
    InitStruct->DMAEn = DISABLE;
80003622:	fdc42783          	lw	a5,-36(s0)
80003626:	0607a223          	sw	zero,100(a5)
}
8000362a:	0001                	nop
8000362c:	5432                	lw	s0,44(sp)
8000362e:	6145                	addi	sp,sp,48
80003630:	8082                	ret

80003632 <ADCSAR_DC_Init>:
  * @param   InitStruct      @ref ADCSAR_DC_Init_TypeDef,
  *                         
  * @retval  void
  */
void ADCSAR_DC_Init(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Init_TypeDef* InitStruct)
{
80003632:	1101                	addi	sp,sp,-32
80003634:	ce06                	sw	ra,28(sp)
80003636:	cc22                	sw	s0,24(sp)
80003638:	1000                	addi	s0,sp,32
8000363a:	fea42623          	sw	a0,-20(s0)
8000363e:	feb42423          	sw	a1,-24(s0)
    ADCSAR_DC_OutputCmd(DC_Num, InitStruct->DCOutput);
80003642:	fe842783          	lw	a5,-24(s0)
80003646:	439c                	lw	a5,0(a5)
80003648:	85be                	mv	a1,a5
8000364a:	fec42503          	lw	a0,-20(s0)
8000364e:	3615                	jal	80003172 <ADCSAR_DC_OutputCmd>
    ADCSAR_DC_SetThresholdLow(DC_Num, InitStruct->ThresholdLow);
80003650:	fe842783          	lw	a5,-24(s0)
80003654:	43dc                	lw	a5,4(a5)
80003656:	85be                	mv	a1,a5
80003658:	fec42503          	lw	a0,-20(s0)
8000365c:	3991                	jal	800032b0 <ADCSAR_DC_SetThresholdLow>
    ADCSAR_DC_SetThresholdHigh(DC_Num, InitStruct->ThresholdHigh);
8000365e:	fe842783          	lw	a5,-24(s0)
80003662:	479c                	lw	a5,8(a5)
80003664:	85be                	mv	a1,a5
80003666:	fec42503          	lw	a0,-20(s0)
8000366a:	3951                	jal	800032fe <ADCSAR_DC_SetThresholdHigh>
    ADCSAR_DC_SourceConfig(DC_Num, InitStruct->Source);
8000366c:	fe842783          	lw	a5,-24(s0)
80003670:	47dc                	lw	a5,12(a5)
80003672:	85be                	mv	a1,a5
80003674:	fec42503          	lw	a0,-20(s0)
80003678:	3689                	jal	800031ba <ADCSAR_DC_SourceConfig>
    ADCSAR_DC_ChannelConfig(DC_Num, InitStruct->Channel);
8000367a:	fe842783          	lw	a5,-24(s0)
8000367e:	4b9c                	lw	a5,16(a5)
80003680:	85be                	mv	a1,a5
80003682:	fec42503          	lw	a0,-20(s0)
80003686:	3ebd                	jal	80003204 <ADCSAR_DC_ChannelConfig>
    ADCSAR_DC_Config(DC_Num, InitStruct->Mode, InitStruct->Condition);
80003688:	fe842783          	lw	a5,-24(s0)
8000368c:	4bd8                	lw	a4,20(a5)
8000368e:	fe842783          	lw	a5,-24(s0)
80003692:	4f9c                	lw	a5,24(a5)
80003694:	863e                	mv	a2,a5
80003696:	85ba                	mv	a1,a4
80003698:	fec42503          	lw	a0,-20(s0)
8000369c:	3e4d                	jal	8000324e <ADCSAR_DC_Config>
}
8000369e:	0001                	nop
800036a0:	40f2                	lw	ra,28(sp)
800036a2:	4462                	lw	s0,24(sp)
800036a4:	6105                	addi	sp,sp,32
800036a6:	8082                	ret

800036a8 <ADCSAR_DC_StructInit>:
  * @param   InitStruct      @ref ADCSAR_DC_Init_TypeDef,
  *                        
  * @retval  void
  */
void ADCSAR_DC_StructInit(ADCSAR_DC_Init_TypeDef* InitStruct)
{
800036a8:	1101                	addi	sp,sp,-32
800036aa:	ce22                	sw	s0,28(sp)
800036ac:	1000                	addi	s0,sp,32
800036ae:	fea42623          	sw	a0,-20(s0)
    InitStruct->DCOutput = DISABLE;
800036b2:	fec42783          	lw	a5,-20(s0)
800036b6:	0007a023          	sw	zero,0(a5)
    InitStruct->ThresholdLow = 0;
800036ba:	fec42783          	lw	a5,-20(s0)
800036be:	0007a223          	sw	zero,4(a5)
    InitStruct->ThresholdHigh = 0;
800036c2:	fec42783          	lw	a5,-20(s0)
800036c6:	0007a423          	sw	zero,8(a5)
    InitStruct->Source = ADCSAR_DC_Source_EOC;
800036ca:	fec42783          	lw	a5,-20(s0)
800036ce:	0007a623          	sw	zero,12(a5)
    InitStruct->Channel = ADCSAR_CH_Num_0;
800036d2:	fec42783          	lw	a5,-20(s0)
800036d6:	0007a823          	sw	zero,16(a5)
    InitStruct->Mode = ADCSAR_DC_Mode_Multiple;
800036da:	fec42783          	lw	a5,-20(s0)
800036de:	0007aa23          	sw	zero,20(a5)
    InitStruct->Condition = ADCSAR_DC_Condition_Low;
800036e2:	fec42783          	lw	a5,-20(s0)
800036e6:	0007ac23          	sw	zero,24(a5)
}
800036ea:	0001                	nop
800036ec:	4472                	lw	s0,28(sp)
800036ee:	6105                	addi	sp,sp,32
800036f0:	8082                	ret

800036f2 <RCU_ADCSDRstCmd>:
  * @brief   C   -
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void RCU_ADCSDRstCmd(FunctionalState State)
{
800036f2:	1101                	addi	sp,sp,-32
800036f4:	ce22                	sw	s0,28(sp)
800036f6:	1000                	addi	s0,sp,32
800036f8:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(RCU->ADCSDCLKCFG_bit.RSTDIS, State);
800036fc:	3000e7b7          	lui	a5,0x3000e
80003700:	fec42703          	lw	a4,-20(s0)
80003704:	8b05                	andi	a4,a4,1
80003706:	0ff77713          	zext.b	a4,a4
8000370a:	8b05                	andi	a4,a4,1
8000370c:	0722                	slli	a4,a4,0x8
8000370e:	0b47a683          	lw	a3,180(a5) # 3000e0b4 <STACK_SIZE+0x3000d8b4>
80003712:	eff6f693          	andi	a3,a3,-257
80003716:	8f55                	or	a4,a4,a3
80003718:	0ae7aa23          	sw	a4,180(a5)
}
8000371c:	0001                	nop
8000371e:	4472                	lw	s0,28(sp)
80003720:	6105                	addi	sp,sp,32
80003722:	8082                	ret

80003724 <ADCSD_WaitCycleCmd>:
  * @brief        -
  * @param   waitClkAmount   
  * @retval  void
  */
__STATIC_INLINE void ADCSD_WaitCycleCmd(uint32_t WaitCycle)
{
80003724:	1101                	addi	sp,sp,-32
80003726:	ce22                	sw	s0,28(sp)
80003728:	1000                	addi	s0,sp,32
8000372a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_WTCYC(WaitCycle));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_WTCYC_Msk, WaitCycle << ADCSD_CTRL_WTCYC_Pos);
8000372e:	300127b7          	lui	a5,0x30012
80003732:	4398                	lw	a4,0(a5)
80003734:	fff907b7          	lui	a5,0xfff90
80003738:	17fd                	addi	a5,a5,-1 # fff8ffff <__data_source_start+0x7ff88e87>
8000373a:	00f776b3          	and	a3,a4,a5
8000373e:	fec42783          	lw	a5,-20(s0)
80003742:	01079713          	slli	a4,a5,0x10
80003746:	300127b7          	lui	a5,0x30012
8000374a:	8f55                	or	a4,a4,a3
8000374c:	c398                	sw	a4,0(a5)
}
8000374e:	0001                	nop
80003750:	4472                	lw	s0,28(sp)
80003752:	6105                	addi	sp,sp,32
80003754:	8082                	ret

80003756 <ADCSD_MainDivCmd>:
  * @brief        -
  * @param   mainDiv    
  * @retval  void
  */
__STATIC_INLINE void ADCSD_MainDivCmd(uint32_t mainDiv)
{
80003756:	1101                	addi	sp,sp,-32
80003758:	ce22                	sw	s0,28(sp)
8000375a:	1000                	addi	s0,sp,32
8000375c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_MDC(mainDiv));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_MDC_Msk, mainDiv << ADCSD_CTRL_MDC_Pos);
80003760:	300127b7          	lui	a5,0x30012
80003764:	4398                	lw	a4,0(a5)
80003766:	77e5                	lui	a5,0xffff9
80003768:	17fd                	addi	a5,a5,-1 # ffff8fff <__data_source_start+0x7fff1e87>
8000376a:	00f776b3          	and	a3,a4,a5
8000376e:	fec42783          	lw	a5,-20(s0)
80003772:	00c79713          	slli	a4,a5,0xc
80003776:	300127b7          	lui	a5,0x30012
8000377a:	8f55                	or	a4,a4,a3
8000377c:	c398                	sw	a4,0(a5)
}
8000377e:	0001                	nop
80003780:	4472                	lw	s0,28(sp)
80003782:	6105                	addi	sp,sp,32
80003784:	8082                	ret

80003786 <ADCSD_SampleDivCmd>:
  * @brief        -
  * @param   sampleDiv    
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SampleDivCmd(uint32_t sampleDiv)
{
80003786:	1101                	addi	sp,sp,-32
80003788:	ce22                	sw	s0,28(sp)
8000378a:	1000                	addi	s0,sp,32
8000378c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_DR(sampleDiv));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_DR_Msk, sampleDiv << ADCSD_CTRL_DR_Pos);
80003790:	300127b7          	lui	a5,0x30012
80003794:	439c                	lw	a5,0(a5)
80003796:	cff7f693          	andi	a3,a5,-769
8000379a:	fec42783          	lw	a5,-20(s0)
8000379e:	00879713          	slli	a4,a5,0x8
800037a2:	300127b7          	lui	a5,0x30012
800037a6:	8f55                	or	a4,a4,a3
800037a8:	c398                	sw	a4,0(a5)
}
800037aa:	0001                	nop
800037ac:	4472                	lw	s0,28(sp)
800037ae:	6105                	addi	sp,sp,32
800037b0:	8082                	ret

800037b2 <ADCSD_SetMode>:
  * @param   ch_num   
  * @param   mode  
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SetMode(ADCSD_CH_Num_TypeDef ch_num, ADCSD_MODE_TypeDef mode)
{
800037b2:	1101                	addi	sp,sp,-32
800037b4:	ce22                	sw	s0,28(sp)
800037b6:	1000                	addi	s0,sp,32
800037b8:	fea42623          	sw	a0,-20(s0)
800037bc:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_ADCSD_CH_NUM(ch_num));
	assert_param(IS_ADCSD_MODE(mode));

	MODIFY_REG(ADCSD->MODE, ADCSD_MODE_CH0_Msk << ((uint32_t)ch_num << 2), mode << ((uint32_t)ch_num << 2));
800037c0:	300127b7          	lui	a5,0x30012
800037c4:	43d8                	lw	a4,4(a5)
800037c6:	fec42783          	lw	a5,-20(s0)
800037ca:	078a                	slli	a5,a5,0x2
800037cc:	468d                	li	a3,3
800037ce:	00f697b3          	sll	a5,a3,a5
800037d2:	fff7c793          	not	a5,a5
800037d6:	00f776b3          	and	a3,a4,a5
800037da:	fec42783          	lw	a5,-20(s0)
800037de:	078a                	slli	a5,a5,0x2
800037e0:	fe842703          	lw	a4,-24(s0)
800037e4:	00f71733          	sll	a4,a4,a5
800037e8:	300127b7          	lui	a5,0x30012
800037ec:	8f55                	or	a4,a4,a3
800037ee:	c3d8                	sw	a4,4(a5)
}
800037f0:	0001                	nop
800037f2:	4472                	lw	s0,28(sp)
800037f4:	6105                	addi	sp,sp,32
800037f6:	8082                	ret

800037f8 <ADCSD_SetAmplification>:
  * @param   ch_num    -
  * @param 	 ampl   
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SetAmplification(ADCSD_CH_Num_TypeDef ch_num, ADCSD_AMPL_TypeDef ampl)
{
800037f8:	1101                	addi	sp,sp,-32
800037fa:	ce22                	sw	s0,28(sp)
800037fc:	1000                	addi	s0,sp,32
800037fe:	fea42623          	sw	a0,-20(s0)
80003802:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_ADCSD_CH_NUM(ch_num));
	assert_param(IS_ADCSD_AMPL(ampl));

	MODIFY_REG(ADCSD->AMPL, ADCSD_AMPL_CH0_Msk << ((uint32_t)ch_num << 2), (uint32_t)ampl << ((uint32_t)ch_num << 2));
80003806:	300127b7          	lui	a5,0x30012
8000380a:	4798                	lw	a4,8(a5)
8000380c:	fec42783          	lw	a5,-20(s0)
80003810:	078a                	slli	a5,a5,0x2
80003812:	469d                	li	a3,7
80003814:	00f697b3          	sll	a5,a3,a5
80003818:	fff7c793          	not	a5,a5
8000381c:	00f776b3          	and	a3,a4,a5
80003820:	fec42783          	lw	a5,-20(s0)
80003824:	078a                	slli	a5,a5,0x2
80003826:	fe842703          	lw	a4,-24(s0)
8000382a:	00f71733          	sll	a4,a4,a5
8000382e:	300127b7          	lui	a5,0x30012
80003832:	8f55                	or	a4,a4,a3
80003834:	c798                	sw	a4,8(a5)
}
80003836:	0001                	nop
80003838:	4472                	lw	s0,28(sp)
8000383a:	6105                	addi	sp,sp,32
8000383c:	8082                	ret

8000383e <ADCSD_DeInit>:
/**
  * @brief      ADCSD   
  * @retval  void
  */
void ADCSD_DeInit(void)
{
8000383e:	1141                	addi	sp,sp,-16
80003840:	c606                	sw	ra,12(sp)
80003842:	c422                	sw	s0,8(sp)
80003844:	0800                	addi	s0,sp,16
    RCU_ADCSDRstCmd(DISABLE);
80003846:	4501                	li	a0,0
80003848:	356d                	jal	800036f2 <RCU_ADCSDRstCmd>
    RCU_ADCSDRstCmd(ENABLE);
8000384a:	4505                	li	a0,1
8000384c:	355d                	jal	800036f2 <RCU_ADCSDRstCmd>
}
8000384e:	0001                	nop
80003850:	40b2                	lw	ra,12(sp)
80003852:	4422                	lw	s0,8(sp)
80003854:	0141                	addi	sp,sp,16
80003856:	8082                	ret

80003858 <ADCSD_Init>:
  * @param   InitStruct      @ref ADCSD_Init_TypeDef,
  *                         
  * @retval  void
  */
void ADCSD_Init(ADCSD_Init_TypeDef* InitStruct)
{
80003858:	1101                	addi	sp,sp,-32
8000385a:	ce06                	sw	ra,28(sp)
8000385c:	cc22                	sw	s0,24(sp)
8000385e:	1000                	addi	s0,sp,32
80003860:	fea42623          	sw	a0,-20(s0)
	ADCSD_WaitCycleCmd(InitStruct->WaitCycle);
80003864:	fec42783          	lw	a5,-20(s0)
80003868:	439c                	lw	a5,0(a5)
8000386a:	853e                	mv	a0,a5
8000386c:	3d65                	jal	80003724 <ADCSD_WaitCycleCmd>
	ADCSD_MainDivCmd(InitStruct->MainDiv);
8000386e:	fec42783          	lw	a5,-20(s0)
80003872:	43dc                	lw	a5,4(a5)
80003874:	853e                	mv	a0,a5
80003876:	35c5                	jal	80003756 <ADCSD_MainDivCmd>
	ADCSD_SampleDivCmd(InitStruct->SampleDiv);
80003878:	fec42783          	lw	a5,-20(s0)
8000387c:	479c                	lw	a5,8(a5)
8000387e:	853e                	mv	a0,a5
80003880:	3719                	jal	80003786 <ADCSD_SampleDivCmd>
}
80003882:	0001                	nop
80003884:	40f2                	lw	ra,28(sp)
80003886:	4462                	lw	s0,24(sp)
80003888:	6105                	addi	sp,sp,32
8000388a:	8082                	ret

8000388c <ADCSD_StructInit>:
  * @param   InitStruct      @ref ADCSD_Init_TypeDef,
  *                        
  * @retval  void
  */
void ADCSD_StructInit(ADCSD_Init_TypeDef* InitStruct)
{
8000388c:	1101                	addi	sp,sp,-32
8000388e:	ce22                	sw	s0,28(sp)
80003890:	1000                	addi	s0,sp,32
80003892:	fea42623          	sw	a0,-20(s0)
	InitStruct->MainDiv = 0x0;
80003896:	fec42783          	lw	a5,-20(s0)
8000389a:	0007a223          	sw	zero,4(a5) # 30012004 <STACK_SIZE+0x30011804>
	InitStruct->SampleDiv = 0x0;
8000389e:	fec42783          	lw	a5,-20(s0)
800038a2:	0007a423          	sw	zero,8(a5)
	InitStruct->WaitCycle = 0x0;
800038a6:	fec42783          	lw	a5,-20(s0)
800038aa:	0007a023          	sw	zero,0(a5)
}
800038ae:	0001                	nop
800038b0:	4472                	lw	s0,28(sp)
800038b2:	6105                	addi	sp,sp,32
800038b4:	8082                	ret

800038b6 <ADCSD_CH_Init>:
  * @param   InitStruct      @ref ADCSD_CH_Init_TypeDef,
  *                         
  * @retval  void
  */
void ADCSD_CH_Init(ADCSD_CH_Num_TypeDef ch_num, ADCSD_CH_Init_TypeDef* InitStruct)
{
800038b6:	1101                	addi	sp,sp,-32
800038b8:	ce06                	sw	ra,28(sp)
800038ba:	cc22                	sw	s0,24(sp)
800038bc:	1000                	addi	s0,sp,32
800038be:	fea42623          	sw	a0,-20(s0)
800038c2:	feb42423          	sw	a1,-24(s0)
	ADCSD_SetMode(ch_num, InitStruct->Mode);
800038c6:	fe842783          	lw	a5,-24(s0)
800038ca:	439c                	lw	a5,0(a5)
800038cc:	85be                	mv	a1,a5
800038ce:	fec42503          	lw	a0,-20(s0)
800038d2:	35c5                	jal	800037b2 <ADCSD_SetMode>
	ADCSD_SetAmplification(ch_num, InitStruct->Amplifier);
800038d4:	fe842783          	lw	a5,-24(s0)
800038d8:	43dc                	lw	a5,4(a5)
800038da:	85be                	mv	a1,a5
800038dc:	fec42503          	lw	a0,-20(s0)
800038e0:	3f21                	jal	800037f8 <ADCSD_SetAmplification>
}
800038e2:	0001                	nop
800038e4:	40f2                	lw	ra,28(sp)
800038e6:	4462                	lw	s0,24(sp)
800038e8:	6105                	addi	sp,sp,32
800038ea:	8082                	ret

800038ec <ADCSD_CH_StructInit>:
  * @param   InitStruct      @ref ADCSD_CH_Init_TypeDef,
  *                        
  * @retval  void
  */
void ADCSD_CH_StructInit(ADCSD_CH_Init_TypeDef* InitStruct)
{
800038ec:	1101                	addi	sp,sp,-32
800038ee:	ce22                	sw	s0,28(sp)
800038f0:	1000                	addi	s0,sp,32
800038f2:	fea42623          	sw	a0,-20(s0)
	InitStruct->Amplifier = 0x0;
800038f6:	fec42783          	lw	a5,-20(s0)
800038fa:	0007a223          	sw	zero,4(a5)
	InitStruct->Mode = 0x1;
800038fe:	fec42783          	lw	a5,-20(s0)
80003902:	4705                	li	a4,1
80003904:	c398                	sw	a4,0(a5)
}
80003906:	0001                	nop
80003908:	4472                	lw	s0,28(sp)
8000390a:	6105                	addi	sp,sp,32
8000390c:	8082                	ret

8000390e <RCU_AHBRstCmd>:
{
8000390e:	1101                	addi	sp,sp,-32
80003910:	ce22                	sw	s0,28(sp)
80003912:	1000                	addi	s0,sp,32
80003914:	fea42623          	sw	a0,-20(s0)
80003918:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
8000391c:	3000e7b7          	lui	a5,0x3000e
80003920:	4b98                	lw	a4,16(a5)
80003922:	fec42783          	lw	a5,-20(s0)
80003926:	fff7c793          	not	a5,a5
8000392a:	00f776b3          	and	a3,a4,a5
8000392e:	fe842783          	lw	a5,-24(s0)
80003932:	c781                	beqz	a5,8000393a <RCU_AHBRstCmd+0x2c>
80003934:	fec42783          	lw	a5,-20(s0)
80003938:	a011                	j	8000393c <RCU_AHBRstCmd+0x2e>
8000393a:	4781                	li	a5,0
8000393c:	3000e737          	lui	a4,0x3000e
80003940:	8fd5                	or	a5,a5,a3
80003942:	cb1c                	sw	a5,16(a4)
}
80003944:	0001                	nop
80003946:	4472                	lw	s0,28(sp)
80003948:	6105                	addi	sp,sp,32
8000394a:	8082                	ret

8000394c <CRC_ResetCmd>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void CRC_ResetCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
8000394c:	1101                	addi	sp,sp,-32
8000394e:	ce22                	sw	s0,28(sp)
80003950:	1000                	addi	s0,sp,32
80003952:	fea42623          	sw	a0,-20(s0)
80003956:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_RESET_Msk, state << CRC_CR_RESET_Pos);
8000395a:	fec42783          	lw	a5,-20(s0)
8000395e:	47dc                	lw	a5,12(a5)
80003960:	ffe7f713          	andi	a4,a5,-2
80003964:	fe842783          	lw	a5,-24(s0)
80003968:	8f5d                	or	a4,a4,a5
8000396a:	fec42783          	lw	a5,-20(s0)
8000396e:	c7d8                	sw	a4,12(a5)
}
80003970:	0001                	nop
80003972:	4472                	lw	s0,28(sp)
80003974:	6105                	addi	sp,sp,32
80003976:	8082                	ret

80003978 <CRC_ModeCmd>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void CRC_ModeCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
80003978:	1101                	addi	sp,sp,-32
8000397a:	ce22                	sw	s0,28(sp)
8000397c:	1000                	addi	s0,sp,32
8000397e:	fea42623          	sw	a0,-20(s0)
80003982:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_MODE_Msk, state << CRC_CR_MODE_Pos);
80003986:	fec42783          	lw	a5,-20(s0)
8000398a:	47dc                	lw	a5,12(a5)
8000398c:	ffd7f713          	andi	a4,a5,-3
80003990:	fe842783          	lw	a5,-24(s0)
80003994:	0786                	slli	a5,a5,0x1
80003996:	8f5d                	or	a4,a4,a5
80003998:	fec42783          	lw	a5,-20(s0)
8000399c:	c7d8                	sw	a4,12(a5)
}
8000399e:	0001                	nop
800039a0:	4472                	lw	s0,28(sp)
800039a2:	6105                	addi	sp,sp,32
800039a4:	8082                	ret

800039a6 <CRC_XOROutCmd>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void CRC_XOROutCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
800039a6:	1101                	addi	sp,sp,-32
800039a8:	ce22                	sw	s0,28(sp)
800039aa:	1000                	addi	s0,sp,32
800039ac:	fea42623          	sw	a0,-20(s0)
800039b0:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_XOROUT_Msk, state << CRC_CR_XOROUT_Pos);
800039b4:	fec42783          	lw	a5,-20(s0)
800039b8:	47dc                	lw	a5,12(a5)
800039ba:	ffb7f713          	andi	a4,a5,-5
800039be:	fe842783          	lw	a5,-24(s0)
800039c2:	078a                	slli	a5,a5,0x2
800039c4:	8f5d                	or	a4,a4,a5
800039c6:	fec42783          	lw	a5,-20(s0)
800039ca:	c7d8                	sw	a4,12(a5)
}
800039cc:	0001                	nop
800039ce:	4472                	lw	s0,28(sp)
800039d0:	6105                	addi	sp,sp,32
800039d2:	8082                	ret

800039d4 <CRC_SetPolysize>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param   polysize   
  * @retval  void
  */
__STATIC_INLINE void CRC_SetPolysize(CRC_TypeDef* CRCx, CRC_POLYSIZE_TypeDef polysize)
{
800039d4:	1101                	addi	sp,sp,-32
800039d6:	ce22                	sw	s0,28(sp)
800039d8:	1000                	addi	s0,sp,32
800039da:	fea42623          	sw	a0,-20(s0)
800039de:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_CRC_POLYSIZE(polysize));

	MODIFY_REG(CRCx->CR, CRC_CR_POLYSIZE_Msk, polysize << CRC_CR_POLYSIZE_Pos);
800039e2:	fec42783          	lw	a5,-20(s0)
800039e6:	47dc                	lw	a5,12(a5)
800039e8:	fe77f713          	andi	a4,a5,-25
800039ec:	fe842783          	lw	a5,-24(s0)
800039f0:	078e                	slli	a5,a5,0x3
800039f2:	8f5d                	or	a4,a4,a5
800039f4:	fec42783          	lw	a5,-20(s0)
800039f8:	c7d8                	sw	a4,12(a5)
}
800039fa:	0001                	nop
800039fc:	4472                	lw	s0,28(sp)
800039fe:	6105                	addi	sp,sp,32
80003a00:	8082                	ret

80003a02 <CRC_SetRevIn>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param   revin   
  * @retval  void
  */
__STATIC_INLINE void CRC_SetRevIn(CRC_TypeDef* CRCx, CRC_REV_IN_TypeDef revin)
{
80003a02:	1101                	addi	sp,sp,-32
80003a04:	ce22                	sw	s0,28(sp)
80003a06:	1000                	addi	s0,sp,32
80003a08:	fea42623          	sw	a0,-20(s0)
80003a0c:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_CRC_REV_IN(revin));

	MODIFY_REG(CRCx->CR, CRC_CR_REV_IN_Msk, revin << CRC_CR_REV_IN_Pos);
80003a10:	fec42783          	lw	a5,-20(s0)
80003a14:	47dc                	lw	a5,12(a5)
80003a16:	f9f7f713          	andi	a4,a5,-97
80003a1a:	fe842783          	lw	a5,-24(s0)
80003a1e:	0796                	slli	a5,a5,0x5
80003a20:	8f5d                	or	a4,a4,a5
80003a22:	fec42783          	lw	a5,-20(s0)
80003a26:	c7d8                	sw	a4,12(a5)
}
80003a28:	0001                	nop
80003a2a:	4472                	lw	s0,28(sp)
80003a2c:	6105                	addi	sp,sp,32
80003a2e:	8082                	ret

80003a30 <CRC_RevOutCmd>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param	 state    
  * @retval  void
  */
__STATIC_INLINE void CRC_RevOutCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
80003a30:	1101                	addi	sp,sp,-32
80003a32:	ce22                	sw	s0,28(sp)
80003a34:	1000                	addi	s0,sp,32
80003a36:	fea42623          	sw	a0,-20(s0)
80003a3a:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_REV_OUT_Msk, state << CRC_CR_REV_OUT_Pos);
80003a3e:	fec42783          	lw	a5,-20(s0)
80003a42:	47dc                	lw	a5,12(a5)
80003a44:	f7f7f713          	andi	a4,a5,-129
80003a48:	fe842783          	lw	a5,-24(s0)
80003a4c:	079e                	slli	a5,a5,0x7
80003a4e:	8f5d                	or	a4,a4,a5
80003a50:	fec42783          	lw	a5,-20(s0)
80003a54:	c7d8                	sw	a4,12(a5)
}
80003a56:	0001                	nop
80003a58:	4472                	lw	s0,28(sp)
80003a5a:	6105                	addi	sp,sp,32
80003a5c:	8082                	ret

80003a5e <CRC_SetInit>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param   val   
  * @retval  void
  */
__STATIC_INLINE void CRC_SetInit(CRC_TypeDef* CRCx, uint32_t val)
{
80003a5e:	1101                	addi	sp,sp,-32
80003a60:	ce22                	sw	s0,28(sp)
80003a62:	1000                	addi	s0,sp,32
80003a64:	fea42623          	sw	a0,-20(s0)
80003a68:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	WRITE_REG(CRCx->INIT, val);
80003a6c:	fec42783          	lw	a5,-20(s0)
80003a70:	fe842703          	lw	a4,-24(s0)
80003a74:	cb98                	sw	a4,16(a5)
}
80003a76:	0001                	nop
80003a78:	4472                	lw	s0,28(sp)
80003a7a:	6105                	addi	sp,sp,32
80003a7c:	8082                	ret

80003a7e <CRC_SetPol>:
  * @param	 CRCx   CRC,  x = 0 | 1
  * @param   val    
  * @retval  void
  */
__STATIC_INLINE void CRC_SetPol(CRC_TypeDef* CRCx, uint32_t val)
{
80003a7e:	1101                	addi	sp,sp,-32
80003a80:	ce22                	sw	s0,28(sp)
80003a82:	1000                	addi	s0,sp,32
80003a84:	fea42623          	sw	a0,-20(s0)
80003a88:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	WRITE_REG(CRCx->POL, val);
80003a8c:	fec42783          	lw	a5,-20(s0)
80003a90:	fe842703          	lw	a4,-24(s0)
80003a94:	cbd8                	sw	a4,20(a5)
}
80003a96:	0001                	nop
80003a98:	4472                	lw	s0,28(sp)
80003a9a:	6105                	addi	sp,sp,32
80003a9c:	8082                	ret

80003a9e <CRC_DeInit>:
/**
  * @brief      CRC   
  * @retval  void
  */
void CRC_DeInit(CRC_TypeDef* CRCx)
{
80003a9e:	7179                	addi	sp,sp,-48
80003aa0:	d606                	sw	ra,44(sp)
80003aa2:	d422                	sw	s0,40(sp)
80003aa4:	1800                	addi	s0,sp,48
80003aa6:	fca42e23          	sw	a0,-36(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	CRC_ResetCmd(CRCx, ENABLE);
80003aaa:	4585                	li	a1,1
80003aac:	fdc42503          	lw	a0,-36(s0)
80003ab0:	3d71                	jal	8000394c <CRC_ResetCmd>
	CRC_ResetCmd(CRCx, DISABLE);
80003ab2:	4581                	li	a1,0
80003ab4:	fdc42503          	lw	a0,-36(s0)
80003ab8:	3d51                	jal	8000394c <CRC_ResetCmd>
	uint32_t CRC_num = (CRCx == CRC0) ? RCU_AHBRst_CRC0 : RCU_AHBRst_CRC1;
80003aba:	fdc42703          	lw	a4,-36(s0)
80003abe:	200307b7          	lui	a5,0x20030
80003ac2:	00f71463          	bne	a4,a5,80003aca <CRC_DeInit+0x2c>
80003ac6:	6785                	lui	a5,0x1
80003ac8:	a011                	j	80003acc <CRC_DeInit+0x2e>
80003aca:	6789                	lui	a5,0x2
80003acc:	fef42623          	sw	a5,-20(s0)
    RCU_AHBRstCmd(CRC_num, DISABLE);
80003ad0:	4581                	li	a1,0
80003ad2:	fec42503          	lw	a0,-20(s0)
80003ad6:	3d25                	jal	8000390e <RCU_AHBRstCmd>
    RCU_AHBRstCmd(CRC_num, ENABLE);
80003ad8:	4585                	li	a1,1
80003ada:	fec42503          	lw	a0,-20(s0)
80003ade:	3d05                	jal	8000390e <RCU_AHBRstCmd>
}
80003ae0:	0001                	nop
80003ae2:	50b2                	lw	ra,44(sp)
80003ae4:	5422                	lw	s0,40(sp)
80003ae6:	6145                	addi	sp,sp,48
80003ae8:	8082                	ret

80003aea <CRC_Init>:
  * @param   InitStruct      @ref CRC_Init_TypeDef,
  *                         
  * @retval  void
  */
void CRC_Init(CRC_TypeDef* CRCx, CRC_Init_TypeDef* InitStruct)
{
80003aea:	1101                	addi	sp,sp,-32
80003aec:	ce06                	sw	ra,28(sp)
80003aee:	cc22                	sw	s0,24(sp)
80003af0:	1000                	addi	s0,sp,32
80003af2:	fea42623          	sw	a0,-20(s0)
80003af6:	feb42423          	sw	a1,-24(s0)
	CRC_SetInit(CRCx, InitStruct->Init);
80003afa:	fe842783          	lw	a5,-24(s0)
80003afe:	439c                	lw	a5,0(a5)
80003b00:	85be                	mv	a1,a5
80003b02:	fec42503          	lw	a0,-20(s0)
80003b06:	3fa1                	jal	80003a5e <CRC_SetInit>
	CRC_SetRevIn(CRCx, InitStruct->RevIn);
80003b08:	fe842783          	lw	a5,-24(s0)
80003b0c:	43dc                	lw	a5,4(a5)
80003b0e:	85be                	mv	a1,a5
80003b10:	fec42503          	lw	a0,-20(s0)
80003b14:	35fd                	jal	80003a02 <CRC_SetRevIn>
	CRC_RevOutCmd(CRCx, InitStruct->RevOut);
80003b16:	fe842783          	lw	a5,-24(s0)
80003b1a:	479c                	lw	a5,8(a5)
80003b1c:	85be                	mv	a1,a5
80003b1e:	fec42503          	lw	a0,-20(s0)
80003b22:	3739                	jal	80003a30 <CRC_RevOutCmd>
	CRC_ModeCmd(CRCx, InitStruct->Mode);
80003b24:	fe842783          	lw	a5,-24(s0)
80003b28:	47dc                	lw	a5,12(a5)
80003b2a:	85be                	mv	a1,a5
80003b2c:	fec42503          	lw	a0,-20(s0)
80003b30:	35a1                	jal	80003978 <CRC_ModeCmd>
	CRC_XOROutCmd(CRCx, InitStruct->XorOut);
80003b32:	fe842783          	lw	a5,-24(s0)
80003b36:	4b9c                	lw	a5,16(a5)
80003b38:	85be                	mv	a1,a5
80003b3a:	fec42503          	lw	a0,-20(s0)
80003b3e:	35a5                	jal	800039a6 <CRC_XOROutCmd>
	CRC_SetPolysize(CRCx, InitStruct->Polysize);
80003b40:	fe842783          	lw	a5,-24(s0)
80003b44:	4bdc                	lw	a5,20(a5)
80003b46:	85be                	mv	a1,a5
80003b48:	fec42503          	lw	a0,-20(s0)
80003b4c:	3561                	jal	800039d4 <CRC_SetPolysize>
	CRC_SetPol(CRCx, InitStruct->Pol);
80003b4e:	fe842783          	lw	a5,-24(s0)
80003b52:	4f9c                	lw	a5,24(a5)
80003b54:	85be                	mv	a1,a5
80003b56:	fec42503          	lw	a0,-20(s0)
80003b5a:	3715                	jal	80003a7e <CRC_SetPol>
}
80003b5c:	0001                	nop
80003b5e:	40f2                	lw	ra,28(sp)
80003b60:	4462                	lw	s0,24(sp)
80003b62:	6105                	addi	sp,sp,32
80003b64:	8082                	ret

80003b66 <CRC_StructInit>:
  * @param   InitStruct      @ref CRC_Init_TypeDef,
  *                        
  * @retval  void
  */
void CRC_StructInit(CRC_Init_TypeDef* InitStruct)
{
80003b66:	1101                	addi	sp,sp,-32
80003b68:	ce22                	sw	s0,28(sp)
80003b6a:	1000                	addi	s0,sp,32
80003b6c:	fea42623          	sw	a0,-20(s0)
	InitStruct->Init = 0x0;
80003b70:	fec42783          	lw	a5,-20(s0)
80003b74:	0007a023          	sw	zero,0(a5) # 2000 <STACK_SIZE+0x1800>
	InitStruct->RevIn = 0x0;
80003b78:	fec42783          	lw	a5,-20(s0)
80003b7c:	0007a223          	sw	zero,4(a5)
	InitStruct->RevOut = 0x0;
80003b80:	fec42783          	lw	a5,-20(s0)
80003b84:	0007a423          	sw	zero,8(a5)
	InitStruct->Mode = 0x0;
80003b88:	fec42783          	lw	a5,-20(s0)
80003b8c:	0007a623          	sw	zero,12(a5)
	InitStruct->XorOut = 0x0;
80003b90:	fec42783          	lw	a5,-20(s0)
80003b94:	0007a823          	sw	zero,16(a5)
	InitStruct->Polysize = 0x0;
80003b98:	fec42783          	lw	a5,-20(s0)
80003b9c:	0007aa23          	sw	zero,20(a5)
	InitStruct->Pol = 0x4C11DB7;	// CRC-32 (Ethernet)
80003ba0:	fec42783          	lw	a5,-20(s0)
80003ba4:	04c12737          	lui	a4,0x4c12
80003ba8:	db770713          	addi	a4,a4,-585 # 4c11db7 <STACK_SIZE+0x4c115b7>
80003bac:	cf98                	sw	a4,24(a5)
}
80003bae:	0001                	nop
80003bb0:	4472                	lw	s0,28(sp)
80003bb2:	6105                	addi	sp,sp,32
80003bb4:	8082                	ret

80003bb6 <RCU_AHBRstCmd>:
{
80003bb6:	1101                	addi	sp,sp,-32
80003bb8:	ce22                	sw	s0,28(sp)
80003bba:	1000                	addi	s0,sp,32
80003bbc:	fea42623          	sw	a0,-20(s0)
80003bc0:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80003bc4:	3000e7b7          	lui	a5,0x3000e
80003bc8:	4b98                	lw	a4,16(a5)
80003bca:	fec42783          	lw	a5,-20(s0)
80003bce:	fff7c793          	not	a5,a5
80003bd2:	00f776b3          	and	a3,a4,a5
80003bd6:	fe842783          	lw	a5,-24(s0)
80003bda:	c781                	beqz	a5,80003be2 <RCU_AHBRstCmd+0x2c>
80003bdc:	fec42783          	lw	a5,-20(s0)
80003be0:	a011                	j	80003be4 <RCU_AHBRstCmd+0x2e>
80003be2:	4781                	li	a5,0
80003be4:	3000e737          	lui	a4,0x3000e
80003be8:	8fd5                	or	a5,a5,a3
80003bea:	cb1c                	sw	a5,16(a4)
}
80003bec:	0001                	nop
80003bee:	4472                	lw	s0,28(sp)
80003bf0:	6105                	addi	sp,sp,32
80003bf2:	8082                	ret

80003bf4 <CRYPTO_UpdateKeyCmd>:
  * 		   KEY_0...KEY_3   AES-128
  * @pararm  state   
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_UpdateKeyCmd(FunctionalState state)
{
80003bf4:	1101                	addi	sp,sp,-32
80003bf6:	ce22                	sw	s0,28(sp)
80003bf8:	1000                	addi	s0,sp,32
80003bfa:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_UPDATE_KEY_Msk, state << CRYPTO_CONTROL_UPDATE_KEY_Pos);
80003bfe:	200207b7          	lui	a5,0x20020
80003c02:	43fc                	lw	a5,68(a5)
80003c04:	ffe7f693          	andi	a3,a5,-2
80003c08:	200207b7          	lui	a5,0x20020
80003c0c:	fec42703          	lw	a4,-20(s0)
80003c10:	8f55                	or	a4,a4,a3
80003c12:	c3f8                	sw	a4,68(a5)
}
80003c14:	0001                	nop
80003c16:	4472                	lw	s0,28(sp)
80003c18:	6105                	addi	sp,sp,32
80003c1a:	8082                	ret

80003c1c <CRYPTO_StartCmd>:
  * @brief       .
  * 		         .
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_StartCmd()
{
80003c1c:	1141                	addi	sp,sp,-16
80003c1e:	c622                	sw	s0,12(sp)
80003c20:	0800                	addi	s0,sp,16
	SET_BIT(CRYPTO->CONTROL, CRYPTO_CONTROL_START_Msk);
80003c22:	200207b7          	lui	a5,0x20020
80003c26:	43f8                	lw	a4,68(a5)
80003c28:	200207b7          	lui	a5,0x20020
80003c2c:	00276713          	ori	a4,a4,2
80003c30:	c3f8                	sw	a4,68(a5)
}
80003c32:	0001                	nop
80003c34:	4432                	lw	s0,12(sp)
80003c36:	0141                	addi	sp,sp,16
80003c38:	8082                	ret

80003c3a <CRYPTO_DirectionConfig>:
  * @brief      
  * @param   dir    0 - , 1 - 
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DirectionConfig(CRYPTO_Dir_TypeDef dir)
{
80003c3a:	1101                	addi	sp,sp,-32
80003c3c:	ce22                	sw	s0,28(sp)
80003c3e:	1000                	addi	s0,sp,32
80003c40:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_DIR(dir));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_DIRECTION_Msk, dir << CRYPTO_CONTROL_DIRECTION_Pos);
80003c44:	200207b7          	lui	a5,0x20020
80003c48:	43fc                	lw	a5,68(a5)
80003c4a:	ffb7f693          	andi	a3,a5,-5
80003c4e:	fec42783          	lw	a5,-20(s0)
80003c52:	00279713          	slli	a4,a5,0x2
80003c56:	200207b7          	lui	a5,0x20020
80003c5a:	8f55                	or	a4,a4,a3
80003c5c:	c3f8                	sw	a4,68(a5)
}
80003c5e:	0001                	nop
80003c60:	4472                	lw	s0,28(sp)
80003c62:	6105                	addi	sp,sp,32
80003c64:	8082                	ret

80003c66 <CRYPTO_AlgoConfig>:
  * @brief      
  * @param   algo   
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_AlgoConfig(CRYPTO_Algo_TypeDef algo)
{
80003c66:	1101                	addi	sp,sp,-32
80003c68:	ce22                	sw	s0,28(sp)
80003c6a:	1000                	addi	s0,sp,32
80003c6c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_ALGO(algo));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_ALGORITHM_Msk, algo << CRYPTO_CONTROL_ALGORITHM_Pos);
80003c70:	200207b7          	lui	a5,0x20020
80003c74:	43fc                	lw	a5,68(a5)
80003c76:	fe77f693          	andi	a3,a5,-25
80003c7a:	fec42783          	lw	a5,-20(s0)
80003c7e:	00379713          	slli	a4,a5,0x3
80003c82:	200207b7          	lui	a5,0x20020
80003c86:	8f55                	or	a4,a4,a3
80003c88:	c3f8                	sw	a4,68(a5)
}
80003c8a:	0001                	nop
80003c8c:	4472                	lw	s0,28(sp)
80003c8e:	6105                	addi	sp,sp,32
80003c90:	8082                	ret

80003c92 <CRYPTO_ModeConfig>:
  * @brief       
  * @param   mode    
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_ModeConfig(CRYPTO_Mode_TypeDef mode)
{
80003c92:	1101                	addi	sp,sp,-32
80003c94:	ce22                	sw	s0,28(sp)
80003c96:	1000                	addi	s0,sp,32
80003c98:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_MODE(mode));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_MODE_Msk, mode << CRYPTO_CONTROL_MODE_Pos);
80003c9c:	200207b7          	lui	a5,0x20020
80003ca0:	43fc                	lw	a5,68(a5)
80003ca2:	f9f7f693          	andi	a3,a5,-97
80003ca6:	fec42783          	lw	a5,-20(s0)
80003caa:	00579713          	slli	a4,a5,0x5
80003cae:	200207b7          	lui	a5,0x20020
80003cb2:	8f55                	or	a4,a4,a3
80003cb4:	c3f8                	sw	a4,68(a5)
}
80003cb6:	0001                	nop
80003cb8:	4472                	lw	s0,28(sp)
80003cba:	6105                	addi	sp,sp,32
80003cbc:	8082                	ret

80003cbe <CRYPTO_GCMPhaseConfig>:
  * @brief       
  * @param   phase        GCM
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_TypeDef phase)
{
80003cbe:	1101                	addi	sp,sp,-32
80003cc0:	ce22                	sw	s0,28(sp)
80003cc2:	1000                	addi	s0,sp,32
80003cc4:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_GCM_PHASE(phase));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_GCM_PHASE_Msk, phase << CRYPTO_CONTROL_GCM_PHASE_Pos);
80003cc8:	200207b7          	lui	a5,0x20020
80003ccc:	43fc                	lw	a5,68(a5)
80003cce:	9ff7f693          	andi	a3,a5,-1537
80003cd2:	fec42783          	lw	a5,-20(s0)
80003cd6:	00979713          	slli	a4,a5,0x9
80003cda:	200207b7          	lui	a5,0x20020
80003cde:	8f55                	or	a4,a4,a3
80003ce0:	c3f8                	sw	a4,68(a5)
}
80003ce2:	0001                	nop
80003ce4:	4472                	lw	s0,28(sp)
80003ce6:	6105                	addi	sp,sp,32
80003ce8:	8082                	ret

80003cea <CRYPTO_InitVectorAutoUpdateCmd>:
  * @brief       IV_*    
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_InitVectorAutoUpdateCmd(FunctionalState state)
{
80003cea:	1101                	addi	sp,sp,-32
80003cec:	ce22                	sw	s0,28(sp)
80003cee:	1000                	addi	s0,sp,32
80003cf0:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_SELF_UPDATE_Msk, state << CRYPTO_CONTROL_SELF_UPDATE_Pos);
80003cf4:	200207b7          	lui	a5,0x20020
80003cf8:	43fc                	lw	a5,68(a5)
80003cfa:	eff7f693          	andi	a3,a5,-257
80003cfe:	fec42783          	lw	a5,-20(s0)
80003d02:	00879713          	slli	a4,a5,0x8
80003d06:	200207b7          	lui	a5,0x20020
80003d0a:	8f55                	or	a4,a4,a3
80003d0c:	c3f8                	sw	a4,68(a5)
}
80003d0e:	0001                	nop
80003d10:	4472                	lw	s0,28(sp)
80003d12:	6105                	addi	sp,sp,32
80003d14:	8082                	ret

80003d16 <CRYPTO_SetInitVector>:
  * @param   idx     
  * @param   val    
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_SetInitVector(uint32_t idx, uint32_t val)
{
80003d16:	1101                	addi	sp,sp,-32
80003d18:	ce22                	sw	s0,28(sp)
80003d1a:	1000                	addi	s0,sp,32
80003d1c:	fea42623          	sw	a0,-20(s0)
80003d20:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRYPTO_IV(idx));

	WRITE_REG(CRYPTO->IV[idx], val);
80003d24:	20020737          	lui	a4,0x20020
80003d28:	fec42783          	lw	a5,-20(s0)
80003d2c:	078a                	slli	a5,a5,0x2
80003d2e:	97ba                	add	a5,a5,a4
80003d30:	fe842703          	lw	a4,-24(s0)
80003d34:	c398                	sw	a4,0(a5)
}
80003d36:	0001                	nop
80003d38:	4472                	lw	s0,28(sp)
80003d3a:	6105                	addi	sp,sp,32
80003d3c:	8082                	ret

80003d3e <CRYPTO_SetTextInput>:
  * @param   idx     
  * @param   val   
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_SetTextInput(uint32_t idx, uint32_t val)
{
80003d3e:	1101                	addi	sp,sp,-32
80003d40:	ce22                	sw	s0,28(sp)
80003d42:	1000                	addi	s0,sp,32
80003d44:	fea42623          	sw	a0,-20(s0)
80003d48:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRYPTO_TEXT_IN(idx));

	WRITE_REG(CRYPTO->TEXT_IN[idx], val);
80003d4c:	20020737          	lui	a4,0x20020
80003d50:	fec42783          	lw	a5,-20(s0)
80003d54:	0791                	addi	a5,a5,4 # 20020004 <STACK_SIZE+0x2001f804>
80003d56:	078a                	slli	a5,a5,0x2
80003d58:	97ba                	add	a5,a5,a4
80003d5a:	fe842703          	lw	a4,-24(s0)
80003d5e:	c398                	sw	a4,0(a5)
}
80003d60:	0001                	nop
80003d62:	4472                	lw	s0,28(sp)
80003d64:	6105                	addi	sp,sp,32
80003d66:	8082                	ret

80003d68 <CRYPTO_SetKeyInReg>:
  * @param   idx     
  * @param   val    
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_SetKeyInReg(uint32_t idx, uint32_t val)
{
80003d68:	1101                	addi	sp,sp,-32
80003d6a:	ce22                	sw	s0,28(sp)
80003d6c:	1000                	addi	s0,sp,32
80003d6e:	fea42623          	sw	a0,-20(s0)
80003d72:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRYPTO_KEY(idx));

	WRITE_REG(CRYPTO->KEY[idx], val);
80003d76:	20020737          	lui	a4,0x20020
80003d7a:	fec42783          	lw	a5,-20(s0)
80003d7e:	07a1                	addi	a5,a5,8
80003d80:	078a                	slli	a5,a5,0x2
80003d82:	97ba                	add	a5,a5,a4
80003d84:	fe842703          	lw	a4,-24(s0)
80003d88:	c398                	sw	a4,0(a5)
}
80003d8a:	0001                	nop
80003d8c:	4472                	lw	s0,28(sp)
80003d8e:	6105                	addi	sp,sp,32
80003d90:	8082                	ret

80003d92 <CRYPTO_GetTextOutput>:
  * @brief      
  * @param   idx    [0; 3]
  * @retval  void
  */
__STATIC_INLINE uint32_t CRYPTO_GetTextOutput(uint32_t idx)
{
80003d92:	1101                	addi	sp,sp,-32
80003d94:	ce22                	sw	s0,28(sp)
80003d96:	1000                	addi	s0,sp,32
80003d98:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_TEXT_OUT(idx));

	return (uint32_t) READ_REG(CRYPTO->TEXT_OUT[idx]);
80003d9c:	20020737          	lui	a4,0x20020
80003da0:	fec42783          	lw	a5,-20(s0)
80003da4:	07f1                	addi	a5,a5,28
80003da6:	078a                	slli	a5,a5,0x2
80003da8:	97ba                	add	a5,a5,a4
80003daa:	439c                	lw	a5,0(a5)
}
80003dac:	853e                	mv	a0,a5
80003dae:	4472                	lw	s0,28(sp)
80003db0:	6105                	addi	sp,sp,32
80003db2:	8082                	ret

80003db4 <CRYPTO_GetGCMTag>:
  * @brief     ,    GCM
  * @param   idx    [0; 3]
  * @retval  void
  */
__STATIC_INLINE uint32_t CRYPTO_GetGCMTag(uint32_t idx)
{
80003db4:	1101                	addi	sp,sp,-32
80003db6:	ce22                	sw	s0,28(sp)
80003db8:	1000                	addi	s0,sp,32
80003dba:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_GCM_TAG(idx));

	return (uint32_t) READ_REG(CRYPTO->GCM_TAG[idx]);
80003dbe:	20020737          	lui	a4,0x20020
80003dc2:	fec42783          	lw	a5,-20(s0)
80003dc6:	02878793          	addi	a5,a5,40
80003dca:	078a                	slli	a5,a5,0x2
80003dcc:	97ba                	add	a5,a5,a4
80003dce:	439c                	lw	a5,0(a5)
}
80003dd0:	853e                	mv	a0,a5
80003dd2:	4472                	lw	s0,28(sp)
80003dd4:	6105                	addi	sp,sp,32
80003dd6:	8082                	ret

80003dd8 <CRYPTO_ReadyStatus>:
/**
  * @brief            /    
  * @retval  state   
  */
__STATIC_INLINE FunctionalState CRYPTO_ReadyStatus()
{
80003dd8:	1141                	addi	sp,sp,-16
80003dda:	c622                	sw	s0,12(sp)
80003ddc:	0800                	addi	s0,sp,16
	return (FunctionalState) READ_BIT(CRYPTO->STATUS, CRYPTO_STATUS_READY_Msk);
80003dde:	200207b7          	lui	a5,0x20020
80003de2:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
80003de6:	8b85                	andi	a5,a5,1
}
80003de8:	853e                	mv	a0,a5
80003dea:	4432                	lw	s0,12(sp)
80003dec:	0141                	addi	sp,sp,16
80003dee:	8082                	ret

80003df0 <CRYPTO_DMA_SetBaseDescriptor>:
  * @brief       DMA
  * @param   address   ,    @ref CRYPTO_DMA_DesciptorAddress_TypeDef
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_SetBaseDescriptor(uint32_t address)
{
80003df0:	1101                	addi	sp,sp,-32
80003df2:	ce22                	sw	s0,28(sp)
80003df4:	1000                	addi	s0,sp,32
80003df6:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(CRYPTO->BASE_DESCRIPTOR, address);
80003dfa:	200207b7          	lui	a5,0x20020
80003dfe:	fec42703          	lw	a4,-20(s0)
80003e02:	c7b8                	sw	a4,72(a5)
}
80003e04:	0001                	nop
80003e06:	4472                	lw	s0,28(sp)
80003e08:	6105                	addi	sp,sp,32
80003e0a:	8082                	ret

80003e0c <CRYPTO_DMA_StartCmd>:
/**
  * @brief        DMA
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_StartCmd()
{
80003e0c:	1141                	addi	sp,sp,-16
80003e0e:	c622                	sw	s0,12(sp)
80003e10:	0800                	addi	s0,sp,16
	SET_BIT(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_START_Msk);
80003e12:	200207b7          	lui	a5,0x20020
80003e16:	47f8                	lw	a4,76(a5)
80003e18:	200207b7          	lui	a5,0x20020
80003e1c:	00176713          	ori	a4,a4,1
80003e20:	c7f8                	sw	a4,76(a5)
}
80003e22:	0001                	nop
80003e24:	4432                	lw	s0,12(sp)
80003e26:	0141                	addi	sp,sp,16
80003e28:	8082                	ret

80003e2a <CRYPTO_DMA_ByteSwapCmd>:
  * @brief         AHB
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_ByteSwapCmd(FunctionalState state)
{
80003e2a:	1101                	addi	sp,sp,-32
80003e2c:	ce22                	sw	s0,28(sp)
80003e2e:	1000                	addi	s0,sp,32
80003e30:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_BYTES_SWAP_Msk, state << CRYPTO_DMA_CONTROL_BYTES_SWAP_Pos);
80003e34:	200207b7          	lui	a5,0x20020
80003e38:	47fc                	lw	a5,76(a5)
80003e3a:	ffd7f693          	andi	a3,a5,-3
80003e3e:	fec42783          	lw	a5,-20(s0)
80003e42:	00179713          	slli	a4,a5,0x1
80003e46:	200207b7          	lui	a5,0x20020
80003e4a:	8f55                	or	a4,a4,a3
80003e4c:	c7f8                	sw	a4,76(a5)
}
80003e4e:	0001                	nop
80003e50:	4472                	lw	s0,28(sp)
80003e52:	6105                	addi	sp,sp,32
80003e54:	8082                	ret

80003e56 <CRYPTO_DMA_WordSwapCmd>:
  * @brief         AHB
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_WordSwapCmd(FunctionalState state)
{
80003e56:	1101                	addi	sp,sp,-32
80003e58:	ce22                	sw	s0,28(sp)
80003e5a:	1000                	addi	s0,sp,32
80003e5c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_WORDS_SWAP_Msk, state << CRYPTO_DMA_CONTROL_WORDS_SWAP_Pos);
80003e60:	200207b7          	lui	a5,0x20020
80003e64:	47fc                	lw	a5,76(a5)
80003e66:	ffb7f693          	andi	a3,a5,-5
80003e6a:	fec42783          	lw	a5,-20(s0)
80003e6e:	00279713          	slli	a4,a5,0x2
80003e72:	200207b7          	lui	a5,0x20020
80003e76:	8f55                	or	a4,a4,a3
80003e78:	c7f8                	sw	a4,76(a5)
}
80003e7a:	0001                	nop
80003e7c:	4472                	lw	s0,28(sp)
80003e7e:	6105                	addi	sp,sp,32
80003e80:	8082                	ret

80003e82 <CRYPTO_DMA_ActiveStatus>:
/**
  * @brief       DMA  
  * @retval  state   DMA
  */
__STATIC_INLINE FunctionalState CRYPTO_DMA_ActiveStatus()
{
80003e82:	1141                	addi	sp,sp,-16
80003e84:	c622                	sw	s0,12(sp)
80003e86:	0800                	addi	s0,sp,16
	return (FunctionalState) READ_BIT(CRYPTO->STATUS, CRYPTO_STATUS_DMA_ACTIVE_Msk);
80003e88:	200207b7          	lui	a5,0x20020
80003e8c:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
80003e90:	1007f793          	andi	a5,a5,256
80003e94:	c399                	beqz	a5,80003e9a <CRYPTO_DMA_ActiveStatus+0x18>
80003e96:	4785                	li	a5,1
80003e98:	a011                	j	80003e9c <CRYPTO_DMA_ActiveStatus+0x1a>
80003e9a:	4781                	li	a5,0
}
80003e9c:	853e                	mv	a0,a5
80003e9e:	4432                	lw	s0,12(sp)
80003ea0:	0141                	addi	sp,sp,16
80003ea2:	8082                	ret

80003ea4 <CRYPTO_DeInit>:
/**
  * @brief      CRYPTO   
  * @retval  void
  */
void CRYPTO_DeInit()
{
80003ea4:	1141                	addi	sp,sp,-16
80003ea6:	c606                	sw	ra,12(sp)
80003ea8:	c422                	sw	s0,8(sp)
80003eaa:	0800                	addi	s0,sp,16
	RCU_AHBRstCmd(RCU_AHBRst_CRYPTO, DISABLE);
80003eac:	4581                	li	a1,0
80003eae:	4511                	li	a0,4
80003eb0:	3319                	jal	80003bb6 <RCU_AHBRstCmd>
	RCU_AHBRstCmd(RCU_AHBRst_CRYPTO, ENABLE);
80003eb2:	4585                	li	a1,1
80003eb4:	4511                	li	a0,4
80003eb6:	3301                	jal	80003bb6 <RCU_AHBRstCmd>
}
80003eb8:	0001                	nop
80003eba:	40b2                	lw	ra,12(sp)
80003ebc:	4422                	lw	s0,8(sp)
80003ebe:	0141                	addi	sp,sp,16
80003ec0:	8082                	ret

80003ec2 <CRYPTO_Init>:
  * @param   InitStruct      @ref CRYPTO_Init_TypeDef,
  *                         
  * @retval  void
  */
void CRYPTO_Init(CRYPTO_Init_TypeDef* InitStruct)
{
80003ec2:	1101                	addi	sp,sp,-32
80003ec4:	ce06                	sw	ra,28(sp)
80003ec6:	cc22                	sw	s0,24(sp)
80003ec8:	1000                	addi	s0,sp,32
80003eca:	fea42623          	sw	a0,-20(s0)
	CRYPTO_DirectionConfig(InitStruct->Direction);
80003ece:	fec42783          	lw	a5,-20(s0)
80003ed2:	439c                	lw	a5,0(a5)
80003ed4:	853e                	mv	a0,a5
80003ed6:	3395                	jal	80003c3a <CRYPTO_DirectionConfig>
	CRYPTO_AlgoConfig(InitStruct->Algorithm);
80003ed8:	fec42783          	lw	a5,-20(s0)
80003edc:	43dc                	lw	a5,4(a5)
80003ede:	853e                	mv	a0,a5
80003ee0:	3359                	jal	80003c66 <CRYPTO_AlgoConfig>
	CRYPTO_ModeConfig(InitStruct->Mode);
80003ee2:	fec42783          	lw	a5,-20(s0)
80003ee6:	479c                	lw	a5,8(a5)
80003ee8:	853e                	mv	a0,a5
80003eea:	3365                	jal	80003c92 <CRYPTO_ModeConfig>
	CRYPTO_InitVectorAutoUpdateCmd(InitStruct->InitVectorAutoUpdate);
80003eec:	fec42783          	lw	a5,-20(s0)
80003ef0:	47dc                	lw	a5,12(a5)
80003ef2:	853e                	mv	a0,a5
80003ef4:	3bdd                	jal	80003cea <CRYPTO_InitVectorAutoUpdateCmd>
	CRYPTO_UpdateKeyCmd(InitStruct->UpdateKey);
80003ef6:	fec42783          	lw	a5,-20(s0)
80003efa:	4b9c                	lw	a5,16(a5)
80003efc:	853e                	mv	a0,a5
80003efe:	39dd                	jal	80003bf4 <CRYPTO_UpdateKeyCmd>
	CRYPTO_GCMPhaseConfig(InitStruct->GCMPhase);
80003f00:	fec42783          	lw	a5,-20(s0)
80003f04:	4bdc                	lw	a5,20(a5)
80003f06:	853e                	mv	a0,a5
80003f08:	3b5d                	jal	80003cbe <CRYPTO_GCMPhaseConfig>
}
80003f0a:	0001                	nop
80003f0c:	40f2                	lw	ra,28(sp)
80003f0e:	4462                	lw	s0,24(sp)
80003f10:	6105                	addi	sp,sp,32
80003f12:	8082                	ret

80003f14 <CRYPTO_StructInit>:
  * @param   InitStruct      @ref CRYPTO_Init_TypeDef,
  *                        
  * @retval  void
  */
void CRYPTO_StructInit(CRYPTO_Init_TypeDef* InitStruct)
{
80003f14:	1101                	addi	sp,sp,-32
80003f16:	ce22                	sw	s0,28(sp)
80003f18:	1000                	addi	s0,sp,32
80003f1a:	fea42623          	sw	a0,-20(s0)
	InitStruct->Direction = CRYPTO_Dir_Encrypt;
80003f1e:	fec42783          	lw	a5,-20(s0)
80003f22:	0007a023          	sw	zero,0(a5)
	InitStruct->Algorithm = CRYPTO_Algo_AES_256;
80003f26:	fec42783          	lw	a5,-20(s0)
80003f2a:	4705                	li	a4,1
80003f2c:	c3d8                	sw	a4,4(a5)
	InitStruct->Mode = CRYPTO_Mode_GCM;
80003f2e:	fec42783          	lw	a5,-20(s0)
80003f32:	470d                	li	a4,3
80003f34:	c798                	sw	a4,8(a5)
	InitStruct->InitVectorAutoUpdate = ENABLE;
80003f36:	fec42783          	lw	a5,-20(s0)
80003f3a:	4705                	li	a4,1
80003f3c:	c7d8                	sw	a4,12(a5)
	InitStruct->UpdateKey = ENABLE;
80003f3e:	fec42783          	lw	a5,-20(s0)
80003f42:	4705                	li	a4,1
80003f44:	cb98                	sw	a4,16(a5)
	InitStruct->GCMPhase = CRYPTO_GCM_PHASE_INIT;
80003f46:	fec42783          	lw	a5,-20(s0)
80003f4a:	0007aa23          	sw	zero,20(a5)
}
80003f4e:	0001                	nop
80003f50:	4472                	lw	s0,28(sp)
80003f52:	6105                	addi	sp,sp,32
80003f54:	8082                	ret

80003f56 <CRYPTO_DMAStructInit>:
  * @param   CryptoStruct     @ref CRYPTO_Init_TypeDef,
  * 					     
  * @retval  void
  */
void CRYPTO_DMAStructInit(CRYPTO_DMAInit_TypeDef* DMAStruct, CRYPTO_Init_TypeDef* CryptoStruct)
{
80003f56:	1101                	addi	sp,sp,-32
80003f58:	ce22                	sw	s0,28(sp)
80003f5a:	1000                	addi	s0,sp,32
80003f5c:	fea42623          	sw	a0,-20(s0)
80003f60:	feb42423          	sw	a1,-24(s0)
	DMAStruct->ByteSwap = DISABLE;
80003f64:	fec42783          	lw	a5,-20(s0)
80003f68:	0007a023          	sw	zero,0(a5)
	DMAStruct->WordSwap = DISABLE;
80003f6c:	fec42783          	lw	a5,-20(s0)
80003f70:	0007a223          	sw	zero,4(a5)

	DMAStruct->CryptoSettings = CryptoStruct;
80003f74:	fec42783          	lw	a5,-20(s0)
80003f78:	fe842703          	lw	a4,-24(s0)
80003f7c:	cbd8                	sw	a4,20(a5)
	DMAStruct->LastDescriptor = ENABLE;
80003f7e:	fec42783          	lw	a5,-20(s0)
80003f82:	4705                	li	a4,1
80003f84:	c798                	sw	a4,8(a5)
	DMAStruct->ITEnable = DISABLE;
80003f86:	fec42783          	lw	a5,-20(s0)
80003f8a:	0007a623          	sw	zero,12(a5)
	DMAStruct->BlocksCount = 0;
80003f8e:	fec42783          	lw	a5,-20(s0)
80003f92:	0007a823          	sw	zero,16(a5)

	DMAStruct->SourceAddress = 0;
80003f96:	fec42783          	lw	a5,-20(s0)
80003f9a:	0007ae23          	sw	zero,28(a5)
	DMAStruct->DestinationAddress = 0;
80003f9e:	fec42783          	lw	a5,-20(s0)
80003fa2:	0207a023          	sw	zero,32(a5)
//	DMAStruct->DescriptorPtr->NEXT_DESCR = 0x80;
//	DMAStruct->DescriptorPtr = 0x80;
}
80003fa6:	0001                	nop
80003fa8:	4472                	lw	s0,28(sp)
80003faa:	6105                	addi	sp,sp,32
80003fac:	8082                	ret

80003fae <CRYPTO_InitDMADescriptor>:
  * @param   DMAStruct      @ref CRYPTO_DMAInit_TypeDef,
  *                        
  * @retval  void
  */
uint32_t CRYPTO_InitDMADescriptor(CRYPTO_DMAInit_TypeDef* DMAStruct)
{
80003fae:	1101                	addi	sp,sp,-32
80003fb0:	ce06                	sw	ra,28(sp)
80003fb2:	cc22                	sw	s0,24(sp)
80003fb4:	1000                	addi	s0,sp,32
80003fb6:	fea42623          	sw	a0,-20(s0)
	/* CRYPTO DMA operation control word */
	DMAStruct->DescriptorPtr->CONTROL_bit.UPDATE_KEY = DMAStruct->CryptoSettings->UpdateKey;
80003fba:	fec42783          	lw	a5,-20(s0)
80003fbe:	4bdc                	lw	a5,20(a5)
80003fc0:	4b98                	lw	a4,16(a5)
80003fc2:	fec42783          	lw	a5,-20(s0)
80003fc6:	53dc                	lw	a5,36(a5)
80003fc8:	8b05                	andi	a4,a4,1
80003fca:	0ff77713          	zext.b	a4,a4
80003fce:	8b05                	andi	a4,a4,1
80003fd0:	4394                	lw	a3,0(a5)
80003fd2:	9af9                	andi	a3,a3,-2
80003fd4:	8f55                	or	a4,a4,a3
80003fd6:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.LAST_DESCRIPTOR = DMAStruct->LastDescriptor;
80003fd8:	fec42783          	lw	a5,-20(s0)
80003fdc:	4798                	lw	a4,8(a5)
80003fde:	fec42783          	lw	a5,-20(s0)
80003fe2:	53dc                	lw	a5,36(a5)
80003fe4:	8b05                	andi	a4,a4,1
80003fe6:	0ff77713          	zext.b	a4,a4
80003fea:	8b05                	andi	a4,a4,1
80003fec:	0706                	slli	a4,a4,0x1
80003fee:	4394                	lw	a3,0(a5)
80003ff0:	9af5                	andi	a3,a3,-3
80003ff2:	8f55                	or	a4,a4,a3
80003ff4:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.DIRECTION = DMAStruct->CryptoSettings->Direction;
80003ff6:	fec42783          	lw	a5,-20(s0)
80003ffa:	4bdc                	lw	a5,20(a5)
80003ffc:	4398                	lw	a4,0(a5)
80003ffe:	fec42783          	lw	a5,-20(s0)
80004002:	53dc                	lw	a5,36(a5)
80004004:	8b05                	andi	a4,a4,1
80004006:	0ff77713          	zext.b	a4,a4
8000400a:	8b05                	andi	a4,a4,1
8000400c:	070a                	slli	a4,a4,0x2
8000400e:	4394                	lw	a3,0(a5)
80004010:	9aed                	andi	a3,a3,-5
80004012:	8f55                	or	a4,a4,a3
80004014:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.ALGORITHM = DMAStruct->CryptoSettings->Algorithm;
80004016:	fec42783          	lw	a5,-20(s0)
8000401a:	4bdc                	lw	a5,20(a5)
8000401c:	43d8                	lw	a4,4(a5)
8000401e:	fec42783          	lw	a5,-20(s0)
80004022:	53dc                	lw	a5,36(a5)
80004024:	8b0d                	andi	a4,a4,3
80004026:	0ff77713          	zext.b	a4,a4
8000402a:	8b0d                	andi	a4,a4,3
8000402c:	070e                	slli	a4,a4,0x3
8000402e:	4394                	lw	a3,0(a5)
80004030:	9a9d                	andi	a3,a3,-25
80004032:	8f55                	or	a4,a4,a3
80004034:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.MODE = DMAStruct->CryptoSettings->Mode;
80004036:	fec42783          	lw	a5,-20(s0)
8000403a:	4bdc                	lw	a5,20(a5)
8000403c:	4798                	lw	a4,8(a5)
8000403e:	fec42783          	lw	a5,-20(s0)
80004042:	53dc                	lw	a5,36(a5)
80004044:	8b0d                	andi	a4,a4,3
80004046:	0ff77713          	zext.b	a4,a4
8000404a:	8b0d                	andi	a4,a4,3
8000404c:	0716                	slli	a4,a4,0x5
8000404e:	4394                	lw	a3,0(a5)
80004050:	f9f6f693          	andi	a3,a3,-97
80004054:	8f55                	or	a4,a4,a3
80004056:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.GCM_PHASE = DMAStruct->CryptoSettings->GCMPhase;
80004058:	fec42783          	lw	a5,-20(s0)
8000405c:	4bdc                	lw	a5,20(a5)
8000405e:	4bd8                	lw	a4,20(a5)
80004060:	fec42783          	lw	a5,-20(s0)
80004064:	53dc                	lw	a5,36(a5)
80004066:	8b0d                	andi	a4,a4,3
80004068:	0ff77713          	zext.b	a4,a4
8000406c:	8b0d                	andi	a4,a4,3
8000406e:	0736                	slli	a4,a4,0xd
80004070:	4390                	lw	a2,0(a5)
80004072:	76e9                	lui	a3,0xffffa
80004074:	16fd                	addi	a3,a3,-1 # ffff9fff <__data_source_start+0x7fff2e87>
80004076:	8ef1                	and	a3,a3,a2
80004078:	8f55                	or	a4,a4,a3
8000407a:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.INTERRUPT_ENABLE = DMAStruct->ITEnable;
8000407c:	fec42783          	lw	a5,-20(s0)
80004080:	47d8                	lw	a4,12(a5)
80004082:	fec42783          	lw	a5,-20(s0)
80004086:	53dc                	lw	a5,36(a5)
80004088:	8b05                	andi	a4,a4,1
8000408a:	0ff77713          	zext.b	a4,a4
8000408e:	8b05                	andi	a4,a4,1
80004090:	073e                	slli	a4,a4,0xf
80004092:	4390                	lw	a2,0(a5)
80004094:	76e1                	lui	a3,0xffff8
80004096:	16fd                	addi	a3,a3,-1 # ffff7fff <__data_source_start+0x7fff0e87>
80004098:	8ef1                	and	a3,a3,a2
8000409a:	8f55                	or	a4,a4,a3
8000409c:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.BLOCKS_COUNT = DMAStruct->BlocksCount;
8000409e:	fec42783          	lw	a5,-20(s0)
800040a2:	4b98                	lw	a4,16(a5)
800040a4:	fec42783          	lw	a5,-20(s0)
800040a8:	53dc                	lw	a5,36(a5)
800040aa:	86ba                	mv	a3,a4
800040ac:	6705                	lui	a4,0x1
800040ae:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
800040b0:	8f75                	and	a4,a4,a3
800040b2:	01071693          	slli	a3,a4,0x10
800040b6:	82c1                	srli	a3,a3,0x10
800040b8:	6705                	lui	a4,0x1
800040ba:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
800040bc:	8f75                	and	a4,a4,a3
800040be:	0742                	slli	a4,a4,0x10
800040c0:	4390                	lw	a2,0(a5)
800040c2:	f00106b7          	lui	a3,0xf0010
800040c6:	16fd                	addi	a3,a3,-1 # f000ffff <__data_source_start+0x70008e87>
800040c8:	8ef1                	and	a3,a3,a2
800040ca:	8f55                	or	a4,a4,a3
800040cc:	c398                	sw	a4,0(a5)

	DMAStruct->DescriptorPtr->SRC_ADDR = (uint32_t) DMAStruct->SourceAddress;
800040ce:	fec42783          	lw	a5,-20(s0)
800040d2:	4fd8                	lw	a4,28(a5)
800040d4:	fec42783          	lw	a5,-20(s0)
800040d8:	53dc                	lw	a5,36(a5)
800040da:	c3d8                	sw	a4,4(a5)
	DMAStruct->DescriptorPtr->DST_ADDR = (uint32_t) DMAStruct->DestinationAddress;
800040dc:	fec42783          	lw	a5,-20(s0)
800040e0:	5398                	lw	a4,32(a5)
800040e2:	fec42783          	lw	a5,-20(s0)
800040e6:	53dc                	lw	a5,36(a5)
800040e8:	c798                	sw	a4,8(a5)
	DMAStruct->DescriptorPtr->NEXT_DESCR = (uint32_t) DMAStruct->LastDescriptor ? 0 : CRYPTO_InitDMADescriptor((CRYPTO_DMAInit_TypeDef*) DMAStruct->NextDescriptor);
800040ea:	fec42783          	lw	a5,-20(s0)
800040ee:	479c                	lw	a5,8(a5)
800040f0:	eb81                	bnez	a5,80004100 <CRYPTO_InitDMADescriptor+0x152>
800040f2:	fec42783          	lw	a5,-20(s0)
800040f6:	4f9c                	lw	a5,24(a5)
800040f8:	853e                	mv	a0,a5
800040fa:	3d55                	jal	80003fae <CRYPTO_InitDMADescriptor>
800040fc:	872a                	mv	a4,a0
800040fe:	a011                	j	80004102 <CRYPTO_InitDMADescriptor+0x154>
80004100:	4701                	li	a4,0
80004102:	fec42783          	lw	a5,-20(s0)
80004106:	53dc                	lw	a5,36(a5)
80004108:	c7d8                	sw	a4,12(a5)

	return (uint32_t) DMAStruct->DescriptorPtr;
8000410a:	fec42783          	lw	a5,-20(s0)
8000410e:	53dc                	lw	a5,36(a5)
}
80004110:	853e                	mv	a0,a5
80004112:	40f2                	lw	ra,28(sp)
80004114:	4462                	lw	s0,24(sp)
80004116:	6105                	addi	sp,sp,32
80004118:	8082                	ret

8000411a <CRPYTO_ProcessData>:
  * @param   DMAStruct      @ref CRYPTO_DMAInit_TypeDef,
  *                           DMA
  * @retval  void
  */
void CRPYTO_ProcessData(CRYPTO_DMAInit_TypeDef* DMAStruct)
{
8000411a:	1101                	addi	sp,sp,-32
8000411c:	ce06                	sw	ra,28(sp)
8000411e:	cc22                	sw	s0,24(sp)
80004120:	1000                	addi	s0,sp,32
80004122:	fea42623          	sw	a0,-20(s0)
	CRYPTO_DMA_ByteSwapCmd(DMAStruct->ByteSwap);
80004126:	fec42783          	lw	a5,-20(s0)
8000412a:	439c                	lw	a5,0(a5)
8000412c:	853e                	mv	a0,a5
8000412e:	39f5                	jal	80003e2a <CRYPTO_DMA_ByteSwapCmd>
	CRYPTO_DMA_WordSwapCmd(DMAStruct->WordSwap);
80004130:	fec42783          	lw	a5,-20(s0)
80004134:	43dc                	lw	a5,4(a5)
80004136:	853e                	mv	a0,a5
80004138:	3b39                	jal	80003e56 <CRYPTO_DMA_WordSwapCmd>
	CRYPTO_DMA_SetBaseDescriptor(CRYPTO_InitDMADescriptor(DMAStruct));
8000413a:	fec42503          	lw	a0,-20(s0)
8000413e:	3d85                	jal	80003fae <CRYPTO_InitDMADescriptor>
80004140:	87aa                	mv	a5,a0
80004142:	853e                	mv	a0,a5
80004144:	3175                	jal	80003df0 <CRYPTO_DMA_SetBaseDescriptor>
	CRYPTO_DMA_StartCmd();
80004146:	31d9                	jal	80003e0c <CRYPTO_DMA_StartCmd>
}
80004148:	0001                	nop
8000414a:	40f2                	lw	ra,28(sp)
8000414c:	4462                	lw	s0,24(sp)
8000414e:	6105                	addi	sp,sp,32
80004150:	8082                	ret

80004152 <CRYPTO_SetKey>:
  * @brief     ,  256 ,  AES-128 128 
  * @param   key  ,    
  * @retval  void
  */
void CRYPTO_SetKey(uint32_t* key, uint32_t len)
{
80004152:	7179                	addi	sp,sp,-48
80004154:	d606                	sw	ra,44(sp)
80004156:	d422                	sw	s0,40(sp)
80004158:	1800                	addi	s0,sp,48
8000415a:	fca42e23          	sw	a0,-36(s0)
8000415e:	fcb42c23          	sw	a1,-40(s0)
	uint32_t idx = 0;
80004162:	fe042623          	sw	zero,-20(s0)
	while(idx < len)
80004166:	a00d                	j	80004188 <CRYPTO_SetKey+0x36>
	{
		CRYPTO_SetKeyInReg(idx++, *key++);
80004168:	fec42703          	lw	a4,-20(s0)
8000416c:	00170793          	addi	a5,a4,1
80004170:	fef42623          	sw	a5,-20(s0)
80004174:	fdc42783          	lw	a5,-36(s0)
80004178:	00478693          	addi	a3,a5,4
8000417c:	fcd42e23          	sw	a3,-36(s0)
80004180:	439c                	lw	a5,0(a5)
80004182:	85be                	mv	a1,a5
80004184:	853a                	mv	a0,a4
80004186:	36cd                	jal	80003d68 <CRYPTO_SetKeyInReg>
	while(idx < len)
80004188:	fec42703          	lw	a4,-20(s0)
8000418c:	fd842783          	lw	a5,-40(s0)
80004190:	fcf76ce3          	bltu	a4,a5,80004168 <CRYPTO_SetKey+0x16>
	}
}
80004194:	0001                	nop
80004196:	0001                	nop
80004198:	50b2                	lw	ra,44(sp)
8000419a:	5422                	lw	s0,40(sp)
8000419c:	6145                	addi	sp,sp,48
8000419e:	8082                	ret

800041a0 <CRYPTO_SetDataInBytes>:
  * @param   data_in   
  * @param   block_size    
  * @retval  void
  */
static void CRYPTO_SetDataInBytes(const unsigned char *data_in, uint32_t block_size)
{
800041a0:	7179                	addi	sp,sp,-48
800041a2:	d606                	sw	ra,44(sp)
800041a4:	d422                	sw	s0,40(sp)
800041a6:	1800                	addi	s0,sp,48
800041a8:	fca42e23          	sw	a0,-36(s0)
800041ac:	fcb42c23          	sw	a1,-40(s0)
	for(uint32_t i = 0; i < block_size; i++)
800041b0:	fe042623          	sw	zero,-20(s0)
800041b4:	a889                	j	80004206 <CRYPTO_SetDataInBytes+0x66>
	{
		CRYPTO_SetTextInput(i, data_in[3] + (data_in[2] << 8) + (data_in[1] << 16) + (data_in[0] << 24));
800041b6:	fdc42783          	lw	a5,-36(s0)
800041ba:	078d                	addi	a5,a5,3
800041bc:	0007c783          	lbu	a5,0(a5)
800041c0:	873e                	mv	a4,a5
800041c2:	fdc42783          	lw	a5,-36(s0)
800041c6:	0789                	addi	a5,a5,2
800041c8:	0007c783          	lbu	a5,0(a5)
800041cc:	07a2                	slli	a5,a5,0x8
800041ce:	973e                	add	a4,a4,a5
800041d0:	fdc42783          	lw	a5,-36(s0)
800041d4:	0785                	addi	a5,a5,1
800041d6:	0007c783          	lbu	a5,0(a5)
800041da:	07c2                	slli	a5,a5,0x10
800041dc:	973e                	add	a4,a4,a5
800041de:	fdc42783          	lw	a5,-36(s0)
800041e2:	0007c783          	lbu	a5,0(a5)
800041e6:	07e2                	slli	a5,a5,0x18
800041e8:	97ba                	add	a5,a5,a4
800041ea:	85be                	mv	a1,a5
800041ec:	fec42503          	lw	a0,-20(s0)
800041f0:	36b9                	jal	80003d3e <CRYPTO_SetTextInput>
		data_in += sizeof(uint32_t);
800041f2:	fdc42783          	lw	a5,-36(s0)
800041f6:	0791                	addi	a5,a5,4
800041f8:	fcf42e23          	sw	a5,-36(s0)
	for(uint32_t i = 0; i < block_size; i++)
800041fc:	fec42783          	lw	a5,-20(s0)
80004200:	0785                	addi	a5,a5,1
80004202:	fef42623          	sw	a5,-20(s0)
80004206:	fec42703          	lw	a4,-20(s0)
8000420a:	fd842783          	lw	a5,-40(s0)
8000420e:	faf764e3          	bltu	a4,a5,800041b6 <CRYPTO_SetDataInBytes+0x16>
	}
}
80004212:	0001                	nop
80004214:	0001                	nop
80004216:	50b2                	lw	ra,44(sp)
80004218:	5422                	lw	s0,40(sp)
8000421a:	6145                	addi	sp,sp,48
8000421c:	8082                	ret

8000421e <CRYPTO_SetKeyBytes>:
  * @param   key   ,     
  * 			  crypto  
  * @retval  void
  */
void CRYPTO_SetKeyBytes(CRYPTO_Init_TypeDef* crypto, const unsigned char* key)
{
8000421e:	7179                	addi	sp,sp,-48
80004220:	d606                	sw	ra,44(sp)
80004222:	d422                	sw	s0,40(sp)
80004224:	1800                	addi	s0,sp,48
80004226:	fca42e23          	sw	a0,-36(s0)
8000422a:	fcb42c23          	sw	a1,-40(s0)
	uint32_t key_size = (crypto->Algorithm == CRYPTO_Algo_AES_128) ? 4 : 8;
8000422e:	fdc42783          	lw	a5,-36(s0)
80004232:	43dc                	lw	a5,4(a5)
80004234:	e399                	bnez	a5,8000423a <CRYPTO_SetKeyBytes+0x1c>
80004236:	4791                	li	a5,4
80004238:	a011                	j	8000423c <CRYPTO_SetKeyBytes+0x1e>
8000423a:	47a1                	li	a5,8
8000423c:	fef42423          	sw	a5,-24(s0)
	for(uint32_t i = 0; i < key_size; i++)
80004240:	fe042623          	sw	zero,-20(s0)
80004244:	a8a1                	j	8000429c <CRYPTO_SetKeyBytes+0x7e>
	{
		uint32_t key_word = key[3] + (key[2] << 8) + (key[1] << 16) + (key[0] << 24);
80004246:	fd842783          	lw	a5,-40(s0)
8000424a:	078d                	addi	a5,a5,3
8000424c:	0007c783          	lbu	a5,0(a5)
80004250:	873e                	mv	a4,a5
80004252:	fd842783          	lw	a5,-40(s0)
80004256:	0789                	addi	a5,a5,2
80004258:	0007c783          	lbu	a5,0(a5)
8000425c:	07a2                	slli	a5,a5,0x8
8000425e:	973e                	add	a4,a4,a5
80004260:	fd842783          	lw	a5,-40(s0)
80004264:	0785                	addi	a5,a5,1
80004266:	0007c783          	lbu	a5,0(a5)
8000426a:	07c2                	slli	a5,a5,0x10
8000426c:	973e                	add	a4,a4,a5
8000426e:	fd842783          	lw	a5,-40(s0)
80004272:	0007c783          	lbu	a5,0(a5)
80004276:	07e2                	slli	a5,a5,0x18
80004278:	97ba                	add	a5,a5,a4
8000427a:	fef42223          	sw	a5,-28(s0)
		CRYPTO_SetKeyInReg(i, key_word);
8000427e:	fe442583          	lw	a1,-28(s0)
80004282:	fec42503          	lw	a0,-20(s0)
80004286:	34cd                	jal	80003d68 <CRYPTO_SetKeyInReg>
		key += sizeof(uint32_t);
80004288:	fd842783          	lw	a5,-40(s0)
8000428c:	0791                	addi	a5,a5,4
8000428e:	fcf42c23          	sw	a5,-40(s0)
	for(uint32_t i = 0; i < key_size; i++)
80004292:	fec42783          	lw	a5,-20(s0)
80004296:	0785                	addi	a5,a5,1
80004298:	fef42623          	sw	a5,-20(s0)
8000429c:	fec42703          	lw	a4,-20(s0)
800042a0:	fe842783          	lw	a5,-24(s0)
800042a4:	faf761e3          	bltu	a4,a5,80004246 <CRYPTO_SetKeyBytes+0x28>
	}
}
800042a8:	0001                	nop
800042aa:	0001                	nop
800042ac:	50b2                	lw	ra,44(sp)
800042ae:	5422                	lw	s0,40(sp)
800042b0:	6145                	addi	sp,sp,48
800042b2:	8082                	ret

800042b4 <CRYPTO_SinglePerform>:
  *			     
  *	@param 	data_out   
  * @retval void
  */
void CRYPTO_SinglePerform(CRYPTO_Init_TypeDef* crypto, const unsigned char *key, const unsigned char *data_in, const unsigned char* iv, unsigned char *data_out)
{
800042b4:	7139                	addi	sp,sp,-64
800042b6:	de06                	sw	ra,60(sp)
800042b8:	dc22                	sw	s0,56(sp)
800042ba:	0080                	addi	s0,sp,64
800042bc:	fca42e23          	sw	a0,-36(s0)
800042c0:	fcb42c23          	sw	a1,-40(s0)
800042c4:	fcc42a23          	sw	a2,-44(s0)
800042c8:	fcd42823          	sw	a3,-48(s0)
800042cc:	fce42623          	sw	a4,-52(s0)
	CRYPTO_Init(crypto);
800042d0:	fdc42503          	lw	a0,-36(s0)
800042d4:	36fd                	jal	80003ec2 <CRYPTO_Init>
	if (key != NULL) // if null then key is already set
800042d6:	fd842783          	lw	a5,-40(s0)
800042da:	c791                	beqz	a5,800042e6 <CRYPTO_SinglePerform+0x32>
		CRYPTO_SetKeyBytes(crypto, key);
800042dc:	fd842583          	lw	a1,-40(s0)
800042e0:	fdc42503          	lw	a0,-36(s0)
800042e4:	3f2d                	jal	8000421e <CRYPTO_SetKeyBytes>
	if (iv != NULL) // if null then iv is already set or there is no need in it (e.g. ECB mode)
800042e6:	fd042783          	lw	a5,-48(s0)
800042ea:	c781                	beqz	a5,800042f2 <CRYPTO_SinglePerform+0x3e>
		CRYPTO_SetIVBytes(iv);
800042ec:	fd042503          	lw	a0,-48(s0)
800042f0:	2405                	jal	80004510 <CRYPTO_SetIVBytes>

	uint32_t block_size = (crypto->Algorithm == CRYPTO_Algo_MAGMA) ? 2 : 4;
800042f2:	fdc42783          	lw	a5,-36(s0)
800042f6:	43d8                	lw	a4,4(a5)
800042f8:	4789                	li	a5,2
800042fa:	00f71463          	bne	a4,a5,80004302 <CRYPTO_SinglePerform+0x4e>
800042fe:	4789                	li	a5,2
80004300:	a011                	j	80004304 <CRYPTO_SinglePerform+0x50>
80004302:	4791                	li	a5,4
80004304:	fef42223          	sw	a5,-28(s0)
	CRYPTO_SetDataInBytes(data_in, block_size);
80004308:	fe442583          	lw	a1,-28(s0)
8000430c:	fd442503          	lw	a0,-44(s0)
80004310:	3d41                	jal	800041a0 <CRYPTO_SetDataInBytes>

	while (!CRYPTO_ReadyStatus()) {}
80004312:	0001                	nop
80004314:	34d1                	jal	80003dd8 <CRYPTO_ReadyStatus>
80004316:	87aa                	mv	a5,a0
80004318:	dff5                	beqz	a5,80004314 <CRYPTO_SinglePerform+0x60>

	CRYPTO_StartCmd();
8000431a:	3209                	jal	80003c1c <CRYPTO_StartCmd>

	while (!(CRYPTO->STATUS & CRYPTO_STATUS_KEYS_READY_Msk)) {}
8000431c:	0001                	nop
8000431e:	200207b7          	lui	a5,0x20020
80004322:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
80004326:	8b89                	andi	a5,a5,2
80004328:	dbfd                	beqz	a5,8000431e <CRYPTO_SinglePerform+0x6a>
	while (!(CRYPTO->STATUS & CRYPTO_STATUS_READY_Msk)) {}
8000432a:	0001                	nop
8000432c:	200207b7          	lui	a5,0x20020
80004330:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
80004334:	8b85                	andi	a5,a5,1
80004336:	dbfd                	beqz	a5,8000432c <CRYPTO_SinglePerform+0x78>

	if (crypto->Mode == CRYPTO_Mode_CBC && crypto->Direction == CRYPTO_Dir_Decrypt)
80004338:	fdc42783          	lw	a5,-36(s0)
8000433c:	4798                	lw	a4,8(a5)
8000433e:	4785                	li	a5,1
80004340:	00f71c63          	bne	a4,a5,80004358 <CRYPTO_SinglePerform+0xa4>
80004344:	fdc42783          	lw	a5,-36(s0)
80004348:	4398                	lw	a4,0(a5)
8000434a:	4785                	li	a5,1
8000434c:	00f71663          	bne	a4,a5,80004358 <CRYPTO_SinglePerform+0xa4>
	{
		CRYPTO_DirectionConfig(CRYPTO_Dir_Encrypt);
80004350:	4501                	li	a0,0
80004352:	30e5                	jal	80003c3a <CRYPTO_DirectionConfig>
		CRYPTO_ModeConfig(CRYPTO_Mode_ECB);
80004354:	4501                	li	a0,0
80004356:	3a35                	jal	80003c92 <CRYPTO_ModeConfig>
	}

	for (uint32_t i = 0; i < block_size; i++)
80004358:	fe042623          	sw	zero,-20(s0)
8000435c:	a0c9                	j	8000441e <CRYPTO_SinglePerform+0x16a>
	{
		uint32_t out_word = CRYPTO_GetTextOutput(i);
8000435e:	fec42503          	lw	a0,-20(s0)
80004362:	3c05                	jal	80003d92 <CRYPTO_GetTextOutput>
80004364:	fea42423          	sw	a0,-24(s0)
		out_word = (out_word >> 24) + ((out_word >> 8) & 0xFF00) + ((out_word << 8) & 0xFF0000) + (out_word << 24);
80004368:	fe842783          	lw	a5,-24(s0)
8000436c:	0187d713          	srli	a4,a5,0x18
80004370:	fe842783          	lw	a5,-24(s0)
80004374:	0087d693          	srli	a3,a5,0x8
80004378:	67c1                	lui	a5,0x10
8000437a:	f0078793          	addi	a5,a5,-256 # ff00 <STACK_SIZE+0xf700>
8000437e:	8ff5                	and	a5,a5,a3
80004380:	973e                	add	a4,a4,a5
80004382:	fe842783          	lw	a5,-24(s0)
80004386:	00879693          	slli	a3,a5,0x8
8000438a:	00ff07b7          	lui	a5,0xff0
8000438e:	8ff5                	and	a5,a5,a3
80004390:	973e                	add	a4,a4,a5
80004392:	fe842783          	lw	a5,-24(s0)
80004396:	07e2                	slli	a5,a5,0x18
80004398:	97ba                	add	a5,a5,a4
8000439a:	fef42423          	sw	a5,-24(s0)
		if (crypto->Mode == CRYPTO_Mode_CBC && crypto->Direction == CRYPTO_Dir_Decrypt)
8000439e:	fdc42783          	lw	a5,-36(s0)
800043a2:	4798                	lw	a4,8(a5)
800043a4:	4785                	li	a5,1
800043a6:	04f71d63          	bne	a4,a5,80004400 <CRYPTO_SinglePerform+0x14c>
800043aa:	fdc42783          	lw	a5,-36(s0)
800043ae:	4398                	lw	a4,0(a5)
800043b0:	4785                	li	a5,1
800043b2:	04f71763          	bne	a4,a5,80004400 <CRYPTO_SinglePerform+0x14c>
		{
			out_word ^= (iv[3] + (iv[2] << 8) + (iv[1] << 16) + (iv[0] << 24));
800043b6:	fd042783          	lw	a5,-48(s0)
800043ba:	078d                	addi	a5,a5,3 # ff0003 <STACK_SIZE+0xfef803>
800043bc:	0007c783          	lbu	a5,0(a5)
800043c0:	873e                	mv	a4,a5
800043c2:	fd042783          	lw	a5,-48(s0)
800043c6:	0789                	addi	a5,a5,2
800043c8:	0007c783          	lbu	a5,0(a5)
800043cc:	07a2                	slli	a5,a5,0x8
800043ce:	973e                	add	a4,a4,a5
800043d0:	fd042783          	lw	a5,-48(s0)
800043d4:	0785                	addi	a5,a5,1
800043d6:	0007c783          	lbu	a5,0(a5)
800043da:	07c2                	slli	a5,a5,0x10
800043dc:	973e                	add	a4,a4,a5
800043de:	fd042783          	lw	a5,-48(s0)
800043e2:	0007c783          	lbu	a5,0(a5)
800043e6:	07e2                	slli	a5,a5,0x18
800043e8:	97ba                	add	a5,a5,a4
800043ea:	873e                	mv	a4,a5
800043ec:	fe842783          	lw	a5,-24(s0)
800043f0:	8fb9                	xor	a5,a5,a4
800043f2:	fef42423          	sw	a5,-24(s0)
			iv += sizeof(uint32_t);
800043f6:	fd042783          	lw	a5,-48(s0)
800043fa:	0791                	addi	a5,a5,4
800043fc:	fcf42823          	sw	a5,-48(s0)
		}
		*((uint32_t *) data_out) = out_word;
80004400:	fcc42783          	lw	a5,-52(s0)
80004404:	fe842703          	lw	a4,-24(s0)
80004408:	c398                	sw	a4,0(a5)
		data_out += sizeof(uint32_t);
8000440a:	fcc42783          	lw	a5,-52(s0)
8000440e:	0791                	addi	a5,a5,4
80004410:	fcf42623          	sw	a5,-52(s0)
	for (uint32_t i = 0; i < block_size; i++)
80004414:	fec42783          	lw	a5,-20(s0)
80004418:	0785                	addi	a5,a5,1
8000441a:	fef42623          	sw	a5,-20(s0)
8000441e:	fec42703          	lw	a4,-20(s0)
80004422:	fe442783          	lw	a5,-28(s0)
80004426:	f2f76ce3          	bltu	a4,a5,8000435e <CRYPTO_SinglePerform+0xaa>
	}
}
8000442a:	0001                	nop
8000442c:	0001                	nop
8000442e:	50f2                	lw	ra,60(sp)
80004430:	5462                	lw	s0,56(sp)
80004432:	6121                	addi	sp,sp,64
80004434:	8082                	ret

80004436 <CRYPTO_CryptWithDMA>:
  *			     
  *	@param 	data_out   
  * @retval void
  */
void CRYPTO_CryptWithDMA(CRYPTO_Init_TypeDef* crypto, const unsigned char *key, const unsigned char *data_in, uint32_t data_in_size, const unsigned char* iv, unsigned char *data_out)
{
80004436:	7151                	addi	sp,sp,-240
80004438:	d786                	sw	ra,236(sp)
8000443a:	d5a2                	sw	s0,232(sp)
8000443c:	d3a6                	sw	s1,228(sp)
8000443e:	1980                	addi	s0,sp,240
80004440:	f2a42623          	sw	a0,-212(s0)
80004444:	f2b42423          	sw	a1,-216(s0)
80004448:	f2c42223          	sw	a2,-220(s0)
8000444c:	f2d42023          	sw	a3,-224(s0)
80004450:	f0e42e23          	sw	a4,-228(s0)
80004454:	f0f42c23          	sw	a5,-232(s0)
80004458:	ff040793          	addi	a5,s0,-16
8000445c:	f0f42a23          	sw	a5,-236(s0)
80004460:	f1442783          	lw	a5,-236(s0)
80004464:	f4078793          	addi	a5,a5,-192
80004468:	07f78793          	addi	a5,a5,127
8000446c:	839d                	srli	a5,a5,0x7
8000446e:	00779493          	slli	s1,a5,0x7
	CRYPTO_DMA_DESCR_TypeDef DMA_CTRLDATA __attribute__((aligned (0x80)));
	DMA_CTRLDATA.CONTROL = 0;
80004472:	0004a023          	sw	zero,0(s1)

	CRYPTO_DMAInit_TypeDef dma_init;

	if (key != NULL)
80004476:	f2842783          	lw	a5,-216(s0)
8000447a:	c791                	beqz	a5,80004486 <CRYPTO_CryptWithDMA+0x50>
		CRYPTO_SetKeyBytes(crypto, key);
8000447c:	f2842583          	lw	a1,-216(s0)
80004480:	f2c42503          	lw	a0,-212(s0)
80004484:	3b69                	jal	8000421e <CRYPTO_SetKeyBytes>
	if (iv != NULL)
80004486:	f1c42783          	lw	a5,-228(s0)
8000448a:	c781                	beqz	a5,80004492 <CRYPTO_CryptWithDMA+0x5c>
		CRYPTO_SetIVBytes(iv);
8000448c:	f1c42503          	lw	a0,-228(s0)
80004490:	2041                	jal	80004510 <CRYPTO_SetIVBytes>

	CRYPTO_DMAStructInit(&dma_init, crypto);
80004492:	fc840793          	addi	a5,s0,-56
80004496:	f2c42583          	lw	a1,-212(s0)
8000449a:	853e                	mv	a0,a5
8000449c:	3c6d                	jal	80003f56 <CRYPTO_DMAStructInit>
	dma_init.BlocksCount = data_in_size >> 3;
8000449e:	f2042783          	lw	a5,-224(s0)
800044a2:	838d                	srli	a5,a5,0x3
800044a4:	fcf42c23          	sw	a5,-40(s0)
	if (crypto->Algorithm != CRYPTO_Algo_MAGMA)
800044a8:	f2c42783          	lw	a5,-212(s0)
800044ac:	43d8                	lw	a4,4(a5)
800044ae:	4789                	li	a5,2
800044b0:	00f70763          	beq	a4,a5,800044be <CRYPTO_CryptWithDMA+0x88>
		dma_init.BlocksCount >>= 1;
800044b4:	fd842783          	lw	a5,-40(s0)
800044b8:	8385                	srli	a5,a5,0x1
800044ba:	fcf42c23          	sw	a5,-40(s0)
	--dma_init.BlocksCount; // n - 1 DMA
800044be:	fd842783          	lw	a5,-40(s0)
800044c2:	17fd                	addi	a5,a5,-1
800044c4:	fcf42c23          	sw	a5,-40(s0)

	dma_init.ByteSwap = ENABLE;
800044c8:	4785                	li	a5,1
800044ca:	fcf42423          	sw	a5,-56(s0)
	dma_init.DescriptorPtr = &DMA_CTRLDATA;
800044ce:	fe942623          	sw	s1,-20(s0)
	dma_init.SourceAddress = (void*) data_in;
800044d2:	f2442783          	lw	a5,-220(s0)
800044d6:	fef42223          	sw	a5,-28(s0)
	dma_init.DestinationAddress = (void*) data_out;
800044da:	f1842783          	lw	a5,-232(s0)
800044de:	fef42423          	sw	a5,-24(s0)

	while (!CRYPTO_ReadyStatus()) {}
800044e2:	0001                	nop
800044e4:	38d5                	jal	80003dd8 <CRYPTO_ReadyStatus>
800044e6:	87aa                	mv	a5,a0
800044e8:	dff5                	beqz	a5,800044e4 <CRYPTO_CryptWithDMA+0xae>

	CRPYTO_ProcessData(&dma_init);
800044ea:	fc840793          	addi	a5,s0,-56
800044ee:	853e                	mv	a0,a5
800044f0:	312d                	jal	8000411a <CRPYTO_ProcessData>

	while (CRYPTO_DMA_ActiveStatus()) {}
800044f2:	0001                	nop
800044f4:	3279                	jal	80003e82 <CRYPTO_DMA_ActiveStatus>
800044f6:	87aa                	mv	a5,a0
800044f8:	fff5                	bnez	a5,800044f4 <CRYPTO_CryptWithDMA+0xbe>
	while (!CRYPTO_ReadyStatus()) {}
800044fa:	0001                	nop
800044fc:	38f1                	jal	80003dd8 <CRYPTO_ReadyStatus>
800044fe:	87aa                	mv	a5,a0
80004500:	dff5                	beqz	a5,800044fc <CRYPTO_CryptWithDMA+0xc6>
}
80004502:	0001                	nop
80004504:	0001                	nop
80004506:	50be                	lw	ra,236(sp)
80004508:	542e                	lw	s0,232(sp)
8000450a:	549e                	lw	s1,228(sp)
8000450c:	616d                	addi	sp,sp,240
8000450e:	8082                	ret

80004510 <CRYPTO_SetIVBytes>:
  * @brief	     
  *	@param 	iv    
  * @retval void
  */
void CRYPTO_SetIVBytes(const unsigned char *iv)
{
80004510:	7179                	addi	sp,sp,-48
80004512:	d606                	sw	ra,44(sp)
80004514:	d422                	sw	s0,40(sp)
80004516:	1800                	addi	s0,sp,48
80004518:	fca42e23          	sw	a0,-36(s0)
	for(int i = 0; i < 4; i++)
8000451c:	fe042623          	sw	zero,-20(s0)
80004520:	a899                	j	80004576 <CRYPTO_SetIVBytes+0x66>
	{
		CRYPTO_SetInitVector(i, iv[3] + (iv[2] << 8) + (iv[1] << 16) + (iv[0] << 24));
80004522:	fec42683          	lw	a3,-20(s0)
80004526:	fdc42783          	lw	a5,-36(s0)
8000452a:	078d                	addi	a5,a5,3
8000452c:	0007c783          	lbu	a5,0(a5)
80004530:	873e                	mv	a4,a5
80004532:	fdc42783          	lw	a5,-36(s0)
80004536:	0789                	addi	a5,a5,2
80004538:	0007c783          	lbu	a5,0(a5)
8000453c:	07a2                	slli	a5,a5,0x8
8000453e:	973e                	add	a4,a4,a5
80004540:	fdc42783          	lw	a5,-36(s0)
80004544:	0785                	addi	a5,a5,1
80004546:	0007c783          	lbu	a5,0(a5)
8000454a:	07c2                	slli	a5,a5,0x10
8000454c:	973e                	add	a4,a4,a5
8000454e:	fdc42783          	lw	a5,-36(s0)
80004552:	0007c783          	lbu	a5,0(a5)
80004556:	07e2                	slli	a5,a5,0x18
80004558:	97ba                	add	a5,a5,a4
8000455a:	85be                	mv	a1,a5
8000455c:	8536                	mv	a0,a3
8000455e:	fb8ff0ef          	jal	ra,80003d16 <CRYPTO_SetInitVector>
		iv += sizeof(uint32_t);
80004562:	fdc42783          	lw	a5,-36(s0)
80004566:	0791                	addi	a5,a5,4
80004568:	fcf42e23          	sw	a5,-36(s0)
	for(int i = 0; i < 4; i++)
8000456c:	fec42783          	lw	a5,-20(s0)
80004570:	0785                	addi	a5,a5,1
80004572:	fef42623          	sw	a5,-20(s0)
80004576:	fec42703          	lw	a4,-20(s0)
8000457a:	478d                	li	a5,3
8000457c:	fae7d3e3          	bge	a5,a4,80004522 <CRYPTO_SetIVBytes+0x12>
	}
}
80004580:	0001                	nop
80004582:	0001                	nop
80004584:	50b2                	lw	ra,44(sp)
80004586:	5422                	lw	s0,40(sp)
80004588:	6145                	addi	sp,sp,48
8000458a:	8082                	ret

8000458c <CRYPTO_InitCryptoStructGCM>:
  *	@param	crypto   -     
  *	@param	phase   GCM
  * @retval void
  */
static void CRYPTO_InitCryptoStructGCM(CRYPTO_Init_TypeDef* descriptor_crypto, CRYPTO_Init_TypeDef* crypto, CRYPTO_GCM_PHASE_TypeDef phase)
{
8000458c:	1101                	addi	sp,sp,-32
8000458e:	ce06                	sw	ra,28(sp)
80004590:	cc22                	sw	s0,24(sp)
80004592:	1000                	addi	s0,sp,32
80004594:	fea42623          	sw	a0,-20(s0)
80004598:	feb42423          	sw	a1,-24(s0)
8000459c:	fec42223          	sw	a2,-28(s0)
	CRYPTO_StructInit(descriptor_crypto);
800045a0:	fec42503          	lw	a0,-20(s0)
800045a4:	3a85                	jal	80003f14 <CRYPTO_StructInit>

	descriptor_crypto->Algorithm = crypto->Algorithm;
800045a6:	fe842783          	lw	a5,-24(s0)
800045aa:	43d8                	lw	a4,4(a5)
800045ac:	fec42783          	lw	a5,-20(s0)
800045b0:	c3d8                	sw	a4,4(a5)
	descriptor_crypto->Direction = crypto->Direction;
800045b2:	fe842783          	lw	a5,-24(s0)
800045b6:	4398                	lw	a4,0(a5)
800045b8:	fec42783          	lw	a5,-20(s0)
800045bc:	c398                	sw	a4,0(a5)
	descriptor_crypto->Mode = CRYPTO_Mode_GCM;
800045be:	fec42783          	lw	a5,-20(s0)
800045c2:	470d                	li	a4,3
800045c4:	c798                	sw	a4,8(a5)
	descriptor_crypto->GCMPhase = phase;
800045c6:	fec42783          	lw	a5,-20(s0)
800045ca:	fe442703          	lw	a4,-28(s0)
800045ce:	cbd8                	sw	a4,20(a5)
}
800045d0:	0001                	nop
800045d2:	40f2                	lw	ra,28(sp)
800045d4:	4462                	lw	s0,24(sp)
800045d6:	6105                	addi	sp,sp,32
800045d8:	8082                	ret

800045da <CRYPTO_InitDescriptor>:
  *	@param	answer    
  * @retval void
  */
static void CRYPTO_InitDescriptor(CRYPTO_DMAInit_TypeDef* base, CRYPTO_Init_TypeDef* crypto, CRYPTO_DMAInit_TypeDef* next,
						CRYPTO_DMA_DESCR_TypeDef* dma_data, const uint32_t* src, uint32_t src_size, uint32_t* answer)
{
800045da:	7179                	addi	sp,sp,-48
800045dc:	d606                	sw	ra,44(sp)
800045de:	d422                	sw	s0,40(sp)
800045e0:	1800                	addi	s0,sp,48
800045e2:	fea42623          	sw	a0,-20(s0)
800045e6:	feb42423          	sw	a1,-24(s0)
800045ea:	fec42223          	sw	a2,-28(s0)
800045ee:	fed42023          	sw	a3,-32(s0)
800045f2:	fce42e23          	sw	a4,-36(s0)
800045f6:	fcf42c23          	sw	a5,-40(s0)
800045fa:	fd042a23          	sw	a6,-44(s0)
	CRYPTO_DMAStructInit(base, crypto);
800045fe:	fe842583          	lw	a1,-24(s0)
80004602:	fec42503          	lw	a0,-20(s0)
80004606:	3a81                	jal	80003f56 <CRYPTO_DMAStructInit>
	base->DescriptorPtr = dma_data;
80004608:	fec42783          	lw	a5,-20(s0)
8000460c:	fe042703          	lw	a4,-32(s0)
80004610:	d3d8                	sw	a4,36(a5)
	base->SourceAddress = (void*) src;
80004612:	fec42783          	lw	a5,-20(s0)
80004616:	fdc42703          	lw	a4,-36(s0)
8000461a:	cfd8                	sw	a4,28(a5)
	base->DestinationAddress = (void*) answer;
8000461c:	fec42783          	lw	a5,-20(s0)
80004620:	fd442703          	lw	a4,-44(s0)
80004624:	d398                	sw	a4,32(a5)

	base->ByteSwap = ENABLE;
80004626:	fec42783          	lw	a5,-20(s0)
8000462a:	4705                	li	a4,1
8000462c:	c398                	sw	a4,0(a5)
	base->BlocksCount = (src_size != 0) ? (src_size >> 4) - 1: 0;
8000462e:	fd842783          	lw	a5,-40(s0)
80004632:	c791                	beqz	a5,8000463e <CRYPTO_InitDescriptor+0x64>
80004634:	fd842783          	lw	a5,-40(s0)
80004638:	8391                	srli	a5,a5,0x4
8000463a:	17fd                	addi	a5,a5,-1
8000463c:	a011                	j	80004640 <CRYPTO_InitDescriptor+0x66>
8000463e:	4781                	li	a5,0
80004640:	fec42703          	lw	a4,-20(s0)
80004644:	cb1c                	sw	a5,16(a4)
	base->LastDescriptor = (next == NULL) ? ENABLE : DISABLE;
80004646:	fe442783          	lw	a5,-28(s0)
8000464a:	0017b793          	seqz	a5,a5
8000464e:	0ff7f793          	zext.b	a5,a5
80004652:	873e                	mv	a4,a5
80004654:	fec42783          	lw	a5,-20(s0)
80004658:	c798                	sw	a4,8(a5)

	base->NextDescriptor = next;
8000465a:	fec42783          	lw	a5,-20(s0)
8000465e:	fe442703          	lw	a4,-28(s0)
80004662:	cf98                	sw	a4,24(a5)
}
80004664:	0001                	nop
80004666:	50b2                	lw	ra,44(sp)
80004668:	5422                	lw	s0,40(sp)
8000466a:	6145                	addi	sp,sp,48
8000466c:	8082                	ret

8000466e <CRYPTO_CryptGCMWithDMA>:
  *	@param	tag  ,   
  * @retval uint32_t   
  */
uint32_t CRYPTO_CryptGCMWithDMA(CRYPTO_Init_TypeDef* crypto, const unsigned char *key, const uint32_t *data_in, uint32_t data_in_size,
									const unsigned char* iv, const uint32_t *additional, uint32_t additional_size, uint32_t *data_out, uint32_t *tag)
{
8000466e:	c9010113          	addi	sp,sp,-880
80004672:	36112623          	sw	ra,876(sp)
80004676:	36812423          	sw	s0,872(sp)
8000467a:	36912223          	sw	s1,868(sp)
8000467e:	1e80                	addi	s0,sp,880
80004680:	caa42e23          	sw	a0,-836(s0)
80004684:	cab42c23          	sw	a1,-840(s0)
80004688:	cac42a23          	sw	a2,-844(s0)
8000468c:	cad42823          	sw	a3,-848(s0)
80004690:	cae42623          	sw	a4,-852(s0)
80004694:	caf42423          	sw	a5,-856(s0)
80004698:	cb042223          	sw	a6,-860(s0)
8000469c:	cb142023          	sw	a7,-864(s0)
800046a0:	ff040793          	addi	a5,s0,-16
800046a4:	c8f42e23          	sw	a5,-868(s0)
800046a8:	c9c42783          	lw	a5,-868(s0)
800046ac:	cd078793          	addi	a5,a5,-816
800046b0:	07f78793          	addi	a5,a5,127
800046b4:	839d                	srli	a5,a5,0x7
800046b6:	00779493          	slli	s1,a5,0x7
	// cant use algorithm with 64 bit block size in GCM mode
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
800046ba:	cbc42783          	lw	a5,-836(s0)
800046be:	43d8                	lw	a4,4(a5)
800046c0:	4789                	li	a5,2
800046c2:	00f71463          	bne	a4,a5,800046ca <CRYPTO_CryptGCMWithDMA+0x5c>
		return 1;
800046c6:	4785                	li	a5,1
800046c8:	a25d                	j	8000486e <CRYPTO_CryptGCMWithDMA+0x200>

	CRYPTO_DMA_DESCR_TypeDef dma_init_data __attribute__((aligned (0x80)));
	CRYPTO_DMA_DESCR_TypeDef dma_payload_data __attribute__((aligned (0x80)));
	CRYPTO_DMA_DESCR_TypeDef dma_last_data __attribute__((aligned (0x80)));
	dma_init_data.CONTROL = 0;
800046ca:	1804a023          	sw	zero,384(s1)
	dma_payload_data.CONTROL = 0;
800046ce:	1004a023          	sw	zero,256(s1)
	dma_last_data.CONTROL = 0;
800046d2:	0804a023          	sw	zero,128(s1)

	CRYPTO_Init_TypeDef crypto_init, crypto_header, crypto_payload, crypto_last_block;

	crypto->InitVectorAutoUpdate = ENABLE;	// should be used for correct operation result
800046d6:	cbc42783          	lw	a5,-836(s0)
800046da:	4705                	li	a4,1
800046dc:	c7d8                	sw	a4,12(a5)
	CRYPTO_InitCryptoStructGCM(&crypto_init, crypto, CRYPTO_GCM_PHASE_INIT);
800046de:	fd040793          	addi	a5,s0,-48
800046e2:	4601                	li	a2,0
800046e4:	cbc42583          	lw	a1,-836(s0)
800046e8:	853e                	mv	a0,a5
800046ea:	354d                	jal	8000458c <CRYPTO_InitCryptoStructGCM>
	CRYPTO_InitCryptoStructGCM(&crypto_payload, crypto, CRYPTO_GCM_PHASE_PAYLOAD);
800046ec:	fa040793          	addi	a5,s0,-96
800046f0:	4609                	li	a2,2
800046f2:	cbc42583          	lw	a1,-836(s0)
800046f6:	853e                	mv	a0,a5
800046f8:	3d51                	jal	8000458c <CRYPTO_InitCryptoStructGCM>
	CRYPTO_InitCryptoStructGCM(&crypto_last_block, crypto, CRYPTO_GCM_PHASE_LAST_BLOCK);
800046fa:	f8840793          	addi	a5,s0,-120
800046fe:	460d                	li	a2,3
80004700:	cbc42583          	lw	a1,-836(s0)
80004704:	853e                	mv	a0,a5
80004706:	3559                	jal	8000458c <CRYPTO_InitCryptoStructGCM>

	CRYPTO_DMAInit_TypeDef dma_init, dma_header, dma_payload, dma_last;

	if (key != NULL)
80004708:	cb842783          	lw	a5,-840(s0)
8000470c:	c791                	beqz	a5,80004718 <CRYPTO_CryptGCMWithDMA+0xaa>
		CRYPTO_SetKeyBytes(crypto, key);
8000470e:	cb842583          	lw	a1,-840(s0)
80004712:	cbc42503          	lw	a0,-836(s0)
80004716:	3621                	jal	8000421e <CRYPTO_SetKeyBytes>
	if (iv != NULL)
80004718:	cac42783          	lw	a5,-852(s0)
8000471c:	c781                	beqz	a5,80004724 <CRYPTO_CryptGCMWithDMA+0xb6>
		CRYPTO_SetIVBytes(iv);
8000471e:	cac42503          	lw	a0,-852(s0)
80004722:	33fd                	jal	80004510 <CRYPTO_SetIVBytes>

	uint32_t add_size_bits = additional_size << 3;
80004724:	ca442783          	lw	a5,-860(s0)
80004728:	078e                	slli	a5,a5,0x3
8000472a:	fef42623          	sw	a5,-20(s0)
	uint32_t data_size_bits = data_in_size << 3;
8000472e:	cb042783          	lw	a5,-848(s0)
80004732:	078e                	slli	a5,a5,0x3
80004734:	fef42423          	sw	a5,-24(s0)
	const uint32_t tagger[] = {
80004738:	ec042c23          	sw	zero,-296(s0)
		0,
		((add_size_bits & 0x000000FF) << 24) + ((add_size_bits & 0x0000FF00) << 8) + ((add_size_bits & 0x00FF0000) >> 8) + ((add_size_bits & 0xFF000000) >> 24),
8000473c:	fec42783          	lw	a5,-20(s0)
80004740:	01879713          	slli	a4,a5,0x18
80004744:	fec42783          	lw	a5,-20(s0)
80004748:	00879693          	slli	a3,a5,0x8
8000474c:	00ff07b7          	lui	a5,0xff0
80004750:	8ff5                	and	a5,a5,a3
80004752:	973e                	add	a4,a4,a5
80004754:	fec42783          	lw	a5,-20(s0)
80004758:	0087d693          	srli	a3,a5,0x8
8000475c:	67c1                	lui	a5,0x10
8000475e:	f0078793          	addi	a5,a5,-256 # ff00 <STACK_SIZE+0xf700>
80004762:	8ff5                	and	a5,a5,a3
80004764:	973e                	add	a4,a4,a5
80004766:	fec42783          	lw	a5,-20(s0)
8000476a:	83e1                	srli	a5,a5,0x18
8000476c:	97ba                	add	a5,a5,a4
	const uint32_t tagger[] = {
8000476e:	ecf42e23          	sw	a5,-292(s0)
80004772:	ee042023          	sw	zero,-288(s0)
		0,
		((data_size_bits & 0x000000FF) << 24) + ((data_size_bits & 0x0000FF00) << 8) + ((data_size_bits & 0x00FF0000) >> 8) + ((data_size_bits & 0xFF000000) >> 24),
80004776:	fe842783          	lw	a5,-24(s0)
8000477a:	01879713          	slli	a4,a5,0x18
8000477e:	fe842783          	lw	a5,-24(s0)
80004782:	00879693          	slli	a3,a5,0x8
80004786:	00ff07b7          	lui	a5,0xff0
8000478a:	8ff5                	and	a5,a5,a3
8000478c:	973e                	add	a4,a4,a5
8000478e:	fe842783          	lw	a5,-24(s0)
80004792:	0087d693          	srli	a3,a5,0x8
80004796:	67c1                	lui	a5,0x10
80004798:	f0078793          	addi	a5,a5,-256 # ff00 <STACK_SIZE+0xf700>
8000479c:	8ff5                	and	a5,a5,a3
8000479e:	973e                	add	a4,a4,a5
800047a0:	fe842783          	lw	a5,-24(s0)
800047a4:	83e1                	srli	a5,a5,0x18
800047a6:	97ba                	add	a5,a5,a4
	const uint32_t tagger[] = {
800047a8:	eef42223          	sw	a5,-284(s0)
	};

	CRYPTO_InitDescriptor(&dma_init, &crypto_init, (additional_size != 0 && additional != NULL) ? &dma_header : &dma_payload, &dma_init_data, NULL, 0, NULL);
800047ac:	ca442783          	lw	a5,-860(s0)
800047b0:	c799                	beqz	a5,800047be <CRYPTO_CryptGCMWithDMA+0x150>
800047b2:	ca842783          	lw	a5,-856(s0)
800047b6:	c781                	beqz	a5,800047be <CRYPTO_CryptGCMWithDMA+0x150>
800047b8:	f3840613          	addi	a2,s0,-200
800047bc:	a019                	j	800047c2 <CRYPTO_CryptGCMWithDMA+0x154>
800047be:	f1040613          	addi	a2,s0,-240
800047c2:	18048693          	addi	a3,s1,384
800047c6:	fd040593          	addi	a1,s0,-48
800047ca:	f6040513          	addi	a0,s0,-160
800047ce:	4801                	li	a6,0
800047d0:	4781                	li	a5,0
800047d2:	4701                	li	a4,0
800047d4:	3519                	jal	800045da <CRYPTO_InitDescriptor>
	if (additional_size != 0 && additional != NULL)
800047d6:	ca442783          	lw	a5,-860(s0)
800047da:	cb95                	beqz	a5,8000480e <CRYPTO_CryptGCMWithDMA+0x1a0>
800047dc:	ca842783          	lw	a5,-856(s0)
800047e0:	c79d                	beqz	a5,8000480e <CRYPTO_CryptGCMWithDMA+0x1a0>
	{
		CRYPTO_DMA_DESCR_TypeDef dma_header_data __attribute__((aligned (0x80)));
		dma_header_data.CONTROL = 0;
800047e2:	0004a023          	sw	zero,0(s1)
		CRYPTO_InitCryptoStructGCM(&crypto_header, crypto, CRYPTO_GCM_PHASE_HEADER);
800047e6:	fb840793          	addi	a5,s0,-72
800047ea:	4605                	li	a2,1
800047ec:	cbc42583          	lw	a1,-836(s0)
800047f0:	853e                	mv	a0,a5
800047f2:	3b69                	jal	8000458c <CRYPTO_InitCryptoStructGCM>
		CRYPTO_InitDescriptor(&dma_header, &crypto_header, &dma_payload, &dma_header_data, additional, additional_size, NULL);
800047f4:	f1040613          	addi	a2,s0,-240
800047f8:	fb840593          	addi	a1,s0,-72
800047fc:	f3840513          	addi	a0,s0,-200
80004800:	4801                	li	a6,0
80004802:	ca442783          	lw	a5,-860(s0)
80004806:	ca842703          	lw	a4,-856(s0)
8000480a:	86a6                	mv	a3,s1
8000480c:	33f9                	jal	800045da <CRYPTO_InitDescriptor>
	}
	CRYPTO_InitDescriptor(&dma_payload, &crypto_payload, &dma_last, &dma_payload_data, data_in, data_in_size, data_out);
8000480e:	10048693          	addi	a3,s1,256
80004812:	ee840613          	addi	a2,s0,-280
80004816:	fa040593          	addi	a1,s0,-96
8000481a:	f1040513          	addi	a0,s0,-240
8000481e:	ca042803          	lw	a6,-864(s0)
80004822:	cb042783          	lw	a5,-848(s0)
80004826:	cb442703          	lw	a4,-844(s0)
8000482a:	3b45                	jal	800045da <CRYPTO_InitDescriptor>
	CRYPTO_InitDescriptor(&dma_last, &crypto_last_block, NULL, &dma_last_data, tagger, 0, tag);
8000482c:	ed840713          	addi	a4,s0,-296
80004830:	08048693          	addi	a3,s1,128
80004834:	f8840593          	addi	a1,s0,-120
80004838:	ee840513          	addi	a0,s0,-280
8000483c:	00042803          	lw	a6,0(s0)
80004840:	4781                	li	a5,0
80004842:	4601                	li	a2,0
80004844:	3b59                	jal	800045da <CRYPTO_InitDescriptor>

	while (!CRYPTO_ReadyStatus()) {}
80004846:	0001                	nop
80004848:	d90ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
8000484c:	87aa                	mv	a5,a0
8000484e:	dfed                	beqz	a5,80004848 <CRYPTO_CryptGCMWithDMA+0x1da>

	CRPYTO_ProcessData(&dma_init);
80004850:	f6040793          	addi	a5,s0,-160
80004854:	853e                	mv	a0,a5
80004856:	30d1                	jal	8000411a <CRPYTO_ProcessData>

	while (CRYPTO_DMA_ActiveStatus()) {}
80004858:	0001                	nop
8000485a:	e28ff0ef          	jal	ra,80003e82 <CRYPTO_DMA_ActiveStatus>
8000485e:	87aa                	mv	a5,a0
80004860:	ffed                	bnez	a5,8000485a <CRYPTO_CryptGCMWithDMA+0x1ec>
	while (!CRYPTO_ReadyStatus()) {}
80004862:	0001                	nop
80004864:	d74ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
80004868:	87aa                	mv	a5,a0
8000486a:	dfed                	beqz	a5,80004864 <CRYPTO_CryptGCMWithDMA+0x1f6>

	return 0;
8000486c:	4781                	li	a5,0
}
8000486e:	853e                	mv	a0,a5
80004870:	36c12083          	lw	ra,876(sp)
80004874:	36812403          	lw	s0,872(sp)
80004878:	36412483          	lw	s1,868(sp)
8000487c:	37010113          	addi	sp,sp,880
80004880:	8082                	ret

80004882 <CRYPTO_GCMInitPhase>:
  * @param	crypto     @ref CREYPTO_Init_TypeDef,   
  *	@param 	iv    
  * @retval uint32_t   
  */
uint32_t CRYPTO_GCMInitPhase(CRYPTO_Init_TypeDef* crypto, const unsigned char *iv)
{
80004882:	1101                	addi	sp,sp,-32
80004884:	ce06                	sw	ra,28(sp)
80004886:	cc22                	sw	s0,24(sp)
80004888:	1000                	addi	s0,sp,32
8000488a:	fea42623          	sw	a0,-20(s0)
8000488e:	feb42423          	sw	a1,-24(s0)
	// cant use algorithm with 64 bit block size in GCM mode
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
80004892:	fec42783          	lw	a5,-20(s0)
80004896:	43d8                	lw	a4,4(a5)
80004898:	4789                	li	a5,2
8000489a:	00f71463          	bne	a4,a5,800048a2 <CRYPTO_GCMInitPhase+0x20>
		return 1;
8000489e:	4785                	li	a5,1
800048a0:	a82d                	j	800048da <CRYPTO_GCMInitPhase+0x58>

	CRYPTO_SetIVBytes(iv);
800048a2:	fe842503          	lw	a0,-24(s0)
800048a6:	31ad                	jal	80004510 <CRYPTO_SetIVBytes>

	crypto->GCMPhase = CRYPTO_GCM_PHASE_INIT;
800048a8:	fec42783          	lw	a5,-20(s0)
800048ac:	0007aa23          	sw	zero,20(a5)
	crypto->InitVectorAutoUpdate = ENABLE;
800048b0:	fec42783          	lw	a5,-20(s0)
800048b4:	4705                	li	a4,1
800048b6:	c7d8                	sw	a4,12(a5)

	CRYPTO_Init(crypto);
800048b8:	fec42503          	lw	a0,-20(s0)
800048bc:	e06ff0ef          	jal	ra,80003ec2 <CRYPTO_Init>

	while (!CRYPTO_ReadyStatus()) {}
800048c0:	0001                	nop
800048c2:	d16ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
800048c6:	87aa                	mv	a5,a0
800048c8:	dfed                	beqz	a5,800048c2 <CRYPTO_GCMInitPhase+0x40>
	CRYPTO_StartCmd();
800048ca:	b52ff0ef          	jal	ra,80003c1c <CRYPTO_StartCmd>
	while (!CRYPTO_ReadyStatus()) {}
800048ce:	0001                	nop
800048d0:	d08ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
800048d4:	87aa                	mv	a5,a0
800048d6:	dfed                	beqz	a5,800048d0 <CRYPTO_GCMInitPhase+0x4e>

	return 0;
800048d8:	4781                	li	a5,0
}
800048da:	853e                	mv	a0,a5
800048dc:	40f2                	lw	ra,28(sp)
800048de:	4462                	lw	s0,24(sp)
800048e0:	6105                	addi	sp,sp,32
800048e2:	8082                	ret

800048e4 <CRYPTO_GCMHeaderPhase>:
  *	@param 	additional     
  *	@param	additional_size    
  * @retval uint32_t   
  */
uint32_t CRYPTO_GCMHeaderPhase(CRYPTO_Init_TypeDef* crypto, const unsigned char *additional, uint32_t additional_size)
{
800048e4:	7179                	addi	sp,sp,-48
800048e6:	d606                	sw	ra,44(sp)
800048e8:	d422                	sw	s0,40(sp)
800048ea:	1800                	addi	s0,sp,48
800048ec:	fca42e23          	sw	a0,-36(s0)
800048f0:	fcb42c23          	sw	a1,-40(s0)
800048f4:	fcc42a23          	sw	a2,-44(s0)
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
800048f8:	fdc42783          	lw	a5,-36(s0)
800048fc:	43d8                	lw	a4,4(a5)
800048fe:	4789                	li	a5,2
80004900:	00f71463          	bne	a4,a5,80004908 <CRYPTO_GCMHeaderPhase+0x24>
		return 1;
80004904:	4785                	li	a5,1
80004906:	a0b9                	j	80004954 <CRYPTO_GCMHeaderPhase+0x70>

	CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_HEADER);
80004908:	4505                	li	a0,1
8000490a:	bb4ff0ef          	jal	ra,80003cbe <CRYPTO_GCMPhaseConfig>

	for(uint32_t i = 0; i < additional_size; i += 16)
8000490e:	fe042623          	sw	zero,-20(s0)
80004912:	a815                	j	80004946 <CRYPTO_GCMHeaderPhase+0x62>
	{
		CRYPTO_SetDataInBytes(additional + i, 4);
80004914:	fd842703          	lw	a4,-40(s0)
80004918:	fec42783          	lw	a5,-20(s0)
8000491c:	97ba                	add	a5,a5,a4
8000491e:	4591                	li	a1,4
80004920:	853e                	mv	a0,a5
80004922:	38bd                	jal	800041a0 <CRYPTO_SetDataInBytes>

		while (!CRYPTO_ReadyStatus()) {}
80004924:	0001                	nop
80004926:	cb2ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
8000492a:	87aa                	mv	a5,a0
8000492c:	dfed                	beqz	a5,80004926 <CRYPTO_GCMHeaderPhase+0x42>
		CRYPTO_StartCmd();
8000492e:	aeeff0ef          	jal	ra,80003c1c <CRYPTO_StartCmd>
		while (!CRYPTO_ReadyStatus()) {}
80004932:	0001                	nop
80004934:	ca4ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
80004938:	87aa                	mv	a5,a0
8000493a:	dfed                	beqz	a5,80004934 <CRYPTO_GCMHeaderPhase+0x50>
	for(uint32_t i = 0; i < additional_size; i += 16)
8000493c:	fec42783          	lw	a5,-20(s0)
80004940:	07c1                	addi	a5,a5,16
80004942:	fef42623          	sw	a5,-20(s0)
80004946:	fec42703          	lw	a4,-20(s0)
8000494a:	fd442783          	lw	a5,-44(s0)
8000494e:	fcf763e3          	bltu	a4,a5,80004914 <CRYPTO_GCMHeaderPhase+0x30>
	}

	return 0;
80004952:	4781                	li	a5,0
}
80004954:	853e                	mv	a0,a5
80004956:	50b2                	lw	ra,44(sp)
80004958:	5422                	lw	s0,40(sp)
8000495a:	6145                	addi	sp,sp,48
8000495c:	8082                	ret

8000495e <CRYPTO_GCMPayloadPhase>:
  *	@param	input_length   
  *	@param	output   
  * @retval uint32_t   
  */
uint32_t CRYPTO_GCMPayloadPhase(CRYPTO_Init_TypeDef* crypto, const unsigned char *input, uint32_t input_length, unsigned char *output)
{
8000495e:	7179                	addi	sp,sp,-48
80004960:	d606                	sw	ra,44(sp)
80004962:	d422                	sw	s0,40(sp)
80004964:	1800                	addi	s0,sp,48
80004966:	fca42e23          	sw	a0,-36(s0)
8000496a:	fcb42c23          	sw	a1,-40(s0)
8000496e:	fcc42a23          	sw	a2,-44(s0)
80004972:	fcd42823          	sw	a3,-48(s0)
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
80004976:	fdc42783          	lw	a5,-36(s0)
8000497a:	43d8                	lw	a4,4(a5)
8000497c:	4789                	li	a5,2
8000497e:	00f71463          	bne	a4,a5,80004986 <CRYPTO_GCMPayloadPhase+0x28>
		return 1;
80004982:	4785                	li	a5,1
80004984:	a221                	j	80004a8c <CRYPTO_GCMPayloadPhase+0x12e>

	CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_PAYLOAD);
80004986:	4509                	li	a0,2
80004988:	b36ff0ef          	jal	ra,80003cbe <CRYPTO_GCMPhaseConfig>

	for(uint32_t i = 0; i < input_length; i += 16)
8000498c:	fe042623          	sw	zero,-20(s0)
80004990:	a0fd                	j	80004a7e <CRYPTO_GCMPayloadPhase+0x120>
	{
		CRYPTO_SetDataInBytes(input + i, 4);
80004992:	fd842703          	lw	a4,-40(s0)
80004996:	fec42783          	lw	a5,-20(s0)
8000499a:	97ba                	add	a5,a5,a4
8000499c:	4591                	li	a1,4
8000499e:	853e                	mv	a0,a5
800049a0:	801ff0ef          	jal	ra,800041a0 <CRYPTO_SetDataInBytes>

		while (!CRYPTO_ReadyStatus()) {}
800049a4:	0001                	nop
800049a6:	c32ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
800049aa:	87aa                	mv	a5,a0
800049ac:	dfed                	beqz	a5,800049a6 <CRYPTO_GCMPayloadPhase+0x48>
		CRYPTO_StartCmd();
800049ae:	a6eff0ef          	jal	ra,80003c1c <CRYPTO_StartCmd>
		while (!CRYPTO_ReadyStatus()) {}
800049b2:	0001                	nop
800049b4:	c24ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
800049b8:	87aa                	mv	a5,a0
800049ba:	dfed                	beqz	a5,800049b4 <CRYPTO_GCMPayloadPhase+0x56>

		for(uint32_t j = 0; j < 4; j++)
800049bc:	fe042423          	sw	zero,-24(s0)
800049c0:	a06d                	j	80004a6a <CRYPTO_GCMPayloadPhase+0x10c>
		{
			uint32_t output_word = CRYPTO_GetTextOutput(j);
800049c2:	fe842503          	lw	a0,-24(s0)
800049c6:	bccff0ef          	jal	ra,80003d92 <CRYPTO_GetTextOutput>
800049ca:	fea42223          	sw	a0,-28(s0)

			output[i + (j << 2)    ] = (output_word & 0x000000FF);
800049ce:	fe842783          	lw	a5,-24(s0)
800049d2:	00279713          	slli	a4,a5,0x2
800049d6:	fec42783          	lw	a5,-20(s0)
800049da:	97ba                	add	a5,a5,a4
800049dc:	fd042703          	lw	a4,-48(s0)
800049e0:	97ba                	add	a5,a5,a4
800049e2:	fe442703          	lw	a4,-28(s0)
800049e6:	0ff77713          	zext.b	a4,a4
800049ea:	00e78023          	sb	a4,0(a5)
			output[i + (j << 2) + 1] = (output_word & 0x0000FF00) >> 8;
800049ee:	fe442783          	lw	a5,-28(s0)
800049f2:	0087d693          	srli	a3,a5,0x8
800049f6:	fe842783          	lw	a5,-24(s0)
800049fa:	00279713          	slli	a4,a5,0x2
800049fe:	fec42783          	lw	a5,-20(s0)
80004a02:	97ba                	add	a5,a5,a4
80004a04:	0785                	addi	a5,a5,1
80004a06:	fd042703          	lw	a4,-48(s0)
80004a0a:	97ba                	add	a5,a5,a4
80004a0c:	0ff6f713          	zext.b	a4,a3
80004a10:	00e78023          	sb	a4,0(a5)
			output[i + (j << 2) + 2] = (output_word & 0x00FF0000) >> 16;
80004a14:	fe442783          	lw	a5,-28(s0)
80004a18:	0107d693          	srli	a3,a5,0x10
80004a1c:	fe842783          	lw	a5,-24(s0)
80004a20:	00279713          	slli	a4,a5,0x2
80004a24:	fec42783          	lw	a5,-20(s0)
80004a28:	97ba                	add	a5,a5,a4
80004a2a:	0789                	addi	a5,a5,2
80004a2c:	fd042703          	lw	a4,-48(s0)
80004a30:	97ba                	add	a5,a5,a4
80004a32:	0ff6f713          	zext.b	a4,a3
80004a36:	00e78023          	sb	a4,0(a5)
			output[i + (j << 2) + 3] = (output_word & 0xFF000000) >> 24;
80004a3a:	fe442783          	lw	a5,-28(s0)
80004a3e:	0187d693          	srli	a3,a5,0x18
80004a42:	fe842783          	lw	a5,-24(s0)
80004a46:	00279713          	slli	a4,a5,0x2
80004a4a:	fec42783          	lw	a5,-20(s0)
80004a4e:	97ba                	add	a5,a5,a4
80004a50:	078d                	addi	a5,a5,3
80004a52:	fd042703          	lw	a4,-48(s0)
80004a56:	97ba                	add	a5,a5,a4
80004a58:	0ff6f713          	zext.b	a4,a3
80004a5c:	00e78023          	sb	a4,0(a5)
		for(uint32_t j = 0; j < 4; j++)
80004a60:	fe842783          	lw	a5,-24(s0)
80004a64:	0785                	addi	a5,a5,1
80004a66:	fef42423          	sw	a5,-24(s0)
80004a6a:	fe842703          	lw	a4,-24(s0)
80004a6e:	478d                	li	a5,3
80004a70:	f4e7f9e3          	bgeu	a5,a4,800049c2 <CRYPTO_GCMPayloadPhase+0x64>
	for(uint32_t i = 0; i < input_length; i += 16)
80004a74:	fec42783          	lw	a5,-20(s0)
80004a78:	07c1                	addi	a5,a5,16
80004a7a:	fef42623          	sw	a5,-20(s0)
80004a7e:	fec42703          	lw	a4,-20(s0)
80004a82:	fd442783          	lw	a5,-44(s0)
80004a86:	f0f766e3          	bltu	a4,a5,80004992 <CRYPTO_GCMPayloadPhase+0x34>
		}
	}

	return 0;
80004a8a:	4781                	li	a5,0
}
80004a8c:	853e                	mv	a0,a5
80004a8e:	50b2                	lw	ra,44(sp)
80004a90:	5422                	lw	s0,40(sp)
80004a92:	6145                	addi	sp,sp,48
80004a94:	8082                	ret

80004a96 <CRYPTO_GCMLastBlockPhase>:
  *	@param	payload_size  ,  ,     
  *	@param	tag	  ,   16 
  * @retval uint32_t   
  */
uint32_t CRYPTO_GCMLastBlockPhase(CRYPTO_Init_TypeDef* crypto, uint32_t additional_size, uint32_t payload_size, unsigned char *tag)
{
80004a96:	7179                	addi	sp,sp,-48
80004a98:	d606                	sw	ra,44(sp)
80004a9a:	d422                	sw	s0,40(sp)
80004a9c:	1800                	addi	s0,sp,48
80004a9e:	fca42e23          	sw	a0,-36(s0)
80004aa2:	fcb42c23          	sw	a1,-40(s0)
80004aa6:	fcc42a23          	sw	a2,-44(s0)
80004aaa:	fcd42823          	sw	a3,-48(s0)
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
80004aae:	fdc42783          	lw	a5,-36(s0)
80004ab2:	43d8                	lw	a4,4(a5)
80004ab4:	4789                	li	a5,2
80004ab6:	00f71463          	bne	a4,a5,80004abe <CRYPTO_GCMLastBlockPhase+0x28>
		return 1;
80004aba:	4785                	li	a5,1
80004abc:	a0cd                	j	80004b9e <CRYPTO_GCMLastBlockPhase+0x108>

	CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_LAST_BLOCK);
80004abe:	450d                	li	a0,3
80004ac0:	9feff0ef          	jal	ra,80003cbe <CRYPTO_GCMPhaseConfig>

	CRYPTO_SetTextInput(0, 0);
80004ac4:	4581                	li	a1,0
80004ac6:	4501                	li	a0,0
80004ac8:	a76ff0ef          	jal	ra,80003d3e <CRYPTO_SetTextInput>
	CRYPTO_SetTextInput(2, 0);
80004acc:	4581                	li	a1,0
80004ace:	4509                	li	a0,2
80004ad0:	a6eff0ef          	jal	ra,80003d3e <CRYPTO_SetTextInput>
	CRYPTO_SetTextInput(1, additional_size << 3);
80004ad4:	fd842783          	lw	a5,-40(s0)
80004ad8:	078e                	slli	a5,a5,0x3
80004ada:	85be                	mv	a1,a5
80004adc:	4505                	li	a0,1
80004ade:	a60ff0ef          	jal	ra,80003d3e <CRYPTO_SetTextInput>
	CRYPTO_SetTextInput(3, payload_size << 3);
80004ae2:	fd442783          	lw	a5,-44(s0)
80004ae6:	078e                	slli	a5,a5,0x3
80004ae8:	85be                	mv	a1,a5
80004aea:	450d                	li	a0,3
80004aec:	a52ff0ef          	jal	ra,80003d3e <CRYPTO_SetTextInput>

	while (!CRYPTO_ReadyStatus()) {}
80004af0:	0001                	nop
80004af2:	ae6ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
80004af6:	87aa                	mv	a5,a0
80004af8:	dfed                	beqz	a5,80004af2 <CRYPTO_GCMLastBlockPhase+0x5c>
	CRYPTO_StartCmd();
80004afa:	922ff0ef          	jal	ra,80003c1c <CRYPTO_StartCmd>
	while (!CRYPTO_ReadyStatus()) {}
80004afe:	0001                	nop
80004b00:	ad8ff0ef          	jal	ra,80003dd8 <CRYPTO_ReadyStatus>
80004b04:	87aa                	mv	a5,a0
80004b06:	dfed                	beqz	a5,80004b00 <CRYPTO_GCMLastBlockPhase+0x6a>

	for(uint32_t i = 0; i < 16; i += 4)
80004b08:	fe042623          	sw	zero,-20(s0)
80004b0c:	a059                	j	80004b92 <CRYPTO_GCMLastBlockPhase+0xfc>
	{
		uint32_t output_word = CRYPTO_GetGCMTag(i >> 2);
80004b0e:	fec42783          	lw	a5,-20(s0)
80004b12:	8389                	srli	a5,a5,0x2
80004b14:	853e                	mv	a0,a5
80004b16:	a9eff0ef          	jal	ra,80003db4 <CRYPTO_GetGCMTag>
80004b1a:	fea42423          	sw	a0,-24(s0)

		tag[i    ] = (output_word & 0x000000FF);
80004b1e:	fd042703          	lw	a4,-48(s0)
80004b22:	fec42783          	lw	a5,-20(s0)
80004b26:	97ba                	add	a5,a5,a4
80004b28:	fe842703          	lw	a4,-24(s0)
80004b2c:	0ff77713          	zext.b	a4,a4
80004b30:	00e78023          	sb	a4,0(a5)
		tag[i + 1] = (output_word & 0x0000FF00) >> 8;
80004b34:	fe842783          	lw	a5,-24(s0)
80004b38:	0087d693          	srli	a3,a5,0x8
80004b3c:	fec42783          	lw	a5,-20(s0)
80004b40:	0785                	addi	a5,a5,1
80004b42:	fd042703          	lw	a4,-48(s0)
80004b46:	97ba                	add	a5,a5,a4
80004b48:	0ff6f713          	zext.b	a4,a3
80004b4c:	00e78023          	sb	a4,0(a5)
		tag[i + 2] = (output_word & 0x00FF0000) >> 16;
80004b50:	fe842783          	lw	a5,-24(s0)
80004b54:	0107d693          	srli	a3,a5,0x10
80004b58:	fec42783          	lw	a5,-20(s0)
80004b5c:	0789                	addi	a5,a5,2
80004b5e:	fd042703          	lw	a4,-48(s0)
80004b62:	97ba                	add	a5,a5,a4
80004b64:	0ff6f713          	zext.b	a4,a3
80004b68:	00e78023          	sb	a4,0(a5)
		tag[i + 3] = (output_word & 0xFF000000) >> 24;
80004b6c:	fe842783          	lw	a5,-24(s0)
80004b70:	0187d693          	srli	a3,a5,0x18
80004b74:	fec42783          	lw	a5,-20(s0)
80004b78:	078d                	addi	a5,a5,3
80004b7a:	fd042703          	lw	a4,-48(s0)
80004b7e:	97ba                	add	a5,a5,a4
80004b80:	0ff6f713          	zext.b	a4,a3
80004b84:	00e78023          	sb	a4,0(a5)
	for(uint32_t i = 0; i < 16; i += 4)
80004b88:	fec42783          	lw	a5,-20(s0)
80004b8c:	0791                	addi	a5,a5,4
80004b8e:	fef42623          	sw	a5,-20(s0)
80004b92:	fec42703          	lw	a4,-20(s0)
80004b96:	47bd                	li	a5,15
80004b98:	f6e7fbe3          	bgeu	a5,a4,80004b0e <CRYPTO_GCMLastBlockPhase+0x78>
	}

	return 0;
80004b9c:	4781                	li	a5,0
}
80004b9e:	853e                	mv	a0,a5
80004ba0:	50b2                	lw	ra,44(sp)
80004ba2:	5422                	lw	s0,40(sp)
80004ba4:	6145                	addi	sp,sp,48
80004ba6:	8082                	ret

80004ba8 <DMA_ProtectConfig>:
  * @brief         DMA   
  * @param   CtrlProtect  ,   
  * @retval  void
  */
__STATIC_INLINE void DMA_ProtectConfig(DMA_Protect_TypeDef* CtrlProtect)
{
80004ba8:	1101                	addi	sp,sp,-32
80004baa:	ce22                	sw	s0,28(sp)
80004bac:	1000                	addi	s0,sp,32
80004bae:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Bufferable));
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Cacheable));
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Priveleged));

    MODIFY_REG(DMA->CFG, DMA_CFG_CHPROT_Msk, ((CtrlProtect->Priveleged << (DMA_CFG_CHPROT_Pos + 0)) |
80004bb2:	3000c7b7          	lui	a5,0x3000c
80004bb6:	43dc                	lw	a5,4(a5)
80004bb8:	ff87f693          	andi	a3,a5,-8
80004bbc:	fec42783          	lw	a5,-20(s0)
80004bc0:	4398                	lw	a4,0(a5)
80004bc2:	fec42783          	lw	a5,-20(s0)
80004bc6:	43dc                	lw	a5,4(a5)
80004bc8:	0786                	slli	a5,a5,0x1
80004bca:	8f5d                	or	a4,a4,a5
80004bcc:	fec42783          	lw	a5,-20(s0)
80004bd0:	479c                	lw	a5,8(a5)
80004bd2:	078a                	slli	a5,a5,0x2
80004bd4:	8f5d                	or	a4,a4,a5
80004bd6:	3000c7b7          	lui	a5,0x3000c
80004bda:	8f55                	or	a4,a4,a3
80004bdc:	c3d8                	sw	a4,4(a5)
                                              (CtrlProtect->Bufferable << (DMA_CFG_CHPROT_Pos + 1)) |
                                              (CtrlProtect->Cacheable << (DMA_CFG_CHPROT_Pos + 2))));
}
80004bde:	0001                	nop
80004be0:	4472                	lw	s0,28(sp)
80004be2:	6105                	addi	sp,sp,32
80004be4:	8082                	ret

80004be6 <DMA_UseBurstCmd>:
  *                        DMA_Channel_x  @ref DMA_Channel_Define.
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void DMA_UseBurstCmd(uint32_t Channel, FunctionalState State)
{
80004be6:	1101                	addi	sp,sp,-32
80004be8:	ce22                	sw	s0,28(sp)
80004bea:	1000                	addi	s0,sp,32
80004bec:	fea42623          	sw	a0,-20(s0)
80004bf0:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80004bf4:	fe842703          	lw	a4,-24(s0)
80004bf8:	4785                	li	a5,1
80004bfa:	00f71863          	bne	a4,a5,80004c0a <DMA_UseBurstCmd+0x24>
        WRITE_REG(DMA->USEBURSTSET, Channel);
80004bfe:	3000c7b7          	lui	a5,0x3000c
80004c02:	fec42703          	lw	a4,-20(s0)
80004c06:	cf98                	sw	a4,24(a5)
    else
        WRITE_REG(DMA->USEBURSTCLR, Channel);
}
80004c08:	a031                	j	80004c14 <DMA_UseBurstCmd+0x2e>
        WRITE_REG(DMA->USEBURSTCLR, Channel);
80004c0a:	3000c7b7          	lui	a5,0x3000c
80004c0e:	fec42703          	lw	a4,-20(s0)
80004c12:	cfd8                	sw	a4,28(a5)
}
80004c14:	0001                	nop
80004c16:	4472                	lw	s0,28(sp)
80004c18:	6105                	addi	sp,sp,32
80004c1a:	8082                	ret

80004c1c <DMA_ReqMaskCmd>:
  *                           DMA_Channel_x  @ref DMA_Channel_Define.
  * @param      State   
  * @retval     void
  */
__STATIC_INLINE void DMA_ReqMaskCmd(uint32_t Channel, FunctionalState State)
{
80004c1c:	1101                	addi	sp,sp,-32
80004c1e:	ce22                	sw	s0,28(sp)
80004c20:	1000                	addi	s0,sp,32
80004c22:	fea42623          	sw	a0,-20(s0)
80004c26:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80004c2a:	fe842703          	lw	a4,-24(s0)
80004c2e:	4785                	li	a5,1
80004c30:	00f71863          	bne	a4,a5,80004c40 <DMA_ReqMaskCmd+0x24>
        WRITE_REG(DMA->REQMASKSET, Channel);
80004c34:	3000c7b7          	lui	a5,0x3000c
80004c38:	fec42703          	lw	a4,-20(s0)
80004c3c:	d398                	sw	a4,32(a5)
    else
        WRITE_REG(DMA->REQMASKCLR, Channel);
}
80004c3e:	a031                	j	80004c4a <DMA_ReqMaskCmd+0x2e>
        WRITE_REG(DMA->REQMASKCLR, Channel);
80004c40:	3000c7b7          	lui	a5,0x3000c
80004c44:	fec42703          	lw	a4,-20(s0)
80004c48:	d3d8                	sw	a4,36(a5)
}
80004c4a:	0001                	nop
80004c4c:	4472                	lw	s0,28(sp)
80004c4e:	6105                	addi	sp,sp,32
80004c50:	8082                	ret

80004c52 <DMA_ChannelEnableCmd>:
  *                        DMA_Channel_x  @ref DMA_Channel_Define.
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void DMA_ChannelEnableCmd(uint32_t Channel, FunctionalState State)
{
80004c52:	1101                	addi	sp,sp,-32
80004c54:	ce22                	sw	s0,28(sp)
80004c56:	1000                	addi	s0,sp,32
80004c58:	fea42623          	sw	a0,-20(s0)
80004c5c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80004c60:	fe842703          	lw	a4,-24(s0)
80004c64:	4785                	li	a5,1
80004c66:	00f71863          	bne	a4,a5,80004c76 <DMA_ChannelEnableCmd+0x24>
        WRITE_REG(DMA->ENSET, Channel);
80004c6a:	3000c7b7          	lui	a5,0x3000c
80004c6e:	fec42703          	lw	a4,-20(s0)
80004c72:	d798                	sw	a4,40(a5)
    else
        WRITE_REG(DMA->ENCLR, Channel);
}
80004c74:	a031                	j	80004c80 <DMA_ChannelEnableCmd+0x2e>
        WRITE_REG(DMA->ENCLR, Channel);
80004c76:	3000c7b7          	lui	a5,0x3000c
80004c7a:	fec42703          	lw	a4,-20(s0)
80004c7e:	d7d8                	sw	a4,44(a5)
}
80004c80:	0001                	nop
80004c82:	4472                	lw	s0,28(sp)
80004c84:	6105                	addi	sp,sp,32
80004c86:	8082                	ret

80004c88 <DMA_AltCtrlCmd>:
  *                        DMA_Channel_x  @ref DMA_Channel_Define.
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void DMA_AltCtrlCmd(uint32_t Channel, FunctionalState State)
{
80004c88:	1101                	addi	sp,sp,-32
80004c8a:	ce22                	sw	s0,28(sp)
80004c8c:	1000                	addi	s0,sp,32
80004c8e:	fea42623          	sw	a0,-20(s0)
80004c92:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80004c96:	fe842703          	lw	a4,-24(s0)
80004c9a:	4785                	li	a5,1
80004c9c:	00f71863          	bne	a4,a5,80004cac <DMA_AltCtrlCmd+0x24>
        WRITE_REG(DMA->PRIALTSET, Channel);
80004ca0:	3000c7b7          	lui	a5,0x3000c
80004ca4:	fec42703          	lw	a4,-20(s0)
80004ca8:	db98                	sw	a4,48(a5)
    else
        WRITE_REG(DMA->PRIALTCLR, Channel);
}
80004caa:	a031                	j	80004cb6 <DMA_AltCtrlCmd+0x2e>
        WRITE_REG(DMA->PRIALTCLR, Channel);
80004cac:	3000c7b7          	lui	a5,0x3000c
80004cb0:	fec42703          	lw	a4,-20(s0)
80004cb4:	dbd8                	sw	a4,52(a5)
}
80004cb6:	0001                	nop
80004cb8:	4472                	lw	s0,28(sp)
80004cba:	6105                	addi	sp,sp,32
80004cbc:	8082                	ret

80004cbe <DMA_HighPriorityCmd>:
  *                        DMA_Channel_x  @ref DMA_Channel_Define.
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void DMA_HighPriorityCmd(uint32_t Channel, FunctionalState State)
{
80004cbe:	1101                	addi	sp,sp,-32
80004cc0:	ce22                	sw	s0,28(sp)
80004cc2:	1000                	addi	s0,sp,32
80004cc4:	fea42623          	sw	a0,-20(s0)
80004cc8:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80004ccc:	fe842703          	lw	a4,-24(s0)
80004cd0:	4785                	li	a5,1
80004cd2:	00f71863          	bne	a4,a5,80004ce2 <DMA_HighPriorityCmd+0x24>
        WRITE_REG(DMA->PRIORITYSET, Channel);
80004cd6:	3000c7b7          	lui	a5,0x3000c
80004cda:	fec42703          	lw	a4,-20(s0)
80004cde:	df98                	sw	a4,56(a5)
    else
        WRITE_REG(DMA->PRIORITYCLR, Channel);
}
80004ce0:	a031                	j	80004cec <DMA_HighPriorityCmd+0x2e>
        WRITE_REG(DMA->PRIORITYCLR, Channel);
80004ce2:	3000c7b7          	lui	a5,0x3000c
80004ce6:	fec42703          	lw	a4,-20(s0)
80004cea:	dfd8                	sw	a4,60(a5)
}
80004cec:	0001                	nop
80004cee:	4472                	lw	s0,28(sp)
80004cf0:	6105                	addi	sp,sp,32
80004cf2:	8082                	ret

80004cf4 <DMA_ChannelDeInit>:
  * @param   ChannelStruct      @ref DMA_Channel_TypeDef,
  *                             
  * @retval  void
  */
void DMA_ChannelDeInit(DMA_Channel_TypeDef* ChannelStruct)
{
80004cf4:	1101                	addi	sp,sp,-32
80004cf6:	ce22                	sw	s0,28(sp)
80004cf8:	1000                	addi	s0,sp,32
80004cfa:	fea42623          	sw	a0,-20(s0)
    ChannelStruct->SRC_DATA_END_PTR = 0;
80004cfe:	fec42783          	lw	a5,-20(s0)
80004d02:	0007a023          	sw	zero,0(a5) # 3000c000 <STACK_SIZE+0x3000b800>
    ChannelStruct->DST_DATA_END_PTR = 0;
80004d06:	fec42783          	lw	a5,-20(s0)
80004d0a:	0007a223          	sw	zero,4(a5)
    ChannelStruct->CHANNEL_CFG = 0;
80004d0e:	fec42783          	lw	a5,-20(s0)
80004d12:	0007a423          	sw	zero,8(a5)
}
80004d16:	0001                	nop
80004d18:	4472                	lw	s0,28(sp)
80004d1a:	6105                	addi	sp,sp,32
80004d1c:	8082                	ret

80004d1e <DMA_ChannelInit>:
  * @param   ChannelInitStruct      @ref DMA_ChannelInit_TypeDef,
  *                                 
  * @retval  void
  */
void DMA_ChannelInit(DMA_Channel_TypeDef* ChannelStruct, DMA_ChannelInit_TypeDef* ChannelInitStruct)
{
80004d1e:	1101                	addi	sp,sp,-32
80004d20:	ce22                	sw	s0,28(sp)
80004d22:	1000                	addi	s0,sp,32
80004d24:	fea42623          	sw	a0,-20(s0)
80004d28:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Bufferable));
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Cacheable));
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Priveleged));

    /*  */
    ChannelStruct->SRC_DATA_END_PTR = (uint32_t)ChannelInitStruct->SrcDataEndPtr;
80004d2c:	fe842783          	lw	a5,-24(s0)
80004d30:	439c                	lw	a5,0(a5)
80004d32:	873e                	mv	a4,a5
80004d34:	fec42783          	lw	a5,-20(s0)
80004d38:	c398                	sw	a4,0(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_SIZE = ChannelInitStruct->SrcDataSize;
80004d3a:	fe842783          	lw	a5,-24(s0)
80004d3e:	5b9c                	lw	a5,48(a5)
80004d40:	8b8d                	andi	a5,a5,3
80004d42:	0ff7f713          	zext.b	a4,a5
80004d46:	fec42783          	lw	a5,-20(s0)
80004d4a:	8b0d                	andi	a4,a4,3
80004d4c:	0746                	slli	a4,a4,0x11
80004d4e:	4790                	lw	a2,8(a5)
80004d50:	fffa06b7          	lui	a3,0xfffa0
80004d54:	16fd                	addi	a3,a3,-1 # fff9ffff <__data_source_start+0x7ff98e87>
80004d56:	8ef1                	and	a3,a3,a2
80004d58:	8f55                	or	a4,a4,a3
80004d5a:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_INC = ChannelInitStruct->SrcDataInc;
80004d5c:	fe842783          	lw	a5,-24(s0)
80004d60:	5f9c                	lw	a5,56(a5)
80004d62:	8b8d                	andi	a5,a5,3
80004d64:	0ff7f713          	zext.b	a4,a5
80004d68:	fec42783          	lw	a5,-20(s0)
80004d6c:	8b0d                	andi	a4,a4,3
80004d6e:	073e                	slli	a4,a4,0xf
80004d70:	4790                	lw	a2,8(a5)
80004d72:	76a1                	lui	a3,0xfffe8
80004d74:	16fd                	addi	a3,a3,-1 # fffe7fff <__data_source_start+0x7ffe0e87>
80004d76:	8ef1                	and	a3,a3,a2
80004d78:	8f55                	or	a4,a4,a3
80004d7a:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_BUFF = ChannelInitStruct->SrcProtect.Bufferable;
80004d7c:	fe842783          	lw	a5,-24(s0)
80004d80:	4fdc                	lw	a5,28(a5)
80004d82:	8b85                	andi	a5,a5,1
80004d84:	0ff7f713          	zext.b	a4,a5
80004d88:	fec42783          	lw	a5,-20(s0)
80004d8c:	8b05                	andi	a4,a4,1
80004d8e:	076e                	slli	a4,a4,0x1b
80004d90:	4790                	lw	a2,8(a5)
80004d92:	f80006b7          	lui	a3,0xf8000
80004d96:	16fd                	addi	a3,a3,-1 # f7ffffff <__data_source_start+0x77ff8e87>
80004d98:	8ef1                	and	a3,a3,a2
80004d9a:	8f55                	or	a4,a4,a3
80004d9c:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_PRIV = ChannelInitStruct->SrcProtect.Priveleged;
80004d9e:	fe842783          	lw	a5,-24(s0)
80004da2:	4f9c                	lw	a5,24(a5)
80004da4:	8b85                	andi	a5,a5,1
80004da6:	0ff7f713          	zext.b	a4,a5
80004daa:	fec42783          	lw	a5,-20(s0)
80004dae:	8b05                	andi	a4,a4,1
80004db0:	076a                	slli	a4,a4,0x1a
80004db2:	4790                	lw	a2,8(a5)
80004db4:	fc0006b7          	lui	a3,0xfc000
80004db8:	16fd                	addi	a3,a3,-1 # fbffffff <__data_source_start+0x7bff8e87>
80004dba:	8ef1                	and	a3,a3,a2
80004dbc:	8f55                	or	a4,a4,a3
80004dbe:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_CACHE = ChannelInitStruct->SrcProtect.Cacheable;
80004dc0:	fe842783          	lw	a5,-24(s0)
80004dc4:	539c                	lw	a5,32(a5)
80004dc6:	8b85                	andi	a5,a5,1
80004dc8:	0ff7f713          	zext.b	a4,a5
80004dcc:	fec42783          	lw	a5,-20(s0)
80004dd0:	8b05                	andi	a4,a4,1
80004dd2:	0772                	slli	a4,a4,0x1c
80004dd4:	4790                	lw	a2,8(a5)
80004dd6:	f00006b7          	lui	a3,0xf0000
80004dda:	16fd                	addi	a3,a3,-1 # efffffff <__data_source_start+0x6fff8e87>
80004ddc:	8ef1                	and	a3,a3,a2
80004dde:	8f55                	or	a4,a4,a3
80004de0:	c798                	sw	a4,8(a5)
    /*  */
    ChannelStruct->DST_DATA_END_PTR = (uint32_t)ChannelInitStruct->DstDataEndPtr;
80004de2:	fe842783          	lw	a5,-24(s0)
80004de6:	43dc                	lw	a5,4(a5)
80004de8:	873e                	mv	a4,a5
80004dea:	fec42783          	lw	a5,-20(s0)
80004dee:	c3d8                	sw	a4,4(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_SIZE = ChannelInitStruct->DstDataSize;
80004df0:	fe842783          	lw	a5,-24(s0)
80004df4:	5bdc                	lw	a5,52(a5)
80004df6:	8b8d                	andi	a5,a5,3
80004df8:	0ff7f713          	zext.b	a4,a5
80004dfc:	fec42783          	lw	a5,-20(s0)
80004e00:	8b0d                	andi	a4,a4,3
80004e02:	0756                	slli	a4,a4,0x15
80004e04:	4790                	lw	a2,8(a5)
80004e06:	ffa006b7          	lui	a3,0xffa00
80004e0a:	16fd                	addi	a3,a3,-1 # ff9fffff <__data_source_start+0x7f9f8e87>
80004e0c:	8ef1                	and	a3,a3,a2
80004e0e:	8f55                	or	a4,a4,a3
80004e10:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_INC = ChannelInitStruct->DstDataInc;
80004e12:	fe842783          	lw	a5,-24(s0)
80004e16:	5fdc                	lw	a5,60(a5)
80004e18:	8b8d                	andi	a5,a5,3
80004e1a:	0ff7f713          	zext.b	a4,a5
80004e1e:	fec42783          	lw	a5,-20(s0)
80004e22:	8b0d                	andi	a4,a4,3
80004e24:	074e                	slli	a4,a4,0x13
80004e26:	4790                	lw	a2,8(a5)
80004e28:	ffe806b7          	lui	a3,0xffe80
80004e2c:	16fd                	addi	a3,a3,-1 # ffe7ffff <__data_source_start+0x7fe78e87>
80004e2e:	8ef1                	and	a3,a3,a2
80004e30:	8f55                	or	a4,a4,a3
80004e32:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_BUFF = ChannelInitStruct->DstProtect.Bufferable;
80004e34:	fe842783          	lw	a5,-24(s0)
80004e38:	579c                	lw	a5,40(a5)
80004e3a:	8b85                	andi	a5,a5,1
80004e3c:	0ff7f713          	zext.b	a4,a5
80004e40:	fec42783          	lw	a5,-20(s0)
80004e44:	8b05                	andi	a4,a4,1
80004e46:	0762                	slli	a4,a4,0x18
80004e48:	4790                	lw	a2,8(a5)
80004e4a:	ff0006b7          	lui	a3,0xff000
80004e4e:	16fd                	addi	a3,a3,-1 # feffffff <__data_source_start+0x7eff8e87>
80004e50:	8ef1                	and	a3,a3,a2
80004e52:	8f55                	or	a4,a4,a3
80004e54:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_PRIV = ChannelInitStruct->DstProtect.Priveleged;
80004e56:	fe842783          	lw	a5,-24(s0)
80004e5a:	53dc                	lw	a5,36(a5)
80004e5c:	8b85                	andi	a5,a5,1
80004e5e:	0ff7f713          	zext.b	a4,a5
80004e62:	fec42783          	lw	a5,-20(s0)
80004e66:	8b05                	andi	a4,a4,1
80004e68:	075e                	slli	a4,a4,0x17
80004e6a:	4790                	lw	a2,8(a5)
80004e6c:	ff8006b7          	lui	a3,0xff800
80004e70:	16fd                	addi	a3,a3,-1 # ff7fffff <__data_source_start+0x7f7f8e87>
80004e72:	8ef1                	and	a3,a3,a2
80004e74:	8f55                	or	a4,a4,a3
80004e76:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_CACHE = ChannelInitStruct->DstProtect.Cacheable;
80004e78:	fe842783          	lw	a5,-24(s0)
80004e7c:	57dc                	lw	a5,44(a5)
80004e7e:	8b85                	andi	a5,a5,1
80004e80:	0ff7f713          	zext.b	a4,a5
80004e84:	fec42783          	lw	a5,-20(s0)
80004e88:	8b05                	andi	a4,a4,1
80004e8a:	0766                	slli	a4,a4,0x19
80004e8c:	4790                	lw	a2,8(a5)
80004e8e:	fe0006b7          	lui	a3,0xfe000
80004e92:	16fd                	addi	a3,a3,-1 # fdffffff <__data_source_start+0x7dff8e87>
80004e94:	8ef1                	and	a3,a3,a2
80004e96:	8f55                	or	a4,a4,a3
80004e98:	c798                	sw	a4,8(a5)
    /*  */
    ChannelStruct->CHANNEL_CFG_bit.NEXT_USEBURST = ChannelInitStruct->NextUseburst;
80004e9a:	fe842783          	lw	a5,-24(s0)
80004e9e:	47dc                	lw	a5,12(a5)
80004ea0:	8b85                	andi	a5,a5,1
80004ea2:	0ff7f713          	zext.b	a4,a5
80004ea6:	fec42783          	lw	a5,-20(s0)
80004eaa:	8b05                	andi	a4,a4,1
80004eac:	4794                	lw	a3,8(a5)
80004eae:	9af9                	andi	a3,a3,-2
80004eb0:	8f55                	or	a4,a4,a3
80004eb2:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.R_POWER = ChannelInitStruct->ArbitrationRate;
80004eb4:	fe842783          	lw	a5,-24(s0)
80004eb8:	4bdc                	lw	a5,20(a5)
80004eba:	8bbd                	andi	a5,a5,15
80004ebc:	0ff7f713          	zext.b	a4,a5
80004ec0:	fec42783          	lw	a5,-20(s0)
80004ec4:	8b3d                	andi	a4,a4,15
80004ec6:	0706                	slli	a4,a4,0x1
80004ec8:	4794                	lw	a3,8(a5)
80004eca:	9a85                	andi	a3,a3,-31
80004ecc:	8f55                	or	a4,a4,a3
80004ece:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.N_MINUS_1 = ChannelInitStruct->TransfersTotal - 1;
80004ed0:	fe842783          	lw	a5,-24(s0)
80004ed4:	4b9c                	lw	a5,16(a5)
80004ed6:	07c2                	slli	a5,a5,0x10
80004ed8:	83c1                	srli	a5,a5,0x10
80004eda:	17fd                	addi	a5,a5,-1
80004edc:	07c2                	slli	a5,a5,0x10
80004ede:	83c1                	srli	a5,a5,0x10
80004ee0:	3ff7f793          	andi	a5,a5,1023
80004ee4:	01079713          	slli	a4,a5,0x10
80004ee8:	8341                	srli	a4,a4,0x10
80004eea:	fec42783          	lw	a5,-20(s0)
80004eee:	3ff77713          	andi	a4,a4,1023
80004ef2:	0716                	slli	a4,a4,0x5
80004ef4:	4790                	lw	a2,8(a5)
80004ef6:	76e1                	lui	a3,0xffff8
80004ef8:	06fd                	addi	a3,a3,31 # ffff801f <__data_source_start+0x7fff0ea7>
80004efa:	8ef1                	and	a3,a3,a2
80004efc:	8f55                	or	a4,a4,a3
80004efe:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.CYCLE_CTRL = ChannelInitStruct->Mode;
80004f00:	fe842783          	lw	a5,-24(s0)
80004f04:	479c                	lw	a5,8(a5)
80004f06:	8b9d                	andi	a5,a5,7
80004f08:	0ff7f713          	zext.b	a4,a5
80004f0c:	fec42783          	lw	a5,-20(s0)
80004f10:	0776                	slli	a4,a4,0x1d
80004f12:	4790                	lw	a2,8(a5)
80004f14:	200006b7          	lui	a3,0x20000
80004f18:	16fd                	addi	a3,a3,-1 # 1fffffff <STACK_SIZE+0x1ffff7ff>
80004f1a:	8ef1                	and	a3,a3,a2
80004f1c:	8f55                	or	a4,a4,a3
80004f1e:	c798                	sw	a4,8(a5)
}
80004f20:	0001                	nop
80004f22:	4472                	lw	s0,28(sp)
80004f24:	6105                	addi	sp,sp,32
80004f26:	8082                	ret

80004f28 <DMA_ChannelStructInit>:
  * @param   ChannelInitStruct      @ref DMA_ChannelInit_TypeDef,
  *                               
  * @retval  void
  */
void DMA_ChannelStructInit(DMA_ChannelInit_TypeDef* ChannelInitStruct)
{
80004f28:	1101                	addi	sp,sp,-32
80004f2a:	ce22                	sw	s0,28(sp)
80004f2c:	1000                	addi	s0,sp,32
80004f2e:	fea42623          	sw	a0,-20(s0)
    /*  */
    ChannelInitStruct->SrcDataEndPtr = (uint32_t*)0x00000000;
80004f32:	fec42783          	lw	a5,-20(s0)
80004f36:	0007a023          	sw	zero,0(a5)
    ChannelInitStruct->SrcDataSize = DMA_DataSize_8;
80004f3a:	fec42783          	lw	a5,-20(s0)
80004f3e:	0207a823          	sw	zero,48(a5)
    ChannelInitStruct->SrcDataInc = DMA_DataInc_Disable;
80004f42:	fec42783          	lw	a5,-20(s0)
80004f46:	470d                	li	a4,3
80004f48:	df98                	sw	a4,56(a5)
    ChannelInitStruct->SrcProtect.Bufferable = DISABLE;
80004f4a:	fec42783          	lw	a5,-20(s0)
80004f4e:	0007ae23          	sw	zero,28(a5)
    ChannelInitStruct->SrcProtect.Priveleged = DISABLE;
80004f52:	fec42783          	lw	a5,-20(s0)
80004f56:	0007ac23          	sw	zero,24(a5)
    ChannelInitStruct->SrcProtect.Cacheable = DISABLE;
80004f5a:	fec42783          	lw	a5,-20(s0)
80004f5e:	0207a023          	sw	zero,32(a5)
    /*  */
    ChannelInitStruct->DstDataEndPtr = (uint32_t*)0x00000000;
80004f62:	fec42783          	lw	a5,-20(s0)
80004f66:	0007a223          	sw	zero,4(a5)
    ChannelInitStruct->DstDataSize = DMA_DataSize_8;
80004f6a:	fec42783          	lw	a5,-20(s0)
80004f6e:	0207aa23          	sw	zero,52(a5)
    ChannelInitStruct->DstDataInc = DMA_DataInc_Disable;
80004f72:	fec42783          	lw	a5,-20(s0)
80004f76:	470d                	li	a4,3
80004f78:	dfd8                	sw	a4,60(a5)
    ChannelInitStruct->DstProtect.Bufferable = DISABLE;
80004f7a:	fec42783          	lw	a5,-20(s0)
80004f7e:	0207a423          	sw	zero,40(a5)
    ChannelInitStruct->DstProtect.Priveleged = DISABLE;
80004f82:	fec42783          	lw	a5,-20(s0)
80004f86:	0207a223          	sw	zero,36(a5)
    ChannelInitStruct->DstProtect.Cacheable = DISABLE;
80004f8a:	fec42783          	lw	a5,-20(s0)
80004f8e:	0207a623          	sw	zero,44(a5)
    /*  */
    ChannelInitStruct->NextUseburst = DISABLE;
80004f92:	fec42783          	lw	a5,-20(s0)
80004f96:	0007a623          	sw	zero,12(a5)
    ChannelInitStruct->ArbitrationRate = DMA_ArbitrationRate_1;
80004f9a:	fec42783          	lw	a5,-20(s0)
80004f9e:	0007aa23          	sw	zero,20(a5)
    ChannelInitStruct->TransfersTotal = 1;
80004fa2:	fec42783          	lw	a5,-20(s0)
80004fa6:	4705                	li	a4,1
80004fa8:	cb98                	sw	a4,16(a5)
    ChannelInitStruct->Mode = DMA_Mode_Disable;
80004faa:	fec42783          	lw	a5,-20(s0)
80004fae:	0007a423          	sw	zero,8(a5)
}
80004fb2:	0001                	nop
80004fb4:	4472                	lw	s0,28(sp)
80004fb6:	6105                	addi	sp,sp,32
80004fb8:	8082                	ret

80004fba <DMA_DeInit>:
/**
  * @brief     DMA
  * @retval  void
  */
void DMA_DeInit()
{
80004fba:	1141                	addi	sp,sp,-16
80004fbc:	c622                	sw	s0,12(sp)
80004fbe:	0800                	addi	s0,sp,16
    CLEAR_REG(DMA->CFG);
80004fc0:	3000c7b7          	lui	a5,0x3000c
80004fc4:	0007a223          	sw	zero,4(a5) # 3000c004 <STACK_SIZE+0x3000b804>
    CLEAR_REG(DMA->BASEPTR);
80004fc8:	3000c7b7          	lui	a5,0x3000c
80004fcc:	0007a423          	sw	zero,8(a5) # 3000c008 <STACK_SIZE+0x3000b808>
    WRITE_REG(DMA->ENCLR, DMA_Channel_All);
80004fd0:	3000c7b7          	lui	a5,0x3000c
80004fd4:	01000737          	lui	a4,0x1000
80004fd8:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80004fda:	d7d8                	sw	a4,44(a5)
    WRITE_REG(DMA->PRIORITYCLR, DMA_Channel_All);
80004fdc:	3000c7b7          	lui	a5,0x3000c
80004fe0:	01000737          	lui	a4,0x1000
80004fe4:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80004fe6:	dfd8                	sw	a4,60(a5)
    WRITE_REG(DMA->PRIALTCLR, DMA_Channel_All);
80004fe8:	3000c7b7          	lui	a5,0x3000c
80004fec:	01000737          	lui	a4,0x1000
80004ff0:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80004ff2:	dbd8                	sw	a4,52(a5)
    WRITE_REG(DMA->REQMASKCLR, DMA_Channel_All);
80004ff4:	3000c7b7          	lui	a5,0x3000c
80004ff8:	01000737          	lui	a4,0x1000
80004ffc:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80004ffe:	d3d8                	sw	a4,36(a5)
    WRITE_REG(DMA->USEBURSTCLR, DMA_Channel_All);
80005000:	3000c7b7          	lui	a5,0x3000c
80005004:	01000737          	lui	a4,0x1000
80005008:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
8000500a:	cfd8                	sw	a4,28(a5)
}
8000500c:	0001                	nop
8000500e:	4432                	lw	s0,12(sp)
80005010:	0141                	addi	sp,sp,16
80005012:	8082                	ret

80005014 <DMA_Init>:
  * @param   InitStruct      @ref DMA_Init_TypeDef,
  *                         
  * @retval  void
  */
void DMA_Init(DMA_Init_TypeDef* InitStruct)
{
80005014:	1101                	addi	sp,sp,-32
80005016:	ce06                	sw	ra,28(sp)
80005018:	cc22                	sw	s0,24(sp)
8000501a:	1000                	addi	s0,sp,32
8000501c:	fea42623          	sw	a0,-20(s0)
    DMA_ProtectConfig(&(InitStruct->CtrlProtect));
80005020:	fec42783          	lw	a5,-20(s0)
80005024:	0791                	addi	a5,a5,4 # 3000c004 <STACK_SIZE+0x3000b804>
80005026:	853e                	mv	a0,a5
80005028:	3641                	jal	80004ba8 <DMA_ProtectConfig>
    DMA_UseBurstCmd(InitStruct->Channel, InitStruct->UseBurst);
8000502a:	fec42783          	lw	a5,-20(s0)
8000502e:	4398                	lw	a4,0(a5)
80005030:	fec42783          	lw	a5,-20(s0)
80005034:	4b9c                	lw	a5,16(a5)
80005036:	85be                	mv	a1,a5
80005038:	853a                	mv	a0,a4
8000503a:	3675                	jal	80004be6 <DMA_UseBurstCmd>
    DMA_AltCtrlCmd(InitStruct->Channel, InitStruct->AltCtrl);
8000503c:	fec42783          	lw	a5,-20(s0)
80005040:	4398                	lw	a4,0(a5)
80005042:	fec42783          	lw	a5,-20(s0)
80005046:	4f9c                	lw	a5,24(a5)
80005048:	85be                	mv	a1,a5
8000504a:	853a                	mv	a0,a4
8000504c:	3935                	jal	80004c88 <DMA_AltCtrlCmd>
    DMA_HighPriorityCmd(InitStruct->Channel, InitStruct->HighPriority);
8000504e:	fec42783          	lw	a5,-20(s0)
80005052:	4398                	lw	a4,0(a5)
80005054:	fec42783          	lw	a5,-20(s0)
80005058:	4fdc                	lw	a5,28(a5)
8000505a:	85be                	mv	a1,a5
8000505c:	853a                	mv	a0,a4
8000505e:	3185                	jal	80004cbe <DMA_HighPriorityCmd>
    DMA_ReqMaskCmd(InitStruct->Channel, InitStruct->ReqMask);
80005060:	fec42783          	lw	a5,-20(s0)
80005064:	4398                	lw	a4,0(a5)
80005066:	fec42783          	lw	a5,-20(s0)
8000506a:	4bdc                	lw	a5,20(a5)
8000506c:	85be                	mv	a1,a5
8000506e:	853a                	mv	a0,a4
80005070:	3675                	jal	80004c1c <DMA_ReqMaskCmd>
    DMA_ChannelEnableCmd(InitStruct->Channel, InitStruct->ChannelEnable);
80005072:	fec42783          	lw	a5,-20(s0)
80005076:	4398                	lw	a4,0(a5)
80005078:	fec42783          	lw	a5,-20(s0)
8000507c:	539c                	lw	a5,32(a5)
8000507e:	85be                	mv	a1,a5
80005080:	853a                	mv	a0,a4
80005082:	3ec1                	jal	80004c52 <DMA_ChannelEnableCmd>
}
80005084:	0001                	nop
80005086:	40f2                	lw	ra,28(sp)
80005088:	4462                	lw	s0,24(sp)
8000508a:	6105                	addi	sp,sp,32
8000508c:	8082                	ret

8000508e <DMA_StructInit>:
  * @param   InitStruct      @ref DMA_Init_TypeDef,
  *                        
  * @retval  void
  */
void DMA_StructInit(DMA_Init_TypeDef* InitStruct)
{
8000508e:	1101                	addi	sp,sp,-32
80005090:	ce22                	sw	s0,28(sp)
80005092:	1000                	addi	s0,sp,32
80005094:	fea42623          	sw	a0,-20(s0)
    InitStruct->Channel = DMA_Channel_All;
80005098:	fec42783          	lw	a5,-20(s0)
8000509c:	01000737          	lui	a4,0x1000
800050a0:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
800050a2:	c398                	sw	a4,0(a5)
    InitStruct->ChannelEnable = DISABLE;
800050a4:	fec42783          	lw	a5,-20(s0)
800050a8:	0207a023          	sw	zero,32(a5)
    InitStruct->HighPriority = DISABLE;
800050ac:	fec42783          	lw	a5,-20(s0)
800050b0:	0007ae23          	sw	zero,28(a5)
    InitStruct->AltCtrl = DISABLE;
800050b4:	fec42783          	lw	a5,-20(s0)
800050b8:	0007ac23          	sw	zero,24(a5)
    InitStruct->ReqMask = DISABLE;
800050bc:	fec42783          	lw	a5,-20(s0)
800050c0:	0007aa23          	sw	zero,20(a5)
    InitStruct->UseBurst = DISABLE;
800050c4:	fec42783          	lw	a5,-20(s0)
800050c8:	0007a823          	sw	zero,16(a5)
    InitStruct->CtrlProtect.Bufferable = DISABLE;
800050cc:	fec42783          	lw	a5,-20(s0)
800050d0:	0007a423          	sw	zero,8(a5)
    InitStruct->CtrlProtect.Cacheable = DISABLE;
800050d4:	fec42783          	lw	a5,-20(s0)
800050d8:	0007a623          	sw	zero,12(a5)
    InitStruct->CtrlProtect.Priveleged = DISABLE;
800050dc:	fec42783          	lw	a5,-20(s0)
800050e0:	0007a223          	sw	zero,4(a5)
}
800050e4:	0001                	nop
800050e6:	4472                	lw	s0,28(sp)
800050e8:	6105                	addi	sp,sp,32
800050ea:	8082                	ret

800050ec <RCU_AHBRstCmd>:
{
800050ec:	1101                	addi	sp,sp,-32
800050ee:	ce22                	sw	s0,28(sp)
800050f0:	1000                	addi	s0,sp,32
800050f2:	fea42623          	sw	a0,-20(s0)
800050f6:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
800050fa:	3000e7b7          	lui	a5,0x3000e
800050fe:	4b98                	lw	a4,16(a5)
80005100:	fec42783          	lw	a5,-20(s0)
80005104:	fff7c793          	not	a5,a5
80005108:	00f776b3          	and	a3,a4,a5
8000510c:	fe842783          	lw	a5,-24(s0)
80005110:	c781                	beqz	a5,80005118 <RCU_AHBRstCmd+0x2c>
80005112:	fec42783          	lw	a5,-20(s0)
80005116:	a011                	j	8000511a <RCU_AHBRstCmd+0x2e>
80005118:	4781                	li	a5,0
8000511a:	3000e737          	lui	a4,0x3000e
8000511e:	8fd5                	or	a5,a5,a3
80005120:	cb1c                	sw	a5,16(a4)
}
80005122:	0001                	nop
80005124:	4472                	lw	s0,28(sp)
80005126:	6105                	addi	sp,sp,32
80005128:	8082                	ret

8000512a <GPIO_OutCmd>:
  * @param   Pin   .     GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void GPIO_OutCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
8000512a:	1101                	addi	sp,sp,-32
8000512c:	ce22                	sw	s0,28(sp)
8000512e:	1000                	addi	s0,sp,32
80005130:	fea42623          	sw	a0,-20(s0)
80005134:	feb42423          	sw	a1,-24(s0)
80005138:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000513c:	fe442703          	lw	a4,-28(s0)
80005140:	4785                	li	a5,1
80005142:	00f71863          	bne	a4,a5,80005152 <GPIO_OutCmd+0x28>
        WRITE_REG(GPIOx->OUTENSET, Pin);
80005146:	fec42783          	lw	a5,-20(s0)
8000514a:	fe842703          	lw	a4,-24(s0)
8000514e:	d7d8                	sw	a4,44(a5)
    else
        WRITE_REG(GPIOx->OUTENCLR, Pin);
}
80005150:	a031                	j	8000515c <GPIO_OutCmd+0x32>
        WRITE_REG(GPIOx->OUTENCLR, Pin);
80005152:	fec42783          	lw	a5,-20(s0)
80005156:	fe842703          	lw	a4,-24(s0)
8000515a:	db98                	sw	a4,48(a5)
}
8000515c:	0001                	nop
8000515e:	4472                	lw	s0,28(sp)
80005160:	6105                	addi	sp,sp,32
80005162:	8082                	ret

80005164 <GPIO_AltFuncCmd>:
  * @param   Pin   .     GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void GPIO_AltFuncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80005164:	1101                	addi	sp,sp,-32
80005166:	ce22                	sw	s0,28(sp)
80005168:	1000                	addi	s0,sp,32
8000516a:	fea42623          	sw	a0,-20(s0)
8000516e:	feb42423          	sw	a1,-24(s0)
80005172:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80005176:	fe442703          	lw	a4,-28(s0)
8000517a:	4785                	li	a5,1
8000517c:	00f71863          	bne	a4,a5,8000518c <GPIO_AltFuncCmd+0x28>
        WRITE_REG(GPIOx->ALTFUNCSET, Pin);
80005180:	fec42783          	lw	a5,-20(s0)
80005184:	fe842703          	lw	a4,-24(s0)
80005188:	dbd8                	sw	a4,52(a5)
    else
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
}
8000518a:	a031                	j	80005196 <GPIO_AltFuncCmd+0x32>
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
8000518c:	fec42783          	lw	a5,-20(s0)
80005190:	fe842703          	lw	a4,-24(s0)
80005194:	df98                	sw	a4,56(a5)
}
80005196:	0001                	nop
80005198:	4472                	lw	s0,28(sp)
8000519a:	6105                	addi	sp,sp,32
8000519c:	8082                	ret

8000519e <modeConfig>:
  * @param   Pin   .    GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   Val    (2- )
  * @retval  void
  */
static void modeConfig(volatile uint32_t* Reg, uint32_t Pin, uint32_t Val)
{
8000519e:	7179                	addi	sp,sp,-48
800051a0:	d622                	sw	s0,44(sp)
800051a2:	1800                	addi	s0,sp,48
800051a4:	fca42e23          	sw	a0,-36(s0)
800051a8:	fcb42c23          	sw	a1,-40(s0)
800051ac:	fcc42a23          	sw	a2,-44(s0)
    uint32_t reg_temp = *Reg;
800051b0:	fdc42783          	lw	a5,-36(s0)
800051b4:	439c                	lw	a5,0(a5)
800051b6:	fef42623          	sw	a5,-20(s0)

    for (uint32_t i = 0; i < 16; i++) {
800051ba:	fe042423          	sw	zero,-24(s0)
800051be:	a889                	j	80005210 <modeConfig+0x72>
        if (Pin & (1 << i)) {
800051c0:	fe842783          	lw	a5,-24(s0)
800051c4:	4705                	li	a4,1
800051c6:	00f717b3          	sll	a5,a4,a5
800051ca:	873e                	mv	a4,a5
800051cc:	fd842783          	lw	a5,-40(s0)
800051d0:	8ff9                	and	a5,a5,a4
800051d2:	cb95                	beqz	a5,80005206 <modeConfig+0x68>
            reg_temp &= ~(0x3UL << i * 0x2UL);
800051d4:	fe842783          	lw	a5,-24(s0)
800051d8:	0786                	slli	a5,a5,0x1
800051da:	470d                	li	a4,3
800051dc:	00f717b3          	sll	a5,a4,a5
800051e0:	fff7c793          	not	a5,a5
800051e4:	fec42703          	lw	a4,-20(s0)
800051e8:	8ff9                	and	a5,a5,a4
800051ea:	fef42623          	sw	a5,-20(s0)
            reg_temp |= Val << i * 0x2UL;
800051ee:	fe842783          	lw	a5,-24(s0)
800051f2:	0786                	slli	a5,a5,0x1
800051f4:	fd442703          	lw	a4,-44(s0)
800051f8:	00f717b3          	sll	a5,a4,a5
800051fc:	fec42703          	lw	a4,-20(s0)
80005200:	8fd9                	or	a5,a5,a4
80005202:	fef42623          	sw	a5,-20(s0)
    for (uint32_t i = 0; i < 16; i++) {
80005206:	fe842783          	lw	a5,-24(s0)
8000520a:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
8000520c:	fef42423          	sw	a5,-24(s0)
80005210:	fe842703          	lw	a4,-24(s0)
80005214:	47bd                	li	a5,15
80005216:	fae7f5e3          	bgeu	a5,a4,800051c0 <modeConfig+0x22>
        }
    }

    WRITE_REG(*Reg, reg_temp);
8000521a:	fdc42783          	lw	a5,-36(s0)
8000521e:	fec42703          	lw	a4,-20(s0)
80005222:	c398                	sw	a4,0(a5)
}
80005224:	0001                	nop
80005226:	5432                	lw	s0,44(sp)
80005228:	6145                	addi	sp,sp,48
8000522a:	8082                	ret

8000522c <GPIO_OutModeConfig>:
  * @param   Pin   .    GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   OutMode   
  * @retval  void
  */
void GPIO_OutModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_OutMode_TypeDef OutMode)
{
8000522c:	1101                	addi	sp,sp,-32
8000522e:	ce06                	sw	ra,28(sp)
80005230:	cc22                	sw	s0,24(sp)
80005232:	1000                	addi	s0,sp,32
80005234:	fea42623          	sw	a0,-20(s0)
80005238:	feb42423          	sw	a1,-24(s0)
8000523c:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_OUT_MODE(OutMode));

    modeConfig(&(GPIOx->OUTMODE), Pin, (uint32_t)OutMode);
80005240:	fec42783          	lw	a5,-20(s0)
80005244:	02478793          	addi	a5,a5,36
80005248:	fe442603          	lw	a2,-28(s0)
8000524c:	fe842583          	lw	a1,-24(s0)
80005250:	853e                	mv	a0,a5
80005252:	37b1                	jal	8000519e <modeConfig>
}
80005254:	0001                	nop
80005256:	40f2                	lw	ra,28(sp)
80005258:	4462                	lw	s0,24(sp)
8000525a:	6105                	addi	sp,sp,32
8000525c:	8082                	ret

8000525e <GPIO_InModeConfig>:
  * @param   Pin   .    GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   InMode   
  * @retval  void
  */
void GPIO_InModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_InMode_TypeDef InMode)
{
8000525e:	1101                	addi	sp,sp,-32
80005260:	ce06                	sw	ra,28(sp)
80005262:	cc22                	sw	s0,24(sp)
80005264:	1000                	addi	s0,sp,32
80005266:	fea42623          	sw	a0,-20(s0)
8000526a:	feb42423          	sw	a1,-24(s0)
8000526e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_IN_MODE(InMode));

    modeConfig(&(GPIOx->INMODE), Pin, (uint32_t)InMode);
80005272:	fec42783          	lw	a5,-20(s0)
80005276:	07f1                	addi	a5,a5,28
80005278:	fe442603          	lw	a2,-28(s0)
8000527c:	fe842583          	lw	a1,-24(s0)
80005280:	853e                	mv	a0,a5
80005282:	3f31                	jal	8000519e <modeConfig>
}
80005284:	0001                	nop
80005286:	40f2                	lw	ra,28(sp)
80005288:	4462                	lw	s0,24(sp)
8000528a:	6105                	addi	sp,sp,32
8000528c:	8082                	ret

8000528e <GPIO_PullModeConfig>:
  * @param   Pin   .    GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   PullMode   
  * @retval  void
  */
void GPIO_PullModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_PullMode_TypeDef PullMode)
{
8000528e:	1101                	addi	sp,sp,-32
80005290:	ce06                	sw	ra,28(sp)
80005292:	cc22                	sw	s0,24(sp)
80005294:	1000                	addi	s0,sp,32
80005296:	fea42623          	sw	a0,-20(s0)
8000529a:	feb42423          	sw	a1,-24(s0)
8000529e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_PULL_MODE(PullMode));

    modeConfig(&(GPIOx->PULLMODE), Pin, (uint32_t)PullMode);
800052a2:	fec42783          	lw	a5,-20(s0)
800052a6:	02078793          	addi	a5,a5,32
800052aa:	fe442603          	lw	a2,-28(s0)
800052ae:	fe842583          	lw	a1,-24(s0)
800052b2:	853e                	mv	a0,a5
800052b4:	35ed                	jal	8000519e <modeConfig>
}
800052b6:	0001                	nop
800052b8:	40f2                	lw	ra,28(sp)
800052ba:	4462                	lw	s0,24(sp)
800052bc:	6105                	addi	sp,sp,32
800052be:	8082                	ret

800052c0 <GPIO_AltFuncNumConfig>:
  * @param   Pin   .    GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   AltFuncNum   
  * @retval  void
  */
void GPIO_AltFuncNumConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_AltFuncNum_TypeDef AltFuncNum)
{
800052c0:	7179                	addi	sp,sp,-48
800052c2:	d622                	sw	s0,44(sp)
800052c4:	1800                	addi	s0,sp,48
800052c6:	fca42e23          	sw	a0,-36(s0)
800052ca:	fcb42c23          	sw	a1,-40(s0)
800052ce:	fcc42a23          	sw	a2,-44(s0)
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_ALT_FUNC_NUM(AltFuncNum));

    uint32_t temp;

    temp = GPIOx->ALTFUNCNUM;
800052d2:	fdc42783          	lw	a5,-36(s0)
800052d6:	5fdc                	lw	a5,60(a5)
800052d8:	fef42623          	sw	a5,-20(s0)

    for (uint32_t i = 0; i < 16; i++) {
800052dc:	fe042423          	sw	zero,-24(s0)
800052e0:	a889                	j	80005332 <GPIO_AltFuncNumConfig+0x72>
    	if (Pin & (1 << i))
800052e2:	fe842783          	lw	a5,-24(s0)
800052e6:	4705                	li	a4,1
800052e8:	00f717b3          	sll	a5,a4,a5
800052ec:	873e                	mv	a4,a5
800052ee:	fd842783          	lw	a5,-40(s0)
800052f2:	8ff9                	and	a5,a5,a4
800052f4:	cb95                	beqz	a5,80005328 <GPIO_AltFuncNumConfig+0x68>
    	{
    		temp &= ~(0x3UL << i * 0x2UL);
800052f6:	fe842783          	lw	a5,-24(s0)
800052fa:	0786                	slli	a5,a5,0x1
800052fc:	470d                	li	a4,3
800052fe:	00f717b3          	sll	a5,a4,a5
80005302:	fff7c793          	not	a5,a5
80005306:	fec42703          	lw	a4,-20(s0)
8000530a:	8ff9                	and	a5,a5,a4
8000530c:	fef42623          	sw	a5,-20(s0)
    		temp |= (uint32_t)AltFuncNum << i * 0x2UL;
80005310:	fe842783          	lw	a5,-24(s0)
80005314:	0786                	slli	a5,a5,0x1
80005316:	fd442703          	lw	a4,-44(s0)
8000531a:	00f717b3          	sll	a5,a4,a5
8000531e:	fec42703          	lw	a4,-20(s0)
80005322:	8fd9                	or	a5,a5,a4
80005324:	fef42623          	sw	a5,-20(s0)
    for (uint32_t i = 0; i < 16; i++) {
80005328:	fe842783          	lw	a5,-24(s0)
8000532c:	0785                	addi	a5,a5,1
8000532e:	fef42423          	sw	a5,-24(s0)
80005332:	fe842703          	lw	a4,-24(s0)
80005336:	47bd                	li	a5,15
80005338:	fae7f5e3          	bgeu	a5,a4,800052e2 <GPIO_AltFuncNumConfig+0x22>
//                temp1 |= (uint32_t)AltFuncNum << (i - 8) * 0x4UL;
//            }
//        }
    }

    GPIOx->ALTFUNCNUM = temp;
8000533c:	fdc42783          	lw	a5,-36(s0)
80005340:	fec42703          	lw	a4,-20(s0)
80005344:	dfd8                	sw	a4,60(a5)
}
80005346:	0001                	nop
80005348:	5432                	lw	s0,44(sp)
8000534a:	6145                	addi	sp,sp,48
8000534c:	8082                	ret

8000534e <GPIO_DeInit>:
  * @brief       GPIOx   
  * @param   GPIOx   ,  x=A|B|C
  * @retval  void
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
8000534e:	7179                	addi	sp,sp,-48
80005350:	d606                	sw	ra,44(sp)
80005352:	d422                	sw	s0,40(sp)
80005354:	1800                	addi	s0,sp,48
80005356:	fca42e23          	sw	a0,-36(s0)
    uint32_t GPIO_rst;

    assert_param(IS_GPIO_PERIPH(GPIOx));

    if (GPIOx == GPIOA)
8000535a:	fdc42703          	lw	a4,-36(s0)
8000535e:	280007b7          	lui	a5,0x28000
80005362:	00f71763          	bne	a4,a5,80005370 <GPIO_DeInit+0x22>
        GPIO_rst = RCU_AHBRst_GPIOA;
80005366:	10000793          	li	a5,256
8000536a:	fef42623          	sw	a5,-20(s0)
8000536e:	a035                	j	8000539a <GPIO_DeInit+0x4c>
    else if (GPIOx == GPIOB)
80005370:	fdc42703          	lw	a4,-36(s0)
80005374:	280017b7          	lui	a5,0x28001
80005378:	00f71763          	bne	a4,a5,80005386 <GPIO_DeInit+0x38>
        GPIO_rst = RCU_AHBRst_GPIOB;
8000537c:	20000793          	li	a5,512
80005380:	fef42623          	sw	a5,-20(s0)
80005384:	a819                	j	8000539a <GPIO_DeInit+0x4c>
    else  if (GPIOx == GPIOC)
80005386:	fdc42703          	lw	a4,-36(s0)
8000538a:	280027b7          	lui	a5,0x28002
8000538e:	00f71663          	bne	a4,a5,8000539a <GPIO_DeInit+0x4c>
        GPIO_rst = RCU_AHBRst_GPIOC;
80005392:	40000793          	li	a5,1024
80005396:	fef42623          	sw	a5,-20(s0)

    RCU_AHBRstCmd(GPIO_rst, DISABLE);
8000539a:	4581                	li	a1,0
8000539c:	fec42503          	lw	a0,-20(s0)
800053a0:	33b1                	jal	800050ec <RCU_AHBRstCmd>
    RCU_AHBRstCmd(GPIO_rst, ENABLE);
800053a2:	4585                	li	a1,1
800053a4:	fec42503          	lw	a0,-20(s0)
800053a8:	3391                	jal	800050ec <RCU_AHBRstCmd>
}
800053aa:	0001                	nop
800053ac:	50b2                	lw	ra,44(sp)
800053ae:	5422                	lw	s0,40(sp)
800053b0:	6145                	addi	sp,sp,48
800053b2:	8082                	ret

800053b4 <GPIO_Init>:
  * @param   InitStruct      @ref GPIO_Init_TypeDef,
  *                         
  * @retval  void
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_Init_TypeDef* InitStruct)
{
800053b4:	1101                	addi	sp,sp,-32
800053b6:	ce06                	sw	ra,28(sp)
800053b8:	cc22                	sw	s0,24(sp)
800053ba:	1000                	addi	s0,sp,32
800053bc:	fea42623          	sw	a0,-20(s0)
800053c0:	feb42423          	sw	a1,-24(s0)
    GPIO_OutCmd(GPIOx, InitStruct->Pin, InitStruct->Out);
800053c4:	fe842783          	lw	a5,-24(s0)
800053c8:	4398                	lw	a4,0(a5)
800053ca:	fe842783          	lw	a5,-24(s0)
800053ce:	43dc                	lw	a5,4(a5)
800053d0:	863e                	mv	a2,a5
800053d2:	85ba                	mv	a1,a4
800053d4:	fec42503          	lw	a0,-20(s0)
800053d8:	3b89                	jal	8000512a <GPIO_OutCmd>
    GPIO_AltFuncNumConfig(GPIOx, InitStruct->Pin, InitStruct->AltFuncNum);
800053da:	fe842783          	lw	a5,-24(s0)
800053de:	4398                	lw	a4,0(a5)
800053e0:	fe842783          	lw	a5,-24(s0)
800053e4:	47dc                	lw	a5,12(a5)
800053e6:	863e                	mv	a2,a5
800053e8:	85ba                	mv	a1,a4
800053ea:	fec42503          	lw	a0,-20(s0)
800053ee:	3dc9                	jal	800052c0 <GPIO_AltFuncNumConfig>
    GPIO_AltFuncCmd(GPIOx, InitStruct->Pin, InitStruct->AltFunc);
800053f0:	fe842783          	lw	a5,-24(s0)
800053f4:	4398                	lw	a4,0(a5)
800053f6:	fe842783          	lw	a5,-24(s0)
800053fa:	479c                	lw	a5,8(a5)
800053fc:	863e                	mv	a2,a5
800053fe:	85ba                	mv	a1,a4
80005400:	fec42503          	lw	a0,-20(s0)
80005404:	3385                	jal	80005164 <GPIO_AltFuncCmd>
    GPIO_OutModeConfig(GPIOx, InitStruct->Pin, InitStruct->OutMode);
80005406:	fe842783          	lw	a5,-24(s0)
8000540a:	4398                	lw	a4,0(a5)
8000540c:	fe842783          	lw	a5,-24(s0)
80005410:	4bdc                	lw	a5,20(a5)
80005412:	863e                	mv	a2,a5
80005414:	85ba                	mv	a1,a4
80005416:	fec42503          	lw	a0,-20(s0)
8000541a:	3d09                	jal	8000522c <GPIO_OutModeConfig>
    GPIO_InModeConfig(GPIOx, InitStruct->Pin, InitStruct->InMode);
8000541c:	fe842783          	lw	a5,-24(s0)
80005420:	4398                	lw	a4,0(a5)
80005422:	fe842783          	lw	a5,-24(s0)
80005426:	4f9c                	lw	a5,24(a5)
80005428:	863e                	mv	a2,a5
8000542a:	85ba                	mv	a1,a4
8000542c:	fec42503          	lw	a0,-20(s0)
80005430:	353d                	jal	8000525e <GPIO_InModeConfig>
    GPIO_PullModeConfig(GPIOx, InitStruct->Pin, InitStruct->PullMode);
80005432:	fe842783          	lw	a5,-24(s0)
80005436:	4398                	lw	a4,0(a5)
80005438:	fe842783          	lw	a5,-24(s0)
8000543c:	4fdc                	lw	a5,28(a5)
8000543e:	863e                	mv	a2,a5
80005440:	85ba                	mv	a1,a4
80005442:	fec42503          	lw	a0,-20(s0)
80005446:	35a1                	jal	8000528e <GPIO_PullModeConfig>
    //GPIO_DigitalCmd(GPIOx, InitStruct->Pin, InitStruct->Digital);
}
80005448:	0001                	nop
8000544a:	40f2                	lw	ra,28(sp)
8000544c:	4462                	lw	s0,24(sp)
8000544e:	6105                	addi	sp,sp,32
80005450:	8082                	ret

80005452 <GPIO_StructInit>:
  * @param   InitStruct      @ref GPIO_Init_TypeDef,
  *                        
  * @retval  void
  */
void GPIO_StructInit(GPIO_Init_TypeDef* InitStruct)
{
80005452:	1101                	addi	sp,sp,-32
80005454:	ce22                	sw	s0,28(sp)
80005456:	1000                	addi	s0,sp,32
80005458:	fea42623          	sw	a0,-20(s0)
    InitStruct->Pin = GPIO_Pin_All;
8000545c:	fec42783          	lw	a5,-20(s0)
80005460:	6741                	lui	a4,0x10
80005462:	177d                	addi	a4,a4,-1 # ffff <STACK_SIZE+0xf7ff>
80005464:	c398                	sw	a4,0(a5)
    InitStruct->Out = DISABLE;
80005466:	fec42783          	lw	a5,-20(s0)
8000546a:	0007a223          	sw	zero,4(a5) # 28002004 <STACK_SIZE+0x28001804>
    InitStruct->AltFuncNum = GPIO_AltFuncNum_None;
8000546e:	fec42783          	lw	a5,-20(s0)
80005472:	0007a623          	sw	zero,12(a5)
    InitStruct->AltFunc = DISABLE;
80005476:	fec42783          	lw	a5,-20(s0)
8000547a:	0007a423          	sw	zero,8(a5)
    InitStruct->OutMode = GPIO_OutMode_PP;
8000547e:	fec42783          	lw	a5,-20(s0)
80005482:	0007aa23          	sw	zero,20(a5)
    InitStruct->InMode = GPIO_InMode_Schmitt;
80005486:	fec42783          	lw	a5,-20(s0)
8000548a:	0007ac23          	sw	zero,24(a5)
    InitStruct->PullMode = GPIO_PullMode_Disable;
8000548e:	fec42783          	lw	a5,-20(s0)
80005492:	0007ae23          	sw	zero,28(a5)
    InitStruct->Digital = DISABLE;
80005496:	fec42783          	lw	a5,-20(s0)
8000549a:	0007a823          	sw	zero,16(a5)
}
8000549e:	0001                	nop
800054a0:	4472                	lw	s0,28(sp)
800054a2:	6105                	addi	sp,sp,32
800054a4:	8082                	ret

800054a6 <RCU_AHBClkCmd>:
{
800054a6:	1101                	addi	sp,sp,-32
800054a8:	ce22                	sw	s0,28(sp)
800054aa:	1000                	addi	s0,sp,32
800054ac:	fea42623          	sw	a0,-20(s0)
800054b0:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->CGCFGAHB, AHBClk, State ? AHBClk : 0);
800054b4:	3000e7b7          	lui	a5,0x3000e
800054b8:	4398                	lw	a4,0(a5)
800054ba:	fec42783          	lw	a5,-20(s0)
800054be:	fff7c793          	not	a5,a5
800054c2:	00f776b3          	and	a3,a4,a5
800054c6:	fe842783          	lw	a5,-24(s0)
800054ca:	c781                	beqz	a5,800054d2 <RCU_AHBClkCmd+0x2c>
800054cc:	fec42783          	lw	a5,-20(s0)
800054d0:	a011                	j	800054d4 <RCU_AHBClkCmd+0x2e>
800054d2:	4781                	li	a5,0
800054d4:	3000e737          	lui	a4,0x3000e
800054d8:	8fd5                	or	a5,a5,a3
800054da:	c31c                	sw	a5,0(a4)
}
800054dc:	0001                	nop
800054de:	4472                	lw	s0,28(sp)
800054e0:	6105                	addi	sp,sp,32
800054e2:	8082                	ret

800054e4 <RCU_AHBRstCmd>:
{
800054e4:	1101                	addi	sp,sp,-32
800054e6:	ce22                	sw	s0,28(sp)
800054e8:	1000                	addi	s0,sp,32
800054ea:	fea42623          	sw	a0,-20(s0)
800054ee:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
800054f2:	3000e7b7          	lui	a5,0x3000e
800054f6:	4b98                	lw	a4,16(a5)
800054f8:	fec42783          	lw	a5,-20(s0)
800054fc:	fff7c793          	not	a5,a5
80005500:	00f776b3          	and	a3,a4,a5
80005504:	fe842783          	lw	a5,-24(s0)
80005508:	c781                	beqz	a5,80005510 <RCU_AHBRstCmd+0x2c>
8000550a:	fec42783          	lw	a5,-20(s0)
8000550e:	a011                	j	80005512 <RCU_AHBRstCmd+0x2e>
80005510:	4781                	li	a5,0
80005512:	3000e737          	lui	a4,0x3000e
80005516:	8fd5                	or	a5,a5,a3
80005518:	cb1c                	sw	a5,16(a4)
}
8000551a:	0001                	nop
8000551c:	4472                	lw	s0,28(sp)
8000551e:	6105                	addi	sp,sp,32
80005520:	8082                	ret

80005522 <HASH_InitCmd>:
  * @brief    -
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void HASH_InitCmd(FunctionalState state)
{
80005522:	1101                	addi	sp,sp,-32
80005524:	ce22                	sw	s0,28(sp)
80005526:	1000                	addi	s0,sp,32
80005528:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_INIT_Msk, state << HASH_CR_INIT_Pos);
8000552c:	200327b7          	lui	a5,0x20032
80005530:	439c                	lw	a5,0(a5)
80005532:	ffe7f693          	andi	a3,a5,-2
80005536:	200327b7          	lui	a5,0x20032
8000553a:	fec42703          	lw	a4,-20(s0)
8000553e:	8f55                	or	a4,a4,a3
80005540:	c398                	sw	a4,0(a5)
}
80005542:	0001                	nop
80005544:	4472                	lw	s0,28(sp)
80005546:	6105                	addi	sp,sp,32
80005548:	8082                	ret

8000554a <HASH_ModeCmd>:
  * @brief     
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void HASH_ModeCmd(HASH_MODE_TypeDef mode)
{
8000554a:	1101                	addi	sp,sp,-32
8000554c:	ce22                	sw	s0,28(sp)
8000554e:	1000                	addi	s0,sp,32
80005550:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_MODE(mode));

	MODIFY_REG(HASH->CR, HASH_CR_MODE_Msk, mode << HASH_CR_MODE_Pos);
80005554:	200327b7          	lui	a5,0x20032
80005558:	439c                	lw	a5,0(a5)
8000555a:	ffd7f693          	andi	a3,a5,-3
8000555e:	fec42783          	lw	a5,-20(s0)
80005562:	00179713          	slli	a4,a5,0x1
80005566:	200327b7          	lui	a5,0x20032
8000556a:	8f55                	or	a4,a4,a3
8000556c:	c398                	sw	a4,0(a5)
}
8000556e:	0001                	nop
80005570:	4472                	lw	s0,28(sp)
80005572:	6105                	addi	sp,sp,32
80005574:	8082                	ret

80005576 <HASH_KeyLengthCmd>:
  * @brief     
  * @param   length  
  * @retval  void
  */
__STATIC_INLINE void HASH_KeyLengthCmd(HASH_LKEY_TypeDef length)
{
80005576:	1101                	addi	sp,sp,-32
80005578:	ce22                	sw	s0,28(sp)
8000557a:	1000                	addi	s0,sp,32
8000557c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_LKEY(length));

	MODIFY_REG(HASH->CR, HASH_CR_LKEY_Msk, length << HASH_CR_LKEY_Pos);
80005580:	200327b7          	lui	a5,0x20032
80005584:	439c                	lw	a5,0(a5)
80005586:	ffb7f693          	andi	a3,a5,-5
8000558a:	fec42783          	lw	a5,-20(s0)
8000558e:	00279713          	slli	a4,a5,0x2
80005592:	200327b7          	lui	a5,0x20032
80005596:	8f55                	or	a4,a4,a3
80005598:	c398                	sw	a4,0(a5)
}
8000559a:	0001                	nop
8000559c:	4472                	lw	s0,28(sp)
8000559e:	6105                	addi	sp,sp,32
800055a0:	8082                	ret

800055a2 <HASH_SameKeyCmd>:
  * @brief        
  * @param   state    
  * @retval  void
  */
__STATIC_INLINE void HASH_SameKeyCmd(FunctionalState state)
{
800055a2:	1101                	addi	sp,sp,-32
800055a4:	ce22                	sw	s0,28(sp)
800055a6:	1000                	addi	s0,sp,32
800055a8:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_SAMK_Msk, state << HASH_CR_SAMK_Pos);
800055ac:	200327b7          	lui	a5,0x20032
800055b0:	439c                	lw	a5,0(a5)
800055b2:	ff77f693          	andi	a3,a5,-9
800055b6:	fec42783          	lw	a5,-20(s0)
800055ba:	00379713          	slli	a4,a5,0x3
800055be:	200327b7          	lui	a5,0x20032
800055c2:	8f55                	or	a4,a4,a3
800055c4:	c398                	sw	a4,0(a5)
}
800055c6:	0001                	nop
800055c8:	4472                	lw	s0,28(sp)
800055ca:	6105                	addi	sp,sp,32
800055cc:	8082                	ret

800055ce <HASH_DataTypeConfig>:
  * @brief     
  * @param   dt  
  * @retval  void
  */
__STATIC_INLINE void HASH_DataTypeConfig(HASH_DATATYPE_TypeDef dt)
{
800055ce:	1101                	addi	sp,sp,-32
800055d0:	ce22                	sw	s0,28(sp)
800055d2:	1000                	addi	s0,sp,32
800055d4:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_DATATYPE(dt));

	MODIFY_REG(HASH->CR, HASH_CR_DATATYPE_Msk, dt << HASH_CR_DATATYPE_Pos);
800055d8:	200327b7          	lui	a5,0x20032
800055dc:	439c                	lw	a5,0(a5)
800055de:	fcf7f693          	andi	a3,a5,-49
800055e2:	fec42783          	lw	a5,-20(s0)
800055e6:	00479713          	slli	a4,a5,0x4
800055ea:	200327b7          	lui	a5,0x20032
800055ee:	8f55                	or	a4,a4,a3
800055f0:	c398                	sw	a4,0(a5)
}
800055f2:	0001                	nop
800055f4:	4472                	lw	s0,28(sp)
800055f6:	6105                	addi	sp,sp,32
800055f8:	8082                	ret

800055fa <HASH_DMACmd>:
  * @brief     DMA
  * @param   state   DMA
  * @retval  void
  */
__STATIC_INLINE void HASH_DMACmd(FunctionalState state)
{
800055fa:	1101                	addi	sp,sp,-32
800055fc:	ce22                	sw	s0,28(sp)
800055fe:	1000                	addi	s0,sp,32
80005600:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_DMAE_Msk, state << HASH_CR_DMAE_Pos);
80005604:	200327b7          	lui	a5,0x20032
80005608:	439c                	lw	a5,0(a5)
8000560a:	fbf7f693          	andi	a3,a5,-65
8000560e:	fec42783          	lw	a5,-20(s0)
80005612:	00679713          	slli	a4,a5,0x6
80005616:	200327b7          	lui	a5,0x20032
8000561a:	8f55                	or	a4,a4,a3
8000561c:	c398                	sw	a4,0(a5)
}
8000561e:	0001                	nop
80005620:	4472                	lw	s0,28(sp)
80005622:	6105                	addi	sp,sp,32
80005624:	8082                	ret

80005626 <HASH_SetMultyDMATransmit>:
  * @brief     MDMAT
  * @param   state   MDMAT
  * @retval  void
  */
__STATIC_INLINE void HASH_SetMultyDMATransmit(FunctionalState state)
{
80005626:	1101                	addi	sp,sp,-32
80005628:	ce22                	sw	s0,28(sp)
8000562a:	1000                	addi	s0,sp,32
8000562c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_MDMAT_Msk, state << HASH_CR_MDMAT_Pos);
80005630:	200327b7          	lui	a5,0x20032
80005634:	439c                	lw	a5,0(a5)
80005636:	f7f7f693          	andi	a3,a5,-129
8000563a:	fec42783          	lw	a5,-20(s0)
8000563e:	00779713          	slli	a4,a5,0x7
80005642:	200327b7          	lui	a5,0x20032
80005646:	8f55                	or	a4,a4,a3
80005648:	c398                	sw	a4,0(a5)
}
8000564a:	0001                	nop
8000564c:	4472                	lw	s0,28(sp)
8000564e:	6105                	addi	sp,sp,32
80005650:	8082                	ret

80005652 <HASH_SetAlgo>:
  * @brief     -
  * @param   algo  -
  * @retval  void
  */
__STATIC_INLINE void HASH_SetAlgo(HASH_ALGO_TypeDef algo)
{
80005652:	1101                	addi	sp,sp,-32
80005654:	ce22                	sw	s0,28(sp)
80005656:	1000                	addi	s0,sp,32
80005658:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_ALGO(algo));

	MODIFY_REG(HASH->CR, HASH_CR_ALGO_Msk, algo << HASH_CR_ALGO_Pos);
8000565c:	200327b7          	lui	a5,0x20032
80005660:	4398                	lw	a4,0(a5)
80005662:	77d1                	lui	a5,0xffff4
80005664:	17fd                	addi	a5,a5,-1 # ffff3fff <__data_source_start+0x7ffece87>
80005666:	00f776b3          	and	a3,a4,a5
8000566a:	fec42783          	lw	a5,-20(s0)
8000566e:	00e79713          	slli	a4,a5,0xe
80005672:	200327b7          	lui	a5,0x20032
80005676:	8f55                	or	a4,a4,a3
80005678:	c398                	sw	a4,0(a5)
}
8000567a:	0001                	nop
8000567c:	4472                	lw	s0,28(sp)
8000567e:	6105                	addi	sp,sp,32
80005680:	8082                	ret

80005682 <HASH_GetAlgo>:
/**
  * @brief      -
  * @retval  algo  -
  */
__STATIC_INLINE HASH_ALGO_TypeDef HASH_GetAlgo()
{
80005682:	1141                	addi	sp,sp,-16
80005684:	c622                	sw	s0,12(sp)
80005686:	0800                	addi	s0,sp,16
	return (HASH_ALGO_TypeDef) ((READ_REG(HASH->CR) & HASH_CR_ALGO_Msk) >> HASH_CR_ALGO_Pos);
80005688:	200327b7          	lui	a5,0x20032
8000568c:	439c                	lw	a5,0(a5)
8000568e:	83b9                	srli	a5,a5,0xe
80005690:	8b8d                	andi	a5,a5,3
}
80005692:	853e                	mv	a0,a5
80005694:	4432                	lw	s0,12(sp)
80005696:	0141                	addi	sp,sp,16
80005698:	8082                	ret

8000569a <HASH_SetData>:
  * @brief       -
  * @param   data   
  * @retval  void
  */
__STATIC_INLINE void HASH_SetData(uint32_t data)
{
8000569a:	1101                	addi	sp,sp,-32
8000569c:	ce22                	sw	s0,28(sp)
8000569e:	1000                	addi	s0,sp,32
800056a0:	fea42623          	sw	a0,-20(s0)
	WRITE_REG(HASH->DATAIN_bit.VAL, data);
800056a4:	200327b7          	lui	a5,0x20032
800056a8:	fec42703          	lw	a4,-20(s0)
800056ac:	c3d8                	sw	a4,4(a5)
}
800056ae:	0001                	nop
800056b0:	4472                	lw	s0,28(sp)
800056b2:	6105                	addi	sp,sp,32
800056b4:	8082                	ret

800056b6 <HASH_GetHash>:
/**
  * @brief        
  * @retval  data   
  */
__STATIC_INLINE uint32_t HASH_GetHash(uint32_t idx)
{
800056b6:	1101                	addi	sp,sp,-32
800056b8:	ce22                	sw	s0,28(sp)
800056ba:	1000                	addi	s0,sp,32
800056bc:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_HR(idx));

	return (uint32_t) READ_REG(HASH->HR[idx].HR);
800056c0:	20032737          	lui	a4,0x20032
800056c4:	fec42783          	lw	a5,-20(s0)
800056c8:	07c1                	addi	a5,a5,16 # 20032010 <STACK_SIZE+0x20031810>
800056ca:	078a                	slli	a5,a5,0x2
800056cc:	97ba                	add	a5,a5,a4
800056ce:	439c                	lw	a5,0(a5)
}
800056d0:	853e                	mv	a0,a5
800056d2:	4472                	lw	s0,28(sp)
800056d4:	6105                	addi	sp,sp,32
800056d6:	8082                	ret

800056d8 <HASH_GetHashLen>:
  * @brief      -
  * @param   buffer    ,        .    10  HR
  * @retval  length  
  */
uint32_t HASH_GetHashLen(HASH_ALGO_TypeDef algo)
{
800056d8:	1101                	addi	sp,sp,-32
800056da:	ce06                	sw	ra,28(sp)
800056dc:	cc22                	sw	s0,24(sp)
800056de:	1000                	addi	s0,sp,32
800056e0:	fea42623          	sw	a0,-20(s0)
	switch(HASH_GetAlgo()) {
800056e4:	3f79                	jal	80005682 <HASH_GetAlgo>
800056e6:	87aa                	mv	a5,a0
800056e8:	470d                	li	a4,3
800056ea:	02e78663          	beq	a5,a4,80005716 <HASH_GetHashLen+0x3e>
800056ee:	470d                	li	a4,3
800056f0:	02f76563          	bltu	a4,a5,8000571a <HASH_GetHashLen+0x42>
800056f4:	4709                	li	a4,2
800056f6:	00e78e63          	beq	a5,a4,80005712 <HASH_GetHashLen+0x3a>
800056fa:	4709                	li	a4,2
800056fc:	00f76f63          	bltu	a4,a5,8000571a <HASH_GetHashLen+0x42>
80005700:	c789                	beqz	a5,8000570a <HASH_GetHashLen+0x32>
80005702:	4705                	li	a4,1
80005704:	00e78563          	beq	a5,a4,8000570e <HASH_GetHashLen+0x36>
80005708:	a809                	j	8000571a <HASH_GetHashLen+0x42>
		case HASH_ALGO_SHA1:
			return 5;
8000570a:	4795                	li	a5,5
8000570c:	a801                	j	8000571c <HASH_GetHashLen+0x44>
		case HASH_ALGO_MD5:
			return 4;
8000570e:	4791                	li	a5,4
80005710:	a031                	j	8000571c <HASH_GetHashLen+0x44>
		case HASH_ALGO_SHA224:
			return 7;
80005712:	479d                	li	a5,7
80005714:	a021                	j	8000571c <HASH_GetHashLen+0x44>
		case HASH_ALGO_SHA256:
			return 8;
80005716:	47a1                	li	a5,8
80005718:	a011                	j	8000571c <HASH_GetHashLen+0x44>
		default:
			return 0;
8000571a:	4781                	li	a5,0
	}
}
8000571c:	853e                	mv	a0,a5
8000571e:	40f2                	lw	ra,28(sp)
80005720:	4462                	lw	s0,24(sp)
80005722:	6105                	addi	sp,sp,32
80005724:	8082                	ret

80005726 <HASH_GetHashBuffer>:

uint32_t HASH_GetHashBuffer(uint32_t* buffer)
{
80005726:	7179                	addi	sp,sp,-48
80005728:	d606                	sw	ra,44(sp)
8000572a:	d422                	sw	s0,40(sp)
8000572c:	d226                	sw	s1,36(sp)
8000572e:	1800                	addi	s0,sp,48
80005730:	fca42e23          	sw	a0,-36(s0)
	uint32_t idx = 0, len = 0;
80005734:	fe042623          	sw	zero,-20(s0)
80005738:	fe042423          	sw	zero,-24(s0)
	idx = len = HASH_GetHashLen(HASH_GetAlgo());
8000573c:	3799                	jal	80005682 <HASH_GetAlgo>
8000573e:	87aa                	mv	a5,a0
80005740:	853e                	mv	a0,a5
80005742:	3f59                	jal	800056d8 <HASH_GetHashLen>
80005744:	fea42423          	sw	a0,-24(s0)
80005748:	fe842783          	lw	a5,-24(s0)
8000574c:	fef42623          	sw	a5,-20(s0)

	while(idx) {
80005750:	a015                	j	80005774 <HASH_GetHashBuffer+0x4e>
		buffer[--idx] = HASH_GetHash(idx);
80005752:	fec42783          	lw	a5,-20(s0)
80005756:	17fd                	addi	a5,a5,-1
80005758:	fef42623          	sw	a5,-20(s0)
8000575c:	fec42783          	lw	a5,-20(s0)
80005760:	078a                	slli	a5,a5,0x2
80005762:	fdc42703          	lw	a4,-36(s0)
80005766:	00f704b3          	add	s1,a4,a5
8000576a:	fec42503          	lw	a0,-20(s0)
8000576e:	37a1                	jal	800056b6 <HASH_GetHash>
80005770:	87aa                	mv	a5,a0
80005772:	c09c                	sw	a5,0(s1)
	while(idx) {
80005774:	fec42783          	lw	a5,-20(s0)
80005778:	ffe9                	bnez	a5,80005752 <HASH_GetHashBuffer+0x2c>
	}

	return len;
8000577a:	fe842783          	lw	a5,-24(s0)
}
8000577e:	853e                	mv	a0,a5
80005780:	50b2                	lw	ra,44(sp)
80005782:	5422                	lw	s0,40(sp)
80005784:	5492                	lw	s1,36(sp)
80005786:	6145                	addi	sp,sp,48
80005788:	8082                	ret

8000578a <HASH_SetHashBuffer>:

void HASH_SetHashBuffer(uint32_t* buffer, uint32_t len)
{
8000578a:	7179                	addi	sp,sp,-48
8000578c:	d606                	sw	ra,44(sp)
8000578e:	d422                	sw	s0,40(sp)
80005790:	1800                	addi	s0,sp,48
80005792:	fca42e23          	sw	a0,-36(s0)
80005796:	fcb42c23          	sw	a1,-40(s0)
	for (uint32_t i = 0 ; i < len; i++)
8000579a:	fe042623          	sw	zero,-20(s0)
8000579e:	a839                	j	800057bc <HASH_SetHashBuffer+0x32>
	{
		HASH_SetData(buffer[i]);
800057a0:	fec42783          	lw	a5,-20(s0)
800057a4:	078a                	slli	a5,a5,0x2
800057a6:	fdc42703          	lw	a4,-36(s0)
800057aa:	97ba                	add	a5,a5,a4
800057ac:	439c                	lw	a5,0(a5)
800057ae:	853e                	mv	a0,a5
800057b0:	35ed                	jal	8000569a <HASH_SetData>
	for (uint32_t i = 0 ; i < len; i++)
800057b2:	fec42783          	lw	a5,-20(s0)
800057b6:	0785                	addi	a5,a5,1
800057b8:	fef42623          	sw	a5,-20(s0)
800057bc:	fec42703          	lw	a4,-20(s0)
800057c0:	fd842783          	lw	a5,-40(s0)
800057c4:	fcf76ee3          	bltu	a4,a5,800057a0 <HASH_SetHashBuffer+0x16>
	}
}
800057c8:	0001                	nop
800057ca:	0001                	nop
800057cc:	50b2                	lw	ra,44(sp)
800057ce:	5422                	lw	s0,40(sp)
800057d0:	6145                	addi	sp,sp,48
800057d2:	8082                	ret

800057d4 <HASH_DeInit>:
/**
  * @brief      HASH   
  * @retval  void
  */
void HASH_DeInit()
{
800057d4:	1141                	addi	sp,sp,-16
800057d6:	c606                	sw	ra,12(sp)
800057d8:	c422                	sw	s0,8(sp)
800057da:	0800                	addi	s0,sp,16
	HASH_InitCmd(DISABLE);
800057dc:	4501                	li	a0,0
800057de:	3391                	jal	80005522 <HASH_InitCmd>

    RCU_AHBRstCmd(RCU_AHBRst_HASH, DISABLE);
800057e0:	4581                	li	a1,0
800057e2:	4521                	li	a0,8
800057e4:	3301                	jal	800054e4 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(RCU_AHBRst_HASH, ENABLE);
800057e6:	4585                	li	a1,1
800057e8:	4521                	li	a0,8
800057ea:	39ed                	jal	800054e4 <RCU_AHBRstCmd>
}
800057ec:	0001                	nop
800057ee:	40b2                	lw	ra,12(sp)
800057f0:	4422                	lw	s0,8(sp)
800057f2:	0141                	addi	sp,sp,16
800057f4:	8082                	ret

800057f6 <HASH_Init>:
  * @param   InitStruct      @ref HASH_Init_TypeDef,
  *                         
  * @retval  void
  */
void HASH_Init(HASH_Init_TypeDef* InitStruct)
{
800057f6:	1101                	addi	sp,sp,-32
800057f8:	ce06                	sw	ra,28(sp)
800057fa:	cc22                	sw	s0,24(sp)
800057fc:	1000                	addi	s0,sp,32
800057fe:	fea42623          	sw	a0,-20(s0)
	RCU_AHBClkCmd(RCU_AHBClk_HASH, ENABLE);
80005802:	4585                	li	a1,1
80005804:	4521                	li	a0,8
80005806:	3145                	jal	800054a6 <RCU_AHBClkCmd>
    RCU_AHBRstCmd(RCU_AHBRst_HASH, ENABLE);
80005808:	4585                	li	a1,1
8000580a:	4521                	li	a0,8
8000580c:	39e1                	jal	800054e4 <RCU_AHBRstCmd>

	HASH_DMACmd(InitStruct->DMATransmition);
8000580e:	fec42783          	lw	a5,-20(s0)
80005812:	4b9c                	lw	a5,16(a5)
80005814:	853e                	mv	a0,a5
80005816:	33d5                	jal	800055fa <HASH_DMACmd>
	HASH_KeyLengthCmd(InitStruct->LongKey);
80005818:	fec42783          	lw	a5,-20(s0)
8000581c:	43dc                	lw	a5,4(a5)
8000581e:	853e                	mv	a0,a5
80005820:	3b99                	jal	80005576 <HASH_KeyLengthCmd>
	HASH_SetMultyDMATransmit(InitStruct->MultyDMATransmition);
80005822:	fec42783          	lw	a5,-20(s0)
80005826:	4bdc                	lw	a5,20(a5)
80005828:	853e                	mv	a0,a5
8000582a:	3bf5                	jal	80005626 <HASH_SetMultyDMATransmit>
	HASH_SetAlgo(InitStruct->Algo);
8000582c:	fec42783          	lw	a5,-20(s0)
80005830:	4f9c                	lw	a5,24(a5)
80005832:	853e                	mv	a0,a5
80005834:	3d39                	jal	80005652 <HASH_SetAlgo>
	HASH_DataTypeConfig(InitStruct->DataType);
80005836:	fec42783          	lw	a5,-20(s0)
8000583a:	47dc                	lw	a5,12(a5)
8000583c:	853e                	mv	a0,a5
8000583e:	3b41                	jal	800055ce <HASH_DataTypeConfig>
	HASH_ModeCmd(InitStruct->Mode);
80005840:	fec42783          	lw	a5,-20(s0)
80005844:	439c                	lw	a5,0(a5)
80005846:	853e                	mv	a0,a5
80005848:	3309                	jal	8000554a <HASH_ModeCmd>
	HASH_SameKeyCmd(InitStruct->SameKey);
8000584a:	fec42783          	lw	a5,-20(s0)
8000584e:	479c                	lw	a5,8(a5)
80005850:	853e                	mv	a0,a5
80005852:	3b81                	jal	800055a2 <HASH_SameKeyCmd>

	HASH_InitCmd(ENABLE);
80005854:	4505                	li	a0,1
80005856:	31f1                	jal	80005522 <HASH_InitCmd>
}
80005858:	0001                	nop
8000585a:	40f2                	lw	ra,28(sp)
8000585c:	4462                	lw	s0,24(sp)
8000585e:	6105                	addi	sp,sp,32
80005860:	8082                	ret

80005862 <HASH_StructInit>:
  * @param   InitStruct      @ref HASH_Init_TypeDef,
  *                        
  * @retval  void
  */
void HASH_StructInit(HASH_Init_TypeDef* InitStruct)
{
80005862:	1101                	addi	sp,sp,-32
80005864:	ce22                	sw	s0,28(sp)
80005866:	1000                	addi	s0,sp,32
80005868:	fea42623          	sw	a0,-20(s0)
	InitStruct->DMATransmition = 0x0;
8000586c:	fec42783          	lw	a5,-20(s0)
80005870:	0007a823          	sw	zero,16(a5)
	InitStruct->LongKey = HASH_LKEY_ShortKey;
80005874:	fec42783          	lw	a5,-20(s0)
80005878:	0007a223          	sw	zero,4(a5)
	InitStruct->MultyDMATransmition = 0x0;
8000587c:	fec42783          	lw	a5,-20(s0)
80005880:	0007aa23          	sw	zero,20(a5)
	InitStruct->Algo = HASH_ALGO_SHA1;
80005884:	fec42783          	lw	a5,-20(s0)
80005888:	0007ac23          	sw	zero,24(a5)
	InitStruct->DataType = HASH_DATATYPE_Word;
8000588c:	fec42783          	lw	a5,-20(s0)
80005890:	0007a623          	sw	zero,12(a5)
	InitStruct->Mode = HASH_MODE_Hash;
80005894:	fec42783          	lw	a5,-20(s0)
80005898:	0007a023          	sw	zero,0(a5)
	InitStruct->SameKey = 0x0;
8000589c:	fec42783          	lw	a5,-20(s0)
800058a0:	0007a423          	sw	zero,8(a5)
}
800058a4:	0001                	nop
800058a6:	4472                	lw	s0,28(sp)
800058a8:	6105                	addi	sp,sp,32
800058aa:	8082                	ret

800058ac <I2C_FSDivLowConfig>:
  *              4 ,  ,     6.
  * @param      DivVal   ( [6:0])
  * @retval     void
  */
__STATIC_INLINE void I2C_FSDivLowConfig(uint32_t DivVal)
{
800058ac:	1101                	addi	sp,sp,-32
800058ae:	ce22                	sw	s0,28(sp)
800058b0:	1000                	addi	s0,sp,32
800058b2:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_FS_DIV_LOW_VAL(DivVal));

    WRITE_REG(I2C->CTL1_bit.SCLFRQ, DivVal);
800058b6:	300057b7          	lui	a5,0x30005
800058ba:	fec42703          	lw	a4,-20(s0)
800058be:	07f77713          	andi	a4,a4,127
800058c2:	0ff77713          	zext.b	a4,a4
800058c6:	0706                	slli	a4,a4,0x1
800058c8:	0147c683          	lbu	a3,20(a5) # 30005014 <STACK_SIZE+0x30004814>
800058cc:	8a85                	andi	a3,a3,1
800058ce:	8f55                	or	a4,a4,a3
800058d0:	00e78a23          	sb	a4,20(a5)
}
800058d4:	0001                	nop
800058d6:	4472                	lw	s0,28(sp)
800058d8:	6105                	addi	sp,sp,32
800058da:	8082                	ret

800058dc <I2C_FSDivHighConfig>:
  * @brief          FS 
  * @param   DivVal   ( [7:0])
  * @retval  void
  */
__STATIC_INLINE void I2C_FSDivHighConfig(uint32_t DivVal)
{
800058dc:	1101                	addi	sp,sp,-32
800058de:	ce22                	sw	s0,28(sp)
800058e0:	1000                	addi	s0,sp,32
800058e2:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_FS_DIV_HIGH_VAL(DivVal));

    WRITE_REG(I2C->CTL3_bit.SCLFRQ, DivVal);
800058e6:	300057b7          	lui	a5,0x30005
800058ea:	fec42703          	lw	a4,-20(s0)
800058ee:	0ff77713          	zext.b	a4,a4
800058f2:	02e78023          	sb	a4,32(a5) # 30005020 <STACK_SIZE+0x30004820>
}
800058f6:	0001                	nop
800058f8:	4472                	lw	s0,28(sp)
800058fa:	6105                	addi	sp,sp,32
800058fc:	8082                	ret

800058fe <I2C_HSDivLowConfig>:
  *              2 ,  ,     3.
  * @param      DivVal   ( [3:0])
  * @retval     void
  */
__STATIC_INLINE void I2C_HSDivLowConfig(uint32_t DivVal)
{
800058fe:	1101                	addi	sp,sp,-32
80005900:	ce22                	sw	s0,28(sp)
80005902:	1000                	addi	s0,sp,32
80005904:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_HS_DIV_LOW_VAL(DivVal));

    WRITE_REG(I2C->CTL2_bit.HSDIV, DivVal);
80005908:	300057b7          	lui	a5,0x30005
8000590c:	fec42703          	lw	a4,-20(s0)
80005910:	8b3d                	andi	a4,a4,15
80005912:	0ff77713          	zext.b	a4,a4
80005916:	0712                	slli	a4,a4,0x4
80005918:	01c7c683          	lbu	a3,28(a5) # 3000501c <STACK_SIZE+0x3000481c>
8000591c:	8abd                	andi	a3,a3,15
8000591e:	8f55                	or	a4,a4,a3
80005920:	00e78e23          	sb	a4,28(a5)
}
80005924:	0001                	nop
80005926:	4472                	lw	s0,28(sp)
80005928:	6105                	addi	sp,sp,32
8000592a:	8082                	ret

8000592c <I2C_HSDivHighConfig>:
  * @brief          HS 
  * @param   DivVal   ( [7:0])
  * @retval  void
  */
__STATIC_INLINE void I2C_HSDivHighConfig(uint32_t DivVal)
{
8000592c:	1101                	addi	sp,sp,-32
8000592e:	ce22                	sw	s0,28(sp)
80005930:	1000                	addi	s0,sp,32
80005932:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_HS_DIV_HIGH_VAL(DivVal));

    WRITE_REG(I2C->CTL4_bit.HSDIV, DivVal);
80005936:	300057b7          	lui	a5,0x30005
8000593a:	fec42703          	lw	a4,-20(s0)
8000593e:	0ff77713          	zext.b	a4,a4
80005942:	02e78223          	sb	a4,36(a5) # 30005024 <STACK_SIZE+0x30004824>
}
80005946:	0001                	nop
80005948:	4472                	lw	s0,28(sp)
8000594a:	6105                	addi	sp,sp,32
8000594c:	8082                	ret

8000594e <I2C_FSFreqConfig>:
  * @param   FSFreq      
  * @param   I2CFreq       I2C  
  * @retval  void
  */
void I2C_FSFreqConfig(uint32_t FSFreq, uint32_t I2CFreq)
{
8000594e:	7179                	addi	sp,sp,-48
80005950:	d606                	sw	ra,44(sp)
80005952:	d422                	sw	s0,40(sp)
80005954:	1800                	addi	s0,sp,48
80005956:	fca42e23          	sw	a0,-36(s0)
8000595a:	fcb42c23          	sw	a1,-40(s0)
    uint32_t freq_calc = I2CFreq / (4 * FSFreq);
8000595e:	fdc42783          	lw	a5,-36(s0)
80005962:	078a                	slli	a5,a5,0x2
80005964:	fd842703          	lw	a4,-40(s0)
80005968:	02f757b3          	divu	a5,a4,a5
8000596c:	fef42623          	sw	a5,-20(s0)

    I2C_FSDivLowConfig(freq_calc & 0x7F);
80005970:	fec42783          	lw	a5,-20(s0)
80005974:	07f7f793          	andi	a5,a5,127
80005978:	853e                	mv	a0,a5
8000597a:	3f0d                	jal	800058ac <I2C_FSDivLowConfig>
    I2C_FSDivHighConfig(freq_calc >> 7);
8000597c:	fec42783          	lw	a5,-20(s0)
80005980:	839d                	srli	a5,a5,0x7
80005982:	853e                	mv	a0,a5
80005984:	3fa1                	jal	800058dc <I2C_FSDivHighConfig>
}
80005986:	0001                	nop
80005988:	50b2                	lw	ra,44(sp)
8000598a:	5422                	lw	s0,40(sp)
8000598c:	6145                	addi	sp,sp,48
8000598e:	8082                	ret

80005990 <I2C_HSFreqConfig>:
  * @param   HSFreq      
  * @param   I2CFreq       I2C  
  * @retval  void
  */
void I2C_HSFreqConfig(uint32_t HSFreq, uint32_t I2CFreq)
{
80005990:	7179                	addi	sp,sp,-48
80005992:	d606                	sw	ra,44(sp)
80005994:	d422                	sw	s0,40(sp)
80005996:	1800                	addi	s0,sp,48
80005998:	fca42e23          	sw	a0,-36(s0)
8000599c:	fcb42c23          	sw	a1,-40(s0)
    uint32_t freq_calc = I2CFreq / (3 * HSFreq);
800059a0:	fdc42703          	lw	a4,-36(s0)
800059a4:	87ba                	mv	a5,a4
800059a6:	0786                	slli	a5,a5,0x1
800059a8:	97ba                	add	a5,a5,a4
800059aa:	fd842703          	lw	a4,-40(s0)
800059ae:	02f757b3          	divu	a5,a4,a5
800059b2:	fef42623          	sw	a5,-20(s0)

    I2C_HSDivLowConfig(freq_calc & 0x0F);
800059b6:	fec42783          	lw	a5,-20(s0)
800059ba:	8bbd                	andi	a5,a5,15
800059bc:	853e                	mv	a0,a5
800059be:	3781                	jal	800058fe <I2C_HSDivLowConfig>
    I2C_HSDivHighConfig(freq_calc >> 4);
800059c0:	fec42783          	lw	a5,-20(s0)
800059c4:	8391                	srli	a5,a5,0x4
800059c6:	853e                	mv	a0,a5
800059c8:	3795                	jal	8000592c <I2C_HSDivHighConfig>
}
800059ca:	0001                	nop
800059cc:	50b2                	lw	ra,44(sp)
800059ce:	5422                	lw	s0,40(sp)
800059d0:	6145                	addi	sp,sp,48
800059d2:	8082                	ret

800059d4 <RCU_AHBRstCmd>:
{
800059d4:	1101                	addi	sp,sp,-32
800059d6:	ce22                	sw	s0,28(sp)
800059d8:	1000                	addi	s0,sp,32
800059da:	fea42623          	sw	a0,-20(s0)
800059de:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
800059e2:	3000e7b7          	lui	a5,0x3000e
800059e6:	4b98                	lw	a4,16(a5)
800059e8:	fec42783          	lw	a5,-20(s0)
800059ec:	fff7c793          	not	a5,a5
800059f0:	00f776b3          	and	a3,a4,a5
800059f4:	fe842783          	lw	a5,-24(s0)
800059f8:	c781                	beqz	a5,80005a00 <RCU_AHBRstCmd+0x2c>
800059fa:	fec42783          	lw	a5,-20(s0)
800059fe:	a011                	j	80005a02 <RCU_AHBRstCmd+0x2e>
80005a00:	4781                	li	a5,0
80005a02:	3000e737          	lui	a4,0x3000e
80005a06:	8fd5                	or	a5,a5,a3
80005a08:	cb1c                	sw	a5,16(a4)
}
80005a0a:	0001                	nop
80005a0c:	4472                	lw	s0,28(sp)
80005a0e:	6105                	addi	sp,sp,32
80005a10:	8082                	ret

80005a12 <QSPI_ModeConfig>:
  * @brief     
  * @param   mode  
  * @retval  void
  */
__STATIC_INLINE void QSPI_ModeConfig(QSPI_Mode_TypeDef mode)
{
80005a12:	1101                	addi	sp,sp,-32
80005a14:	ce22                	sw	s0,28(sp)
80005a16:	1000                	addi	s0,sp,32
80005a18:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_QSPI_MODE(mode));

    WRITE_REG(QSPI->DCR_bit.FMOD, mode);
80005a1c:	200407b7          	lui	a5,0x20040
80005a20:	fec42703          	lw	a4,-20(s0)
80005a24:	8b1d                	andi	a4,a4,7
80005a26:	0ff77713          	zext.b	a4,a4
80005a2a:	8b1d                	andi	a4,a4,7
80005a2c:	0742                	slli	a4,a4,0x10
80005a2e:	43d0                	lw	a2,4(a5)
80005a30:	fff906b7          	lui	a3,0xfff90
80005a34:	16fd                	addi	a3,a3,-1 # fff8ffff <__data_source_start+0x7ff88e87>
80005a36:	8ef1                	and	a3,a3,a2
80005a38:	8f55                	or	a4,a4,a3
80005a3a:	c3d8                	sw	a4,4(a5)
}
80005a3c:	0001                	nop
80005a3e:	4472                	lw	s0,28(sp)
80005a40:	6105                	addi	sp,sp,32
80005a42:	8082                	ret

80005a44 <QSPI_SCKDivConfig>:
  * @param   div	  .
  *                        0-255.
  * @retval  void
  */
__STATIC_INLINE void QSPI_SCKDivConfig(uint32_t div)
{
80005a44:	1101                	addi	sp,sp,-32
80005a46:	ce22                	sw	s0,28(sp)
80005a48:	1000                	addi	s0,sp,32
80005a4a:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_QSPI_CDIV(div));

    WRITE_REG(QSPI->DCR_bit.CDIV, div);
80005a4e:	200407b7          	lui	a5,0x20040
80005a52:	fec42703          	lw	a4,-20(s0)
80005a56:	0ff77713          	zext.b	a4,a4
80005a5a:	00e782a3          	sb	a4,5(a5) # 20040005 <STACK_SIZE+0x2003f805>
}
80005a5e:	0001                	nop
80005a60:	4472                	lw	s0,28(sp)
80005a62:	6105                	addi	sp,sp,32
80005a64:	8082                	ret

80005a66 <QSPI_SetWordLength>:
  * @brief      
  * @param   length  ,   1  32
  * @retval  void
  */
__STATIC_INLINE void QSPI_SetWordLength(uint32_t length)
{
80005a66:	1101                	addi	sp,sp,-32
80005a68:	ce22                	sw	s0,28(sp)
80005a6a:	1000                	addi	s0,sp,32
80005a6c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_WORD(length));

	WRITE_REG(QSPI->TCR_bit.LEN, length);
80005a70:	200407b7          	lui	a5,0x20040
80005a74:	fec42703          	lw	a4,-20(s0)
80005a78:	03f77713          	andi	a4,a4,63
80005a7c:	0ff77713          	zext.b	a4,a4
80005a80:	03f77713          	andi	a4,a4,63
80005a84:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80005a88:	fc06f693          	andi	a3,a3,-64
80005a8c:	8f55                	or	a4,a4,a3
80005a8e:	00e79623          	sh	a4,12(a5)
}
80005a92:	0001                	nop
80005a94:	4472                	lw	s0,28(sp)
80005a96:	6105                	addi	sp,sp,32
80005a98:	8082                	ret

80005a9a <QSPI_SPIDataRateConfig>:
  * @brief      
  * @param   dataRate     @ref QSPI_DR_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_SPIDataRateConfig(QSPI_SPI_DataRate_TypeDef dataRate)
{
80005a9a:	1101                	addi	sp,sp,-32
80005a9c:	ce22                	sw	s0,28(sp)
80005a9e:	1000                	addi	s0,sp,32
80005aa0:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_SPI_DR(dataRate));

	WRITE_REG(QSPI->TCR_bit.DDR, dataRate);
80005aa4:	200407b7          	lui	a5,0x20040
80005aa8:	fec42703          	lw	a4,-20(s0)
80005aac:	8b05                	andi	a4,a4,1
80005aae:	0ff77713          	zext.b	a4,a4
80005ab2:	8b05                	andi	a4,a4,1
80005ab4:	071e                	slli	a4,a4,0x7
80005ab6:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80005aba:	f7f6f693          	andi	a3,a3,-129
80005abe:	8f55                	or	a4,a4,a3
80005ac0:	00e79623          	sh	a4,12(a5)
}
80005ac4:	0001                	nop
80005ac6:	4472                	lw	s0,28(sp)
80005ac8:	6105                	addi	sp,sp,32
80005aca:	8082                	ret

80005acc <QSPI_TxCmd>:
  * @brief    
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void QSPI_TxCmd(FunctionalState state)
{
80005acc:	1101                	addi	sp,sp,-32
80005ace:	ce22                	sw	s0,28(sp)
80005ad0:	1000                	addi	s0,sp,32
80005ad2:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	WRITE_REG(QSPI->TCR_bit.TXE, state);
80005ad6:	200407b7          	lui	a5,0x20040
80005ada:	fec42703          	lw	a4,-20(s0)
80005ade:	8b05                	andi	a4,a4,1
80005ae0:	0ff77713          	zext.b	a4,a4
80005ae4:	8b05                	andi	a4,a4,1
80005ae6:	0722                	slli	a4,a4,0x8
80005ae8:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80005aec:	eff6f693          	andi	a3,a3,-257
80005af0:	8f55                	or	a4,a4,a3
80005af2:	00e79623          	sh	a4,12(a5)
}
80005af6:	0001                	nop
80005af8:	4472                	lw	s0,28(sp)
80005afa:	6105                	addi	sp,sp,32
80005afc:	8082                	ret

80005afe <QSPI_RxCmd>:
  * @brief    
  * @param   state  
  * @retval  void
  */
__STATIC_INLINE void QSPI_RxCmd(FunctionalState state)
{
80005afe:	1101                	addi	sp,sp,-32
80005b00:	ce22                	sw	s0,28(sp)
80005b02:	1000                	addi	s0,sp,32
80005b04:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	WRITE_REG(QSPI->TCR_bit.RXE, state);
80005b08:	200407b7          	lui	a5,0x20040
80005b0c:	fec42703          	lw	a4,-20(s0)
80005b10:	8b05                	andi	a4,a4,1
80005b12:	0ff77713          	zext.b	a4,a4
80005b16:	8b05                	andi	a4,a4,1
80005b18:	0726                	slli	a4,a4,0x9
80005b1a:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80005b1e:	dff6f693          	andi	a3,a3,-513
80005b22:	8f55                	or	a4,a4,a3
80005b24:	00e79623          	sh	a4,12(a5)
}
80005b28:	0001                	nop
80005b2a:	4472                	lw	s0,28(sp)
80005b2c:	6105                	addi	sp,sp,32
80005b2e:	8082                	ret

80005b30 <QSPI_SPITransactionModeConfig>:
  * @brief      
  * @param   mode    @ref QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_SPITransactionModeConfig(QSPI_SPI_IOMode_TypeDef mode)
{
80005b30:	1101                	addi	sp,sp,-32
80005b32:	ce22                	sw	s0,28(sp)
80005b34:	1000                	addi	s0,sp,32
80005b36:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_SPI_IOMODE(mode));

	WRITE_REG(QSPI->TCR_bit.IOM, mode);
80005b3a:	200407b7          	lui	a5,0x20040
80005b3e:	fec42703          	lw	a4,-20(s0)
80005b42:	8b0d                	andi	a4,a4,3
80005b44:	0ff77713          	zext.b	a4,a4
80005b48:	8b0d                	andi	a4,a4,3
80005b4a:	00a71613          	slli	a2,a4,0xa
80005b4e:	00c7d703          	lhu	a4,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80005b52:	86ba                	mv	a3,a4
80005b54:	777d                	lui	a4,0xfffff
80005b56:	3ff70713          	addi	a4,a4,1023 # fffff3ff <__data_source_start+0x7fff8287>
80005b5a:	8f75                	and	a4,a4,a3
80005b5c:	86ba                	mv	a3,a4
80005b5e:	8732                	mv	a4,a2
80005b60:	8f55                	or	a4,a4,a3
80005b62:	00e79623          	sh	a4,12(a5)
}
80005b66:	0001                	nop
80005b68:	4472                	lw	s0,28(sp)
80005b6a:	6105                	addi	sp,sp,32
80005b6c:	8082                	ret

80005b6e <QSPI_InstructionConfig>:
  * @brief        
  * @param   instruction  ,      QuadSPI
  * @retval  void
  */
__STATIC_INLINE void QSPI_InstructionConfig(uint8_t instruction)
{
80005b6e:	1101                	addi	sp,sp,-32
80005b70:	ce22                	sw	s0,28(sp)
80005b72:	1000                	addi	s0,sp,32
80005b74:	87aa                	mv	a5,a0
80005b76:	fef407a3          	sb	a5,-17(s0)
	WRITE_REG(QSPI->QCC_bit.INST, instruction);
80005b7a:	200407b7          	lui	a5,0x20040
80005b7e:	fef44703          	lbu	a4,-17(s0)
80005b82:	00e78c23          	sb	a4,24(a5) # 20040018 <STACK_SIZE+0x2003f818>
}
80005b86:	0001                	nop
80005b88:	4472                	lw	s0,28(sp)
80005b8a:	6105                	addi	sp,sp,32
80005b8c:	8082                	ret

80005b8e <QSPI_InstructionModeConfig>:
  * @brief        QuadSPI
  * @param   mode    @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_InstructionModeConfig(QSPI_IOMode_TypeDef mode)
{
80005b8e:	1101                	addi	sp,sp,-32
80005b90:	ce22                	sw	s0,28(sp)
80005b92:	1000                	addi	s0,sp,32
80005b94:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.IMOD, mode);
80005b98:	200407b7          	lui	a5,0x20040
80005b9c:	fec42703          	lw	a4,-20(s0)
80005ba0:	8b0d                	andi	a4,a4,3
80005ba2:	0ff77713          	zext.b	a4,a4
80005ba6:	8b0d                	andi	a4,a4,3
80005ba8:	0722                	slli	a4,a4,0x8
80005baa:	4f94                	lw	a3,24(a5)
80005bac:	cff6f693          	andi	a3,a3,-769
80005bb0:	8f55                	or	a4,a4,a3
80005bb2:	cf98                	sw	a4,24(a5)
}
80005bb4:	0001                	nop
80005bb6:	4472                	lw	s0,28(sp)
80005bb8:	6105                	addi	sp,sp,32
80005bba:	8082                	ret

80005bbc <QSPI_AddressModeConfig>:
  * @brief        QuadSPI
  * @param   mode    @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AddressModeConfig(QSPI_IOMode_TypeDef mode)
{
80005bbc:	1101                	addi	sp,sp,-32
80005bbe:	ce22                	sw	s0,28(sp)
80005bc0:	1000                	addi	s0,sp,32
80005bc2:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.ADMOD, mode);
80005bc6:	200407b7          	lui	a5,0x20040
80005bca:	fec42703          	lw	a4,-20(s0)
80005bce:	8b0d                	andi	a4,a4,3
80005bd0:	0ff77713          	zext.b	a4,a4
80005bd4:	8b0d                	andi	a4,a4,3
80005bd6:	072a                	slli	a4,a4,0xa
80005bd8:	4f90                	lw	a2,24(a5)
80005bda:	76fd                	lui	a3,0xfffff
80005bdc:	3ff68693          	addi	a3,a3,1023 # fffff3ff <__data_source_start+0x7fff8287>
80005be0:	8ef1                	and	a3,a3,a2
80005be2:	8f55                	or	a4,a4,a3
80005be4:	cf98                	sw	a4,24(a5)
}
80005be6:	0001                	nop
80005be8:	4472                	lw	s0,28(sp)
80005bea:	6105                	addi	sp,sp,32
80005bec:	8082                	ret

80005bee <QSPI_AddressSizeConfig>:
  * @brief       QuadSPI
  * @param   size   @ref QSPI_QSPI_DataSize_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AddressSizeConfig(QSPI_DataSize_TypeDef size)
{
80005bee:	1101                	addi	sp,sp,-32
80005bf0:	ce22                	sw	s0,28(sp)
80005bf2:	1000                	addi	s0,sp,32
80005bf4:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATASIZE(size));

	WRITE_REG(QSPI->QCC_bit.ADSIZ, size);
80005bf8:	200407b7          	lui	a5,0x20040
80005bfc:	fec42703          	lw	a4,-20(s0)
80005c00:	8b0d                	andi	a4,a4,3
80005c02:	0ff77713          	zext.b	a4,a4
80005c06:	8b0d                	andi	a4,a4,3
80005c08:	0732                	slli	a4,a4,0xc
80005c0a:	4f90                	lw	a2,24(a5)
80005c0c:	76f5                	lui	a3,0xffffd
80005c0e:	16fd                	addi	a3,a3,-1 # ffffcfff <__data_source_start+0x7fff5e87>
80005c10:	8ef1                	and	a3,a3,a2
80005c12:	8f55                	or	a4,a4,a3
80005c14:	cf98                	sw	a4,24(a5)
}
80005c16:	0001                	nop
80005c18:	4472                	lw	s0,28(sp)
80005c1a:	6105                	addi	sp,sp,32
80005c1c:	8082                	ret

80005c1e <QSPI_AdditionalModeConfig>:
  * @brief         QuadSPI
  * @param   mode    @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AdditionalModeConfig(QSPI_IOMode_TypeDef mode)
{
80005c1e:	1101                	addi	sp,sp,-32
80005c20:	ce22                	sw	s0,28(sp)
80005c22:	1000                	addi	s0,sp,32
80005c24:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.ABMOD, mode);
80005c28:	200407b7          	lui	a5,0x20040
80005c2c:	fec42703          	lw	a4,-20(s0)
80005c30:	8b0d                	andi	a4,a4,3
80005c32:	0ff77713          	zext.b	a4,a4
80005c36:	8b0d                	andi	a4,a4,3
80005c38:	073a                	slli	a4,a4,0xe
80005c3a:	4f90                	lw	a2,24(a5)
80005c3c:	76d1                	lui	a3,0xffff4
80005c3e:	16fd                	addi	a3,a3,-1 # ffff3fff <__data_source_start+0x7ffece87>
80005c40:	8ef1                	and	a3,a3,a2
80005c42:	8f55                	or	a4,a4,a3
80005c44:	cf98                	sw	a4,24(a5)
}
80005c46:	0001                	nop
80005c48:	4472                	lw	s0,28(sp)
80005c4a:	6105                	addi	sp,sp,32
80005c4c:	8082                	ret

80005c4e <QSPI_AdditionalSizeConfig>:
  * @brief        QuadSPI
  * @param   size   @ref QSPI_QSPI_DataSize_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AdditionalSizeConfig(QSPI_DataSize_TypeDef size)
{
80005c4e:	1101                	addi	sp,sp,-32
80005c50:	ce22                	sw	s0,28(sp)
80005c52:	1000                	addi	s0,sp,32
80005c54:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATASIZE(size));

	WRITE_REG(QSPI->QCC_bit.ABSIZ, size);
80005c58:	200407b7          	lui	a5,0x20040
80005c5c:	fec42703          	lw	a4,-20(s0)
80005c60:	8b0d                	andi	a4,a4,3
80005c62:	0ff77713          	zext.b	a4,a4
80005c66:	8b0d                	andi	a4,a4,3
80005c68:	0742                	slli	a4,a4,0x10
80005c6a:	4f90                	lw	a2,24(a5)
80005c6c:	fffd06b7          	lui	a3,0xfffd0
80005c70:	16fd                	addi	a3,a3,-1 # fffcffff <__data_source_start+0x7ffc8e87>
80005c72:	8ef1                	and	a3,a3,a2
80005c74:	8f55                	or	a4,a4,a3
80005c76:	cf98                	sw	a4,24(a5)
}
80005c78:	0001                	nop
80005c7a:	4472                	lw	s0,28(sp)
80005c7c:	6105                	addi	sp,sp,32
80005c7e:	8082                	ret

80005c80 <QSPI_WaitCyclesConfig>:
  * @brief        QuadSPI
  * @param   waitCycles       0  31
  * @retval  void
  */
__STATIC_INLINE void QSPI_WaitCyclesConfig(uint32_t waitCycles)
{
80005c80:	1101                	addi	sp,sp,-32
80005c82:	ce22                	sw	s0,28(sp)
80005c84:	1000                	addi	s0,sp,32
80005c86:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DCYCS(waitCycles));

	WRITE_REG(QSPI->QCC_bit.DCYCS, waitCycles);
80005c8a:	200407b7          	lui	a5,0x20040
80005c8e:	fec42703          	lw	a4,-20(s0)
80005c92:	8b7d                	andi	a4,a4,31
80005c94:	0ff77713          	zext.b	a4,a4
80005c98:	8b7d                	andi	a4,a4,31
80005c9a:	074a                	slli	a4,a4,0x12
80005c9c:	4f90                	lw	a2,24(a5)
80005c9e:	ff8406b7          	lui	a3,0xff840
80005ca2:	16fd                	addi	a3,a3,-1 # ff83ffff <__data_source_start+0x7f838e87>
80005ca4:	8ef1                	and	a3,a3,a2
80005ca6:	8f55                	or	a4,a4,a3
80005ca8:	cf98                	sw	a4,24(a5)
}
80005caa:	0001                	nop
80005cac:	4472                	lw	s0,28(sp)
80005cae:	6105                	addi	sp,sp,32
80005cb0:	8082                	ret

80005cb2 <QSPI_DataModeConfig>:
  * @brief        QuadSPI
  * @param   mode    @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataModeConfig(QSPI_IOMode_TypeDef mode)
{
80005cb2:	1101                	addi	sp,sp,-32
80005cb4:	ce22                	sw	s0,28(sp)
80005cb6:	1000                	addi	s0,sp,32
80005cb8:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.DMOD, mode);
80005cbc:	200407b7          	lui	a5,0x20040
80005cc0:	fec42703          	lw	a4,-20(s0)
80005cc4:	8b0d                	andi	a4,a4,3
80005cc6:	0ff77713          	zext.b	a4,a4
80005cca:	8b0d                	andi	a4,a4,3
80005ccc:	0762                	slli	a4,a4,0x18
80005cce:	4f90                	lw	a2,24(a5)
80005cd0:	fd0006b7          	lui	a3,0xfd000
80005cd4:	16fd                	addi	a3,a3,-1 # fcffffff <__data_source_start+0x7cff8e87>
80005cd6:	8ef1                	and	a3,a3,a2
80005cd8:	8f55                	or	a4,a4,a3
80005cda:	cf98                	sw	a4,24(a5)
}
80005cdc:	0001                	nop
80005cde:	4472                	lw	s0,28(sp)
80005ce0:	6105                	addi	sp,sp,32
80005ce2:	8082                	ret

80005ce4 <QSPI_DataDirectionConfig>:
  * @brief        QuadSPI
  * @param   dir     @ref QSPI_QSPI_Direction_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataDirectionConfig(QSPI_Direction_TypeDef dir)
{
80005ce4:	1101                	addi	sp,sp,-32
80005ce6:	ce22                	sw	s0,28(sp)
80005ce8:	1000                	addi	s0,sp,32
80005cea:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DIR(dir));

	WRITE_REG(QSPI->QCC_bit.DIOD, dir);
80005cee:	200407b7          	lui	a5,0x20040
80005cf2:	fec42703          	lw	a4,-20(s0)
80005cf6:	8b0d                	andi	a4,a4,3
80005cf8:	0ff77713          	zext.b	a4,a4
80005cfc:	8b0d                	andi	a4,a4,3
80005cfe:	076a                	slli	a4,a4,0x1a
80005d00:	4f90                	lw	a2,24(a5)
80005d02:	f40006b7          	lui	a3,0xf4000
80005d06:	16fd                	addi	a3,a3,-1 # f3ffffff <__data_source_start+0x73ff8e87>
80005d08:	8ef1                	and	a3,a3,a2
80005d0a:	8f55                	or	a4,a4,a3
80005d0c:	cf98                	sw	a4,24(a5)
}
80005d0e:	0001                	nop
80005d10:	4472                	lw	s0,28(sp)
80005d12:	6105                	addi	sp,sp,32
80005d14:	8082                	ret

80005d16 <QSPI_DataRateConfig>:
  * @brief      
  * @param   dataRate     @ref QSPI_QSPI_DataRate_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataRateConfig(QSPI_DataRate_TypeDef dataRate)
{
80005d16:	1101                	addi	sp,sp,-32
80005d18:	ce22                	sw	s0,28(sp)
80005d1a:	1000                	addi	s0,sp,32
80005d1c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATARATE(dataRate));

	WRITE_REG(QSPI->QCC_bit.DDRM, dataRate);
80005d20:	200407b7          	lui	a5,0x20040
80005d24:	fec42703          	lw	a4,-20(s0)
80005d28:	8b05                	andi	a4,a4,1
80005d2a:	0ff77713          	zext.b	a4,a4
80005d2e:	077e                	slli	a4,a4,0x1f
80005d30:	4f90                	lw	a2,24(a5)
80005d32:	800006b7          	lui	a3,0x80000
80005d36:	fff6c693          	not	a3,a3
80005d3a:	8ef1                	and	a3,a3,a2
80005d3c:	8f55                	or	a4,a4,a3
80005d3e:	cf98                	sw	a4,24(a5)
}
80005d40:	0001                	nop
80005d42:	4472                	lw	s0,28(sp)
80005d44:	6105                	addi	sp,sp,32
80005d46:	8082                	ret

80005d48 <QSPI_DeInit>:
/**
  * @brief      QSPI   
  * @retval  void
  */
void QSPI_DeInit()
{
80005d48:	1141                	addi	sp,sp,-16
80005d4a:	c606                	sw	ra,12(sp)
80005d4c:	c422                	sw	s0,8(sp)
80005d4e:	0800                	addi	s0,sp,16
	RCU_AHBRstCmd(RCU_AHBClk_QSPI, DISABLE);
80005d50:	4581                	li	a1,0
80005d52:	4541                	li	a0,16
80005d54:	3141                	jal	800059d4 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(RCU_AHBClk_QSPI, ENABLE);
80005d56:	4585                	li	a1,1
80005d58:	4541                	li	a0,16
80005d5a:	39ad                	jal	800059d4 <RCU_AHBRstCmd>
}
80005d5c:	0001                	nop
80005d5e:	40b2                	lw	ra,12(sp)
80005d60:	4422                	lw	s0,8(sp)
80005d62:	0141                	addi	sp,sp,16
80005d64:	8082                	ret

80005d66 <QSPI_SPI_Init>:
  * @param   InitStruct      @ref QSPI_SPI_Init_TypeDef,
  *                         .
  * @retval  Status    
  */
void QSPI_SPI_Init(QSPI_SPI_Init_TypeDef* InitStruct)
{
80005d66:	1101                	addi	sp,sp,-32
80005d68:	ce06                	sw	ra,28(sp)
80005d6a:	cc22                	sw	s0,24(sp)
80005d6c:	1000                	addi	s0,sp,32
80005d6e:	fea42623          	sw	a0,-20(s0)
	QSPI_ModeConfig(QSPI_Mode_SPI);
80005d72:	4501                	li	a0,0
80005d74:	3979                	jal	80005a12 <QSPI_ModeConfig>
	QSPI_SPITransactionModeConfig(InitStruct->IOMode);
80005d76:	fec42783          	lw	a5,-20(s0)
80005d7a:	439c                	lw	a5,0(a5)
80005d7c:	853e                	mv	a0,a5
80005d7e:	3b4d                	jal	80005b30 <QSPI_SPITransactionModeConfig>
	QSPI_SPIDataRateConfig(InitStruct->dataRate);
80005d80:	fec42783          	lw	a5,-20(s0)
80005d84:	43dc                	lw	a5,4(a5)
80005d86:	853e                	mv	a0,a5
80005d88:	3b09                	jal	80005a9a <QSPI_SPIDataRateConfig>
	QSPI_SetWordLength(InitStruct->dataWidth);
80005d8a:	fec42783          	lw	a5,-20(s0)
80005d8e:	479c                	lw	a5,8(a5)
80005d90:	853e                	mv	a0,a5
80005d92:	39d1                	jal	80005a66 <QSPI_SetWordLength>
	QSPI_TxCmd(InitStruct->TxEnable);
80005d94:	fec42783          	lw	a5,-20(s0)
80005d98:	47dc                	lw	a5,12(a5)
80005d9a:	853e                	mv	a0,a5
80005d9c:	3b05                	jal	80005acc <QSPI_TxCmd>
	QSPI_RxCmd(InitStruct->RxEnable);
80005d9e:	fec42783          	lw	a5,-20(s0)
80005da2:	4b9c                	lw	a5,16(a5)
80005da4:	853e                	mv	a0,a5
80005da6:	3ba1                	jal	80005afe <QSPI_RxCmd>
	QSPI_SCKDivConfig(InitStruct->SCKDiv);
80005da8:	fec42783          	lw	a5,-20(s0)
80005dac:	4bdc                	lw	a5,20(a5)
80005dae:	853e                	mv	a0,a5
80005db0:	3951                	jal	80005a44 <QSPI_SCKDivConfig>
}
80005db2:	0001                	nop
80005db4:	40f2                	lw	ra,28(sp)
80005db6:	4462                	lw	s0,24(sp)
80005db8:	6105                	addi	sp,sp,32
80005dba:	8082                	ret

80005dbc <QSPI_SPI_StructInit>:
  * @param   InitStruct      @ref QSPI_SPI_Init_TypeDef,
  *                        .
  * @retval  void
  */
void QSPI_SPI_StructInit(QSPI_SPI_Init_TypeDef* InitStruct)
{
80005dbc:	1101                	addi	sp,sp,-32
80005dbe:	ce22                	sw	s0,28(sp)
80005dc0:	1000                	addi	s0,sp,32
80005dc2:	fea42623          	sw	a0,-20(s0)
    InitStruct->IOMode = QSPI_SPI_IOMode_Single;
80005dc6:	fec42783          	lw	a5,-20(s0)
80005dca:	0007a023          	sw	zero,0(a5) # 20040000 <STACK_SIZE+0x2003f800>
    InitStruct->dataRate = QSPI_SPI_DataRate_Single;
80005dce:	fec42783          	lw	a5,-20(s0)
80005dd2:	0007a223          	sw	zero,4(a5)
    InitStruct->dataWidth = 0x1;
80005dd6:	fec42783          	lw	a5,-20(s0)
80005dda:	4705                	li	a4,1
80005ddc:	c798                	sw	a4,8(a5)
    InitStruct->TxEnable = DISABLE;
80005dde:	fec42783          	lw	a5,-20(s0)
80005de2:	0007a623          	sw	zero,12(a5)
    InitStruct->RxEnable = DISABLE;
80005de6:	fec42783          	lw	a5,-20(s0)
80005dea:	0007a823          	sw	zero,16(a5)
    InitStruct->SCKDiv = 0x0;
80005dee:	fec42783          	lw	a5,-20(s0)
80005df2:	0007aa23          	sw	zero,20(a5)
}
80005df6:	0001                	nop
80005df8:	4472                	lw	s0,28(sp)
80005dfa:	6105                	addi	sp,sp,32
80005dfc:	8082                	ret

80005dfe <QSPI_Init>:
  * @param   InitStruct      @ref QSPI_Init_TypeDef,
  *                         .
  * @retval  Status    
  */
void QSPI_Init(QSPI_Init_TypeDef* InitStruct)
{
80005dfe:	1101                	addi	sp,sp,-32
80005e00:	ce06                	sw	ra,28(sp)
80005e02:	cc22                	sw	s0,24(sp)
80005e04:	1000                	addi	s0,sp,32
80005e06:	fea42623          	sw	a0,-20(s0)
    QSPI_ModeConfig(QSPI_Mode_QSPI);
80005e0a:	4509                	li	a0,2
80005e0c:	3119                	jal	80005a12 <QSPI_ModeConfig>

	QSPI_InstructionConfig(InitStruct->instruction);
80005e0e:	fec42783          	lw	a5,-20(s0)
80005e12:	0007c783          	lbu	a5,0(a5)
80005e16:	853e                	mv	a0,a5
80005e18:	3b99                	jal	80005b6e <QSPI_InstructionConfig>
	QSPI_InstructionModeConfig(InitStruct->instructionMode);
80005e1a:	fec42783          	lw	a5,-20(s0)
80005e1e:	43dc                	lw	a5,4(a5)
80005e20:	853e                	mv	a0,a5
80005e22:	33b5                	jal	80005b8e <QSPI_InstructionModeConfig>
	QSPI_AddressModeConfig(InitStruct->addressMode);
80005e24:	fec42783          	lw	a5,-20(s0)
80005e28:	479c                	lw	a5,8(a5)
80005e2a:	853e                	mv	a0,a5
80005e2c:	3b41                	jal	80005bbc <QSPI_AddressModeConfig>
	QSPI_AddressSizeConfig(InitStruct->addressSize);
80005e2e:	fec42783          	lw	a5,-20(s0)
80005e32:	47dc                	lw	a5,12(a5)
80005e34:	853e                	mv	a0,a5
80005e36:	3b65                	jal	80005bee <QSPI_AddressSizeConfig>
	QSPI_AdditionalModeConfig(InitStruct->additionalMode);
80005e38:	fec42783          	lw	a5,-20(s0)
80005e3c:	4b9c                	lw	a5,16(a5)
80005e3e:	853e                	mv	a0,a5
80005e40:	3bf9                	jal	80005c1e <QSPI_AdditionalModeConfig>
	QSPI_AdditionalSizeConfig(InitStruct->additionalSize);
80005e42:	fec42783          	lw	a5,-20(s0)
80005e46:	4bdc                	lw	a5,20(a5)
80005e48:	853e                	mv	a0,a5
80005e4a:	3511                	jal	80005c4e <QSPI_AdditionalSizeConfig>
	QSPI_WaitCyclesConfig(InitStruct->waitCycles);
80005e4c:	fec42783          	lw	a5,-20(s0)
80005e50:	4f9c                	lw	a5,24(a5)
80005e52:	853e                	mv	a0,a5
80005e54:	3535                	jal	80005c80 <QSPI_WaitCyclesConfig>
	QSPI_DataModeConfig(InitStruct->dataMode);
80005e56:	fec42783          	lw	a5,-20(s0)
80005e5a:	4fdc                	lw	a5,28(a5)
80005e5c:	853e                	mv	a0,a5
80005e5e:	3d91                	jal	80005cb2 <QSPI_DataModeConfig>
	QSPI_DataDirectionConfig(InitStruct->dataDirection);
80005e60:	fec42783          	lw	a5,-20(s0)
80005e64:	539c                	lw	a5,32(a5)
80005e66:	853e                	mv	a0,a5
80005e68:	3db5                	jal	80005ce4 <QSPI_DataDirectionConfig>
	QSPI_DataRateConfig(InitStruct->dataRate);
80005e6a:	fec42783          	lw	a5,-20(s0)
80005e6e:	53dc                	lw	a5,36(a5)
80005e70:	853e                	mv	a0,a5
80005e72:	3555                	jal	80005d16 <QSPI_DataRateConfig>
	QSPI_SCKDivConfig(InitStruct->SCKDiv);
80005e74:	fec42783          	lw	a5,-20(s0)
80005e78:	579c                	lw	a5,40(a5)
80005e7a:	853e                	mv	a0,a5
80005e7c:	36e1                	jal	80005a44 <QSPI_SCKDivConfig>
}
80005e7e:	0001                	nop
80005e80:	40f2                	lw	ra,28(sp)
80005e82:	4462                	lw	s0,24(sp)
80005e84:	6105                	addi	sp,sp,32
80005e86:	8082                	ret

80005e88 <QSPI_StructInit>:
  * @param   InitStruct      @ref QSPI_Init_TypeDef,
  *                        .
  * @retval  void
  */
void QSPI_StructInit(QSPI_Init_TypeDef* InitStruct)
{
80005e88:	1101                	addi	sp,sp,-32
80005e8a:	ce22                	sw	s0,28(sp)
80005e8c:	1000                	addi	s0,sp,32
80005e8e:	fea42623          	sw	a0,-20(s0)
	InitStruct->instruction = 0x0;
80005e92:	fec42783          	lw	a5,-20(s0)
80005e96:	00078023          	sb	zero,0(a5)
	InitStruct->instructionMode = QSPI_Lines_No;
80005e9a:	fec42783          	lw	a5,-20(s0)
80005e9e:	0007a223          	sw	zero,4(a5)
	InitStruct->addressMode = QSPI_Lines_No;
80005ea2:	fec42783          	lw	a5,-20(s0)
80005ea6:	0007a423          	sw	zero,8(a5)
	InitStruct->addressSize = QSPI_DataSize_8;
80005eaa:	fec42783          	lw	a5,-20(s0)
80005eae:	0007a623          	sw	zero,12(a5)
	InitStruct->additionalMode = QSPI_Lines_No;
80005eb2:	fec42783          	lw	a5,-20(s0)
80005eb6:	0007a823          	sw	zero,16(a5)
	InitStruct->additionalSize = QSPI_DataSize_8;
80005eba:	fec42783          	lw	a5,-20(s0)
80005ebe:	0007aa23          	sw	zero,20(a5)
	InitStruct->waitCycles = 0x0;
80005ec2:	fec42783          	lw	a5,-20(s0)
80005ec6:	0007ac23          	sw	zero,24(a5)
	InitStruct->dataMode = QSPI_Lines_No;
80005eca:	fec42783          	lw	a5,-20(s0)
80005ece:	0007ae23          	sw	zero,28(a5)
	InitStruct->dataDirection = QSPI_Direction_Write;
80005ed2:	fec42783          	lw	a5,-20(s0)
80005ed6:	0207a023          	sw	zero,32(a5)
	InitStruct->dataRate = QSPI_DataRate_Single;
80005eda:	fec42783          	lw	a5,-20(s0)
80005ede:	0207a223          	sw	zero,36(a5)
	InitStruct->SCKDiv = 0x0;
80005ee2:	fec42783          	lw	a5,-20(s0)
80005ee6:	0207a423          	sw	zero,40(a5)
}
80005eea:	0001                	nop
80005eec:	4472                	lw	s0,28(sp)
80005eee:	6105                	addi	sp,sp,32
80005ef0:	8082                	ret

80005ef2 <RCU_SysClkConfig>:
{
80005ef2:	1101                	addi	sp,sp,-32
80005ef4:	ce22                	sw	s0,28(sp)
80005ef6:	1000                	addi	s0,sp,32
80005ef8:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(RCU->SYSCLKCFG_bit.SRC, SysClk);
80005efc:	3000e7b7          	lui	a5,0x3000e
80005f00:	fec42703          	lw	a4,-20(s0)
80005f04:	8b0d                	andi	a4,a4,3
80005f06:	0ff77713          	zext.b	a4,a4
80005f0a:	8b0d                	andi	a4,a4,3
80005f0c:	5b94                	lw	a3,48(a5)
80005f0e:	9af1                	andi	a3,a3,-4
80005f10:	8f55                	or	a4,a4,a3
80005f12:	db98                	sw	a4,48(a5)
}
80005f14:	0001                	nop
80005f16:	4472                	lw	s0,28(sp)
80005f18:	6105                	addi	sp,sp,32
80005f1a:	8082                	ret

80005f1c <RCU_SysClkStatus>:
{
80005f1c:	1141                	addi	sp,sp,-16
80005f1e:	c622                	sw	s0,12(sp)
80005f20:	0800                	addi	s0,sp,16
    return (RCU_SysClk_TypeDef)READ_REG(RCU->CLKSTAT_bit.SRC);
80005f22:	3000e7b7          	lui	a5,0x3000e
80005f26:	5fdc                	lw	a5,60(a5)
80005f28:	8b8d                	andi	a5,a5,3
80005f2a:	0ff7f793          	zext.b	a5,a5
}
80005f2e:	853e                	mv	a0,a5
80005f30:	4432                	lw	s0,12(sp)
80005f32:	0141                	addi	sp,sp,16
80005f34:	8082                	ret

80005f36 <getSysClkFreq>:
  * @brief        
  * @param   Clk    
  * @retval  Val   
  */
static uint32_t getSysClkFreq(RCU_SysClk_TypeDef Clk)
{
80005f36:	7179                	addi	sp,sp,-48
80005f38:	d622                	sw	s0,44(sp)
80005f3a:	1800                	addi	s0,sp,48
80005f3c:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80005f40:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80005f44:	fdc42703          	lw	a4,-36(s0)
80005f48:	478d                	li	a5,3
80005f4a:	02f70063          	beq	a4,a5,80005f6a <getSysClkFreq+0x34>
80005f4e:	fdc42703          	lw	a4,-36(s0)
80005f52:	478d                	li	a5,3
80005f54:	00e7ee63          	bltu	a5,a4,80005f70 <getSysClkFreq+0x3a>
80005f58:	fdc42703          	lw	a4,-36(s0)
80005f5c:	4789                	li	a5,2
80005f5e:	00f70863          	beq	a4,a5,80005f6e <getSysClkFreq+0x38>
80005f62:	fdc42703          	lw	a4,-36(s0)
80005f66:	4789                	li	a5,2
80005f68:	a021                	j	80005f70 <getSysClkFreq+0x3a>
    case RCU_SysClk_SysPLL0Clk:
        //clk_freq = RCU_GetSysPLL0ClkFreq();
        break;
    case RCU_SysClk_LsiClk:
        //clk_freq = RCU_GetLsiClkFreq();
        break;
80005f6a:	0001                	nop
80005f6c:	a011                	j	80005f70 <getSysClkFreq+0x3a>
        break;
80005f6e:	0001                	nop
    }

    return clk_freq;
80005f70:	fec42783          	lw	a5,-20(s0)
}
80005f74:	853e                	mv	a0,a5
80005f76:	5432                	lw	s0,44(sp)
80005f78:	6145                	addi	sp,sp,48
80005f7a:	8082                	ret

80005f7c <getPeriphClkFreq>:
  * @brief        
  * @param   Clk    
  * @retval  Val   
  */
static uint32_t getPeriphClkFreq(RCU_PeriphClk_TypeDef Clk)
{
80005f7c:	7179                	addi	sp,sp,-48
80005f7e:	d622                	sw	s0,44(sp)
80005f80:	1800                	addi	s0,sp,48
80005f82:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80005f86:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80005f8a:	fdc42703          	lw	a4,-36(s0)
80005f8e:	478d                	li	a5,3
80005f90:	02f70063          	beq	a4,a5,80005fb0 <getPeriphClkFreq+0x34>
80005f94:	fdc42703          	lw	a4,-36(s0)
80005f98:	478d                	li	a5,3
80005f9a:	00e7ee63          	bltu	a5,a4,80005fb6 <getPeriphClkFreq+0x3a>
80005f9e:	fdc42703          	lw	a4,-36(s0)
80005fa2:	4789                	li	a5,2
80005fa4:	00f70863          	beq	a4,a5,80005fb4 <getPeriphClkFreq+0x38>
80005fa8:	fdc42703          	lw	a4,-36(s0)
80005fac:	4789                	li	a5,2
80005fae:	a021                	j	80005fb6 <getPeriphClkFreq+0x3a>
    case RCU_PeriphClk_SysPLL0Clk:
        //clk_freq = RCU_GetPLLDivClkFreq();
        break;
    case RCU_PeriphClk_SysPLL1Clk:
        //clk_freq = RCU_GetPLLExtClkFreq();
        break;
80005fb0:	0001                	nop
80005fb2:	a011                	j	80005fb6 <getPeriphClkFreq+0x3a>
        break;
80005fb4:	0001                	nop
    }

    return clk_freq;
80005fb6:	fec42783          	lw	a5,-20(s0)
}
80005fba:	853e                	mv	a0,a5
80005fbc:	5432                	lw	s0,44(sp)
80005fbe:	6145                	addi	sp,sp,48
80005fc0:	8082                	ret

80005fc2 <getSysPeriphClkFreq>:
  * @brief        
  * @param   Clk    
  * @retval  Val   
  */
static uint32_t getSysPeriphClkFreq(RCU_PeriphClk_TypeDef Clk)
{
80005fc2:	7179                	addi	sp,sp,-48
80005fc4:	d622                	sw	s0,44(sp)
80005fc6:	1800                	addi	s0,sp,48
80005fc8:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80005fcc:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80005fd0:	fdc42703          	lw	a4,-36(s0)
80005fd4:	478d                	li	a5,3
80005fd6:	02f70063          	beq	a4,a5,80005ff6 <getSysPeriphClkFreq+0x34>
80005fda:	fdc42703          	lw	a4,-36(s0)
80005fde:	478d                	li	a5,3
80005fe0:	00e7ee63          	bltu	a5,a4,80005ffc <getSysPeriphClkFreq+0x3a>
80005fe4:	fdc42703          	lw	a4,-36(s0)
80005fe8:	4789                	li	a5,2
80005fea:	00f70863          	beq	a4,a5,80005ffa <getSysPeriphClkFreq+0x38>
80005fee:	fdc42703          	lw	a4,-36(s0)
80005ff2:	4789                	li	a5,2
80005ff4:	a021                	j	80005ffc <getSysPeriphClkFreq+0x3a>
    case RCU_PeriphClk_SysPLL0Clk:
        //clk_freq = RCU_GetSysClkFreq();
        break;
    case RCU_PeriphClk_SysPLL1Clk:
        //clk_freq = RCU_GetPLLClkFreq();
        break;
80005ff6:	0001                	nop
80005ff8:	a011                	j	80005ffc <getSysPeriphClkFreq+0x3a>
        break;
80005ffa:	0001                	nop
    }

    return clk_freq;
80005ffc:	fec42783          	lw	a5,-20(s0)
}
80006000:	853e                	mv	a0,a5
80006002:	5432                	lw	s0,44(sp)
80006004:	6145                	addi	sp,sp,48
80006006:	8082                	ret

80006008 <RCU_GetHSIClkFreq>:
/**
  * @brief        HSICLK
  * @retval  Val   
  */
uint32_t RCU_GetHSIClkFreq()
{
80006008:	1141                	addi	sp,sp,-16
8000600a:	c622                	sw	s0,12(sp)
8000600c:	0800                	addi	s0,sp,16
    return HSICLK_VAL;
8000600e:	000f47b7          	lui	a5,0xf4
80006012:	24078793          	addi	a5,a5,576 # f4240 <STACK_SIZE+0xf3a40>
}
80006016:	853e                	mv	a0,a5
80006018:	4432                	lw	s0,12(sp)
8000601a:	0141                	addi	sp,sp,16
8000601c:	8082                	ret

8000601e <RCU_GetHSEClkFreq>:
/**
  * @brief        HSECLK
  * @retval  Val   
  */
uint32_t RCU_GetHSEClkFreq()
{
8000601e:	1141                	addi	sp,sp,-16
80006020:	c622                	sw	s0,12(sp)
80006022:	0800                	addi	s0,sp,16
    return HSECLK_VAL;
80006024:	00f427b7          	lui	a5,0xf42
80006028:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
}
8000602c:	853e                	mv	a0,a5
8000602e:	4432                	lw	s0,12(sp)
80006030:	0141                	addi	sp,sp,16
80006032:	8082                	ret

80006034 <RCU_GetLsiClkFreq1>:
/**
  * @brief        LSICLK
  * @retval  Val   
  */
uint32_t RCU_GetLsiClkFreq1()
{
80006034:	1141                	addi	sp,sp,-16
80006036:	c622                	sw	s0,12(sp)
80006038:	0800                	addi	s0,sp,16
    return (uint32_t)LSICLK_VAL;
8000603a:	67a1                	lui	a5,0x8
8000603c:	d0078793          	addi	a5,a5,-768 # 7d00 <STACK_SIZE+0x7500>
}
80006040:	853e                	mv	a0,a5
80006042:	4432                	lw	s0,12(sp)
80006044:	0141                	addi	sp,sp,16
80006046:	8082                	ret

80006048 <RCU_GetSysPLL0ClkFreq1>:
/**
  * @brief        SYSPLL0CLK
  * @retval  Val   
  */
uint32_t RCU_GetSysPLL0ClkFreq1()
{
80006048:	7179                	addi	sp,sp,-48
8000604a:	d622                	sw	s0,44(sp)
8000604c:	1800                	addi	s0,sp,48
    uint32_t pll_div0a, pll_div0b, pll_div1a, pll_div1b , pll_fracdiv, pll_fbdiv, pll_refdiv, pll_refclk;

    pll_div0a = READ_REG(RCU->PLLSYSCFG0_bit.PD0A)+1;
8000604e:	3000e7b7          	lui	a5,0x3000e
80006052:	4bbc                	lw	a5,80(a5)
80006054:	83b5                	srli	a5,a5,0xd
80006056:	8b9d                	andi	a5,a5,7
80006058:	0ff7f793          	zext.b	a5,a5
8000605c:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
8000605e:	fef42623          	sw	a5,-20(s0)
    pll_div0b = READ_REG(RCU->PLLSYSCFG0_bit.PD0B)+1;
80006062:	3000e7b7          	lui	a5,0x3000e
80006066:	4bbc                	lw	a5,80(a5)
80006068:	83c1                	srli	a5,a5,0x10
8000606a:	03f7f793          	andi	a5,a5,63
8000606e:	0ff7f793          	zext.b	a5,a5
80006072:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80006074:	fef42423          	sw	a5,-24(s0)
    pll_fbdiv = READ_REG(RCU->PLLSYSCFG2_bit.FBDIV);
80006078:	3000e7b7          	lui	a5,0x3000e
8000607c:	4fbc                	lw	a5,88(a5)
8000607e:	873e                	mv	a4,a5
80006080:	6785                	lui	a5,0x1
80006082:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80006084:	8ff9                	and	a5,a5,a4
80006086:	07c2                	slli	a5,a5,0x10
80006088:	83c1                	srli	a5,a5,0x10
8000608a:	fef42223          	sw	a5,-28(s0)
    pll_refdiv = READ_REG(RCU->PLLSYSCFG0_bit.REFDIV);
8000608e:	3000e7b7          	lui	a5,0x3000e
80006092:	4bbc                	lw	a5,80(a5)
80006094:	839d                	srli	a5,a5,0x7
80006096:	03f7f793          	andi	a5,a5,63
8000609a:	0ff7f793          	zext.b	a5,a5
8000609e:	fef42023          	sw	a5,-32(s0)
    pll_refclk = HSECLK_VAL;
800060a2:	00f427b7          	lui	a5,0xf42
800060a6:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
800060aa:	fcf42e23          	sw	a5,-36(s0)

    return (uint32_t)((pll_refclk * pll_fbdiv) / (pll_refdiv * pll_div0a * pll_div0b));
800060ae:	fdc42703          	lw	a4,-36(s0)
800060b2:	fe442783          	lw	a5,-28(s0)
800060b6:	02f70733          	mul	a4,a4,a5
800060ba:	fe042683          	lw	a3,-32(s0)
800060be:	fec42783          	lw	a5,-20(s0)
800060c2:	02f686b3          	mul	a3,a3,a5
800060c6:	fe842783          	lw	a5,-24(s0)
800060ca:	02f687b3          	mul	a5,a3,a5
800060ce:	02f757b3          	divu	a5,a4,a5
}
800060d2:	853e                	mv	a0,a5
800060d4:	5432                	lw	s0,44(sp)
800060d6:	6145                	addi	sp,sp,48
800060d8:	8082                	ret

800060da <RCU_GetSysClkFreq>:
/**
  * @brief      SYSCLK
  * @retval  Val   
  */
uint32_t RCU_GetSysClkFreq()
{
800060da:	1101                	addi	sp,sp,-32
800060dc:	ce06                	sw	ra,28(sp)
800060de:	cc22                	sw	s0,24(sp)
800060e0:	1000                	addi	s0,sp,32
    RCU_SysClk_TypeDef sys_clk;

    sys_clk = RCU_SysClkStatus();
800060e2:	3d2d                	jal	80005f1c <RCU_SysClkStatus>
800060e4:	fea42623          	sw	a0,-20(s0)

    return getSysClkFreq(sys_clk);
800060e8:	fec42503          	lw	a0,-20(s0)
800060ec:	35a9                	jal	80005f36 <getSysClkFreq>
800060ee:	87aa                	mv	a5,a0
}
800060f0:	853e                	mv	a0,a5
800060f2:	40f2                	lw	ra,28(sp)
800060f4:	4462                	lw	s0,24(sp)
800060f6:	6105                	addi	sp,sp,32
800060f8:	8082                	ret

800060fa <RCU_GetUARTClkFreq>:
  * @brief      UARTCLK
  * @param   UARTx_Num     UART
  * @retval  Val   
  */
uint32_t RCU_GetUARTClkFreq(UART_Num_TypeDef UARTx_Num)
{
800060fa:	7179                	addi	sp,sp,-48
800060fc:	d606                	sw	ra,44(sp)
800060fe:	d422                	sw	s0,40(sp)
80006100:	1800                	addi	s0,sp,48
80006102:	fca42e23          	sw	a0,-36(s0)
    RCU_PeriphClk_TypeDef uart_clk;
    uint32_t div_val;

    uart_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.CLKSEL);
80006106:	3000e737          	lui	a4,0x3000e
8000610a:	fdc42783          	lw	a5,-36(s0)
8000610e:	07f1                	addi	a5,a5,28
80006110:	078a                	slli	a5,a5,0x2
80006112:	97ba                	add	a5,a5,a4
80006114:	439c                	lw	a5,0(a5)
80006116:	83c1                	srli	a5,a5,0x10
80006118:	8b8d                	andi	a5,a5,3
8000611a:	0ff7f793          	zext.b	a5,a5
8000611e:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.DIVEN))
80006122:	3000e737          	lui	a4,0x3000e
80006126:	fdc42783          	lw	a5,-36(s0)
8000612a:	07f1                	addi	a5,a5,28
8000612c:	078a                	slli	a5,a5,0x2
8000612e:	97ba                	add	a5,a5,a4
80006130:	439c                	lw	a5,0(a5)
80006132:	83d1                	srli	a5,a5,0x14
80006134:	8b85                	andi	a5,a5,1
80006136:	0ff7f793          	zext.b	a5,a5
8000613a:	c39d                	beqz	a5,80006160 <RCU_GetUARTClkFreq+0x66>
        div_val = 2 * (READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.DIVN) + 1);
8000613c:	3000e737          	lui	a4,0x3000e
80006140:	fdc42783          	lw	a5,-36(s0)
80006144:	07f1                	addi	a5,a5,28
80006146:	078a                	slli	a5,a5,0x2
80006148:	97ba                	add	a5,a5,a4
8000614a:	439c                	lw	a5,0(a5)
8000614c:	83e1                	srli	a5,a5,0x18
8000614e:	03f7f793          	andi	a5,a5,63
80006152:	0ff7f793          	zext.b	a5,a5
80006156:	0785                	addi	a5,a5,1
80006158:	0786                	slli	a5,a5,0x1
8000615a:	fef42623          	sw	a5,-20(s0)
8000615e:	a021                	j	80006166 <RCU_GetUARTClkFreq+0x6c>
    else
        div_val = 1;
80006160:	4785                	li	a5,1
80006162:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(uart_clk) / div_val;
80006166:	fe842503          	lw	a0,-24(s0)
8000616a:	3d09                	jal	80005f7c <getPeriphClkFreq>
8000616c:	872a                	mv	a4,a0
8000616e:	fec42783          	lw	a5,-20(s0)
80006172:	02f757b3          	divu	a5,a4,a5
}
80006176:	853e                	mv	a0,a5
80006178:	50b2                	lw	ra,44(sp)
8000617a:	5422                	lw	s0,40(sp)
8000617c:	6145                	addi	sp,sp,48
8000617e:	8082                	ret

80006180 <RCU_GetSPIClkFreq>:
  * @brief      SPICLK
  * @param   SPIx_Num     SPI
  * @retval  Val   
  */
uint32_t RCU_GetSPIClkFreq(SPI_Num_TypeDef SPIx_Num)
{
80006180:	7179                	addi	sp,sp,-48
80006182:	d606                	sw	ra,44(sp)
80006184:	d422                	sw	s0,40(sp)
80006186:	1800                	addi	s0,sp,48
80006188:	fca42e23          	sw	a0,-36(s0)
    RCU_PeriphClk_TypeDef spi_clk;
    uint32_t div_val;

    spi_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.CLKSEL);
8000618c:	3000e737          	lui	a4,0x3000e
80006190:	fdc42783          	lw	a5,-36(s0)
80006194:	02478793          	addi	a5,a5,36
80006198:	078a                	slli	a5,a5,0x2
8000619a:	97ba                	add	a5,a5,a4
8000619c:	43dc                	lw	a5,4(a5)
8000619e:	83c1                	srli	a5,a5,0x10
800061a0:	8b8d                	andi	a5,a5,3
800061a2:	0ff7f793          	zext.b	a5,a5
800061a6:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.DIVEN))
800061aa:	3000e737          	lui	a4,0x3000e
800061ae:	fdc42783          	lw	a5,-36(s0)
800061b2:	02478793          	addi	a5,a5,36
800061b6:	078a                	slli	a5,a5,0x2
800061b8:	97ba                	add	a5,a5,a4
800061ba:	43dc                	lw	a5,4(a5)
800061bc:	83d1                	srli	a5,a5,0x14
800061be:	8b85                	andi	a5,a5,1
800061c0:	0ff7f793          	zext.b	a5,a5
800061c4:	c785                	beqz	a5,800061ec <RCU_GetSPIClkFreq+0x6c>
        div_val = 2 * (READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.DIVN) + 1);
800061c6:	3000e737          	lui	a4,0x3000e
800061ca:	fdc42783          	lw	a5,-36(s0)
800061ce:	02478793          	addi	a5,a5,36
800061d2:	078a                	slli	a5,a5,0x2
800061d4:	97ba                	add	a5,a5,a4
800061d6:	43dc                	lw	a5,4(a5)
800061d8:	83e1                	srli	a5,a5,0x18
800061da:	03f7f793          	andi	a5,a5,63
800061de:	0ff7f793          	zext.b	a5,a5
800061e2:	0785                	addi	a5,a5,1
800061e4:	0786                	slli	a5,a5,0x1
800061e6:	fef42623          	sw	a5,-20(s0)
800061ea:	a021                	j	800061f2 <RCU_GetSPIClkFreq+0x72>
    else
        div_val = 1;
800061ec:	4785                	li	a5,1
800061ee:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(spi_clk) / div_val;
800061f2:	fe842503          	lw	a0,-24(s0)
800061f6:	3359                	jal	80005f7c <getPeriphClkFreq>
800061f8:	872a                	mv	a4,a0
800061fa:	fec42783          	lw	a5,-20(s0)
800061fe:	02f757b3          	divu	a5,a4,a5
}
80006202:	853e                	mv	a0,a5
80006204:	50b2                	lw	ra,44(sp)
80006206:	5422                	lw	s0,40(sp)
80006208:	6145                	addi	sp,sp,48
8000620a:	8082                	ret

8000620c <RCU_GetADCSARClkFreq>:
/**
  * @brief      ADCCLK
  * @retval  Val   
  */
uint32_t RCU_GetADCSARClkFreq()
{
8000620c:	1101                	addi	sp,sp,-32
8000620e:	ce06                	sw	ra,28(sp)
80006210:	cc22                	sw	s0,24(sp)
80006212:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef adc_clk;
    uint32_t div_val;

    adc_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->ADCSARCLKCFG_bit.CLKSEL);
80006214:	3000e7b7          	lui	a5,0x3000e
80006218:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
8000621c:	83c1                	srli	a5,a5,0x10
8000621e:	8b8d                	andi	a5,a5,3
80006220:	0ff7f793          	zext.b	a5,a5
80006224:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->ADCSARCLKCFG_bit.DIVEN))
80006228:	3000e7b7          	lui	a5,0x3000e
8000622c:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80006230:	83d1                	srli	a5,a5,0x14
80006232:	8b85                	andi	a5,a5,1
80006234:	0ff7f793          	zext.b	a5,a5
80006238:	cf99                	beqz	a5,80006256 <RCU_GetADCSARClkFreq+0x4a>
        div_val = 2 * (READ_REG(RCU->ADCSARCLKCFG_bit.DIVN) + 1);
8000623a:	3000e7b7          	lui	a5,0x3000e
8000623e:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80006242:	83e1                	srli	a5,a5,0x18
80006244:	03f7f793          	andi	a5,a5,63
80006248:	0ff7f793          	zext.b	a5,a5
8000624c:	0785                	addi	a5,a5,1
8000624e:	0786                	slli	a5,a5,0x1
80006250:	fef42623          	sw	a5,-20(s0)
80006254:	a021                	j	8000625c <RCU_GetADCSARClkFreq+0x50>
    else
        div_val = 1;
80006256:	4785                	li	a5,1
80006258:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(adc_clk) / div_val;
8000625c:	fe842503          	lw	a0,-24(s0)
80006260:	3b31                	jal	80005f7c <getPeriphClkFreq>
80006262:	872a                	mv	a4,a0
80006264:	fec42783          	lw	a5,-20(s0)
80006268:	02f757b3          	divu	a5,a4,a5
}
8000626c:	853e                	mv	a0,a5
8000626e:	40f2                	lw	ra,28(sp)
80006270:	4462                	lw	s0,24(sp)
80006272:	6105                	addi	sp,sp,32
80006274:	8082                	ret

80006276 <RCU_GetWDTClkFreq>:
/**
  * @brief      WDTCLK
  * @retval  Val   
  */
uint32_t RCU_GetWDTClkFreq()
{
80006276:	1101                	addi	sp,sp,-32
80006278:	ce06                	sw	ra,28(sp)
8000627a:	cc22                	sw	s0,24(sp)
8000627c:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef wdt_clk;
    uint32_t div_val;

    wdt_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->WDOGCLKCFG_bit.CLKSEL);
8000627e:	3000e7b7          	lui	a5,0x3000e
80006282:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
80006286:	83c1                	srli	a5,a5,0x10
80006288:	8b8d                	andi	a5,a5,3
8000628a:	0ff7f793          	zext.b	a5,a5
8000628e:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->WDOGCLKCFG_bit.DIVEN))
80006292:	3000e7b7          	lui	a5,0x3000e
80006296:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
8000629a:	83d1                	srli	a5,a5,0x14
8000629c:	8b85                	andi	a5,a5,1
8000629e:	0ff7f793          	zext.b	a5,a5
800062a2:	cf99                	beqz	a5,800062c0 <RCU_GetWDTClkFreq+0x4a>
        div_val = 2 * (READ_REG(RCU->WDOGCLKCFG_bit.DIVN) + 1);
800062a4:	3000e7b7          	lui	a5,0x3000e
800062a8:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
800062ac:	83e1                	srli	a5,a5,0x18
800062ae:	03f7f793          	andi	a5,a5,63
800062b2:	0ff7f793          	zext.b	a5,a5
800062b6:	0785                	addi	a5,a5,1
800062b8:	0786                	slli	a5,a5,0x1
800062ba:	fef42623          	sw	a5,-20(s0)
800062be:	a021                	j	800062c6 <RCU_GetWDTClkFreq+0x50>
    else
        div_val = 1;
800062c0:	4785                	li	a5,1
800062c2:	fef42623          	sw	a5,-20(s0)

    return getSysPeriphClkFreq(wdt_clk) / div_val;
800062c6:	fe842503          	lw	a0,-24(s0)
800062ca:	39e5                	jal	80005fc2 <getSysPeriphClkFreq>
800062cc:	872a                	mv	a4,a0
800062ce:	fec42783          	lw	a5,-20(s0)
800062d2:	02f757b3          	divu	a5,a4,a5
}
800062d6:	853e                	mv	a0,a5
800062d8:	40f2                	lw	ra,28(sp)
800062da:	4462                	lw	s0,24(sp)
800062dc:	6105                	addi	sp,sp,32
800062de:	8082                	ret

800062e0 <RCU_GetClkOutFreq>:
/**
  * @brief      CLKOUT
  * @retval  Val   
  */
uint32_t RCU_GetClkOutFreq()
{
800062e0:	1101                	addi	sp,sp,-32
800062e2:	ce06                	sw	ra,28(sp)
800062e4:	cc22                	sw	s0,24(sp)
800062e6:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef clkout;
    uint32_t div_val;

    clkout = (RCU_PeriphClk_TypeDef)READ_REG(RCU->CLKOUTCFG_bit.CLKSEL);
800062e8:	3000e7b7          	lui	a5,0x3000e
800062ec:	0bc7a783          	lw	a5,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
800062f0:	8391                	srli	a5,a5,0x4
800062f2:	8b8d                	andi	a5,a5,3
800062f4:	0ff7f793          	zext.b	a5,a5
800062f8:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->CLKOUTCFG_bit.DIVEN))
800062fc:	3000e7b7          	lui	a5,0x3000e
80006300:	0bc7a783          	lw	a5,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
80006304:	83b1                	srli	a5,a5,0xc
80006306:	8b85                	andi	a5,a5,1
80006308:	0ff7f793          	zext.b	a5,a5
8000630c:	cf81                	beqz	a5,80006324 <RCU_GetClkOutFreq+0x44>
        div_val = 2 * (READ_REG(RCU->CLKOUTCFG_bit.DIVN) + 1);
8000630e:	3000e7b7          	lui	a5,0x3000e
80006312:	0be7d783          	lhu	a5,190(a5) # 3000e0be <STACK_SIZE+0x3000d8be>
80006316:	07c2                	slli	a5,a5,0x10
80006318:	83c1                	srli	a5,a5,0x10
8000631a:	0785                	addi	a5,a5,1
8000631c:	0786                	slli	a5,a5,0x1
8000631e:	fef42623          	sw	a5,-20(s0)
80006322:	a021                	j	8000632a <RCU_GetClkOutFreq+0x4a>
    else
        div_val = 1;
80006324:	4785                	li	a5,1
80006326:	fef42623          	sw	a5,-20(s0)

    return getSysPeriphClkFreq(clkout) / div_val;
8000632a:	fe842503          	lw	a0,-24(s0)
8000632e:	3951                	jal	80005fc2 <getSysPeriphClkFreq>
80006330:	872a                	mv	a4,a0
80006332:	fec42783          	lw	a5,-20(s0)
80006336:	02f757b3          	divu	a5,a4,a5
}
8000633a:	853e                	mv	a0,a5
8000633c:	40f2                	lw	ra,28(sp)
8000633e:	4462                	lw	s0,24(sp)
80006340:	6105                	addi	sp,sp,32
80006342:	8082                	ret

80006344 <RCU_PLL_Init>:
  * @param      InitStruct      @ref RCU_PLL_Init_TypeDef,
  *                            
  * @retval     Status
  */
OperationStatus RCU_PLL_Init(RCU_PLL_Init_TypeDef* InitStruct)
{
80006344:	7179                	addi	sp,sp,-48
80006346:	d622                	sw	s0,44(sp)
80006348:	1800                	addi	s0,sp,48
8000634a:	fca42e23          	sw	a0,-36(s0)
    uint32_t timeout = RCU_PLLCLK_LOCK_TIMEOUT;
8000634e:	6789                	lui	a5,0x2
80006350:	71078793          	addi	a5,a5,1808 # 2710 <STACK_SIZE+0x1f10>
80006354:	fef42423          	sw	a5,-24(s0)
    OperationStatus status = OK;
80006358:	fe042623          	sw	zero,-20(s0)
    assert_param(IS_RCU_PLL_REF_DIV(InitStruct->RefDiv));
    assert_param(IS_RCU_PLL_REF(InitStruct->Ref));
    assert_param(IS_RCU_PLL_DIV1(InitStruct->Div1));
    assert_param(IS_RCU_PLL_DIV2(InitStruct->Div2));

    CLEAR_BIT(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_BYP_Msk | RCU_PLLSYSCFG0_PLLEN_Msk);
8000635c:	3000e7b7          	lui	a5,0x3000e
80006360:	4bb8                	lw	a4,80(a5)
80006362:	3000e7b7          	lui	a5,0x3000e
80006366:	9b61                	andi	a4,a4,-8
80006368:	cbb8                	sw	a4,80(a5)
    MODIFY_REG(RCU->PLLSYSCFG0, (RCU_PLLSYSCFG0_REFDIV_Msk | RCU_PLLSYSCFG0_PD0A_Msk | RCU_PLLSYSCFG0_PD0B_Msk),
8000636a:	3000e7b7          	lui	a5,0x3000e
8000636e:	4bb8                	lw	a4,80(a5)
80006370:	ffc007b7          	lui	a5,0xffc00
80006374:	07f78793          	addi	a5,a5,127 # ffc0007f <__data_source_start+0x7fbf8f07>
80006378:	00f776b3          	and	a3,a4,a5
8000637c:	fdc42783          	lw	a5,-36(s0)
80006380:	43dc                	lw	a5,4(a5)
80006382:	00779713          	slli	a4,a5,0x7
80006386:	fdc42783          	lw	a5,-36(s0)
8000638a:	4b9c                	lw	a5,16(a5)
8000638c:	07b6                	slli	a5,a5,0xd
8000638e:	8f5d                	or	a4,a4,a5
80006390:	fdc42783          	lw	a5,-36(s0)
80006394:	4bdc                	lw	a5,20(a5)
80006396:	07c2                	slli	a5,a5,0x10
80006398:	8f5d                	or	a4,a4,a5
8000639a:	3000e7b7          	lui	a5,0x3000e
8000639e:	8f55                	or	a4,a4,a3
800063a0:	cbb8                	sw	a4,80(a5)
               (InitStruct->RefDiv << RCU_PLLSYSCFG0_REFDIV_Pos |
                InitStruct->Div0A << RCU_PLLSYSCFG0_PD0A_Pos |
                InitStruct->Div0B << RCU_PLLSYSCFG0_PD0B_Pos));
    MODIFY_REG(RCU->PLLSYSCFG2, (RCU_PLLSYSCFG2_FBDIV_Msk),
800063a2:	3000e7b7          	lui	a5,0x3000e
800063a6:	4fb8                	lw	a4,88(a5)
800063a8:	77fd                	lui	a5,0xfffff
800063aa:	00f776b3          	and	a3,a4,a5
800063ae:	fdc42783          	lw	a5,-36(s0)
800063b2:	4798                	lw	a4,8(a5)
800063b4:	3000e7b7          	lui	a5,0x3000e
800063b8:	8f55                	or	a4,a4,a3
800063ba:	cfb8                	sw	a4,88(a5)
               (InitStruct->FbDiv << RCU_PLLSYSCFG2_FBDIV_Pos));

    //RCU_PLL_OutCmd(ENABLE);
    while (timeout) {
800063bc:	0001                	nop
800063be:	fe842783          	lw	a5,-24(s0)
800063c2:	fff5                	bnez	a5,800063be <RCU_PLL_Init+0x7a>
        //     break;
        // } else {
        //     timeout--;
        // }
    }
    if (!timeout) {
800063c4:	fe842783          	lw	a5,-24(s0)
800063c8:	e781                	bnez	a5,800063d0 <RCU_PLL_Init+0x8c>
        status = ERROR;
800063ca:	4785                	li	a5,1
800063cc:	fef42623          	sw	a5,-20(s0)
    }

    return status;
800063d0:	fec42783          	lw	a5,-20(s0)
}
800063d4:	853e                	mv	a0,a5
800063d6:	5432                	lw	s0,44(sp)
800063d8:	6145                	addi	sp,sp,48
800063da:	8082                	ret

800063dc <RCU_PLL_StructInit>:
  * @param   InitStruct      @ref RCU_PLL_Init_TypeDef,
  *                        
  * @retval  void
  */
void RCU_PLL_StructInit(RCU_PLL_Init_TypeDef* InitStruct)
{
800063dc:	1101                	addi	sp,sp,-32
800063de:	ce22                	sw	s0,28(sp)
800063e0:	1000                	addi	s0,sp,32
800063e2:	fea42623          	sw	a0,-20(s0)
    InitStruct->FbDiv = 16;
800063e6:	fec42783          	lw	a5,-20(s0)
800063ea:	4741                	li	a4,16
800063ec:	c798                	sw	a4,8(a5)
    InitStruct->RefDiv = 1;
800063ee:	fec42783          	lw	a5,-20(s0)
800063f2:	4705                	li	a4,1
800063f4:	c3d8                	sw	a4,4(a5)
    InitStruct->Div0A = 1;
800063f6:	fec42783          	lw	a5,-20(s0)
800063fa:	4705                	li	a4,1
800063fc:	cb98                	sw	a4,16(a5)
    InitStruct->Div0B = 1;
800063fe:	fec42783          	lw	a5,-20(s0)
80006402:	4705                	li	a4,1
80006404:	cbd8                	sw	a4,20(a5)
    InitStruct->Div1A = 1;
80006406:	fec42783          	lw	a5,-20(s0)
8000640a:	4705                	li	a4,1
8000640c:	cf98                	sw	a4,24(a5)
    InitStruct->Div1B = 1;
8000640e:	fec42783          	lw	a5,-20(s0)
80006412:	4705                	li	a4,1
80006414:	cfd8                	sw	a4,28(a5)
}
80006416:	0001                	nop
80006418:	4472                	lw	s0,28(sp)
8000641a:	6105                	addi	sp,sp,32
8000641c:	8082                	ret

8000641e <RCU_PLL_DeInit>:
/**
  * @brief      PLL   
  * @retval  void
  */
void RCU_PLL_DeInit()
{
8000641e:	1141                	addi	sp,sp,-16
80006420:	c622                	sw	s0,12(sp)
80006422:	0800                	addi	s0,sp,16
    //RCU_PLL_OutCmd(DISABLE);
    WRITE_REG(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_RST_VAL);
80006424:	3000e7b7          	lui	a5,0x3000e
80006428:	34111737          	lui	a4,0x34111
8000642c:	10170713          	addi	a4,a4,257 # 34111101 <STACK_SIZE+0x34110901>
80006430:	cbb8                	sw	a4,80(a5)
}
80006432:	0001                	nop
80006434:	4432                	lw	s0,12(sp)
80006436:	0141                	addi	sp,sp,16
80006438:	8082                	ret

8000643a <RCU_SysClkChangeCmd>:
  * @brief        
  * @param   SysClk   
  * @retval  void
  */
OperationStatus RCU_SysClkChangeCmd(RCU_SysClk_TypeDef SysClk)
{
8000643a:	7179                	addi	sp,sp,-48
8000643c:	d606                	sw	ra,44(sp)
8000643e:	d422                	sw	s0,40(sp)
80006440:	1800                	addi	s0,sp,48
80006442:	fca42e23          	sw	a0,-36(s0)
    uint32_t timeout = RCU_SYSCLK_CHANGE_TIMEOUT;
80006446:	6789                	lui	a5,0x2
80006448:	71078793          	addi	a5,a5,1808 # 2710 <STACK_SIZE+0x1f10>
8000644c:	fef42423          	sw	a5,-24(s0)
    OperationStatus status = OK;
80006450:	fe042623          	sw	zero,-20(s0)

    assert_param(IS_RCU_SYS_CLK(SysClk));

    RCU_SysClkConfig(SysClk);
80006454:	fdc42503          	lw	a0,-36(s0)
80006458:	3c69                	jal	80005ef2 <RCU_SysClkConfig>

    while (timeout) {
8000645a:	0001                	nop
8000645c:	fe842783          	lw	a5,-24(s0)
80006460:	fff5                	bnez	a5,8000645c <RCU_SysClkChangeCmd+0x22>
        //} else {
        //    break;
       // }
    }

    if (!timeout) {
80006462:	fe842783          	lw	a5,-24(s0)
80006466:	e781                	bnez	a5,8000646e <RCU_SysClkChangeCmd+0x34>
        status = ERROR;
80006468:	4785                	li	a5,1
8000646a:	fef42623          	sw	a5,-20(s0)
    }

    return status;
8000646e:	fec42783          	lw	a5,-20(s0)
}
80006472:	853e                	mv	a0,a5
80006474:	50b2                	lw	ra,44(sp)
80006476:	5422                	lw	s0,40(sp)
80006478:	6145                	addi	sp,sp,48
8000647a:	8082                	ret

8000647c <RCU_SPIRstCmd>:
{
8000647c:	1101                	addi	sp,sp,-32
8000647e:	ce22                	sw	s0,28(sp)
80006480:	1000                	addi	s0,sp,32
80006482:	fea42623          	sw	a0,-20(s0)
80006486:	feb42423          	sw	a1,-24(s0)
    WRITE_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.RSTDIS, State);
8000648a:	3000e6b7          	lui	a3,0x3000e
8000648e:	fe842783          	lw	a5,-24(s0)
80006492:	8b85                	andi	a5,a5,1
80006494:	0ff7f713          	zext.b	a4,a5
80006498:	fec42783          	lw	a5,-20(s0)
8000649c:	02478793          	addi	a5,a5,36
800064a0:	078a                	slli	a5,a5,0x2
800064a2:	97b6                	add	a5,a5,a3
800064a4:	8b05                	andi	a4,a4,1
800064a6:	0722                	slli	a4,a4,0x8
800064a8:	43d4                	lw	a3,4(a5)
800064aa:	eff6f693          	andi	a3,a3,-257
800064ae:	8f55                	or	a4,a4,a3
800064b0:	c3d8                	sw	a4,4(a5)
}
800064b2:	0001                	nop
800064b4:	4472                	lw	s0,28(sp)
800064b6:	6105                	addi	sp,sp,32
800064b8:	8082                	ret

800064ba <SPI_DataWidthConfig>:
  * @param   SPIx    SPI,  x=0|1
  * @param   DataWidth    
  * @retval  void
  */
__STATIC_INLINE void SPI_DataWidthConfig(SPI_TypeDef* SPIx, SPI_DataWidth_TypeDef DataWidth)
{
800064ba:	1101                	addi	sp,sp,-32
800064bc:	ce22                	sw	s0,28(sp)
800064be:	1000                	addi	s0,sp,32
800064c0:	fea42623          	sw	a0,-20(s0)
800064c4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_DATA_WIDTH(DataWidth));

    WRITE_REG(SPIx->CR0_bit.DSS, DataWidth);
800064c8:	fe842783          	lw	a5,-24(s0)
800064cc:	8bbd                	andi	a5,a5,15
800064ce:	0ff7f713          	zext.b	a4,a5
800064d2:	fec42783          	lw	a5,-20(s0)
800064d6:	8b3d                	andi	a4,a4,15
800064d8:	0007d683          	lhu	a3,0(a5)
800064dc:	9ac1                	andi	a3,a3,-16
800064de:	8f55                	or	a4,a4,a3
800064e0:	00e79023          	sh	a4,0(a5)
}
800064e4:	0001                	nop
800064e6:	4472                	lw	s0,28(sp)
800064e8:	6105                	addi	sp,sp,32
800064ea:	8082                	ret

800064ec <SPI_ModeConfig>:
  * @param   SPIx    SPI,  x=0|1
  * @param   Mode   
  * @retval  void
  */
__STATIC_INLINE void SPI_ModeConfig(SPI_TypeDef* SPIx, SPI_Mode_TypeDef Mode)
{
800064ec:	1101                	addi	sp,sp,-32
800064ee:	ce22                	sw	s0,28(sp)
800064f0:	1000                	addi	s0,sp,32
800064f2:	fea42623          	sw	a0,-20(s0)
800064f6:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_MODE(Mode));

    WRITE_REG(SPIx->CR1_bit.MS, Mode);
800064fa:	fe842783          	lw	a5,-24(s0)
800064fe:	8b85                	andi	a5,a5,1
80006500:	0ff7f713          	zext.b	a4,a5
80006504:	fec42783          	lw	a5,-20(s0)
80006508:	8b05                	andi	a4,a4,1
8000650a:	070a                	slli	a4,a4,0x2
8000650c:	0047d683          	lhu	a3,4(a5)
80006510:	9aed                	andi	a3,a3,-5
80006512:	8f55                	or	a4,a4,a3
80006514:	00e79223          	sh	a4,4(a5)
}
80006518:	0001                	nop
8000651a:	4472                	lw	s0,28(sp)
8000651c:	6105                	addi	sp,sp,32
8000651e:	8082                	ret

80006520 <SPI_FrameFormatConfig>:
  * @param   SPIx    SPI,  x=0|1
  * @param   FrameFormat   
  * @retval  void
  */
__STATIC_INLINE void SPI_FrameFormatConfig(SPI_TypeDef* SPIx, SPI_FrameFormat_TypeDef FrameFormat)
{
80006520:	1101                	addi	sp,sp,-32
80006522:	ce22                	sw	s0,28(sp)
80006524:	1000                	addi	s0,sp,32
80006526:	fea42623          	sw	a0,-20(s0)
8000652a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_FRAME_FORMAT(FrameFormat));

    WRITE_REG(SPIx->CR0_bit.FRF, FrameFormat);
8000652e:	fe842783          	lw	a5,-24(s0)
80006532:	8b8d                	andi	a5,a5,3
80006534:	0ff7f713          	zext.b	a4,a5
80006538:	fec42783          	lw	a5,-20(s0)
8000653c:	8b0d                	andi	a4,a4,3
8000653e:	0712                	slli	a4,a4,0x4
80006540:	0007d683          	lhu	a3,0(a5)
80006544:	fcf6f693          	andi	a3,a3,-49
80006548:	8f55                	or	a4,a4,a3
8000654a:	00e79023          	sh	a4,0(a5)
}
8000654e:	0001                	nop
80006550:	4472                	lw	s0,28(sp)
80006552:	6105                	addi	sp,sp,32
80006554:	8082                	ret

80006556 <SPI_SCKDivConfig>:
                                 : 2-254.

  * @retval  void
  */
__STATIC_INLINE void SPI_SCKDivConfig(SPI_TypeDef* SPIx, uint32_t SCKDiv, uint32_t SCKDivExtra)
{
80006556:	1101                	addi	sp,sp,-32
80006558:	ce22                	sw	s0,28(sp)
8000655a:	1000                	addi	s0,sp,32
8000655c:	fea42623          	sw	a0,-20(s0)
80006560:	feb42423          	sw	a1,-24(s0)
80006564:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_SCK_DIV(SCKDiv));
    assert_param(IS_SPI_SCK_DIV_EXTRA(SCKDivExtra));

    WRITE_REG(SPIx->CR0_bit.SCR, SCKDiv);
80006568:	fe842783          	lw	a5,-24(s0)
8000656c:	0ff7f713          	zext.b	a4,a5
80006570:	fec42783          	lw	a5,-20(s0)
80006574:	00e780a3          	sb	a4,1(a5)
    WRITE_REG(SPIx->CPSR, SCKDivExtra);
80006578:	fec42783          	lw	a5,-20(s0)
8000657c:	fe442703          	lw	a4,-28(s0)
80006580:	cb98                	sw	a4,16(a5)
}
80006582:	0001                	nop
80006584:	4472                	lw	s0,28(sp)
80006586:	6105                	addi	sp,sp,32
80006588:	8082                	ret

8000658a <SPI_DeInit>:
  * @brief      SPI   
  * @param   SPIx    SPI,  x=0|1
  * @retval  void
  */
void SPI_DeInit(SPI_TypeDef* SPIx)
{
8000658a:	7179                	addi	sp,sp,-48
8000658c:	d606                	sw	ra,44(sp)
8000658e:	d422                	sw	s0,40(sp)
80006590:	1800                	addi	s0,sp,48
80006592:	fca42e23          	sw	a0,-36(s0)
    SPI_Num_TypeDef SPIx_Num;
    assert_param(IS_SPI_PERIPH(SPIx));

    if (SPIx == SPI0) {
80006596:	fdc42703          	lw	a4,-36(s0)
8000659a:	200507b7          	lui	a5,0x20050
8000659e:	00f71563          	bne	a4,a5,800065a8 <SPI_DeInit+0x1e>
        SPIx_Num = SPI0_Num;
800065a2:	fe042623          	sw	zero,-20(s0)
800065a6:	a811                	j	800065ba <SPI_DeInit+0x30>
    } else if (SPIx == SPI1) {
800065a8:	fdc42703          	lw	a4,-36(s0)
800065ac:	200607b7          	lui	a5,0x20060
800065b0:	00f71563          	bne	a4,a5,800065ba <SPI_DeInit+0x30>
        SPIx_Num = SPI1_Num;
800065b4:	4785                	li	a5,1
800065b6:	fef42623          	sw	a5,-20(s0)
    }

    RCU_SPIRstCmd(SPIx_Num, DISABLE);
800065ba:	4581                	li	a1,0
800065bc:	fec42503          	lw	a0,-20(s0)
800065c0:	3d75                	jal	8000647c <RCU_SPIRstCmd>
    RCU_SPIRstCmd(SPIx_Num, ENABLE);
800065c2:	4585                	li	a1,1
800065c4:	fec42503          	lw	a0,-20(s0)
800065c8:	3d55                	jal	8000647c <RCU_SPIRstCmd>
}
800065ca:	0001                	nop
800065cc:	50b2                	lw	ra,44(sp)
800065ce:	5422                	lw	s0,40(sp)
800065d0:	6145                	addi	sp,sp,48
800065d2:	8082                	ret

800065d4 <SPI_Init>:
  * @param   InitStruct      @ref SPI_Init_TypeDef,
  *                         .
  * @retval  Status    
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_Init_TypeDef* InitStruct)
{
800065d4:	1101                	addi	sp,sp,-32
800065d6:	ce06                	sw	ra,28(sp)
800065d8:	cc22                	sw	s0,24(sp)
800065da:	1000                	addi	s0,sp,32
800065dc:	fea42623          	sw	a0,-20(s0)
800065e0:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));

    SPI_SCKDivConfig(SPIx, InitStruct->SCKDiv, InitStruct->SCKDivExtra);
800065e4:	fe842783          	lw	a5,-24(s0)
800065e8:	47d8                	lw	a4,12(a5)
800065ea:	fe842783          	lw	a5,-24(s0)
800065ee:	4b9c                	lw	a5,16(a5)
800065f0:	863e                	mv	a2,a5
800065f2:	85ba                	mv	a1,a4
800065f4:	fec42503          	lw	a0,-20(s0)
800065f8:	3fb9                	jal	80006556 <SPI_SCKDivConfig>
    SPI_DataWidthConfig(SPIx, InitStruct->DataWidth);
800065fa:	fe842783          	lw	a5,-24(s0)
800065fe:	479c                	lw	a5,8(a5)
80006600:	85be                	mv	a1,a5
80006602:	fec42503          	lw	a0,-20(s0)
80006606:	3d55                	jal	800064ba <SPI_DataWidthConfig>
    SPI_FrameFormatConfig(SPIx, InitStruct->FrameFormat);
80006608:	fe842783          	lw	a5,-24(s0)
8000660c:	43dc                	lw	a5,4(a5)
8000660e:	85be                	mv	a1,a5
80006610:	fec42503          	lw	a0,-20(s0)
80006614:	3731                	jal	80006520 <SPI_FrameFormatConfig>
    SPI_ModeConfig(SPIx, InitStruct->Mode);
80006616:	fe842783          	lw	a5,-24(s0)
8000661a:	439c                	lw	a5,0(a5)
8000661c:	85be                	mv	a1,a5
8000661e:	fec42503          	lw	a0,-20(s0)
80006622:	35e9                	jal	800064ec <SPI_ModeConfig>
}
80006624:	0001                	nop
80006626:	40f2                	lw	ra,28(sp)
80006628:	4462                	lw	s0,24(sp)
8000662a:	6105                	addi	sp,sp,32
8000662c:	8082                	ret

8000662e <SPI_StructInit>:
  * @param   InitStruct      @ref SPI_Init_TypeDef,
  *                        .
  * @retval  void
  */
void SPI_StructInit(SPI_Init_TypeDef* InitStruct)
{
8000662e:	1101                	addi	sp,sp,-32
80006630:	ce22                	sw	s0,28(sp)
80006632:	1000                	addi	s0,sp,32
80006634:	fea42623          	sw	a0,-20(s0)
    InitStruct->SCKDiv = 0;
80006638:	fec42783          	lw	a5,-20(s0)
8000663c:	0007a623          	sw	zero,12(a5) # 2006000c <STACK_SIZE+0x2005f80c>
    InitStruct->SCKDivExtra = 2;
80006640:	fec42783          	lw	a5,-20(s0)
80006644:	4709                	li	a4,2
80006646:	cb98                	sw	a4,16(a5)
    InitStruct->DataWidth = SPI_DataWidth_8;
80006648:	fec42783          	lw	a5,-20(s0)
8000664c:	471d                	li	a4,7
8000664e:	c798                	sw	a4,8(a5)
    InitStruct->FrameFormat = SPI_FrameFormat_SPI;
80006650:	fec42783          	lw	a5,-20(s0)
80006654:	0007a223          	sw	zero,4(a5)
    InitStruct->Mode = SPI_Mode_Master;
80006658:	fec42783          	lw	a5,-20(s0)
8000665c:	0007a023          	sw	zero,0(a5)
}
80006660:	0001                	nop
80006662:	4472                	lw	s0,28(sp)
80006664:	6105                	addi	sp,sp,32
80006666:	8082                	ret

80006668 <RCU_APBClkCmd>:
{
80006668:	1101                	addi	sp,sp,-32
8000666a:	ce22                	sw	s0,28(sp)
8000666c:	1000                	addi	s0,sp,32
8000666e:	fea42623          	sw	a0,-20(s0)
80006672:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->CGCFGAPB, APBClk, State ? APBClk : 0);
80006676:	3000e7b7          	lui	a5,0x3000e
8000667a:	4798                	lw	a4,8(a5)
8000667c:	fec42783          	lw	a5,-20(s0)
80006680:	fff7c793          	not	a5,a5
80006684:	00f776b3          	and	a3,a4,a5
80006688:	fe842783          	lw	a5,-24(s0)
8000668c:	c781                	beqz	a5,80006694 <RCU_APBClkCmd+0x2c>
8000668e:	fec42783          	lw	a5,-20(s0)
80006692:	a011                	j	80006696 <RCU_APBClkCmd+0x2e>
80006694:	4781                	li	a5,0
80006696:	3000e737          	lui	a4,0x3000e
8000669a:	8fd5                	or	a5,a5,a3
8000669c:	c71c                	sw	a5,8(a4)
}
8000669e:	0001                	nop
800066a0:	4472                	lw	s0,28(sp)
800066a2:	6105                	addi	sp,sp,32
800066a4:	8082                	ret

800066a6 <RCU_APBRstCmd>:
{
800066a6:	1101                	addi	sp,sp,-32
800066a8:	ce22                	sw	s0,28(sp)
800066aa:	1000                	addi	s0,sp,32
800066ac:	fea42623          	sw	a0,-20(s0)
800066b0:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAPB, APBRst, State ? APBRst : 0);
800066b4:	3000e7b7          	lui	a5,0x3000e
800066b8:	4f98                	lw	a4,24(a5)
800066ba:	fec42783          	lw	a5,-20(s0)
800066be:	fff7c793          	not	a5,a5
800066c2:	00f776b3          	and	a3,a4,a5
800066c6:	fe842783          	lw	a5,-24(s0)
800066ca:	c781                	beqz	a5,800066d2 <RCU_APBRstCmd+0x2c>
800066cc:	fec42783          	lw	a5,-20(s0)
800066d0:	a011                	j	800066d4 <RCU_APBRstCmd+0x2e>
800066d2:	4781                	li	a5,0
800066d4:	3000e737          	lui	a4,0x3000e
800066d8:	8fd5                	or	a5,a5,a3
800066da:	cf1c                	sw	a5,24(a4)
}
800066dc:	0001                	nop
800066de:	4472                	lw	s0,28(sp)
800066e0:	6105                	addi	sp,sp,32
800066e2:	8082                	ret

800066e4 <TRNG_StartCmd>:
  * @brief    
  * @param   state   
  * @retval  void
  */
__STATIC_INLINE void TRNG_StartCmd(FunctionalState state)
{
800066e4:	1101                	addi	sp,sp,-32
800066e6:	ce22                	sw	s0,28(sp)
800066e8:	1000                	addi	s0,sp,32
800066ea:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_START_Msk, state << TRNG_CR_START_Pos);
800066ee:	300047b7          	lui	a5,0x30004
800066f2:	439c                	lw	a5,0(a5)
800066f4:	ffe7f693          	andi	a3,a5,-2
800066f8:	300047b7          	lui	a5,0x30004
800066fc:	fec42703          	lw	a4,-20(s0)
80006700:	8f55                	or	a4,a4,a3
80006702:	c398                	sw	a4,0(a5)
}
80006704:	0001                	nop
80006706:	4472                	lw	s0,28(sp)
80006708:	6105                	addi	sp,sp,32
8000670a:	8082                	ret

8000670c <TRNG_PseudorandomGeneratorCmd>:
  * @brief        
  * @param   state   0 -    , 1 -  
  * @retval  void
  */
__STATIC_INLINE void TRNG_PseudorandomGeneratorCmd(FunctionalState state)
{
8000670c:	1101                	addi	sp,sp,-32
8000670e:	ce22                	sw	s0,28(sp)
80006710:	1000                	addi	s0,sp,32
80006712:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_LFSR_Msk, state << TRNG_CR_LFSR_Pos);
80006716:	300047b7          	lui	a5,0x30004
8000671a:	439c                	lw	a5,0(a5)
8000671c:	ffd7f693          	andi	a3,a5,-3
80006720:	fec42783          	lw	a5,-20(s0)
80006724:	00179713          	slli	a4,a5,0x1
80006728:	300047b7          	lui	a5,0x30004
8000672c:	8f55                	or	a4,a4,a3
8000672e:	c398                	sw	a4,0(a5)
}
80006730:	0001                	nop
80006732:	4472                	lw	s0,28(sp)
80006734:	6105                	addi	sp,sp,32
80006736:	8082                	ret

80006738 <TRNG_BypassHandlerCmd>:
  * @brief     
  * @param   state     0 -   , 1 -   
  * @retval  void
  */
__STATIC_INLINE void TRNG_BypassHandlerCmd(FunctionalState state)
{
80006738:	1101                	addi	sp,sp,-32
8000673a:	ce22                	sw	s0,28(sp)
8000673c:	1000                	addi	s0,sp,32
8000673e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_CONDBYPASS_Msk, state << TRNG_CR_CONDBYPASS_Pos);
80006742:	300047b7          	lui	a5,0x30004
80006746:	439c                	lw	a5,0(a5)
80006748:	ff77f693          	andi	a3,a5,-9
8000674c:	fec42783          	lw	a5,-20(s0)
80006750:	00379713          	slli	a4,a5,0x3
80006754:	300047b7          	lui	a5,0x30004
80006758:	8f55                	or	a4,a4,a3
8000675a:	c398                	sw	a4,0(a5)
}
8000675c:	0001                	nop
8000675e:	4472                	lw	s0,28(sp)
80006760:	6105                	addi	sp,sp,32
80006762:	8082                	ret

80006764 <TRNG_SwResetCmd>:
  * 		     !
  * @param   state   
  * @retval  void
  */
__STATIC_INLINE void TRNG_SwResetCmd(FunctionalState state)
{
80006764:	1101                	addi	sp,sp,-32
80006766:	ce22                	sw	s0,28(sp)
80006768:	1000                	addi	s0,sp,32
8000676a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_SOFTRST_Msk, state << TRNG_CR_SOFTRST_Pos);
8000676e:	300047b7          	lui	a5,0x30004
80006772:	439c                	lw	a5,0(a5)
80006774:	eff7f693          	andi	a3,a5,-257
80006778:	fec42783          	lw	a5,-20(s0)
8000677c:	00879713          	slli	a4,a5,0x8
80006780:	300047b7          	lui	a5,0x30004
80006784:	8f55                	or	a4,a4,a3
80006786:	c398                	sw	a4,0(a5)
}
80006788:	0001                	nop
8000678a:	4472                	lw	s0,28(sp)
8000678c:	6105                	addi	sp,sp,32
8000678e:	8082                	ret

80006790 <TRNG_ForceGeneratorCmd>:
  * @brief     ,  FIFO 
  * @param   state    
  * @retval  void
  */
__STATIC_INLINE void TRNG_ForceGeneratorCmd(FunctionalState state)
{
80006790:	1101                	addi	sp,sp,-32
80006792:	ce22                	sw	s0,28(sp)
80006794:	1000                	addi	s0,sp,32
80006796:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_FORCEROS_Msk, state << TRNG_CR_FORCEROS_Pos);
8000679a:	300047b7          	lui	a5,0x30004
8000679e:	4398                	lw	a4,0(a5)
800067a0:	77fd                	lui	a5,0xfffff
800067a2:	7ff78793          	addi	a5,a5,2047 # fffff7ff <__data_source_start+0x7fff8687>
800067a6:	00f776b3          	and	a3,a4,a5
800067aa:	fec42783          	lw	a5,-20(s0)
800067ae:	00b79713          	slli	a4,a5,0xb
800067b2:	300047b7          	lui	a5,0x30004
800067b6:	8f55                	or	a4,a4,a3
800067b8:	c398                	sw	a4,0(a5)
}
800067ba:	0001                	nop
800067bc:	4472                	lw	s0,28(sp)
800067be:	6105                	addi	sp,sp,32
800067c0:	8082                	ret

800067c2 <TRNG_SetBlockAmountForHandler>:
  * @param   countBlock     
  * 		    
  * @retval  void
  */
__STATIC_INLINE void TRNG_SetBlockAmountForHandler(uint32_t countBlock)
{
800067c2:	1101                	addi	sp,sp,-32
800067c4:	ce22                	sw	s0,28(sp)
800067c6:	1000                	addi	s0,sp,32
800067c8:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TRNG_COUNTBLOCK(countBlock));

	MODIFY_REG(TRNG->CR, TRNG_CR_COUNTBLOCK_Msk, countBlock << TRNG_CR_COUNTBLOCK_Pos);
800067cc:	300047b7          	lui	a5,0x30004
800067d0:	4398                	lw	a4,0(a5)
800067d2:	fff107b7          	lui	a5,0xfff10
800067d6:	17fd                	addi	a5,a5,-1 # fff0ffff <__data_source_start+0x7ff08e87>
800067d8:	00f776b3          	and	a3,a4,a5
800067dc:	fec42783          	lw	a5,-20(s0)
800067e0:	01079713          	slli	a4,a5,0x10
800067e4:	300047b7          	lui	a5,0x30004
800067e8:	8f55                	or	a4,a4,a3
800067ea:	c398                	sw	a4,0(a5)
}
800067ec:	0001                	nop
800067ee:	4472                	lw	s0,28(sp)
800067f0:	6105                	addi	sp,sp,32
800067f2:	8082                	ret

800067f4 <TRNG_FIFOfillOnStartCmd>:
  * @brief       FIFO   
  * @param   state   
  * @retval  void
  */
__STATIC_INLINE void TRNG_FIFOfillOnStartCmd(FunctionalState state)
{
800067f4:	1101                	addi	sp,sp,-32
800067f6:	ce22                	sw	s0,28(sp)
800067f8:	1000                	addi	s0,sp,32
800067fa:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_FIFOFILLST_Msk, state << TRNG_CR_FIFOFILLST_Pos);
800067fe:	300047b7          	lui	a5,0x30004
80006802:	4398                	lw	a4,0(a5)
80006804:	fff007b7          	lui	a5,0xfff00
80006808:	17fd                	addi	a5,a5,-1 # ffefffff <__data_source_start+0x7fef8e87>
8000680a:	00f776b3          	and	a3,a4,a5
8000680e:	fec42783          	lw	a5,-20(s0)
80006812:	01479713          	slli	a4,a5,0x14
80006816:	300047b7          	lui	a5,0x30004
8000681a:	8f55                	or	a4,a4,a3
8000681c:	c398                	sw	a4,0(a5)
}
8000681e:	0001                	nop
80006820:	4472                	lw	s0,28(sp)
80006822:	6105                	addi	sp,sp,32
80006824:	8082                	ret

80006826 <TRNG_BlendMethodConfig>:
  * @brief     
  * @param   method  
  * @retval  void
  */
__STATIC_INLINE void TRNG_BlendMethodConfig(TRNG_BLENDMETHOD_TypeDef method)
{
80006826:	1101                	addi	sp,sp,-32
80006828:	ce22                	sw	s0,28(sp)
8000682a:	1000                	addi	s0,sp,32
8000682c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TRNG_BLENDMETHOD(method));

	MODIFY_REG(TRNG->CR, TRNG_CR_BLENDMETHOD_Msk, method << TRNG_CR_BLENDMETHOD_Pos);
80006830:	300047b7          	lui	a5,0x30004
80006834:	4398                	lw	a4,0(a5)
80006836:	400007b7          	lui	a5,0x40000
8000683a:	17fd                	addi	a5,a5,-1 # 3fffffff <STACK_SIZE+0x3ffff7ff>
8000683c:	00f776b3          	and	a3,a4,a5
80006840:	fec42783          	lw	a5,-20(s0)
80006844:	01e79713          	slli	a4,a5,0x1e
80006848:	300047b7          	lui	a5,0x30004
8000684c:	8f55                	or	a4,a4,a3
8000684e:	c398                	sw	a4,0(a5)
}
80006850:	0001                	nop
80006852:	4472                	lw	s0,28(sp)
80006854:	6105                	addi	sp,sp,32
80006856:	8082                	ret

80006858 <TRNG_GetFIFOlength>:
/**
  * @brief      32-    FIFO
  * @retval  length   32-    FIFO
  */
__STATIC_INLINE uint32_t TRNG_GetFIFOlength()
{
80006858:	1141                	addi	sp,sp,-16
8000685a:	c622                	sw	s0,12(sp)
8000685c:	0800                	addi	s0,sp,16
	return (uint32_t) READ_REG(TRNG->FIFOLEV);
8000685e:	300047b7          	lui	a5,0x30004
80006862:	43dc                	lw	a5,4(a5)
}
80006864:	853e                	mv	a0,a5
80006866:	4432                	lw	s0,12(sp)
80006868:	0141                	addi	sp,sp,16
8000686a:	8082                	ret

8000686c <TRNG_GetFIFOValue>:
/**
  * @brief      FIFO 
  * @retval  Val    FIFO
  */
__STATIC_INLINE uint32_t TRNG_GetFIFOValue()
{
8000686c:	1141                	addi	sp,sp,-16
8000686e:	c622                	sw	s0,12(sp)
80006870:	0800                	addi	s0,sp,16
	return (uint32_t) READ_REG(TRNG->FIFO[0].FIFO);
80006872:	300047b7          	lui	a5,0x30004
80006876:	0807a783          	lw	a5,128(a5) # 30004080 <STACK_SIZE+0x30003880>
}
8000687a:	853e                	mv	a0,a5
8000687c:	4432                	lw	s0,12(sp)
8000687e:	0141                	addi	sp,sp,16
80006880:	8082                	ret

80006882 <TRNG_DeInit>:
/**
  * @brief      TRNG   
  * @retval  void
  */
void TRNG_DeInit()
{
80006882:	1141                	addi	sp,sp,-16
80006884:	c606                	sw	ra,12(sp)
80006886:	c422                	sw	s0,8(sp)
80006888:	0800                	addi	s0,sp,16
	TRNG_SwResetCmd(ENABLE);
8000688a:	4505                	li	a0,1
8000688c:	3de1                	jal	80006764 <TRNG_SwResetCmd>

    RCU_APBRstCmd(RCU_APBRst_TRNG, DISABLE);
8000688e:	4581                	li	a1,0
80006890:	4541                	li	a0,16
80006892:	3d11                	jal	800066a6 <RCU_APBRstCmd>
    RCU_APBRstCmd(RCU_APBRst_TRNG, ENABLE);
80006894:	4585                	li	a1,1
80006896:	4541                	li	a0,16
80006898:	3539                	jal	800066a6 <RCU_APBRstCmd>

    TRNG_SwResetCmd(DISABLE);
8000689a:	4501                	li	a0,0
8000689c:	35e1                	jal	80006764 <TRNG_SwResetCmd>
}
8000689e:	0001                	nop
800068a0:	40b2                	lw	ra,12(sp)
800068a2:	4422                	lw	s0,8(sp)
800068a4:	0141                	addi	sp,sp,16
800068a6:	8082                	ret

800068a8 <TRNG_Init>:
  * @param   InitStruct      @ref TRNG_Init_TypeDef,
  *                         
  * @retval  void
  */
void TRNG_Init(TRNG_Init_TypeDef* InitStruct)
{
800068a8:	1101                	addi	sp,sp,-32
800068aa:	ce06                	sw	ra,28(sp)
800068ac:	cc22                	sw	s0,24(sp)
800068ae:	1000                	addi	s0,sp,32
800068b0:	fea42623          	sw	a0,-20(s0)
	TRNG_PseudorandomGeneratorCmd(InitStruct->PseudoRandomEnable);
800068b4:	fec42783          	lw	a5,-20(s0)
800068b8:	439c                	lw	a5,0(a5)
800068ba:	853e                	mv	a0,a5
800068bc:	3d81                	jal	8000670c <TRNG_PseudorandomGeneratorCmd>
//	TRNG_TestSourceCmd(InitStruct->TestSourceEnable);
	TRNG_BypassHandlerCmd(InitStruct->BypassHandler);
800068be:	fec42783          	lw	a5,-20(s0)
800068c2:	43dc                	lw	a5,4(a5)
800068c4:	853e                	mv	a0,a5
800068c6:	3d8d                	jal	80006738 <TRNG_BypassHandlerCmd>
//	TRNG_ITTestFailCmd(InitStruct->ITOnAnyTestFail);
//	TRNG_ITFIFOfullCmd(InitStruct->ITOnFIFOfull);
	TRNG_ForceGeneratorCmd(InitStruct->ForceGenerator);
800068c8:	fec42783          	lw	a5,-20(s0)
800068cc:	479c                	lw	a5,8(a5)
800068ce:	853e                	mv	a0,a5
800068d0:	35c1                	jal	80006790 <TRNG_ForceGeneratorCmd>
//	TRNG_IgnoreHardwareTestsCmd(InitStruct->IgnoreHardwareTests);
	TRNG_SetBlockAmountForHandler(InitStruct->AmountBlocksForHandler);
800068d2:	fec42783          	lw	a5,-20(s0)
800068d6:	47dc                	lw	a5,12(a5)
800068d8:	853e                	mv	a0,a5
800068da:	35e5                	jal	800067c2 <TRNG_SetBlockAmountForHandler>
	TRNG_FIFOfillOnStartCmd(InitStruct->FIFOfillOnStart);
800068dc:	fec42783          	lw	a5,-20(s0)
800068e0:	4b9c                	lw	a5,16(a5)
800068e2:	853e                	mv	a0,a5
800068e4:	3f01                	jal	800067f4 <TRNG_FIFOfillOnStartCmd>
//	TRNG_RepeatTestDisableCmd(InitStruct->RepeatTestDisable);
//	TRNG_ProportionTestDisableCmd(InitStruct->ProportionTestDisable);
//	TRNG_AutoCorrelationTestDisableConfig(InitStruct->AutocorrelationTestDisable);
//	TRNG_CorrelationTestDisableConfig(InitStruct->CorrelationTestDisable);
	TRNG_BlendMethodConfig(InitStruct->BlendMethod);
800068e6:	fec42783          	lw	a5,-20(s0)
800068ea:	4bdc                	lw	a5,20(a5)
800068ec:	853e                	mv	a0,a5
800068ee:	3f25                	jal	80006826 <TRNG_BlendMethodConfig>
	TRNG_SwResetCmd(DISABLE);
800068f0:	4501                	li	a0,0
800068f2:	3d8d                	jal	80006764 <TRNG_SwResetCmd>
}
800068f4:	0001                	nop
800068f6:	40f2                	lw	ra,28(sp)
800068f8:	4462                	lw	s0,24(sp)
800068fa:	6105                	addi	sp,sp,32
800068fc:	8082                	ret

800068fe <TRNG_StructInit>:
  * @param   InitStruct      @ref TRNG_Init_TypeDef,
  *                        
  * @retval  void
  */
void TRNG_StructInit(TRNG_Init_TypeDef* InitStruct)
{
800068fe:	1101                	addi	sp,sp,-32
80006900:	ce22                	sw	s0,28(sp)
80006902:	1000                	addi	s0,sp,32
80006904:	fea42623          	sw	a0,-20(s0)
	InitStruct->PseudoRandomEnable = DISABLE;
80006908:	fec42783          	lw	a5,-20(s0)
8000690c:	0007a023          	sw	zero,0(a5)
//	InitStruct->TestSourceEnable = DISABLE;
	InitStruct->BypassHandler = DISABLE;
80006910:	fec42783          	lw	a5,-20(s0)
80006914:	0007a223          	sw	zero,4(a5)
//	InitStruct->ITOnAnyTestFail = DISABLE;
//	InitStruct->ITOnFIFOfull = DISABLE;
	InitStruct->ForceGenerator = DISABLE;
80006918:	fec42783          	lw	a5,-20(s0)
8000691c:	0007a423          	sw	zero,8(a5)
//	InitStruct->IgnoreHardwareTests = DISABLE;
	InitStruct->AmountBlocksForHandler = 0x0;
80006920:	fec42783          	lw	a5,-20(s0)
80006924:	0007a623          	sw	zero,12(a5)
	InitStruct->FIFOfillOnStart = DISABLE;
80006928:	fec42783          	lw	a5,-20(s0)
8000692c:	0007a823          	sw	zero,16(a5)
//	InitStruct->RepeatTestDisable = DISABLE;
//	InitStruct->ProportionTestDisable = DISABLE;
//	InitStruct->AutocorrelationTestDisable = TRNG_AUTOCORRELATIONDISABLE_Nothing;
//	InitStruct->CorrelationTestDisable = TRNG_CORRELATIONDISABLE_Nothing;
	InitStruct->BlendMethod = TRNG_BLENDMETHOD_Concatenation;
80006930:	fec42783          	lw	a5,-20(s0)
80006934:	0007aa23          	sw	zero,20(a5)
	InitStruct->WarmPeriod = 0x00000200;
80006938:	fec42783          	lw	a5,-20(s0)
8000693c:	20000713          	li	a4,512
80006940:	cf98                	sw	a4,24(a5)
	InitStruct->CoolPeriod = 0x00000000;
80006942:	fec42783          	lw	a5,-20(s0)
80006946:	0007ae23          	sw	zero,28(a5)
	InitStruct->SamplePeriod = 0x0000001E;
8000694a:	fec42783          	lw	a5,-20(s0)
8000694e:	4779                	li	a4,30
80006950:	d398                	sw	a4,32(a5)
}
80006952:	0001                	nop
80006954:	4472                	lw	s0,28(sp)
80006956:	6105                	addi	sp,sp,32
80006958:	8082                	ret

8000695a <TRNG_GenerateKey>:
  * @param   key   ,      keyLength
  * @param   keyLength    32- 
  * @retval  void
  */
void TRNG_GenerateKey(uint32_t *key, uint32_t keyLength)
{
8000695a:	715d                	addi	sp,sp,-80
8000695c:	c686                	sw	ra,76(sp)
8000695e:	c4a2                	sw	s0,72(sp)
80006960:	c2a6                	sw	s1,68(sp)
80006962:	0880                	addi	s0,sp,80
80006964:	faa42e23          	sw	a0,-68(s0)
80006968:	fab42c23          	sw	a1,-72(s0)
	TRNG_DeInit();
8000696c:	3f19                	jal	80006882 <TRNG_DeInit>
	RCU_APBClkCmd(RCU_APBClk_TRNG, ENABLE);
8000696e:	4585                	li	a1,1
80006970:	4541                	li	a0,16
80006972:	39dd                	jal	80006668 <RCU_APBClkCmd>
	RCU_APBRstCmd(RCU_APBRst_TRNG, ENABLE);
80006974:	4585                	li	a1,1
80006976:	4541                	li	a0,16
80006978:	333d                	jal	800066a6 <RCU_APBRstCmd>
	TRNG_SwResetCmd(ENABLE);
8000697a:	4505                	li	a0,1
8000697c:	33e5                	jal	80006764 <TRNG_SwResetCmd>
	TRNG_Init_TypeDef trngInit;
	TRNG_StructInit(&trngInit);
8000697e:	fcc40793          	addi	a5,s0,-52
80006982:	853e                	mv	a0,a5
80006984:	3fad                	jal	800068fe <TRNG_StructInit>

	// Start filling FIFO with noise source, with conditioning, all start-up tests and wait until interrupt triggers
	trngInit.WarmPeriod       = 0x00000200; //
80006986:	20000793          	li	a5,512
8000698a:	fef42223          	sw	a5,-28(s0)
	trngInit.SamplePeriod     = 0x00000020;
8000698e:	02000793          	li	a5,32
80006992:	fef42623          	sw	a5,-20(s0)
	trngInit.CoolPeriod       = 0x00000000;
80006996:	fe042423          	sw	zero,-24(s0)
	trngInit.AmountBlocksForHandler = 0x4;
8000699a:	4791                	li	a5,4
8000699c:	fcf42c23          	sw	a5,-40(s0)
	trngInit.BypassHandler    = DISABLE;
800069a0:	fc042823          	sw	zero,-48(s0)

	TRNG_Init(&trngInit);
800069a4:	fcc40793          	addi	a5,s0,-52
800069a8:	853e                	mv	a0,a5
800069aa:	3dfd                	jal	800068a8 <TRNG_Init>

	TRNG_StartCmd(ENABLE);
800069ac:	4505                	li	a0,1
800069ae:	3b1d                	jal	800066e4 <TRNG_StartCmd>

	while (TRNG_GetFIFOlength() != keyLength) {}
800069b0:	0001                	nop
800069b2:	355d                	jal	80006858 <TRNG_GetFIFOlength>
800069b4:	872a                	mv	a4,a0
800069b6:	fb842783          	lw	a5,-72(s0)
800069ba:	fee79ce3          	bne	a5,a4,800069b2 <TRNG_GenerateKey+0x58>

	TRNG_StartCmd(DISABLE);
800069be:	4501                	li	a0,0
800069c0:	3315                	jal	800066e4 <TRNG_StartCmd>

	while (keyLength--)
800069c2:	a811                	j	800069d6 <TRNG_GenerateKey+0x7c>
	{
		*key++ = TRNG_GetFIFOValue();
800069c4:	fbc42483          	lw	s1,-68(s0)
800069c8:	00448793          	addi	a5,s1,4
800069cc:	faf42e23          	sw	a5,-68(s0)
800069d0:	3d71                	jal	8000686c <TRNG_GetFIFOValue>
800069d2:	87aa                	mv	a5,a0
800069d4:	c09c                	sw	a5,0(s1)
	while (keyLength--)
800069d6:	fb842783          	lw	a5,-72(s0)
800069da:	fff78713          	addi	a4,a5,-1
800069de:	fae42c23          	sw	a4,-72(s0)
800069e2:	f3ed                	bnez	a5,800069c4 <TRNG_GenerateKey+0x6a>
	}

	TRNG_SwResetCmd(ENABLE);
800069e4:	4505                	li	a0,1
800069e6:	3bbd                	jal	80006764 <TRNG_SwResetCmd>
}
800069e8:	0001                	nop
800069ea:	40b6                	lw	ra,76(sp)
800069ec:	4426                	lw	s0,72(sp)
800069ee:	4496                	lw	s1,68(sp)
800069f0:	6161                	addi	sp,sp,80
800069f2:	8082                	ret

800069f4 <RCU_UARTRstCmd>:
{
800069f4:	1101                	addi	sp,sp,-32
800069f6:	ce22                	sw	s0,28(sp)
800069f8:	1000                	addi	s0,sp,32
800069fa:	fea42623          	sw	a0,-20(s0)
800069fe:	feb42423          	sw	a1,-24(s0)
    WRITE_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.RSTDIS, State);
80006a02:	3000e6b7          	lui	a3,0x3000e
80006a06:	fe842783          	lw	a5,-24(s0)
80006a0a:	8b85                	andi	a5,a5,1
80006a0c:	0ff7f713          	zext.b	a4,a5
80006a10:	fec42783          	lw	a5,-20(s0)
80006a14:	07f1                	addi	a5,a5,28
80006a16:	078a                	slli	a5,a5,0x2
80006a18:	97b6                	add	a5,a5,a3
80006a1a:	8b05                	andi	a4,a4,1
80006a1c:	0722                	slli	a4,a4,0x8
80006a1e:	4394                	lw	a3,0(a5)
80006a20:	eff6f693          	andi	a3,a3,-257
80006a24:	8f55                	or	a4,a4,a3
80006a26:	c398                	sw	a4,0(a5)
}
80006a28:	0001                	nop
80006a2a:	4472                	lw	s0,28(sp)
80006a2c:	6105                	addi	sp,sp,32
80006a2e:	8082                	ret

80006a30 <UART_DataWidthConfig>:
  * @param   UARTx    UART,  x=0|1|2|3
  * @param   DataWidth    
  * @retval  void
  */
__STATIC_INLINE void UART_DataWidthConfig(UART_TypeDef* UARTx, UART_DataWidth_TypeDef DataWidth)
{
80006a30:	1101                	addi	sp,sp,-32
80006a32:	ce22                	sw	s0,28(sp)
80006a34:	1000                	addi	s0,sp,32
80006a36:	fea42623          	sw	a0,-20(s0)
80006a3a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_DATA_WIDTH(DataWidth));

    WRITE_REG(UARTx->LCRH_bit.WLEN, DataWidth);
80006a3e:	fe842783          	lw	a5,-24(s0)
80006a42:	8b8d                	andi	a5,a5,3
80006a44:	0ff7f713          	zext.b	a4,a5
80006a48:	fec42783          	lw	a5,-20(s0)
80006a4c:	8b0d                	andi	a4,a4,3
80006a4e:	0716                	slli	a4,a4,0x5
80006a50:	02c7c683          	lbu	a3,44(a5)
80006a54:	f9f6f693          	andi	a3,a3,-97
80006a58:	8f55                	or	a4,a4,a3
80006a5a:	02e78623          	sb	a4,44(a5)
}
80006a5e:	0001                	nop
80006a60:	4472                	lw	s0,28(sp)
80006a62:	6105                	addi	sp,sp,32
80006a64:	8082                	ret

80006a66 <UART_StopBitConfig>:
  * @param   UARTx    UART,  x=0|1|2|3
  * @param   StopBit   -
  * @retval  void
  */
__STATIC_INLINE void UART_StopBitConfig(UART_TypeDef* UARTx, UART_StopBit_TypeDef StopBit)
{
80006a66:	1101                	addi	sp,sp,-32
80006a68:	ce22                	sw	s0,28(sp)
80006a6a:	1000                	addi	s0,sp,32
80006a6c:	fea42623          	sw	a0,-20(s0)
80006a70:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_STOP_BIT(StopBit));

    WRITE_REG(UARTx->LCRH_bit.STP2, StopBit);
80006a74:	fe842783          	lw	a5,-24(s0)
80006a78:	8b85                	andi	a5,a5,1
80006a7a:	0ff7f713          	zext.b	a4,a5
80006a7e:	fec42783          	lw	a5,-20(s0)
80006a82:	8b05                	andi	a4,a4,1
80006a84:	070e                	slli	a4,a4,0x3
80006a86:	02c7c683          	lbu	a3,44(a5)
80006a8a:	9add                	andi	a3,a3,-9
80006a8c:	8f55                	or	a4,a4,a3
80006a8e:	02e78623          	sb	a4,44(a5)
}
80006a92:	0001                	nop
80006a94:	4472                	lw	s0,28(sp)
80006a96:	6105                	addi	sp,sp,32
80006a98:	8082                	ret

80006a9a <UART_ParityBitConfig>:
  * @param   UARTx    UART,  x=0|1|2|3
  * @param   ParityBit  
  * @retval  void
  */
__STATIC_INLINE void UART_ParityBitConfig(UART_TypeDef* UARTx, UART_ParityBit_TypeDef ParityBit)
{
80006a9a:	1101                	addi	sp,sp,-32
80006a9c:	ce22                	sw	s0,28(sp)
80006a9e:	1000                	addi	s0,sp,32
80006aa0:	fea42623          	sw	a0,-20(s0)
80006aa4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_PARITY_BIT(ParityBit));

    MODIFY_REG(UARTx->LCRH, UART_LCRH_PEN_Msk | UART_LCRH_SPS_Msk | UART_LCRH_EPS_Msk, ParityBit);
80006aa8:	fec42783          	lw	a5,-20(s0)
80006aac:	57dc                	lw	a5,44(a5)
80006aae:	f797f713          	andi	a4,a5,-135
80006ab2:	fe842783          	lw	a5,-24(s0)
80006ab6:	8f5d                	or	a4,a4,a5
80006ab8:	fec42783          	lw	a5,-20(s0)
80006abc:	d7d8                	sw	a4,44(a5)
}
80006abe:	0001                	nop
80006ac0:	4472                	lw	s0,28(sp)
80006ac2:	6105                	addi	sp,sp,32
80006ac4:	8082                	ret

80006ac6 <UART_BaudDivConfig>:
  *                         0-63.  ,  IntDiv
  *                    65535,  FracDiv    0.
  * @retval  void
  */
__STATIC_INLINE void UART_BaudDivConfig(UART_TypeDef* UARTx, uint32_t IntDiv, uint32_t FracDiv)
{
80006ac6:	1101                	addi	sp,sp,-32
80006ac8:	ce22                	sw	s0,28(sp)
80006aca:	1000                	addi	s0,sp,32
80006acc:	fea42623          	sw	a0,-20(s0)
80006ad0:	feb42423          	sw	a1,-24(s0)
80006ad4:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_INT_DIV(IntDiv));
    assert_param(IS_UART_FRAC_DIV(FracDiv));

    WRITE_REG(UARTx->IBRD, IntDiv);
80006ad8:	fec42783          	lw	a5,-20(s0)
80006adc:	fe842703          	lw	a4,-24(s0)
80006ae0:	d3d8                	sw	a4,36(a5)
    WRITE_REG(UARTx->FBRD, FracDiv);
80006ae2:	fec42783          	lw	a5,-20(s0)
80006ae6:	fe442703          	lw	a4,-28(s0)
80006aea:	d798                	sw	a4,40(a5)
}
80006aec:	0001                	nop
80006aee:	4472                	lw	s0,28(sp)
80006af0:	6105                	addi	sp,sp,32
80006af2:	8082                	ret

80006af4 <UART_FIFOCmd>:
  * @param   UARTx    UART,  x=0|1|2|3
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void UART_FIFOCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80006af4:	1101                	addi	sp,sp,-32
80006af6:	ce22                	sw	s0,28(sp)
80006af8:	1000                	addi	s0,sp,32
80006afa:	fea42623          	sw	a0,-20(s0)
80006afe:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->LCRH_bit.FEN, State);
80006b02:	fe842783          	lw	a5,-24(s0)
80006b06:	8b85                	andi	a5,a5,1
80006b08:	0ff7f713          	zext.b	a4,a5
80006b0c:	fec42783          	lw	a5,-20(s0)
80006b10:	8b05                	andi	a4,a4,1
80006b12:	0712                	slli	a4,a4,0x4
80006b14:	02c7c683          	lbu	a3,44(a5)
80006b18:	9abd                	andi	a3,a3,-17
80006b1a:	8f55                	or	a4,a4,a3
80006b1c:	02e78623          	sb	a4,44(a5)
}
80006b20:	0001                	nop
80006b22:	4472                	lw	s0,28(sp)
80006b24:	6105                	addi	sp,sp,32
80006b26:	8082                	ret

80006b28 <UART_RxCmd>:
  * @param   UARTx    UART,  x=0|1|2|3
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void UART_RxCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80006b28:	1101                	addi	sp,sp,-32
80006b2a:	ce22                	sw	s0,28(sp)
80006b2c:	1000                	addi	s0,sp,32
80006b2e:	fea42623          	sw	a0,-20(s0)
80006b32:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->CR_bit.RXE, State);
80006b36:	fe842783          	lw	a5,-24(s0)
80006b3a:	8b85                	andi	a5,a5,1
80006b3c:	0ff7f713          	zext.b	a4,a5
80006b40:	fec42783          	lw	a5,-20(s0)
80006b44:	8b05                	andi	a4,a4,1
80006b46:	0726                	slli	a4,a4,0x9
80006b48:	0307d683          	lhu	a3,48(a5)
80006b4c:	dff6f693          	andi	a3,a3,-513
80006b50:	8f55                	or	a4,a4,a3
80006b52:	02e79823          	sh	a4,48(a5)
}
80006b56:	0001                	nop
80006b58:	4472                	lw	s0,28(sp)
80006b5a:	6105                	addi	sp,sp,32
80006b5c:	8082                	ret

80006b5e <UART_TxCmd>:
  * @param   UARTx    UART,  x=0|1|2|3
  * @param   State   
  * @retval  void
  */
__STATIC_INLINE void UART_TxCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80006b5e:	1101                	addi	sp,sp,-32
80006b60:	ce22                	sw	s0,28(sp)
80006b62:	1000                	addi	s0,sp,32
80006b64:	fea42623          	sw	a0,-20(s0)
80006b68:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->CR_bit.TXE, State);
80006b6c:	fe842783          	lw	a5,-24(s0)
80006b70:	8b85                	andi	a5,a5,1
80006b72:	0ff7f713          	zext.b	a4,a5
80006b76:	fec42783          	lw	a5,-20(s0)
80006b7a:	8b05                	andi	a4,a4,1
80006b7c:	0722                	slli	a4,a4,0x8
80006b7e:	0307d683          	lhu	a3,48(a5)
80006b82:	eff6f693          	andi	a3,a3,-257
80006b86:	8f55                	or	a4,a4,a3
80006b88:	02e79823          	sh	a4,48(a5)
}
80006b8c:	0001                	nop
80006b8e:	4472                	lw	s0,28(sp)
80006b90:	6105                	addi	sp,sp,32
80006b92:	8082                	ret

80006b94 <UART_AutoBaudConfig>:
  * @param   UARTx    UART,  x=0|1|2|3
  * @param   State   
  * @retval  void
  */
void UART_AutoBaudConfig(UART_TypeDef* UARTx, uint32_t BaudRate)
{
80006b94:	7179                	addi	sp,sp,-48
80006b96:	d606                	sw	ra,44(sp)
80006b98:	d422                	sw	s0,40(sp)
80006b9a:	1800                	addi	s0,sp,48
80006b9c:	fca42e23          	sw	a0,-36(s0)
80006ba0:	fcb42c23          	sw	a1,-40(s0)
    UART_Num_TypeDef UARTx_Num;
    uint32_t uart_clk_freq, int_div, frac_div;

    assert_param(IS_UART_PERIPH(UARTx));

    if (UARTx == UART0) {
80006ba4:	fdc42703          	lw	a4,-36(s0)
80006ba8:	300067b7          	lui	a5,0x30006
80006bac:	00f71563          	bne	a4,a5,80006bb6 <UART_AutoBaudConfig+0x22>
        UARTx_Num = UART0_Num;
80006bb0:	fe042623          	sw	zero,-20(s0)
80006bb4:	a805                	j	80006be4 <UART_AutoBaudConfig+0x50>
    } else if (UARTx == UART1) {
80006bb6:	fdc42703          	lw	a4,-36(s0)
80006bba:	300077b7          	lui	a5,0x30007
80006bbe:	00f71663          	bne	a4,a5,80006bca <UART_AutoBaudConfig+0x36>
        UARTx_Num = UART1_Num;
80006bc2:	4785                	li	a5,1
80006bc4:	fef42623          	sw	a5,-20(s0)
80006bc8:	a831                	j	80006be4 <UART_AutoBaudConfig+0x50>
    } else if (UARTx == UART2) {
80006bca:	fdc42703          	lw	a4,-36(s0)
80006bce:	300087b7          	lui	a5,0x30008
80006bd2:	00f71663          	bne	a4,a5,80006bde <UART_AutoBaudConfig+0x4a>
        UARTx_Num = UART2_Num;
80006bd6:	4789                	li	a5,2
80006bd8:	fef42623          	sw	a5,-20(s0)
80006bdc:	a021                	j	80006be4 <UART_AutoBaudConfig+0x50>
    } else /*if (UARTx == UART3)*/ {
        UARTx_Num = UART3_Num;
80006bde:	478d                	li	a5,3
80006be0:	fef42623          	sw	a5,-20(s0)
    }

    uart_clk_freq = RCU_GetUARTClkFreq(UARTx_Num);
80006be4:	fec42503          	lw	a0,-20(s0)
80006be8:	d12ff0ef          	jal	ra,800060fa <RCU_GetUARTClkFreq>
80006bec:	fea42423          	sw	a0,-24(s0)
    int_div = uart_clk_freq / (16 * BaudRate);
80006bf0:	fd842783          	lw	a5,-40(s0)
80006bf4:	0792                	slli	a5,a5,0x4
80006bf6:	fe842703          	lw	a4,-24(s0)
80006bfa:	02f757b3          	divu	a5,a4,a5
80006bfe:	fef42223          	sw	a5,-28(s0)
    frac_div = (uint32_t)((uart_clk_freq / (16.0f * BaudRate) - int_div) * 64.0f + 0.5f);
80006c02:	fe842783          	lw	a5,-24(s0)
80006c06:	d017f753          	fcvt.s.wu	fa4,a5
80006c0a:	fd842783          	lw	a5,-40(s0)
80006c0e:	d017f6d3          	fcvt.s.wu	fa3,a5
80006c12:	800077b7          	lui	a5,0x80007
80006c16:	1607a787          	flw	fa5,352(a5) # 80007160 <__data_source_start+0xffffffe8>
80006c1a:	10f6f7d3          	fmul.s	fa5,fa3,fa5
80006c1e:	18f77753          	fdiv.s	fa4,fa4,fa5
80006c22:	fe442783          	lw	a5,-28(s0)
80006c26:	d017f7d3          	fcvt.s.wu	fa5,a5
80006c2a:	08f77753          	fsub.s	fa4,fa4,fa5
80006c2e:	800077b7          	lui	a5,0x80007
80006c32:	1647a787          	flw	fa5,356(a5) # 80007164 <__data_source_start+0xffffffec>
80006c36:	10f77753          	fmul.s	fa4,fa4,fa5
80006c3a:	800077b7          	lui	a5,0x80007
80006c3e:	1687a787          	flw	fa5,360(a5) # 80007168 <__data_source_start+0xfffffff0>
80006c42:	00f777d3          	fadd.s	fa5,fa4,fa5
80006c46:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80006c4a:	fef42023          	sw	a5,-32(s0)
    UART_BaudDivConfig(UARTx, int_div, frac_div);
80006c4e:	fe042603          	lw	a2,-32(s0)
80006c52:	fe442583          	lw	a1,-28(s0)
80006c56:	fdc42503          	lw	a0,-36(s0)
80006c5a:	35b5                	jal	80006ac6 <UART_BaudDivConfig>
}
80006c5c:	0001                	nop
80006c5e:	50b2                	lw	ra,44(sp)
80006c60:	5422                	lw	s0,40(sp)
80006c62:	6145                	addi	sp,sp,48
80006c64:	8082                	ret

80006c66 <UART_DeInit>:
  * @brief      UART   
  * @param   UARTx     UART,  x=0|1|2|3
  * @retval  void
  */
void UART_DeInit(UART_TypeDef* UARTx)
{
80006c66:	7179                	addi	sp,sp,-48
80006c68:	d606                	sw	ra,44(sp)
80006c6a:	d422                	sw	s0,40(sp)
80006c6c:	1800                	addi	s0,sp,48
80006c6e:	fca42e23          	sw	a0,-36(s0)
    UART_Num_TypeDef UARTx_Num;

    assert_param(IS_UART_PERIPH(UARTx));

    if (UARTx == UART0) {
80006c72:	fdc42703          	lw	a4,-36(s0)
80006c76:	300067b7          	lui	a5,0x30006
80006c7a:	00f71563          	bne	a4,a5,80006c84 <UART_DeInit+0x1e>
        UARTx_Num = UART0_Num;
80006c7e:	fe042623          	sw	zero,-20(s0)
80006c82:	a805                	j	80006cb2 <UART_DeInit+0x4c>
    } else if (UARTx == UART1) {
80006c84:	fdc42703          	lw	a4,-36(s0)
80006c88:	300077b7          	lui	a5,0x30007
80006c8c:	00f71663          	bne	a4,a5,80006c98 <UART_DeInit+0x32>
        UARTx_Num = UART1_Num;
80006c90:	4785                	li	a5,1
80006c92:	fef42623          	sw	a5,-20(s0)
80006c96:	a831                	j	80006cb2 <UART_DeInit+0x4c>
    } else if (UARTx == UART2) {
80006c98:	fdc42703          	lw	a4,-36(s0)
80006c9c:	300087b7          	lui	a5,0x30008
80006ca0:	00f71663          	bne	a4,a5,80006cac <UART_DeInit+0x46>
        UARTx_Num = UART2_Num;
80006ca4:	4789                	li	a5,2
80006ca6:	fef42623          	sw	a5,-20(s0)
80006caa:	a021                	j	80006cb2 <UART_DeInit+0x4c>
    } else /*if (UARTx == UART3)*/ {
        UARTx_Num = UART3_Num;
80006cac:	478d                	li	a5,3
80006cae:	fef42623          	sw	a5,-20(s0)
    }

    RCU_UARTRstCmd(UARTx_Num, DISABLE);
80006cb2:	4581                	li	a1,0
80006cb4:	fec42503          	lw	a0,-20(s0)
80006cb8:	3b35                	jal	800069f4 <RCU_UARTRstCmd>
    RCU_UARTRstCmd(UARTx_Num, ENABLE);
80006cba:	4585                	li	a1,1
80006cbc:	fec42503          	lw	a0,-20(s0)
80006cc0:	3b15                	jal	800069f4 <RCU_UARTRstCmd>
}
80006cc2:	0001                	nop
80006cc4:	50b2                	lw	ra,44(sp)
80006cc6:	5422                	lw	s0,40(sp)
80006cc8:	6145                	addi	sp,sp,48
80006cca:	8082                	ret

80006ccc <UART_Init>:
  * @param   InitStruct      @ref UART_Init_TypeDef,
  *                         .
  * @retval  Status    
  */
void UART_Init(UART_TypeDef* UARTx, UART_Init_TypeDef* InitStruct)
{
80006ccc:	1101                	addi	sp,sp,-32
80006cce:	ce06                	sw	ra,28(sp)
80006cd0:	cc22                	sw	s0,24(sp)
80006cd2:	1000                	addi	s0,sp,32
80006cd4:	fea42623          	sw	a0,-20(s0)
80006cd8:	feb42423          	sw	a1,-24(s0)
    UART_AutoBaudConfig(UARTx, InitStruct->BaudRate);
80006cdc:	fe842783          	lw	a5,-24(s0)
80006ce0:	47dc                	lw	a5,12(a5)
80006ce2:	85be                	mv	a1,a5
80006ce4:	fec42503          	lw	a0,-20(s0)
80006ce8:	3575                	jal	80006b94 <UART_AutoBaudConfig>
    UART_DataWidthConfig(UARTx, InitStruct->DataWidth);
80006cea:	fe842783          	lw	a5,-24(s0)
80006cee:	479c                	lw	a5,8(a5)
80006cf0:	85be                	mv	a1,a5
80006cf2:	fec42503          	lw	a0,-20(s0)
80006cf6:	3b2d                	jal	80006a30 <UART_DataWidthConfig>
    UART_StopBitConfig(UARTx, InitStruct->StopBit);
80006cf8:	fe842783          	lw	a5,-24(s0)
80006cfc:	439c                	lw	a5,0(a5)
80006cfe:	85be                	mv	a1,a5
80006d00:	fec42503          	lw	a0,-20(s0)
80006d04:	338d                	jal	80006a66 <UART_StopBitConfig>
    UART_ParityBitConfig(UARTx, InitStruct->ParityBit);
80006d06:	fe842783          	lw	a5,-24(s0)
80006d0a:	43dc                	lw	a5,4(a5)
80006d0c:	85be                	mv	a1,a5
80006d0e:	fec42503          	lw	a0,-20(s0)
80006d12:	3361                	jal	80006a9a <UART_ParityBitConfig>
    UART_FIFOCmd(UARTx, InitStruct->FIFO);
80006d14:	fe842783          	lw	a5,-24(s0)
80006d18:	4b9c                	lw	a5,16(a5)
80006d1a:	85be                	mv	a1,a5
80006d1c:	fec42503          	lw	a0,-20(s0)
80006d20:	3bd1                	jal	80006af4 <UART_FIFOCmd>
    UART_TxCmd(UARTx, InitStruct->Tx);
80006d22:	fe842783          	lw	a5,-24(s0)
80006d26:	4f9c                	lw	a5,24(a5)
80006d28:	85be                	mv	a1,a5
80006d2a:	fec42503          	lw	a0,-20(s0)
80006d2e:	3d05                	jal	80006b5e <UART_TxCmd>
    UART_RxCmd(UARTx, InitStruct->Rx);
80006d30:	fe842783          	lw	a5,-24(s0)
80006d34:	4bdc                	lw	a5,20(a5)
80006d36:	85be                	mv	a1,a5
80006d38:	fec42503          	lw	a0,-20(s0)
80006d3c:	33f5                	jal	80006b28 <UART_RxCmd>
}
80006d3e:	0001                	nop
80006d40:	40f2                	lw	ra,28(sp)
80006d42:	4462                	lw	s0,24(sp)
80006d44:	6105                	addi	sp,sp,32
80006d46:	8082                	ret

80006d48 <UART_StructInit>:
  * @param   InitStruct      @ref UART_Init_TypeDef,
  *                        .
  * @retval  void
  */
void UART_StructInit(UART_Init_TypeDef* InitStruct)
{
80006d48:	1101                	addi	sp,sp,-32
80006d4a:	ce22                	sw	s0,28(sp)
80006d4c:	1000                	addi	s0,sp,32
80006d4e:	fea42623          	sw	a0,-20(s0)
    InitStruct->BaudRate = 9600;
80006d52:	fec42783          	lw	a5,-20(s0)
80006d56:	6709                	lui	a4,0x2
80006d58:	58070713          	addi	a4,a4,1408 # 2580 <STACK_SIZE+0x1d80>
80006d5c:	c7d8                	sw	a4,12(a5)
    InitStruct->DataWidth = UART_DataWidth_8;
80006d5e:	fec42783          	lw	a5,-20(s0)
80006d62:	470d                	li	a4,3
80006d64:	c798                	sw	a4,8(a5)
    InitStruct->FIFO = DISABLE;
80006d66:	fec42783          	lw	a5,-20(s0)
80006d6a:	0007a823          	sw	zero,16(a5) # 30008010 <STACK_SIZE+0x30007810>
    InitStruct->ParityBit = UART_ParityBit_Disable;
80006d6e:	fec42783          	lw	a5,-20(s0)
80006d72:	0007a223          	sw	zero,4(a5)
    InitStruct->StopBit = UART_StopBit_1;
80006d76:	fec42783          	lw	a5,-20(s0)
80006d7a:	0007a023          	sw	zero,0(a5)
    InitStruct->Rx = DISABLE;
80006d7e:	fec42783          	lw	a5,-20(s0)
80006d82:	0007aa23          	sw	zero,20(a5)
    InitStruct->Tx = DISABLE;
80006d86:	fec42783          	lw	a5,-20(s0)
80006d8a:	0007ac23          	sw	zero,24(a5)
}
80006d8e:	0001                	nop
80006d90:	4472                	lw	s0,28(sp)
80006d92:	6105                	addi	sp,sp,32
80006d94:	8082                	ret

80006d96 <memcpy>:
80006d96:	832a                	mv	t1,a0
80006d98:	ca09                	beqz	a2,80006daa <memcpy+0x14>
80006d9a:	00058383          	lb	t2,0(a1)
80006d9e:	00730023          	sb	t2,0(t1)
80006da2:	167d                	addi	a2,a2,-1 # 3000ffff <STACK_SIZE+0x3000f7ff>
80006da4:	0305                	addi	t1,t1,1
80006da6:	0585                	addi	a1,a1,1
80006da8:	fa6d                	bnez	a2,80006d9a <memcpy+0x4>
80006daa:	8082                	ret

80006dac <memset>:
80006dac:	832a                	mv	t1,a0
80006dae:	c611                	beqz	a2,80006dba <memset+0xe>
80006db0:	00b30023          	sb	a1,0(t1)
80006db4:	167d                	addi	a2,a2,-1
80006db6:	0305                	addi	t1,t1,1
80006db8:	fe65                	bnez	a2,80006db0 <memset+0x4>
80006dba:	8082                	ret
