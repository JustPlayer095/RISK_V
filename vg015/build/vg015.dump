
build/vg015.elf:     file format elf32-littleriscv


Disassembly of section .text.startup:

80000000 <_start>:
    .section ".startup.entry","ax",@progbits

    ## Entry point
_start:
    ## reset mstatus
    csrw  mstatus, zero
80000000:	30001073          	csrw	mstatus,zero
    ## reset PMURTC->RTC_HISTORY
    lui     s1,0x38011
80000004:	380114b7          	lui	s1,0x38011
    sw      zero,8(s1) 
80000008:	0004a423          	sw	zero,8(s1) # 38011008 <STACK_SIZE+0x38010808>
    init_regs_const 16, 31, 0
#endif // !__riscv_32e
#endif // PLF_INIT_REGS

    ## setup gp
    load_addrword_abs gp, __global_pointer$
8000000c:	400001b7          	lui	gp,0x40000
80000010:	78018193          	addi	gp,gp,1920 # 40000780 <__global_pointer$>
    ## setup MTVEC
    load_addrword_abs t0, trap_entry
80000014:	800002b7          	lui	t0,0x80000
80000018:	1c028293          	addi	t0,t0,448 # 800001c0 <__data_source_start+0xffff679c>
    csrw  mtvec, t0
8000001c:	30529073          	csrw	mtvec,t0
    ## setup MIE, MIP


    csrw  mie, zero
80000020:	30401073          	csrw	mie,zero
    csrw  mip, zero
80000024:	34401073          	csrw	mip,zero
    load_const_int32 t1, __TEXT_INIT_SIZE__
    cache_flush t0, t1
#endif // PLF_CACHE_CFG

    ## init FPU (if supported)
    csrr  a0, misa
80000028:	30102573          	csrr	a0,misa
    andi  a0, a0, (1 << ('F' - 'A')) | (1 << ('D' - 'A'))
8000002c:	02857513          	andi	a0,a0,40
    beqz  a0, 1f
80000030:	00050863          	beqz	a0,80000040 <_start+0x40>
    li    a0, (1 << 13) // mstatus.FS = 1 (initial)
80000034:	00002537          	lui	a0,0x2
    csrs  mstatus, a0
80000038:	30052073          	csrs	mstatus,a0
    csrw  fcsr, zero
8000003c:	00301073          	fscsr	zero
#else
#define slave_hart_start _hart_halt
#endif // PLF_SMP_SUPPORT

    ## park/prep SMP slaves
    csrr  a0, mhartid
80000040:	f1402573          	csrr	a0,mhartid
#if PLF_SMP_MASTER_HARTID > 0
    li    t0, PLF_SMP_MASTER_HARTID
    bne   a0, t0, slave_hart_start
#endif // PLF_SMP_MASTER_HARTID > 0
#else // PLF_SMP_MASTER_HARTID
    bnez  a0, slave_hart_start
80000044:	04051463          	bnez	a0,8000008c <_hart_halt>
#endif // PLF_SMP_MASTER_HARTID

    ## init HART#0 sp, tp
    load_addrword_abs sp, __TLS0_BASE__
80000048:	40040137          	lui	sp,0x40040
8000004c:	00010113          	mv	sp,sp
    mv    tp, sp
80000050:	00010213          	mv	tp,sp
    csrw  mscratch, sp
80000054:	34011073          	csrw	mscratch,sp
    // reserve trap stack space
    li    t0, PLF_TRAP_STACK
    sub   sp, sp, t0
#endif // PLF_TRAP_STACK
    ## platform init
    load_addrword t0, plf_init
80000058:	800002b7          	lui	t0,0x80000
8000005c:	0be28293          	addi	t0,t0,190 # 800000be <__data_source_start+0xffff669a>
    jalr  t0
80000060:	000280e7          	jalr	t0
    ## jal  plf_init
    ## application-specific initialization hook
    load_addrword t0, app_init
80000064:	800002b7          	lui	t0,0x80000
80000068:	0a428293          	addi	t0,t0,164 # 800000a4 <__data_source_start+0xffff6680>
    jalr  t0
8000006c:	000280e7          	jalr	t0
    ## jal  app_init
    ## main() args
    li    a0, 0
80000070:	00000513          	li	a0,0
    li    a1, 0
80000074:	00000593          	li	a1,0
#if PLF_SMP_NON_COHERENT
    clflush t1
#endif // PLF_SMP_NON_COHERENT
#endif // PLF_SMP_SUPPORT
    ## start main
    load_addrword t0, main
80000078:	800022b7          	lui	t0,0x80002
8000007c:	73628293          	addi	t0,t0,1846 # 80002736 <__data_source_start+0xffff8d12>
    load_addrword ra, exit
80000080:	800000b7          	lui	ra,0x80000
80000084:	09c08093          	addi	ra,ra,156 # 8000009c <__data_source_start+0xffff6678>
    jr    t0
80000088:	00028067          	jr	t0

8000008c <_hart_halt>:
1:  wfi
    j     1b
#endif // PLF_SMP_SUPPORT
#else // PLF_HTIF_BASE
    ## disable interrupts
    csrci mstatus, 0xf
8000008c:	3007f073          	csrci	mstatus,15
    csrw  mie, zero
80000090:	30401073          	csrw	mie,zero
1:  wfi
80000094:	10500073          	wfi
    j     1b
80000098:	ffdff06f          	j	80000094 <_hart_halt+0x8>

8000009c <exit>:
#endif // PLF_HTIF_BASE

exit:
    nop
8000009c:	00000013          	nop

800000a0 <abort>:
abort:
    j     _hart_halt
800000a0:	fedff06f          	j	8000008c <_hart_halt>

800000a4 <app_init>:
    jr    t0
#endif // PLF_SMP_SUPPORT

    ## stubs
app_init:
    ret
800000a4:	00008067          	ret
	...

800000b0 <plf_init_noreloc>:
extern void plf_init_relocate(void) __attribute__((weak));

extern char __bss_start[], __bss_end[];

void __init plf_init_noreloc(void)
{
800000b0:	1141                	addi	sp,sp,-16 # 4003fff0 <__STACK_START__+0x7f0>
800000b2:	c622                	sw	s0,12(sp)
800000b4:	0800                	addi	s0,sp,16
    // do nothing
}
800000b6:	0001                	nop
800000b8:	4432                	lw	s0,12(sp)
800000ba:	0141                	addi	sp,sp,16
800000bc:	8082                	ret

800000be <plf_init_generic>:

void __init plf_init_generic(void)
{
800000be:	1101                	addi	sp,sp,-32
800000c0:	ce06                	sw	ra,28(sp)
800000c2:	cc22                	sw	s0,24(sp)
800000c4:	1000                	addi	s0,sp,32
    // init BSS
    memset(__bss_start, 0, (size_t)(__bss_end - __bss_start));
800000c6:	f3418713          	addi	a4,gp,-204 # 400006b4 <__BSS_END__>
800000ca:	e1818793          	addi	a5,gp,-488 # 40000598 <SystemCoreClock>
800000ce:	40f707b3          	sub	a5,a4,a5
800000d2:	863e                	mv	a2,a5
800000d4:	4581                	li	a1,0
800000d6:	e1818513          	addi	a0,gp,-488 # 40000598 <SystemCoreClock>
800000da:	775080ef          	jal	ra,8000904e <memset>

    memcpy((void*)&__data_target_start,
           (const void*)&__data_source_start,
           (&__data_target_end - &__data_target_start));
800000de:	e1818713          	addi	a4,gp,-488 # 40000598 <SystemCoreClock>
800000e2:	89018793          	addi	a5,gp,-1904 # 40000010 <mach_plic_handler>
800000e6:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__data_target_start,
800000ea:	863e                	mv	a2,a5
800000ec:	8000a7b7          	lui	a5,0x8000a
800000f0:	a2478593          	addi	a1,a5,-1500 # 80009a24 <__data_source_start+0x0>
800000f4:	89018513          	addi	a0,gp,-1904 # 40000010 <mach_plic_handler>
800000f8:	741080ef          	jal	ra,80009038 <memcpy>

    memcpy((void*)&__sdata_target_start,
              (const void*)&__sdata_source_start,
              (&__sdata_target_end - &__sdata_target_start));
800000fc:	88c18713          	addi	a4,gp,-1908 # 4000000c <__sdata_target_end>
80000100:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80000104:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__sdata_target_start,
80000108:	863e                	mv	a2,a5
8000010a:	8000a7b7          	lui	a5,0x8000a
8000010e:	a1878593          	addi	a1,a5,-1512 # 80009a18 <__data_source_start+0xfffffff4>
80000112:	88018513          	addi	a0,gp,-1920 # 40000000 <g_btn_last_state>
80000116:	723080ef          	jal	ra,80009038 <memcpy>

    memcpy((void*)&__init_array_target_start,
              (const void*)&__init_array_source_start,
              (&__init_array_target_end - &__init_array_target_start));
8000011a:	88018713          	addi	a4,gp,-1920 # 40000000 <g_btn_last_state>
8000011e:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80000122:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__init_array_target_start,
80000126:	863e                	mv	a2,a5
80000128:	800097b7          	lui	a5,0x80009
8000012c:	41078593          	addi	a1,a5,1040 # 80009410 <__data_source_start+0xfffff9ec>
80000130:	88018513          	addi	a0,gp,-1920 # 40000000 <g_btn_last_state>
80000134:	705080ef          	jal	ra,80009038 <memcpy>

    memcpy((void*)&__fini_array_target_start,
              (const void*)&__fini_array_source_start,
              (&__fini_array_target_end - &__fini_array_target_start));
80000138:	88018713          	addi	a4,gp,-1920 # 40000000 <g_btn_last_state>
8000013c:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80000140:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__fini_array_target_start,
80000144:	863e                	mv	a2,a5
80000146:	800097b7          	lui	a5,0x80009
8000014a:	41078593          	addi	a1,a5,1040 # 80009410 <__data_source_start+0xfffff9ec>
8000014e:	88018513          	addi	a0,gp,-1920 # 40000000 <g_btn_last_state>
80000152:	6e7080ef          	jal	ra,80009038 <memcpy>

    // init functions for cpp
    for (uint32_t i = 0; i < ((uint32_t) (&__init_array_target_end - &__init_array_target_start)) >> 2; i++)
80000156:	fe042623          	sw	zero,-20(s0)
8000015a:	a839                	j	80000178 <plf_init_generic+0xba>
    	((void (*)())((uint32_t*)&__init_array_target_start)[i])();
8000015c:	fec42783          	lw	a5,-20(s0)
80000160:	00279713          	slli	a4,a5,0x2
80000164:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80000168:	97ba                	add	a5,a5,a4
8000016a:	439c                	lw	a5,0(a5)
8000016c:	9782                	jalr	a5
    for (uint32_t i = 0; i < ((uint32_t) (&__init_array_target_end - &__init_array_target_start)) >> 2; i++)
8000016e:	fec42783          	lw	a5,-20(s0)
80000172:	0785                	addi	a5,a5,1
80000174:	fef42623          	sw	a5,-20(s0)
80000178:	88018713          	addi	a4,gp,-1920 # 40000000 <g_btn_last_state>
8000017c:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80000180:	40f707b3          	sub	a5,a4,a5
80000184:	8389                	srli	a5,a5,0x2
80000186:	fec42703          	lw	a4,-20(s0)
8000018a:	fcf769e3          	bltu	a4,a5,8000015c <plf_init_generic+0x9e>
}
8000018e:	0001                	nop
80000190:	0001                	nop
80000192:	40f2                	lw	ra,28(sp)
80000194:	4462                	lw	s0,24(sp)
80000196:	6105                	addi	sp,sp,32
80000198:	8082                	ret
8000019a:	0000                	unimp
8000019c:	0000                	unimp
	...

Disassembly of section .text.crt:

800001c0 <trap_entry>:
    .section ".text.crt.trap_entry","ax",@progbits
    .align 6
    .type trap_entry, @function
trap_entry:
    ## save context
    context_save
800001c0:	fe512e23          	sw	t0,-4(sp)
800001c4:	00010293          	mv	t0,sp
800001c8:	f8010113          	addi	sp,sp,-128
800001cc:	ff017113          	andi	sp,sp,-16
800001d0:	00112223          	sw	ra,4(sp)
800001d4:	00512423          	sw	t0,8(sp)
800001d8:	ffc2a283          	lw	t0,-4(t0)
800001dc:	00312623          	sw	gp,12(sp)
800001e0:	00412823          	sw	tp,16(sp)
800001e4:	00512a23          	sw	t0,20(sp)
800001e8:	00612c23          	sw	t1,24(sp)
800001ec:	00712e23          	sw	t2,28(sp)
800001f0:	02812023          	sw	s0,32(sp)
800001f4:	02912223          	sw	s1,36(sp)
800001f8:	02a12423          	sw	a0,40(sp)
800001fc:	02b12623          	sw	a1,44(sp)
80000200:	02c12823          	sw	a2,48(sp)
80000204:	02d12a23          	sw	a3,52(sp)
80000208:	02e12c23          	sw	a4,56(sp)
8000020c:	02f12e23          	sw	a5,60(sp)
80000210:	05012023          	sw	a6,64(sp)
80000214:	05112223          	sw	a7,68(sp)
80000218:	05212423          	sw	s2,72(sp)
8000021c:	05312623          	sw	s3,76(sp)
80000220:	05412823          	sw	s4,80(sp)
80000224:	05512a23          	sw	s5,84(sp)
80000228:	05612c23          	sw	s6,88(sp)
8000022c:	05712e23          	sw	s7,92(sp)
80000230:	07812023          	sw	s8,96(sp)
80000234:	07912223          	sw	s9,100(sp)
80000238:	07a12423          	sw	s10,104(sp)
8000023c:	07b12623          	sw	s11,108(sp)
80000240:	07c12823          	sw	t3,112(sp)
80000244:	07d12a23          	sw	t4,116(sp)
80000248:	07e12c23          	sw	t5,120(sp)
8000024c:	07f12e23          	sw	t6,124(sp)
80000250:	34002273          	csrr	tp,mscratch
80000254:	34102373          	csrr	t1,mepc
80000258:	00612023          	sw	t1,0(sp)
    ## save mstatus priv stack
    csrr s0, mstatus
8000025c:	30002473          	csrr	s0,mstatus
    ## load trap handler args
    csrr a0, mcause
80000260:	34202573          	csrr	a0,mcause
    csrr a1, mepc
80000264:	341025f3          	csrr	a1,mepc
    mv   a2, sp
80000268:	00010613          	mv	a2,sp

    ## setup gp
    load_addrword_abs gp, __global_pointer$
8000026c:	400001b7          	lui	gp,0x40000
80000270:	78018193          	addi	gp,gp,1920 # 40000780 <__global_pointer$>
    ## call trap handler
    load_addrword t0, trap_handler
80000274:	800012b7          	lui	t0,0x80001
80000278:	9ce28293          	addi	t0,t0,-1586 # 800009ce <__data_source_start+0xffff6faa>
    jalr t0
8000027c:	000280e7          	jalr	t0

    ## restore mstatus priv stack
    csrw mstatus, s0
80000280:	30041073          	csrw	mstatus,s0
    ## restore context
    context_restore
80000284:	00012303          	lw	t1,0(sp)
80000288:	34131073          	csrw	mepc,t1
8000028c:	00c12183          	lw	gp,12(sp)
80000290:	01012203          	lw	tp,16(sp)
80000294:	01412283          	lw	t0,20(sp)
80000298:	01812303          	lw	t1,24(sp)
8000029c:	01c12383          	lw	t2,28(sp)
800002a0:	02012403          	lw	s0,32(sp)
800002a4:	02412483          	lw	s1,36(sp)
800002a8:	02812503          	lw	a0,40(sp)
800002ac:	02c12583          	lw	a1,44(sp)
800002b0:	03012603          	lw	a2,48(sp)
800002b4:	03412683          	lw	a3,52(sp)
800002b8:	03812703          	lw	a4,56(sp)
800002bc:	03c12783          	lw	a5,60(sp)
800002c0:	04012803          	lw	a6,64(sp)
800002c4:	04412883          	lw	a7,68(sp)
800002c8:	04812903          	lw	s2,72(sp)
800002cc:	04c12983          	lw	s3,76(sp)
800002d0:	05012a03          	lw	s4,80(sp)
800002d4:	05412a83          	lw	s5,84(sp)
800002d8:	05812b03          	lw	s6,88(sp)
800002dc:	05c12b83          	lw	s7,92(sp)
800002e0:	06012c03          	lw	s8,96(sp)
800002e4:	06412c83          	lw	s9,100(sp)
800002e8:	06812d03          	lw	s10,104(sp)
800002ec:	06c12d83          	lw	s11,108(sp)
800002f0:	07012e03          	lw	t3,112(sp)
800002f4:	07412e83          	lw	t4,116(sp)
800002f8:	07812f03          	lw	t5,120(sp)
800002fc:	07c12f83          	lw	t6,124(sp)
80000300:	00412083          	lw	ra,4(sp)
80000304:	00812103          	lw	sp,8(sp)
    mret
80000308:	30200073          	mret
	...

Disassembly of section .text:

80000344 <BSP_LED_Init>:
//-- Private variables ---------------------------------------------------------
static volatile uint32_t btn_press_event = 0;

//-- Functions -----------------------------------------------------------------
void BSP_LED_Init()
{
80000344:	1141                	addi	sp,sp,-16
80000346:	c622                	sw	s0,12(sp)
80000348:	0800                	addi	s0,sp,16
	RCU->CGCFGAHB_bit.LED_PORT_EN = 1;
8000034a:	3000e7b7          	lui	a5,0x3000e
8000034e:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80000352:	10076713          	ori	a4,a4,256
80000356:	00e79023          	sh	a4,0(a5)
	RCU->RSTDISAHB_bit.LED_PORT_EN = 1;
8000035a:	3000e7b7          	lui	a5,0x3000e
8000035e:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80000362:	10076713          	ori	a4,a4,256
80000366:	00e79823          	sh	a4,16(a5)
	LED_PORT->OUTENSET = LEDS_MSK;
8000036a:	280007b7          	lui	a5,0x28000
8000036e:	673d                	lui	a4,0xf
80000370:	d7d8                	sw	a4,44(a5)
	LED_PORT->DATAOUTSET = LEDS_MSK;
80000372:	280007b7          	lui	a5,0x28000
80000376:	673d                	lui	a4,0xf
80000378:	c798                	sw	a4,8(a5)
}
8000037a:	0001                	nop
8000037c:	4432                	lw	s0,12(sp)
8000037e:	0141                	addi	sp,sp,16
80000380:	8082                	ret

80000382 <BSP_LED_Toggle>:

void BSP_LED_Toggle(uint32_t leds)
{
80000382:	1101                	addi	sp,sp,-32
80000384:	ce22                	sw	s0,28(sp)
80000386:	1000                	addi	s0,sp,32
80000388:	fea42623          	sw	a0,-20(s0)
	LED_PORT->DATAOUTTGL = leds;
8000038c:	280007b7          	lui	a5,0x28000
80000390:	fec42703          	lw	a4,-20(s0)
80000394:	cb98                	sw	a4,16(a5)
}
80000396:	0001                	nop
80000398:	4472                	lw	s0,28(sp)
8000039a:	6105                	addi	sp,sp,32
8000039c:	8082                	ret

8000039e <BSP_LED_On>:

void BSP_LED_On(uint32_t leds)
{
8000039e:	1101                	addi	sp,sp,-32
800003a0:	ce22                	sw	s0,28(sp)
800003a2:	1000                	addi	s0,sp,32
800003a4:	fea42623          	sw	a0,-20(s0)
	LED_PORT->DATAOUTCLR = leds;
800003a8:	280007b7          	lui	a5,0x28000
800003ac:	fec42703          	lw	a4,-20(s0)
800003b0:	c7d8                	sw	a4,12(a5)
}
800003b2:	0001                	nop
800003b4:	4472                	lw	s0,28(sp)
800003b6:	6105                	addi	sp,sp,32
800003b8:	8082                	ret

800003ba <BSP_LED_Off>:

void BSP_LED_Off(uint32_t leds)
{
800003ba:	1101                	addi	sp,sp,-32
800003bc:	ce22                	sw	s0,28(sp)
800003be:	1000                	addi	s0,sp,32
800003c0:	fea42623          	sw	a0,-20(s0)
	LED_PORT->DATAOUTSET = leds;
800003c4:	280007b7          	lui	a5,0x28000
800003c8:	fec42703          	lw	a4,-20(s0)
800003cc:	c798                	sw	a4,8(a5)
}
800003ce:	0001                	nop
800003d0:	4472                	lw	s0,28(sp)
800003d2:	6105                	addi	sp,sp,32
800003d4:	8082                	ret

800003d6 <BSP_Btn_Init>:

void BSP_Btn_Init()
{
800003d6:	1141                	addi	sp,sp,-16
800003d8:	c606                	sw	ra,12(sp)
800003da:	c422                	sw	s0,8(sp)
800003dc:	0800                	addi	s0,sp,16
	RCU->CGCFGAHB_bit.BTN_PORT_EN = 1;
800003de:	3000e7b7          	lui	a5,0x3000e
800003e2:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
800003e6:	10076713          	ori	a4,a4,256
800003ea:	00e79023          	sh	a4,0(a5)
	RCU->RSTDISAHB_bit.BTN_PORT_EN = 1;
800003ee:	3000e7b7          	lui	a5,0x3000e
800003f2:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
800003f6:	10076713          	ori	a4,a4,256
800003fa:	00e79823          	sh	a4,16(a5)
	BTN_PORT->OUTENCLR = BTN_PIN_MSK;
800003fe:	280007b7          	lui	a5,0x28000
80000402:	6705                	lui	a4,0x1
80000404:	80070713          	addi	a4,a4,-2048 # 800 <STACK_SIZE>
80000408:	db98                	sw	a4,48(a5)
	BTN_PORT->INTTYPESET = BTN_PIN_MSK; // фронт
8000040a:	280007b7          	lui	a5,0x28000
8000040e:	6705                	lui	a4,0x1
80000410:	80070713          	addi	a4,a4,-2048 # 800 <STACK_SIZE>
80000414:	d7b8                	sw	a4,104(a5)
	BTN_PORT->INTPOLSET = BTN_PIN_MSK;  // положительный
80000416:	280007b7          	lui	a5,0x28000
8000041a:	6705                	lui	a4,0x1
8000041c:	80070713          	addi	a4,a4,-2048 # 800 <STACK_SIZE>
80000420:	dbb8                	sw	a4,112(a5)
	BTN_PORT->INTENSET = BTN_PIN_MSK;
80000422:	280007b7          	lui	a5,0x28000
80000426:	6705                	lui	a4,0x1
80000428:	80070713          	addi	a4,a4,-2048 # 800 <STACK_SIZE>
8000042c:	d3b8                	sw	a4,96(a5)
	// Настраиваем обработчик прерывания
	PLIC_SetIrqHandler (Plic_Mach_Target, BTN_IRQ_N, BTN_IRQ_HANDLER);
8000042e:	800007b7          	lui	a5,0x80000
80000432:	47078613          	addi	a2,a5,1136 # 80000470 <__data_source_start+0xffff6a4c>
80000436:	4595                	li	a1,5
80000438:	4501                	li	a0,0
8000043a:	24e1                	jal	80000702 <PLIC_SetIrqHandler>
	PLIC_SetPriority   (BTN_IRQ_N, 0x1);
8000043c:	4585                	li	a1,1
8000043e:	4515                	li	a0,5
80000440:	2639                	jal	8000074e <PLIC_SetPriority>
	PLIC_IntEnable     (Plic_Mach_Target, BTN_IRQ_N);
80000442:	4595                	li	a1,5
80000444:	4501                	li	a0,0
80000446:	2e0d                	jal	80000778 <PLIC_IntEnable>
}
80000448:	0001                	nop
8000044a:	40b2                	lw	ra,12(sp)
8000044c:	4422                	lw	s0,8(sp)
8000044e:	0141                	addi	sp,sp,16
80000450:	8082                	ret

80000452 <BSP_Btn_IsPressed>:

uint32_t BSP_Btn_IsPressed()
{
80000452:	1141                	addi	sp,sp,-16
80000454:	c622                	sw	s0,12(sp)
80000456:	0800                	addi	s0,sp,16
    if (btn_press_event) {
80000458:	e2c1a783          	lw	a5,-468(gp) # 400005ac <btn_press_event>
8000045c:	c789                	beqz	a5,80000466 <BSP_Btn_IsPressed+0x14>
        btn_press_event = 0;
8000045e:	e201a623          	sw	zero,-468(gp) # 400005ac <btn_press_event>
        return 1;
80000462:	4785                	li	a5,1
80000464:	a011                	j	80000468 <BSP_Btn_IsPressed+0x16>
    } else
        return 0;
80000466:	4781                	li	a5,0
}
80000468:	853e                	mv	a0,a5
8000046a:	4432                	lw	s0,12(sp)
8000046c:	0141                	addi	sp,sp,16
8000046e:	8082                	ret

80000470 <BTN_IRQ_HANDLER>:

//-- IRQ handlers --------------------------------------------------------------
void BTN_IRQ_HANDLER()
{
80000470:	1141                	addi	sp,sp,-16
80000472:	c622                	sw	s0,12(sp)
80000474:	0800                	addi	s0,sp,16
	BTN_PORT->INTSTATUS = BTN_PIN_MSK;
80000476:	280007b7          	lui	a5,0x28000
8000047a:	6705                	lui	a4,0x1
8000047c:	80070713          	addi	a4,a4,-2048 # 800 <STACK_SIZE>
80000480:	08e7a023          	sw	a4,128(a5) # 28000080 <STACK_SIZE+0x27fff880>
	btn_press_event = 1;
80000484:	4705                	li	a4,1
80000486:	e2e1a623          	sw	a4,-468(gp) # 400005ac <btn_press_event>
}
8000048a:	0001                	nop
8000048c:	4432                	lw	s0,12(sp)
8000048e:	0141                	addi	sp,sp,16
80000490:	8082                	ret

80000492 <mtimer_set_raw_time_cmp>:
#include "mtimer.h"

void mtimer_set_raw_time_cmp(uint64_t clock_offset) {
80000492:	7179                	addi	sp,sp,-48
80000494:	d606                	sw	ra,44(sp)
80000496:	d422                	sw	s0,40(sp)
80000498:	d24a                	sw	s2,36(sp)
8000049a:	d04e                	sw	s3,32(sp)
8000049c:	1800                	addi	s0,sp,48
8000049e:	fca42c23          	sw	a0,-40(s0)
800004a2:	fcb42e23          	sw	a1,-36(s0)
    // First of all set 
    uint64_t new_mtimecmp = mtimer_get_raw_time() + clock_offset;
800004a6:	20ad                	jal	80000510 <mtimer_get_raw_time>
800004a8:	fd842603          	lw	a2,-40(s0)
800004ac:	fdc42683          	lw	a3,-36(s0)
800004b0:	00a60733          	add	a4,a2,a0
800004b4:	883a                	mv	a6,a4
800004b6:	00c83833          	sltu	a6,a6,a2
800004ba:	00b687b3          	add	a5,a3,a1
800004be:	00f806b3          	add	a3,a6,a5
800004c2:	87b6                	mv	a5,a3
800004c4:	fee42423          	sw	a4,-24(s0)
800004c8:	fef42623          	sw	a5,-20(s0)
    volatile uint32_t *mtimecmpl = (volatile uint32_t *)(RISCV_MTIMECMP_ADDR);
800004cc:	020047b7          	lui	a5,0x2004
800004d0:	fef42223          	sw	a5,-28(s0)
    volatile uint32_t *mtimecmph = (volatile uint32_t *)(RISCV_MTIMECMP_ADDR+4);
800004d4:	020047b7          	lui	a5,0x2004
800004d8:	0791                	addi	a5,a5,4 # 2004004 <STACK_SIZE+0x2003804>
800004da:	fef42023          	sw	a5,-32(s0)
    // AS we are doing 32 bit writes, an intermediate mtimecmp value may cause spurious interrupts.
    // Prevent that by first setting the dummy MSB to an unacheivable value
    *mtimecmpl = 0xFFFFFFFF;  // cppcheck-suppress redundantAssignment
800004de:	fe442783          	lw	a5,-28(s0)
800004e2:	577d                	li	a4,-1
800004e4:	c398                	sw	a4,0(a5)
    // Set the correct MSB
    *mtimecmph = (uint32_t)(new_mtimecmp >> 32); // cppcheck-suppress redundantAssignment
800004e6:	fec42783          	lw	a5,-20(s0)
800004ea:	0007d913          	srli	s2,a5,0x0
800004ee:	4981                	li	s3,0
800004f0:	874a                	mv	a4,s2
800004f2:	fe042783          	lw	a5,-32(s0)
800004f6:	c398                	sw	a4,0(a5)
    // set the LSB
    *mtimecmpl = (uint32_t)(new_mtimecmp & 0x0FFFFFFFFUL);
800004f8:	fe842703          	lw	a4,-24(s0)
800004fc:	fe442783          	lw	a5,-28(s0)
80000500:	c398                	sw	a4,0(a5)
}
80000502:	0001                	nop
80000504:	50b2                	lw	ra,44(sp)
80000506:	5422                	lw	s0,40(sp)
80000508:	5912                	lw	s2,36(sp)
8000050a:	5982                	lw	s3,32(sp)
8000050c:	6145                	addi	sp,sp,48
8000050e:	8082                	ret

80000510 <mtimer_get_raw_time>:
 
/** Read the raw time of the system timer in system timer clocks
 */
uint64_t mtimer_get_raw_time(void) {
80000510:	1101                	addi	sp,sp,-32
80000512:	ce22                	sw	s0,28(sp)
80000514:	1000                	addi	s0,sp,32

    volatile uint32_t * mtimel = (volatile uint32_t *)(RISCV_MTIME_ADDR);
80000516:	0200c337          	lui	t1,0x200c
8000051a:	1361                	addi	t1,t1,-8 # 200bff8 <STACK_SIZE+0x200b7f8>
8000051c:	fe642623          	sw	t1,-20(s0)
    volatile uint32_t * mtimeh = (volatile uint32_t *)(RISCV_MTIME_ADDR+4);
80000520:	0200c337          	lui	t1,0x200c
80000524:	1371                	addi	t1,t1,-4 # 200bffc <STACK_SIZE+0x200b7fc>
80000526:	fe642423          	sw	t1,-24(s0)
    uint32_t mtimeh_val;
    uint32_t mtimel_val;
    do {
        // There is a small risk the mtimeh will tick over after reading mtimel
        mtimeh_val = *mtimeh;
8000052a:	fe842303          	lw	t1,-24(s0)
8000052e:	00032303          	lw	t1,0(t1)
80000532:	fe642223          	sw	t1,-28(s0)
        mtimel_val = *mtimel;
80000536:	fec42303          	lw	t1,-20(s0)
8000053a:	00032303          	lw	t1,0(t1)
8000053e:	fe642023          	sw	t1,-32(s0)
        // Poll mtimeh to ensure it's consistent after reading mtimel
        // The frequency of mtimeh ticking over is low
    } while (mtimeh_val != *mtimeh);
80000542:	fe842303          	lw	t1,-24(s0)
80000546:	00032303          	lw	t1,0(t1)
8000054a:	fe442e03          	lw	t3,-28(s0)
8000054e:	fc6e1ee3          	bne	t3,t1,8000052a <mtimer_get_raw_time+0x1a>
    return (uint64_t) ( ( ((uint64_t)mtimeh_val)<<32) | mtimel_val);
80000552:	fe442303          	lw	t1,-28(s0)
80000556:	881a                	mv	a6,t1
80000558:	4881                	li	a7,0
8000055a:	00081793          	slli	a5,a6,0x0
8000055e:	4701                	li	a4,0
80000560:	fe042803          	lw	a6,-32(s0)
80000564:	8642                	mv	a2,a6
80000566:	4681                	li	a3,0
80000568:	00c76533          	or	a0,a4,a2
8000056c:	00d7e5b3          	or	a1,a5,a3
80000570:	872a                	mv	a4,a0
80000572:	87ae                	mv	a5,a1
} 
80000574:	853a                	mv	a0,a4
80000576:	85be                	mv	a1,a5
80000578:	4472                	lw	s0,28(sp)
8000057a:	6105                	addi	sp,sp,32
8000057c:	8082                	ret

8000057e <sleep>:

/** Delay in ms
 */
void sleep(uint32_t ms)
{
8000057e:	7139                	addi	sp,sp,-64
80000580:	de06                	sw	ra,60(sp)
80000582:	dc22                	sw	s0,56(sp)
80000584:	da4a                	sw	s2,52(sp)
80000586:	d84e                	sw	s3,48(sp)
80000588:	d652                	sw	s4,44(sp)
8000058a:	d456                	sw	s5,40(sp)
8000058c:	d25a                	sw	s6,36(sp)
8000058e:	d05e                	sw	s7,32(sp)
80000590:	0080                	addi	s0,sp,64
80000592:	fca42623          	sw	a0,-52(s0)
uint64_t end_time = mtimer_get_raw_time() + MTIMER_MSEC_TO_CLOCKS(ms);
80000596:	3fad                	jal	80000510 <mtimer_get_raw_time>
80000598:	8a2a                	mv	s4,a0
8000059a:	8aae                	mv	s5,a1
8000059c:	fcc42783          	lw	a5,-52(s0)
800005a0:	893e                	mv	s2,a5
800005a2:	4981                	li	s3,0
800005a4:	02faf7b7          	lui	a5,0x2faf
800005a8:	08078793          	addi	a5,a5,128 # 2faf080 <STACK_SIZE+0x2fae880>
800005ac:	02f98733          	mul	a4,s3,a5
800005b0:	4781                	li	a5,0
800005b2:	02f907b3          	mul	a5,s2,a5
800005b6:	973e                	add	a4,a4,a5
800005b8:	02faf7b7          	lui	a5,0x2faf
800005bc:	08078793          	addi	a5,a5,128 # 2faf080 <STACK_SIZE+0x2fae880>
800005c0:	02f906b3          	mul	a3,s2,a5
800005c4:	02f93bb3          	mulhu	s7,s2,a5
800005c8:	8b36                	mv	s6,a3
800005ca:	017707b3          	add	a5,a4,s7
800005ce:	8bbe                	mv	s7,a5
800005d0:	3e800613          	li	a2,1000
800005d4:	4681                	li	a3,0
800005d6:	855a                	mv	a0,s6
800005d8:	85de                	mv	a1,s7
800005da:	285080ef          	jal	ra,8000905e <__udivdi3>
800005de:	872a                	mv	a4,a0
800005e0:	87ae                	mv	a5,a1
800005e2:	863a                	mv	a2,a4
800005e4:	86be                	mv	a3,a5
800005e6:	00ca0733          	add	a4,s4,a2
800005ea:	85ba                	mv	a1,a4
800005ec:	0145b5b3          	sltu	a1,a1,s4
800005f0:	00da87b3          	add	a5,s5,a3
800005f4:	00f586b3          	add	a3,a1,a5
800005f8:	87b6                	mv	a5,a3
800005fa:	fce42c23          	sw	a4,-40(s0)
800005fe:	fcf42e23          	sw	a5,-36(s0)
while (mtimer_get_raw_time() < end_time);
80000602:	0001                	nop
80000604:	3731                	jal	80000510 <mtimer_get_raw_time>
80000606:	872a                	mv	a4,a0
80000608:	87ae                	mv	a5,a1
8000060a:	fdc42683          	lw	a3,-36(s0)
8000060e:	863e                	mv	a2,a5
80000610:	fed66ae3          	bltu	a2,a3,80000604 <sleep+0x86>
80000614:	fdc42683          	lw	a3,-36(s0)
80000618:	863e                	mv	a2,a5
8000061a:	00c69763          	bne	a3,a2,80000628 <sleep+0xaa>
8000061e:	fd842683          	lw	a3,-40(s0)
80000622:	87ba                	mv	a5,a4
80000624:	fed7e0e3          	bltu	a5,a3,80000604 <sleep+0x86>
}
80000628:	0001                	nop
8000062a:	50f2                	lw	ra,60(sp)
8000062c:	5462                	lw	s0,56(sp)
8000062e:	5952                	lw	s2,52(sp)
80000630:	59c2                	lw	s3,48(sp)
80000632:	5a32                	lw	s4,44(sp)
80000634:	5aa2                	lw	s5,40(sp)
80000636:	5b12                	lw	s6,36(sp)
80000638:	5b82                	lw	s7,32(sp)
8000063a:	6121                	addi	sp,sp,64
8000063c:	8082                	ret

8000063e <usleep>:

/** Delay in us
 */
void usleep(uint32_t us)
{
8000063e:	7139                	addi	sp,sp,-64
80000640:	de06                	sw	ra,60(sp)
80000642:	dc22                	sw	s0,56(sp)
80000644:	da4a                	sw	s2,52(sp)
80000646:	d84e                	sw	s3,48(sp)
80000648:	d652                	sw	s4,44(sp)
8000064a:	d456                	sw	s5,40(sp)
8000064c:	d25a                	sw	s6,36(sp)
8000064e:	d05e                	sw	s7,32(sp)
80000650:	0080                	addi	s0,sp,64
80000652:	fca42623          	sw	a0,-52(s0)
uint64_t end_time = mtimer_get_raw_time() + MTIMER_USEC_TO_CLOCKS(us);
80000656:	3d6d                	jal	80000510 <mtimer_get_raw_time>
80000658:	8a2a                	mv	s4,a0
8000065a:	8aae                	mv	s5,a1
8000065c:	fcc42783          	lw	a5,-52(s0)
80000660:	893e                	mv	s2,a5
80000662:	4981                	li	s3,0
80000664:	02faf7b7          	lui	a5,0x2faf
80000668:	08078793          	addi	a5,a5,128 # 2faf080 <STACK_SIZE+0x2fae880>
8000066c:	02f98733          	mul	a4,s3,a5
80000670:	4781                	li	a5,0
80000672:	02f907b3          	mul	a5,s2,a5
80000676:	973e                	add	a4,a4,a5
80000678:	02faf7b7          	lui	a5,0x2faf
8000067c:	08078793          	addi	a5,a5,128 # 2faf080 <STACK_SIZE+0x2fae880>
80000680:	02f906b3          	mul	a3,s2,a5
80000684:	02f93bb3          	mulhu	s7,s2,a5
80000688:	8b36                	mv	s6,a3
8000068a:	017707b3          	add	a5,a4,s7
8000068e:	8bbe                	mv	s7,a5
80000690:	000f4637          	lui	a2,0xf4
80000694:	24060613          	addi	a2,a2,576 # f4240 <STACK_SIZE+0xf3a40>
80000698:	4681                	li	a3,0
8000069a:	855a                	mv	a0,s6
8000069c:	85de                	mv	a1,s7
8000069e:	1c1080ef          	jal	ra,8000905e <__udivdi3>
800006a2:	872a                	mv	a4,a0
800006a4:	87ae                	mv	a5,a1
800006a6:	863a                	mv	a2,a4
800006a8:	86be                	mv	a3,a5
800006aa:	00ca0733          	add	a4,s4,a2
800006ae:	85ba                	mv	a1,a4
800006b0:	0145b5b3          	sltu	a1,a1,s4
800006b4:	00da87b3          	add	a5,s5,a3
800006b8:	00f586b3          	add	a3,a1,a5
800006bc:	87b6                	mv	a5,a3
800006be:	fce42c23          	sw	a4,-40(s0)
800006c2:	fcf42e23          	sw	a5,-36(s0)
while (mtimer_get_raw_time() < end_time);
800006c6:	0001                	nop
800006c8:	35a1                	jal	80000510 <mtimer_get_raw_time>
800006ca:	872a                	mv	a4,a0
800006cc:	87ae                	mv	a5,a1
800006ce:	fdc42683          	lw	a3,-36(s0)
800006d2:	863e                	mv	a2,a5
800006d4:	fed66ae3          	bltu	a2,a3,800006c8 <usleep+0x8a>
800006d8:	fdc42683          	lw	a3,-36(s0)
800006dc:	863e                	mv	a2,a5
800006de:	00c69763          	bne	a3,a2,800006ec <usleep+0xae>
800006e2:	fd842683          	lw	a3,-40(s0)
800006e6:	87ba                	mv	a5,a4
800006e8:	fed7e0e3          	bltu	a5,a3,800006c8 <usleep+0x8a>
}
800006ec:	0001                	nop
800006ee:	50f2                	lw	ra,60(sp)
800006f0:	5462                	lw	s0,56(sp)
800006f2:	5952                	lw	s2,52(sp)
800006f4:	59c2                	lw	s3,48(sp)
800006f6:	5a32                	lw	s4,44(sp)
800006f8:	5aa2                	lw	s5,40(sp)
800006fa:	5b12                	lw	s6,36(sp)
800006fc:	5b82                	lw	s7,32(sp)
800006fe:	6121                	addi	sp,sp,64
80000700:	8082                	ret

80000702 <PLIC_SetIrqHandler>:
/*
 * Set PLIC handler function for isr num
 */

void PLIC_SetIrqHandler (uint8_t target, uint32_t isr_num, irqfunc* func)
{
80000702:	1101                	addi	sp,sp,-32
80000704:	ce22                	sw	s0,28(sp)
80000706:	1000                	addi	s0,sp,32
80000708:	87aa                	mv	a5,a0
8000070a:	feb42423          	sw	a1,-24(s0)
8000070e:	fec42223          	sw	a2,-28(s0)
80000712:	fef407a3          	sb	a5,-17(s0)
    if(target == Plic_Mach_Target) {
80000716:	fef44783          	lbu	a5,-17(s0)
8000071a:	ef89                	bnez	a5,80000734 <PLIC_SetIrqHandler+0x32>
        mach_plic_handler[isr_num] = func;
8000071c:	400007b7          	lui	a5,0x40000
80000720:	01078713          	addi	a4,a5,16 # 40000010 <mach_plic_handler>
80000724:	fe842783          	lw	a5,-24(s0)
80000728:	078a                	slli	a5,a5,0x2
8000072a:	97ba                	add	a5,a5,a4
8000072c:	fe442703          	lw	a4,-28(s0)
80000730:	c398                	sw	a4,0(a5)
    } else {
        supervisor_plic_handler[isr_num] = func;
    }
}
80000732:	a811                	j	80000746 <PLIC_SetIrqHandler+0x44>
        supervisor_plic_handler[isr_num] = func;
80000734:	91018713          	addi	a4,gp,-1776 # 40000090 <supervisor_plic_handler>
80000738:	fe842783          	lw	a5,-24(s0)
8000073c:	078a                	slli	a5,a5,0x2
8000073e:	97ba                	add	a5,a5,a4
80000740:	fe442703          	lw	a4,-28(s0)
80000744:	c398                	sw	a4,0(a5)
}
80000746:	0001                	nop
80000748:	4472                	lw	s0,28(sp)
8000074a:	6105                	addi	sp,sp,32
8000074c:	8082                	ret

8000074e <PLIC_SetPriority>:
/*
 * Set PLIC irq priority
 */

void PLIC_SetPriority (uint32_t isr_num, uint8_t pri)
{
8000074e:	1101                	addi	sp,sp,-32
80000750:	ce22                	sw	s0,28(sp)
80000752:	1000                	addi	s0,sp,32
80000754:	fea42623          	sw	a0,-20(s0)
80000758:	87ae                	mv	a5,a1
8000075a:	fef405a3          	sb	a5,-21(s0)
    PLIC->PRI[isr_num] = pri;
8000075e:	0c0006b7          	lui	a3,0xc000
80000762:	feb44703          	lbu	a4,-21(s0)
80000766:	fec42783          	lw	a5,-20(s0)
8000076a:	078a                	slli	a5,a5,0x2
8000076c:	97b6                	add	a5,a5,a3
8000076e:	c398                	sw	a4,0(a5)
}
80000770:	0001                	nop
80000772:	4472                	lw	s0,28(sp)
80000774:	6105                	addi	sp,sp,32
80000776:	8082                	ret

80000778 <PLIC_IntEnable>:
/*
 * Enable PLIC irq
 */

void PLIC_IntEnable (uint8_t target, uint32_t isr_num)
{
80000778:	7179                	addi	sp,sp,-48
8000077a:	d622                	sw	s0,44(sp)
8000077c:	1800                	addi	s0,sp,48
8000077e:	87aa                	mv	a5,a0
80000780:	fcb42c23          	sw	a1,-40(s0)
80000784:	fcf40fa3          	sb	a5,-33(s0)
	uint32_t value;

	//read - modify - write operation

    if(target == Plic_Mach_Target) {
80000788:	fdf44783          	lbu	a5,-33(s0)
8000078c:	eb9d                	bnez	a5,800007c2 <PLIC_IntEnable+0x4a>
    	value  = PLIC->MIEM0;
8000078e:	0c000737          	lui	a4,0xc000
80000792:	6789                	lui	a5,0x2
80000794:	97ba                	add	a5,a5,a4
80000796:	439c                	lw	a5,0(a5)
80000798:	fef42623          	sw	a5,-20(s0)
    	value |= (1<<isr_num);
8000079c:	fd842783          	lw	a5,-40(s0)
800007a0:	4705                	li	a4,1
800007a2:	00f717b3          	sll	a5,a4,a5
800007a6:	873e                	mv	a4,a5
800007a8:	fec42783          	lw	a5,-20(s0)
800007ac:	8fd9                	or	a5,a5,a4
800007ae:	fef42623          	sw	a5,-20(s0)
    	PLIC->MIEM0 = value;
800007b2:	0c000737          	lui	a4,0xc000
800007b6:	6789                	lui	a5,0x2
800007b8:	97ba                	add	a5,a5,a4
800007ba:	fec42703          	lw	a4,-20(s0)
800007be:	c398                	sw	a4,0(a5)
    } else {
    	value = PLIC->UIEM0;
    	value |= (1<<isr_num);
    	PLIC->UIEM0 = value;
    }
}
800007c0:	a825                	j	800007f8 <PLIC_IntEnable+0x80>
    	value = PLIC->UIEM0;
800007c2:	0c000737          	lui	a4,0xc000
800007c6:	6789                	lui	a5,0x2
800007c8:	97ba                	add	a5,a5,a4
800007ca:	0807a783          	lw	a5,128(a5) # 2080 <STACK_SIZE+0x1880>
800007ce:	fef42623          	sw	a5,-20(s0)
    	value |= (1<<isr_num);
800007d2:	fd842783          	lw	a5,-40(s0)
800007d6:	4705                	li	a4,1
800007d8:	00f717b3          	sll	a5,a4,a5
800007dc:	873e                	mv	a4,a5
800007de:	fec42783          	lw	a5,-20(s0)
800007e2:	8fd9                	or	a5,a5,a4
800007e4:	fef42623          	sw	a5,-20(s0)
    	PLIC->UIEM0 = value;
800007e8:	0c000737          	lui	a4,0xc000
800007ec:	6789                	lui	a5,0x2
800007ee:	97ba                	add	a5,a5,a4
800007f0:	fec42703          	lw	a4,-20(s0)
800007f4:	08e7a023          	sw	a4,128(a5) # 2080 <STACK_SIZE+0x1880>
}
800007f8:	0001                	nop
800007fa:	5432                	lw	s0,44(sp)
800007fc:	6145                	addi	sp,sp,48
800007fe:	8082                	ret

80000800 <SetIrqHandler>:

void SetIrqHandler(Plic_IsrVect_TypeDef IsrVector, irqfunc* IRQHandler,uint8_t Priority)
{
80000800:	1101                	addi	sp,sp,-32
80000802:	ce06                	sw	ra,28(sp)
80000804:	cc22                	sw	s0,24(sp)
80000806:	1000                	addi	s0,sp,32
80000808:	fea42623          	sw	a0,-20(s0)
8000080c:	feb42423          	sw	a1,-24(s0)
80000810:	87b2                	mv	a5,a2
80000812:	fef403a3          	sb	a5,-25(s0)
	PLIC_SetIrqHandler (Plic_Mach_Target,IsrVector,IRQHandler);
80000816:	fe842603          	lw	a2,-24(s0)
8000081a:	fec42583          	lw	a1,-20(s0)
8000081e:	4501                	li	a0,0
80000820:	35cd                	jal	80000702 <PLIC_SetIrqHandler>
	PLIC_SetPriority   (IsrVector, Priority);
80000822:	fe744783          	lbu	a5,-25(s0)
80000826:	85be                	mv	a1,a5
80000828:	fec42503          	lw	a0,-20(s0)
8000082c:	370d                	jal	8000074e <PLIC_SetPriority>
	PLIC_IntEnable     (Plic_Mach_Target, IsrVector);
8000082e:	fec42583          	lw	a1,-20(s0)
80000832:	4501                	li	a0,0
80000834:	3791                	jal	80000778 <PLIC_IntEnable>
}
80000836:	0001                	nop
80000838:	40f2                	lw	ra,28(sp)
8000083a:	4462                	lw	s0,24(sp)
8000083c:	6105                	addi	sp,sp,32
8000083e:	8082                	ret

80000840 <PLIC_IntDisable>:
/*
 * Disable PLIC irq
 */

void PLIC_IntDisable (uint8_t target, uint32_t isr_num)
{
80000840:	7179                	addi	sp,sp,-48
80000842:	d622                	sw	s0,44(sp)
80000844:	1800                	addi	s0,sp,48
80000846:	87aa                	mv	a5,a0
80000848:	fcb42c23          	sw	a1,-40(s0)
8000084c:	fcf40fa3          	sb	a5,-33(s0)
	uint32_t value;

	//read - modify - write operation

	if(target == Plic_Mach_Target) {
80000850:	fdf44783          	lbu	a5,-33(s0)
80000854:	ef8d                	bnez	a5,8000088e <PLIC_IntDisable+0x4e>
		value  = PLIC->MIEM0;
80000856:	0c000737          	lui	a4,0xc000
8000085a:	6789                	lui	a5,0x2
8000085c:	97ba                	add	a5,a5,a4
8000085e:	439c                	lw	a5,0(a5)
80000860:	fef42623          	sw	a5,-20(s0)
		value &= ~(1<<isr_num);
80000864:	fd842783          	lw	a5,-40(s0)
80000868:	4705                	li	a4,1
8000086a:	00f717b3          	sll	a5,a4,a5
8000086e:	fff7c793          	not	a5,a5
80000872:	873e                	mv	a4,a5
80000874:	fec42783          	lw	a5,-20(s0)
80000878:	8ff9                	and	a5,a5,a4
8000087a:	fef42623          	sw	a5,-20(s0)
		PLIC->MIEM0 = value;
8000087e:	0c000737          	lui	a4,0xc000
80000882:	6789                	lui	a5,0x2
80000884:	97ba                	add	a5,a5,a4
80000886:	fec42703          	lw	a4,-20(s0)
8000088a:	c398                	sw	a4,0(a5)
	} else {
		value  = PLIC->UIEM0;
		value &= ~(1<<isr_num);
		PLIC->UIEM0 = value;
	}
}
8000088c:	a835                	j	800008c8 <PLIC_IntDisable+0x88>
		value  = PLIC->UIEM0;
8000088e:	0c000737          	lui	a4,0xc000
80000892:	6789                	lui	a5,0x2
80000894:	97ba                	add	a5,a5,a4
80000896:	0807a783          	lw	a5,128(a5) # 2080 <STACK_SIZE+0x1880>
8000089a:	fef42623          	sw	a5,-20(s0)
		value &= ~(1<<isr_num);
8000089e:	fd842783          	lw	a5,-40(s0)
800008a2:	4705                	li	a4,1
800008a4:	00f717b3          	sll	a5,a4,a5
800008a8:	fff7c793          	not	a5,a5
800008ac:	873e                	mv	a4,a5
800008ae:	fec42783          	lw	a5,-20(s0)
800008b2:	8ff9                	and	a5,a5,a4
800008b4:	fef42623          	sw	a5,-20(s0)
		PLIC->UIEM0 = value;
800008b8:	0c000737          	lui	a4,0xc000
800008bc:	6789                	lui	a5,0x2
800008be:	97ba                	add	a5,a5,a4
800008c0:	fec42703          	lw	a4,-20(s0)
800008c4:	08e7a023          	sw	a4,128(a5) # 2080 <STACK_SIZE+0x1880>
}
800008c8:	0001                	nop
800008ca:	5432                	lw	s0,44(sp)
800008cc:	6145                	addi	sp,sp,48
800008ce:	8082                	ret

800008d0 <PLIC_ClaimIrq>:
/*
 * Get current isr number
 */

uint32_t PLIC_ClaimIrq (uint8_t target)
{
800008d0:	1101                	addi	sp,sp,-32
800008d2:	ce22                	sw	s0,28(sp)
800008d4:	1000                	addi	s0,sp,32
800008d6:	87aa                	mv	a5,a0
800008d8:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
800008dc:	fef44783          	lbu	a5,-17(s0)
800008e0:	eb81                	bnez	a5,800008f0 <PLIC_ClaimIrq+0x20>
		return (uint32_t)(PLIC->MICC);
800008e2:	0c000737          	lui	a4,0xc000
800008e6:	002007b7          	lui	a5,0x200
800008ea:	97ba                	add	a5,a5,a4
800008ec:	43dc                	lw	a5,4(a5)
800008ee:	a039                	j	800008fc <PLIC_ClaimIrq+0x2c>
	} else {
		return (uint32_t)(PLIC->UICC);
800008f0:	0c000737          	lui	a4,0xc000
800008f4:	002017b7          	lui	a5,0x201
800008f8:	97ba                	add	a5,a5,a4
800008fa:	43dc                	lw	a5,4(a5)
	}
}
800008fc:	853e                	mv	a0,a5
800008fe:	4472                	lw	s0,28(sp)
80000900:	6105                	addi	sp,sp,32
80000902:	8082                	ret

80000904 <PLIC_ClaimComplete>:
/*
 * Set current isr as completed
 */

void PLIC_ClaimComplete (uint8_t target, uint32_t isrnum)
{
80000904:	1101                	addi	sp,sp,-32
80000906:	ce22                	sw	s0,28(sp)
80000908:	1000                	addi	s0,sp,32
8000090a:	87aa                	mv	a5,a0
8000090c:	feb42423          	sw	a1,-24(s0)
80000910:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
80000914:	fef44783          	lbu	a5,-17(s0)
80000918:	eb91                	bnez	a5,8000092c <PLIC_ClaimComplete+0x28>
		PLIC->MICC = isrnum;
8000091a:	0c000737          	lui	a4,0xc000
8000091e:	002007b7          	lui	a5,0x200
80000922:	97ba                	add	a5,a5,a4
80000924:	fe842703          	lw	a4,-24(s0)
80000928:	c3d8                	sw	a4,4(a5)
	} else {
		PLIC->UICC = isrnum;
	}
}
8000092a:	a809                	j	8000093c <PLIC_ClaimComplete+0x38>
		PLIC->UICC = isrnum;
8000092c:	0c000737          	lui	a4,0xc000
80000930:	002017b7          	lui	a5,0x201
80000934:	97ba                	add	a5,a5,a4
80000936:	fe842703          	lw	a4,-24(s0)
8000093a:	c3d8                	sw	a4,4(a5)
}
8000093c:	0001                	nop
8000093e:	4472                	lw	s0,28(sp)
80000940:	6105                	addi	sp,sp,32
80000942:	8082                	ret

80000944 <PLIC_SetThreshold>:

/*
 * Set threshold for irqs
 */

void PLIC_SetThreshold(uint8_t target, uint32_t value) {
80000944:	1101                	addi	sp,sp,-32
80000946:	ce22                	sw	s0,28(sp)
80000948:	1000                	addi	s0,sp,32
8000094a:	87aa                	mv	a5,a0
8000094c:	feb42423          	sw	a1,-24(s0)
80000950:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
80000954:	fef44783          	lbu	a5,-17(s0)
80000958:	eb91                	bnez	a5,8000096c <PLIC_SetThreshold+0x28>
		PLIC->MTHR = value;
8000095a:	0c000737          	lui	a4,0xc000
8000095e:	002007b7          	lui	a5,0x200
80000962:	97ba                	add	a5,a5,a4
80000964:	fe842703          	lw	a4,-24(s0)
80000968:	c398                	sw	a4,0(a5)
	} else {
		PLIC->UTHR = value;
	}
}
8000096a:	a809                	j	8000097c <PLIC_SetThreshold+0x38>
		PLIC->UTHR = value;
8000096c:	0c000737          	lui	a4,0xc000
80000970:	002017b7          	lui	a5,0x201
80000974:	97ba                	add	a5,a5,a4
80000976:	fe842703          	lw	a4,-24(s0)
8000097a:	c398                	sw	a4,0(a5)
}
8000097c:	0001                	nop
8000097e:	4472                	lw	s0,28(sp)
80000980:	6105                	addi	sp,sp,32
80000982:	8082                	ret

80000984 <PLIC_MachHandler>:


void PLIC_MachHandler(void) {
80000984:	1101                	addi	sp,sp,-32
80000986:	ce06                	sw	ra,28(sp)
80000988:	cc22                	sw	s0,24(sp)
8000098a:	1000                	addi	s0,sp,32

	// handle interrupt
	uint32_t isr_num = PLIC_ClaimIrq(Plic_Mach_Target);
8000098c:	4501                	li	a0,0
8000098e:	3789                	jal	800008d0 <PLIC_ClaimIrq>
80000990:	fea42623          	sw	a0,-20(s0)
	// check if handler exist
	if(mach_plic_handler[isr_num] != NULL_IRQ) {
80000994:	400007b7          	lui	a5,0x40000
80000998:	01078713          	addi	a4,a5,16 # 40000010 <mach_plic_handler>
8000099c:	fec42783          	lw	a5,-20(s0)
800009a0:	078a                	slli	a5,a5,0x2
800009a2:	97ba                	add	a5,a5,a4
800009a4:	439c                	lw	a5,0(a5)
800009a6:	cf99                	beqz	a5,800009c4 <PLIC_MachHandler+0x40>
		// call isr handler
		mach_plic_handler[isr_num]();
800009a8:	400007b7          	lui	a5,0x40000
800009ac:	01078713          	addi	a4,a5,16 # 40000010 <mach_plic_handler>
800009b0:	fec42783          	lw	a5,-20(s0)
800009b4:	078a                	slli	a5,a5,0x2
800009b6:	97ba                	add	a5,a5,a4
800009b8:	439c                	lw	a5,0(a5)
800009ba:	9782                	jalr	a5
		// set isr completes
		PLIC_ClaimComplete(Plic_Mach_Target, isr_num);
800009bc:	fec42583          	lw	a1,-20(s0)
800009c0:	4501                	li	a0,0
800009c2:	3789                	jal	80000904 <PLIC_ClaimComplete>
	}
}
800009c4:	0001                	nop
800009c6:	40f2                	lw	ra,28(sp)
800009c8:	4462                	lw	s0,24(sp)
800009ca:	6105                	addi	sp,sp,32
800009cc:	8082                	ret

800009ce <trap_handler>:
#define MCAUSE_EXCEPT_STAMOADDRMISALGN  0x6
#define MCAUSE_EXCEPT_STAMOACCSFAULT    0x7
#define MCAUSE_EXCEPT_ECALLFRM_M_MODE   0xB

void trap_handler (void)
{
800009ce:	7179                	addi	sp,sp,-48
800009d0:	d606                	sw	ra,44(sp)
800009d2:	d422                	sw	s0,40(sp)
800009d4:	1800                	addi	s0,sp,48
	uint32_t mcause_val = read_csr(mcause);
800009d6:	342027f3          	csrr	a5,mcause
800009da:	fef42623          	sw	a5,-20(s0)
800009de:	fec42783          	lw	a5,-20(s0)
800009e2:	fef42423          	sw	a5,-24(s0)
	uint32_t mepc = read_csr(0x341);   // mepc
800009e6:	341027f3          	csrr	a5,mepc
800009ea:	fef42223          	sw	a5,-28(s0)
800009ee:	fe442783          	lw	a5,-28(s0)
800009f2:	fef42023          	sw	a5,-32(s0)

	if((mcause_val & MCAUSE_INTERRUPT_FLAG) == 0) {
800009f6:	fe842783          	lw	a5,-24(s0)
800009fa:	0207ce63          	bltz	a5,80000a36 <trap_handler+0x68>
		// handle exception
		switch (mcause_val & MCAUSE_EXCEPT_MASK)
800009fe:	fe842783          	lw	a5,-24(s0)
80000a02:	8bbd                	andi	a5,a5,15
80000a04:	472d                	li	a4,11
80000a06:	02f76563          	bltu	a4,a5,80000a30 <trap_handler+0x62>
80000a0a:	00279713          	slli	a4,a5,0x2
80000a0e:	800097b7          	lui	a5,0x80009
80000a12:	41078793          	addi	a5,a5,1040 # 80009410 <__data_source_start+0xfffff9ec>
80000a16:	97ba                	add	a5,a5,a4
80000a18:	439c                	lw	a5,0(a5)
80000a1a:	8782                	jr	a5
			case MCAUSE_EXCEPT_STAMOADDRMISALGN:
				break;
			case MCAUSE_EXCEPT_STAMOACCSFAULT:
				break;
			case MCAUSE_EXCEPT_ECALLFRM_M_MODE:
				write_csr(0x341, mepc + 4);    // mepc += 4
80000a1c:	fe042783          	lw	a5,-32(s0)
80000a20:	0791                	addi	a5,a5,4
80000a22:	fcf42e23          	sw	a5,-36(s0)
80000a26:	fdc42783          	lw	a5,-36(s0)
80000a2a:	34179073          	csrw	mepc,a5
				break;
80000a2e:	a011                	j	80000a32 <trap_handler+0x64>

			default: // MCAUSE_EXCEPT UNKNOWN

				break;
80000a30:	0001                	nop
		}

		while(1) {}; //TRAP
80000a32:	0001                	nop
80000a34:	bffd                	j	80000a32 <trap_handler+0x64>
	} else {
		// handle interrupt
		PLIC_MachHandler();
80000a36:	37b9                	jal	80000984 <PLIC_MachHandler>
	}
}
80000a38:	0001                	nop
80000a3a:	50b2                	lw	ra,44(sp)
80000a3c:	5422                	lw	s0,40(sp)
80000a3e:	6145                	addi	sp,sp,48
80000a40:	8082                	ret

80000a42 <PrintChar>:
 *
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
void PrintChar(char c)
{
80000a42:	1101                	addi	sp,sp,-32
80000a44:	ce06                	sw	ra,28(sp)
80000a46:	cc22                	sw	s0,24(sp)
80000a48:	1000                	addi	s0,sp,32
80000a4a:	87aa                	mv	a5,a0
80000a4c:	fef407a3          	sb	a5,-17(s0)
	retarget_put_char(c);
80000a50:	fef44783          	lbu	a5,-17(s0)
80000a54:	853e                	mv	a0,a5
80000a56:	349000ef          	jal	ra,8000159e <retarget_put_char>
}
80000a5a:	0001                	nop
80000a5c:	40f2                	lw	ra,28(sp)
80000a5e:	4462                	lw	s0,24(sp)
80000a60:	6105                	addi	sp,sp,32
80000a62:	8082                	ret

80000a64 <PutChar>:
 *
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
signed int PutChar(char *pStr, char c)
{
80000a64:	1101                	addi	sp,sp,-32
80000a66:	ce22                	sw	s0,28(sp)
80000a68:	1000                	addi	s0,sp,32
80000a6a:	fea42623          	sw	a0,-20(s0)
80000a6e:	87ae                	mv	a5,a1
80000a70:	fef405a3          	sb	a5,-21(s0)
    *pStr = c;
80000a74:	fec42783          	lw	a5,-20(s0)
80000a78:	feb44703          	lbu	a4,-21(s0)
80000a7c:	00e78023          	sb	a4,0(a5)
    return 1;
80000a80:	4785                	li	a5,1
}
80000a82:	853e                	mv	a0,a5
80000a84:	4472                	lw	s0,28(sp)
80000a86:	6105                	addi	sp,sp,32
80000a88:	8082                	ret

80000a8a <PutString>:
 * @param  pStr     Storage string.
 * @param  pSource  Source string.
 * @return  The size of the written
 */
signed int PutString(char *pStr, const char *pSource)
{
80000a8a:	7179                	addi	sp,sp,-48
80000a8c:	d622                	sw	s0,44(sp)
80000a8e:	1800                	addi	s0,sp,48
80000a90:	fca42e23          	sw	a0,-36(s0)
80000a94:	fcb42c23          	sw	a1,-40(s0)
    signed int num = 0;
80000a98:	fe042623          	sw	zero,-20(s0)

    while (*pSource != 0) {
80000a9c:	a035                	j	80000ac8 <PutString+0x3e>

        *pStr++ = *pSource++;
80000a9e:	fd842703          	lw	a4,-40(s0)
80000aa2:	00170793          	addi	a5,a4,1 # c000001 <STACK_SIZE+0xbfff801>
80000aa6:	fcf42c23          	sw	a5,-40(s0)
80000aaa:	fdc42783          	lw	a5,-36(s0)
80000aae:	00178693          	addi	a3,a5,1
80000ab2:	fcd42e23          	sw	a3,-36(s0)
80000ab6:	00074703          	lbu	a4,0(a4)
80000aba:	00e78023          	sb	a4,0(a5)
        num++;
80000abe:	fec42783          	lw	a5,-20(s0)
80000ac2:	0785                	addi	a5,a5,1
80000ac4:	fef42623          	sw	a5,-20(s0)
    while (*pSource != 0) {
80000ac8:	fd842783          	lw	a5,-40(s0)
80000acc:	0007c783          	lbu	a5,0(a5)
80000ad0:	f7f9                	bnez	a5,80000a9e <PutString+0x14>
    }

    return num;
80000ad2:	fec42783          	lw	a5,-20(s0)
}
80000ad6:	853e                	mv	a0,a5
80000ad8:	5432                	lw	s0,44(sp)
80000ada:	6145                	addi	sp,sp,48
80000adc:	8082                	ret

80000ade <PutUnsignedInt>:
signed int PutUnsignedInt(
    char *pStr,
    char fill,
    signed int width,
    unsigned int value)
{
80000ade:	7179                	addi	sp,sp,-48
80000ae0:	d606                	sw	ra,44(sp)
80000ae2:	d422                	sw	s0,40(sp)
80000ae4:	1800                	addi	s0,sp,48
80000ae6:	fca42e23          	sw	a0,-36(s0)
80000aea:	87ae                	mv	a5,a1
80000aec:	fcc42a23          	sw	a2,-44(s0)
80000af0:	fcd42823          	sw	a3,-48(s0)
80000af4:	fcf40da3          	sb	a5,-37(s0)
    signed int num = 0;
80000af8:	fe042623          	sw	zero,-20(s0)

    /* Take current digit into account when calculating width */
    width--;
80000afc:	fd442783          	lw	a5,-44(s0)
80000b00:	17fd                	addi	a5,a5,-1
80000b02:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively write upper digits */
    if ((value / 10) > 0) {
80000b06:	fd042703          	lw	a4,-48(s0)
80000b0a:	47a5                	li	a5,9
80000b0c:	04e7ff63          	bgeu	a5,a4,80000b6a <PutUnsignedInt+0x8c>

        num = PutUnsignedInt(pStr, fill, width, value / 10);
80000b10:	fd042703          	lw	a4,-48(s0)
80000b14:	47a9                	li	a5,10
80000b16:	02f75733          	divu	a4,a4,a5
80000b1a:	fdb44783          	lbu	a5,-37(s0)
80000b1e:	86ba                	mv	a3,a4
80000b20:	fd442603          	lw	a2,-44(s0)
80000b24:	85be                	mv	a1,a5
80000b26:	fdc42503          	lw	a0,-36(s0)
80000b2a:	3f55                	jal	80000ade <PutUnsignedInt>
80000b2c:	fea42623          	sw	a0,-20(s0)
        pStr += num;
80000b30:	fec42783          	lw	a5,-20(s0)
80000b34:	fdc42703          	lw	a4,-36(s0)
80000b38:	97ba                	add	a5,a5,a4
80000b3a:	fcf42e23          	sw	a5,-36(s0)
80000b3e:	a815                	j	80000b72 <PutUnsignedInt+0x94>
    /* Write filler characters */
    else {

        while (width > 0) {

            PutChar(pStr, fill);
80000b40:	fdb44783          	lbu	a5,-37(s0)
80000b44:	85be                	mv	a1,a5
80000b46:	fdc42503          	lw	a0,-36(s0)
80000b4a:	3f29                	jal	80000a64 <PutChar>
            pStr++;
80000b4c:	fdc42783          	lw	a5,-36(s0)
80000b50:	0785                	addi	a5,a5,1
80000b52:	fcf42e23          	sw	a5,-36(s0)
            num++;
80000b56:	fec42783          	lw	a5,-20(s0)
80000b5a:	0785                	addi	a5,a5,1
80000b5c:	fef42623          	sw	a5,-20(s0)
            width--;
80000b60:	fd442783          	lw	a5,-44(s0)
80000b64:	17fd                	addi	a5,a5,-1
80000b66:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
80000b6a:	fd442783          	lw	a5,-44(s0)
80000b6e:	fcf049e3          	bgtz	a5,80000b40 <PutUnsignedInt+0x62>
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (value % 10) + '0');
80000b72:	fd042703          	lw	a4,-48(s0)
80000b76:	47a9                	li	a5,10
80000b78:	02f777b3          	remu	a5,a4,a5
80000b7c:	0ff7f793          	zext.b	a5,a5
80000b80:	03078793          	addi	a5,a5,48
80000b84:	0ff7f793          	zext.b	a5,a5
80000b88:	85be                	mv	a1,a5
80000b8a:	fdc42503          	lw	a0,-36(s0)
80000b8e:	3dd9                	jal	80000a64 <PutChar>
80000b90:	872a                	mv	a4,a0
80000b92:	fec42783          	lw	a5,-20(s0)
80000b96:	97ba                	add	a5,a5,a4
80000b98:	fef42623          	sw	a5,-20(s0)

    return num;
80000b9c:	fec42783          	lw	a5,-20(s0)
}
80000ba0:	853e                	mv	a0,a5
80000ba2:	50b2                	lw	ra,44(sp)
80000ba4:	5422                	lw	s0,40(sp)
80000ba6:	6145                	addi	sp,sp,48
80000ba8:	8082                	ret

80000baa <PutSignedInt>:
signed int PutSignedInt(
    char *pStr,
    char fill,
    signed int width,
    signed int value)
{
80000baa:	7179                	addi	sp,sp,-48
80000bac:	d606                	sw	ra,44(sp)
80000bae:	d422                	sw	s0,40(sp)
80000bb0:	1800                	addi	s0,sp,48
80000bb2:	fca42e23          	sw	a0,-36(s0)
80000bb6:	87ae                	mv	a5,a1
80000bb8:	fcc42a23          	sw	a2,-44(s0)
80000bbc:	fcd42823          	sw	a3,-48(s0)
80000bc0:	fcf40da3          	sb	a5,-37(s0)
    signed int num = 0;
80000bc4:	fe042623          	sw	zero,-20(s0)
    unsigned int absolute;

    /* Compute absolute value */
    if (value < 0) {
80000bc8:	fd042783          	lw	a5,-48(s0)
80000bcc:	0007d963          	bgez	a5,80000bde <PutSignedInt+0x34>

        absolute = -value;
80000bd0:	fd042783          	lw	a5,-48(s0)
80000bd4:	40f007b3          	neg	a5,a5
80000bd8:	fef42423          	sw	a5,-24(s0)
80000bdc:	a029                	j	80000be6 <PutSignedInt+0x3c>
    }
    else {

        absolute = value;
80000bde:	fd042783          	lw	a5,-48(s0)
80000be2:	fef42423          	sw	a5,-24(s0)
    }

    /* Take current digit into account when calculating width */
    width--;
80000be6:	fd442783          	lw	a5,-44(s0)
80000bea:	17fd                	addi	a5,a5,-1
80000bec:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively write upper digits */
    if ((absolute / 10) > 0) {
80000bf0:	fe842703          	lw	a4,-24(s0)
80000bf4:	47a5                	li	a5,9
80000bf6:	06e7f363          	bgeu	a5,a4,80000c5c <PutSignedInt+0xb2>

        if (value < 0) {
80000bfa:	fd042783          	lw	a5,-48(s0)
80000bfe:	0207d663          	bgez	a5,80000c2a <PutSignedInt+0x80>

            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
80000c02:	fe842703          	lw	a4,-24(s0)
80000c06:	47a9                	li	a5,10
80000c08:	02f757b3          	divu	a5,a4,a5
80000c0c:	40f007b3          	neg	a5,a5
80000c10:	873e                	mv	a4,a5
80000c12:	fdb44783          	lbu	a5,-37(s0)
80000c16:	86ba                	mv	a3,a4
80000c18:	fd442603          	lw	a2,-44(s0)
80000c1c:	85be                	mv	a1,a5
80000c1e:	fdc42503          	lw	a0,-36(s0)
80000c22:	3761                	jal	80000baa <PutSignedInt>
80000c24:	fea42623          	sw	a0,-20(s0)
80000c28:	a015                	j	80000c4c <PutSignedInt+0xa2>
        }
        else {

            num = PutSignedInt(pStr, fill, width, absolute / 10);
80000c2a:	fe842703          	lw	a4,-24(s0)
80000c2e:	47a9                	li	a5,10
80000c30:	02f757b3          	divu	a5,a4,a5
80000c34:	873e                	mv	a4,a5
80000c36:	fdb44783          	lbu	a5,-37(s0)
80000c3a:	86ba                	mv	a3,a4
80000c3c:	fd442603          	lw	a2,-44(s0)
80000c40:	85be                	mv	a1,a5
80000c42:	fdc42503          	lw	a0,-36(s0)
80000c46:	3795                	jal	80000baa <PutSignedInt>
80000c48:	fea42623          	sw	a0,-20(s0)
        }
        pStr += num;
80000c4c:	fec42783          	lw	a5,-20(s0)
80000c50:	fdc42703          	lw	a4,-36(s0)
80000c54:	97ba                	add	a5,a5,a4
80000c56:	fcf42e23          	sw	a5,-36(s0)
80000c5a:	a885                	j	80000cca <PutSignedInt+0x120>
    }
    else {

        /* Reserve space for sign */
        if (value < 0) {
80000c5c:	fd042783          	lw	a5,-48(s0)
80000c60:	0207dd63          	bgez	a5,80000c9a <PutSignedInt+0xf0>

            width--;
80000c64:	fd442783          	lw	a5,-44(s0)
80000c68:	17fd                	addi	a5,a5,-1
80000c6a:	fcf42a23          	sw	a5,-44(s0)
        }

        /* Write filler characters */
        while (width > 0) {
80000c6e:	a035                	j	80000c9a <PutSignedInt+0xf0>

            PutChar(pStr, fill);
80000c70:	fdb44783          	lbu	a5,-37(s0)
80000c74:	85be                	mv	a1,a5
80000c76:	fdc42503          	lw	a0,-36(s0)
80000c7a:	33ed                	jal	80000a64 <PutChar>
            pStr++;
80000c7c:	fdc42783          	lw	a5,-36(s0)
80000c80:	0785                	addi	a5,a5,1
80000c82:	fcf42e23          	sw	a5,-36(s0)
            num++;
80000c86:	fec42783          	lw	a5,-20(s0)
80000c8a:	0785                	addi	a5,a5,1
80000c8c:	fef42623          	sw	a5,-20(s0)
            width--;
80000c90:	fd442783          	lw	a5,-44(s0)
80000c94:	17fd                	addi	a5,a5,-1
80000c96:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
80000c9a:	fd442783          	lw	a5,-44(s0)
80000c9e:	fcf049e3          	bgtz	a5,80000c70 <PutSignedInt+0xc6>
        }

        /* Write sign */
        if (value < 0) {
80000ca2:	fd042783          	lw	a5,-48(s0)
80000ca6:	0207d263          	bgez	a5,80000cca <PutSignedInt+0x120>

            num += PutChar(pStr, '-');
80000caa:	02d00593          	li	a1,45
80000cae:	fdc42503          	lw	a0,-36(s0)
80000cb2:	3b4d                	jal	80000a64 <PutChar>
80000cb4:	872a                	mv	a4,a0
80000cb6:	fec42783          	lw	a5,-20(s0)
80000cba:	97ba                	add	a5,a5,a4
80000cbc:	fef42623          	sw	a5,-20(s0)
            pStr++;
80000cc0:	fdc42783          	lw	a5,-36(s0)
80000cc4:	0785                	addi	a5,a5,1
80000cc6:	fcf42e23          	sw	a5,-36(s0)
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (absolute % 10) + '0');
80000cca:	fe842703          	lw	a4,-24(s0)
80000cce:	47a9                	li	a5,10
80000cd0:	02f777b3          	remu	a5,a4,a5
80000cd4:	0ff7f793          	zext.b	a5,a5
80000cd8:	03078793          	addi	a5,a5,48
80000cdc:	0ff7f793          	zext.b	a5,a5
80000ce0:	85be                	mv	a1,a5
80000ce2:	fdc42503          	lw	a0,-36(s0)
80000ce6:	3bbd                	jal	80000a64 <PutChar>
80000ce8:	872a                	mv	a4,a0
80000cea:	fec42783          	lw	a5,-20(s0)
80000cee:	97ba                	add	a5,a5,a4
80000cf0:	fef42623          	sw	a5,-20(s0)

    return num;
80000cf4:	fec42783          	lw	a5,-20(s0)
}
80000cf8:	853e                	mv	a0,a5
80000cfa:	50b2                	lw	ra,44(sp)
80000cfc:	5422                	lw	s0,40(sp)
80000cfe:	6145                	addi	sp,sp,48
80000d00:	8082                	ret

80000d02 <PutHexa>:
    char *pStr,
    char fill,
    signed int width,
    unsigned char maj,
    unsigned int value)
{
80000d02:	7179                	addi	sp,sp,-48
80000d04:	d606                	sw	ra,44(sp)
80000d06:	d422                	sw	s0,40(sp)
80000d08:	1800                	addi	s0,sp,48
80000d0a:	fca42e23          	sw	a0,-36(s0)
80000d0e:	87ae                	mv	a5,a1
80000d10:	fcc42a23          	sw	a2,-44(s0)
80000d14:	fce42823          	sw	a4,-48(s0)
80000d18:	fcf40da3          	sb	a5,-37(s0)
80000d1c:	87b6                	mv	a5,a3
80000d1e:	fcf40d23          	sb	a5,-38(s0)
    signed int num = 0;
80000d22:	fe042623          	sw	zero,-20(s0)

    /* Decrement width */
    width--;
80000d26:	fd442783          	lw	a5,-44(s0)
80000d2a:	17fd                	addi	a5,a5,-1
80000d2c:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively output upper digits */
    if ((value >> 4) > 0) {
80000d30:	fd042783          	lw	a5,-48(s0)
80000d34:	8391                	srli	a5,a5,0x4
80000d36:	c3b5                	beqz	a5,80000d9a <PutHexa+0x98>

        num += PutHexa(pStr, fill, width, maj, value >> 4);
80000d38:	fd042783          	lw	a5,-48(s0)
80000d3c:	0047d713          	srli	a4,a5,0x4
80000d40:	fda44683          	lbu	a3,-38(s0)
80000d44:	fdb44783          	lbu	a5,-37(s0)
80000d48:	fd442603          	lw	a2,-44(s0)
80000d4c:	85be                	mv	a1,a5
80000d4e:	fdc42503          	lw	a0,-36(s0)
80000d52:	3f45                	jal	80000d02 <PutHexa>
80000d54:	872a                	mv	a4,a0
80000d56:	fec42783          	lw	a5,-20(s0)
80000d5a:	97ba                	add	a5,a5,a4
80000d5c:	fef42623          	sw	a5,-20(s0)
        pStr += num;
80000d60:	fec42783          	lw	a5,-20(s0)
80000d64:	fdc42703          	lw	a4,-36(s0)
80000d68:	97ba                	add	a5,a5,a4
80000d6a:	fcf42e23          	sw	a5,-36(s0)
80000d6e:	a815                	j	80000da2 <PutHexa+0xa0>
    /* Write filler chars */
    else {

        while (width > 0) {

            PutChar(pStr, fill);
80000d70:	fdb44783          	lbu	a5,-37(s0)
80000d74:	85be                	mv	a1,a5
80000d76:	fdc42503          	lw	a0,-36(s0)
80000d7a:	31ed                	jal	80000a64 <PutChar>
            pStr++;
80000d7c:	fdc42783          	lw	a5,-36(s0)
80000d80:	0785                	addi	a5,a5,1
80000d82:	fcf42e23          	sw	a5,-36(s0)
            num++;
80000d86:	fec42783          	lw	a5,-20(s0)
80000d8a:	0785                	addi	a5,a5,1
80000d8c:	fef42623          	sw	a5,-20(s0)
            width--;
80000d90:	fd442783          	lw	a5,-44(s0)
80000d94:	17fd                	addi	a5,a5,-1
80000d96:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
80000d9a:	fd442783          	lw	a5,-44(s0)
80000d9e:	fcf049e3          	bgtz	a5,80000d70 <PutHexa+0x6e>
        }
    }

    /* Write current digit */
    if ((value & 0xF) < 10) {
80000da2:	fd042783          	lw	a5,-48(s0)
80000da6:	00f7f713          	andi	a4,a5,15
80000daa:	47a5                	li	a5,9
80000dac:	02e7e263          	bltu	a5,a4,80000dd0 <PutHexa+0xce>

        PutChar(pStr, (value & 0xF) + '0');
80000db0:	fd042783          	lw	a5,-48(s0)
80000db4:	0ff7f793          	zext.b	a5,a5
80000db8:	8bbd                	andi	a5,a5,15
80000dba:	0ff7f793          	zext.b	a5,a5
80000dbe:	03078793          	addi	a5,a5,48
80000dc2:	0ff7f793          	zext.b	a5,a5
80000dc6:	85be                	mv	a1,a5
80000dc8:	fdc42503          	lw	a0,-36(s0)
80000dcc:	3961                	jal	80000a64 <PutChar>
80000dce:	a099                	j	80000e14 <PutHexa+0x112>
    }
    else if (maj) {
80000dd0:	fda44783          	lbu	a5,-38(s0)
80000dd4:	c38d                	beqz	a5,80000df6 <PutHexa+0xf4>

        PutChar(pStr, (value & 0xF) - 10 + 'A');
80000dd6:	fd042783          	lw	a5,-48(s0)
80000dda:	0ff7f793          	zext.b	a5,a5
80000dde:	8bbd                	andi	a5,a5,15
80000de0:	0ff7f793          	zext.b	a5,a5
80000de4:	03778793          	addi	a5,a5,55
80000de8:	0ff7f793          	zext.b	a5,a5
80000dec:	85be                	mv	a1,a5
80000dee:	fdc42503          	lw	a0,-36(s0)
80000df2:	398d                	jal	80000a64 <PutChar>
80000df4:	a005                	j	80000e14 <PutHexa+0x112>
    }
    else {

        PutChar(pStr, (value & 0xF) - 10 + 'a');
80000df6:	fd042783          	lw	a5,-48(s0)
80000dfa:	0ff7f793          	zext.b	a5,a5
80000dfe:	8bbd                	andi	a5,a5,15
80000e00:	0ff7f793          	zext.b	a5,a5
80000e04:	05778793          	addi	a5,a5,87
80000e08:	0ff7f793          	zext.b	a5,a5
80000e0c:	85be                	mv	a1,a5
80000e0e:	fdc42503          	lw	a0,-36(s0)
80000e12:	3989                	jal	80000a64 <PutChar>
    }
    num++;
80000e14:	fec42783          	lw	a5,-20(s0)
80000e18:	0785                	addi	a5,a5,1
80000e1a:	fef42623          	sw	a5,-20(s0)

    return num;
80000e1e:	fec42783          	lw	a5,-20(s0)
}
80000e22:	853e                	mv	a0,a5
80000e24:	50b2                	lw	ra,44(sp)
80000e26:	5422                	lw	s0,40(sp)
80000e28:	6145                	addi	sp,sp,48
80000e2a:	8082                	ret

80000e2c <vsnprintf>:
 * @param ap      Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsnprintf(char *pStr, size_t length, const char *pFormat, va_list ap)
{
80000e2c:	7179                	addi	sp,sp,-48
80000e2e:	d606                	sw	ra,44(sp)
80000e30:	d422                	sw	s0,40(sp)
80000e32:	1800                	addi	s0,sp,48
80000e34:	fca42e23          	sw	a0,-36(s0)
80000e38:	fcb42c23          	sw	a1,-40(s0)
80000e3c:	fcc42a23          	sw	a2,-44(s0)
80000e40:	fcd42823          	sw	a3,-48(s0)
    char          fill;
    unsigned char width;
    signed int    num = 0;
80000e44:	fe042423          	sw	zero,-24(s0)
    signed int    size = 0;
80000e48:	fe042223          	sw	zero,-28(s0)

    /* Clear the string */
    if (pStr) {
80000e4c:	fdc42783          	lw	a5,-36(s0)
80000e50:	26078163          	beqz	a5,800010b2 <vsnprintf+0x286>

        *pStr = 0;
80000e54:	fdc42783          	lw	a5,-36(s0)
80000e58:	00078023          	sb	zero,0(a5)
    }

    /* Phase string */
    while (*pFormat != 0 && size < length) {
80000e5c:	ac99                	j	800010b2 <vsnprintf+0x286>

        /* Normal character */
        if (*pFormat != '%') {
80000e5e:	fd442783          	lw	a5,-44(s0)
80000e62:	0007c703          	lbu	a4,0(a5)
80000e66:	02500793          	li	a5,37
80000e6a:	02f70863          	beq	a4,a5,80000e9a <vsnprintf+0x6e>

            *pStr++ = *pFormat++;
80000e6e:	fd442703          	lw	a4,-44(s0)
80000e72:	00170793          	addi	a5,a4,1
80000e76:	fcf42a23          	sw	a5,-44(s0)
80000e7a:	fdc42783          	lw	a5,-36(s0)
80000e7e:	00178693          	addi	a3,a5,1
80000e82:	fcd42e23          	sw	a3,-36(s0)
80000e86:	00074703          	lbu	a4,0(a4)
80000e8a:	00e78023          	sb	a4,0(a5)
            size++;
80000e8e:	fe442783          	lw	a5,-28(s0)
80000e92:	0785                	addi	a5,a5,1
80000e94:	fef42223          	sw	a5,-28(s0)
80000e98:	ac29                	j	800010b2 <vsnprintf+0x286>
        }
        /* Escaped '%' */
        else if (*(pFormat+1) == '%') {
80000e9a:	fd442783          	lw	a5,-44(s0)
80000e9e:	0785                	addi	a5,a5,1
80000ea0:	0007c703          	lbu	a4,0(a5)
80000ea4:	02500793          	li	a5,37
80000ea8:	02f71763          	bne	a4,a5,80000ed6 <vsnprintf+0xaa>

            *pStr++ = '%';
80000eac:	fdc42783          	lw	a5,-36(s0)
80000eb0:	00178713          	addi	a4,a5,1
80000eb4:	fce42e23          	sw	a4,-36(s0)
80000eb8:	02500713          	li	a4,37
80000ebc:	00e78023          	sb	a4,0(a5)
            pFormat += 2;
80000ec0:	fd442783          	lw	a5,-44(s0)
80000ec4:	0789                	addi	a5,a5,2
80000ec6:	fcf42a23          	sw	a5,-44(s0)
            size++;
80000eca:	fe442783          	lw	a5,-28(s0)
80000ece:	0785                	addi	a5,a5,1
80000ed0:	fef42223          	sw	a5,-28(s0)
80000ed4:	aaf9                	j	800010b2 <vsnprintf+0x286>
        }
        /* Token delimiter */
        else {

            fill = ' ';
80000ed6:	02000793          	li	a5,32
80000eda:	fef407a3          	sb	a5,-17(s0)
            width = 0;
80000ede:	fe040723          	sb	zero,-18(s0)
            pFormat++;
80000ee2:	fd442783          	lw	a5,-44(s0)
80000ee6:	0785                	addi	a5,a5,1
80000ee8:	fcf42a23          	sw	a5,-44(s0)

            /* Parse filler */
            if (*pFormat == '0') {
80000eec:	fd442783          	lw	a5,-44(s0)
80000ef0:	0007c703          	lbu	a4,0(a5)
80000ef4:	03000793          	li	a5,48
80000ef8:	04f71563          	bne	a4,a5,80000f42 <vsnprintf+0x116>

                fill = '0';
80000efc:	03000793          	li	a5,48
80000f00:	fef407a3          	sb	a5,-17(s0)
                pFormat++;
80000f04:	fd442783          	lw	a5,-44(s0)
80000f08:	0785                	addi	a5,a5,1
80000f0a:	fcf42a23          	sw	a5,-44(s0)
            }

            /* Parse width */
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
80000f0e:	a815                	j	80000f42 <vsnprintf+0x116>

                width = (width*10) + *pFormat-'0';
80000f10:	fee44783          	lbu	a5,-18(s0)
80000f14:	873e                	mv	a4,a5
80000f16:	87ba                	mv	a5,a4
80000f18:	078a                	slli	a5,a5,0x2
80000f1a:	97ba                	add	a5,a5,a4
80000f1c:	0786                	slli	a5,a5,0x1
80000f1e:	0ff7f713          	zext.b	a4,a5
80000f22:	fd442783          	lw	a5,-44(s0)
80000f26:	0007c783          	lbu	a5,0(a5)
80000f2a:	97ba                	add	a5,a5,a4
80000f2c:	0ff7f793          	zext.b	a5,a5
80000f30:	fd078793          	addi	a5,a5,-48
80000f34:	fef40723          	sb	a5,-18(s0)
                pFormat++;
80000f38:	fd442783          	lw	a5,-44(s0)
80000f3c:	0785                	addi	a5,a5,1
80000f3e:	fcf42a23          	sw	a5,-44(s0)
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
80000f42:	fd442783          	lw	a5,-44(s0)
80000f46:	0007c703          	lbu	a4,0(a5)
80000f4a:	02f00793          	li	a5,47
80000f4e:	00e7fa63          	bgeu	a5,a4,80000f62 <vsnprintf+0x136>
80000f52:	fd442783          	lw	a5,-44(s0)
80000f56:	0007c703          	lbu	a4,0(a5)
80000f5a:	03900793          	li	a5,57
80000f5e:	fae7f9e3          	bgeu	a5,a4,80000f10 <vsnprintf+0xe4>
            }

            /* Check if there is enough space */
            if (size + width > length) {
80000f62:	fee44703          	lbu	a4,-18(s0)
80000f66:	fe442783          	lw	a5,-28(s0)
80000f6a:	97ba                	add	a5,a5,a4
80000f6c:	873e                	mv	a4,a5
80000f6e:	fd842783          	lw	a5,-40(s0)
80000f72:	00e7fe63          	bgeu	a5,a4,80000f8e <vsnprintf+0x162>

                width = length - size;
80000f76:	fd842783          	lw	a5,-40(s0)
80000f7a:	0ff7f713          	zext.b	a4,a5
80000f7e:	fe442783          	lw	a5,-28(s0)
80000f82:	0ff7f793          	zext.b	a5,a5
80000f86:	40f707b3          	sub	a5,a4,a5
80000f8a:	fef40723          	sb	a5,-18(s0)
            }

            /* Parse type */
            switch (*pFormat) {
80000f8e:	fd442783          	lw	a5,-44(s0)
80000f92:	0007c783          	lbu	a5,0(a5)
80000f96:	fa878793          	addi	a5,a5,-88
80000f9a:	02000713          	li	a4,32
80000f9e:	0ef76563          	bltu	a4,a5,80001088 <vsnprintf+0x25c>
80000fa2:	00279713          	slli	a4,a5,0x2
80000fa6:	800097b7          	lui	a5,0x80009
80000faa:	44078793          	addi	a5,a5,1088 # 80009440 <__data_source_start+0xfffffa1c>
80000fae:	97ba                	add	a5,a5,a4
80000fb0:	439c                	lw	a5,0(a5)
80000fb2:	8782                	jr	a5
            case 'd':
            case 'i': num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int)); break;
80000fb4:	fee44603          	lbu	a2,-18(s0)
80000fb8:	fd042783          	lw	a5,-48(s0)
80000fbc:	00478713          	addi	a4,a5,4
80000fc0:	fce42823          	sw	a4,-48(s0)
80000fc4:	4398                	lw	a4,0(a5)
80000fc6:	fef44783          	lbu	a5,-17(s0)
80000fca:	86ba                	mv	a3,a4
80000fcc:	85be                	mv	a1,a5
80000fce:	fdc42503          	lw	a0,-36(s0)
80000fd2:	3ee1                	jal	80000baa <PutSignedInt>
80000fd4:	fea42423          	sw	a0,-24(s0)
80000fd8:	a855                	j	8000108c <vsnprintf+0x260>
            case 'u': num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned int)); break;
80000fda:	fee44603          	lbu	a2,-18(s0)
80000fde:	fd042783          	lw	a5,-48(s0)
80000fe2:	00478713          	addi	a4,a5,4
80000fe6:	fce42823          	sw	a4,-48(s0)
80000fea:	4398                	lw	a4,0(a5)
80000fec:	fef44783          	lbu	a5,-17(s0)
80000ff0:	86ba                	mv	a3,a4
80000ff2:	85be                	mv	a1,a5
80000ff4:	fdc42503          	lw	a0,-36(s0)
80000ff8:	34dd                	jal	80000ade <PutUnsignedInt>
80000ffa:	fea42423          	sw	a0,-24(s0)
80000ffe:	a079                	j	8000108c <vsnprintf+0x260>
            case 'x': num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int)); break;
80001000:	fee44603          	lbu	a2,-18(s0)
80001004:	fd042783          	lw	a5,-48(s0)
80001008:	00478713          	addi	a4,a5,4
8000100c:	fce42823          	sw	a4,-48(s0)
80001010:	4398                	lw	a4,0(a5)
80001012:	fef44783          	lbu	a5,-17(s0)
80001016:	4681                	li	a3,0
80001018:	85be                	mv	a1,a5
8000101a:	fdc42503          	lw	a0,-36(s0)
8000101e:	31d5                	jal	80000d02 <PutHexa>
80001020:	fea42423          	sw	a0,-24(s0)
80001024:	a0a5                	j	8000108c <vsnprintf+0x260>
            case 'X': num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int)); break;
80001026:	fee44603          	lbu	a2,-18(s0)
8000102a:	fd042783          	lw	a5,-48(s0)
8000102e:	00478713          	addi	a4,a5,4
80001032:	fce42823          	sw	a4,-48(s0)
80001036:	4398                	lw	a4,0(a5)
80001038:	fef44783          	lbu	a5,-17(s0)
8000103c:	4685                	li	a3,1
8000103e:	85be                	mv	a1,a5
80001040:	fdc42503          	lw	a0,-36(s0)
80001044:	397d                	jal	80000d02 <PutHexa>
80001046:	fea42423          	sw	a0,-24(s0)
8000104a:	a089                	j	8000108c <vsnprintf+0x260>
            case 's': num = PutString(pStr, va_arg(ap, char *)); break;
8000104c:	fd042783          	lw	a5,-48(s0)
80001050:	00478713          	addi	a4,a5,4
80001054:	fce42823          	sw	a4,-48(s0)
80001058:	439c                	lw	a5,0(a5)
8000105a:	85be                	mv	a1,a5
8000105c:	fdc42503          	lw	a0,-36(s0)
80001060:	342d                	jal	80000a8a <PutString>
80001062:	fea42423          	sw	a0,-24(s0)
80001066:	a01d                	j	8000108c <vsnprintf+0x260>
            case 'c': num = PutChar(pStr, va_arg(ap, unsigned int)); break;
80001068:	fd042783          	lw	a5,-48(s0)
8000106c:	00478713          	addi	a4,a5,4
80001070:	fce42823          	sw	a4,-48(s0)
80001074:	439c                	lw	a5,0(a5)
80001076:	0ff7f793          	zext.b	a5,a5
8000107a:	85be                	mv	a1,a5
8000107c:	fdc42503          	lw	a0,-36(s0)
80001080:	32d5                	jal	80000a64 <PutChar>
80001082:	fea42423          	sw	a0,-24(s0)
80001086:	a019                	j	8000108c <vsnprintf+0x260>
            default:
                return EOF;
80001088:	57fd                	li	a5,-1
8000108a:	a895                	j	800010fe <vsnprintf+0x2d2>
            }

            pFormat++;
8000108c:	fd442783          	lw	a5,-44(s0)
80001090:	0785                	addi	a5,a5,1
80001092:	fcf42a23          	sw	a5,-44(s0)
            pStr += num;
80001096:	fe842783          	lw	a5,-24(s0)
8000109a:	fdc42703          	lw	a4,-36(s0)
8000109e:	97ba                	add	a5,a5,a4
800010a0:	fcf42e23          	sw	a5,-36(s0)
            size += num;
800010a4:	fe442703          	lw	a4,-28(s0)
800010a8:	fe842783          	lw	a5,-24(s0)
800010ac:	97ba                	add	a5,a5,a4
800010ae:	fef42223          	sw	a5,-28(s0)
    while (*pFormat != 0 && size < length) {
800010b2:	fd442783          	lw	a5,-44(s0)
800010b6:	0007c783          	lbu	a5,0(a5)
800010ba:	c799                	beqz	a5,800010c8 <vsnprintf+0x29c>
800010bc:	fe442783          	lw	a5,-28(s0)
800010c0:	fd842703          	lw	a4,-40(s0)
800010c4:	d8e7ede3          	bltu	a5,a4,80000e5e <vsnprintf+0x32>
        }
    }

    /* NULL-terminated (final \0 is not counted) */
    if (size < length) {
800010c8:	fe442783          	lw	a5,-28(s0)
800010cc:	fd842703          	lw	a4,-40(s0)
800010d0:	00e7f763          	bgeu	a5,a4,800010de <vsnprintf+0x2b2>

        *pStr = 0;
800010d4:	fdc42783          	lw	a5,-36(s0)
800010d8:	00078023          	sb	zero,0(a5)
800010dc:	a839                	j	800010fa <vsnprintf+0x2ce>
    }
    else {

        *(--pStr) = 0;
800010de:	fdc42783          	lw	a5,-36(s0)
800010e2:	17fd                	addi	a5,a5,-1
800010e4:	fcf42e23          	sw	a5,-36(s0)
800010e8:	fdc42783          	lw	a5,-36(s0)
800010ec:	00078023          	sb	zero,0(a5)
        size--;
800010f0:	fe442783          	lw	a5,-28(s0)
800010f4:	17fd                	addi	a5,a5,-1
800010f6:	fef42223          	sw	a5,-28(s0)
    }

    return size;
800010fa:	fe442783          	lw	a5,-28(s0)
}
800010fe:	853e                	mv	a0,a5
80001100:	50b2                	lw	ra,44(sp)
80001102:	5422                	lw	s0,40(sp)
80001104:	6145                	addi	sp,sp,48
80001106:	8082                	ret

80001108 <snprintf>:
 * @param ...     Other arguments
 *
 * @return  The number of characters written.
 */
signed int snprintf(char *pString, size_t length, const char *pFormat, ...)
{
80001108:	715d                	addi	sp,sp,-80
8000110a:	d606                	sw	ra,44(sp)
8000110c:	d422                	sw	s0,40(sp)
8000110e:	1800                	addi	s0,sp,48
80001110:	fca42e23          	sw	a0,-36(s0)
80001114:	fcb42c23          	sw	a1,-40(s0)
80001118:	fcc42a23          	sw	a2,-44(s0)
8000111c:	c454                	sw	a3,12(s0)
8000111e:	c818                	sw	a4,16(s0)
80001120:	c85c                	sw	a5,20(s0)
80001122:	01042c23          	sw	a6,24(s0)
80001126:	01142e23          	sw	a7,28(s0)
    va_list    ap;
    signed int rc;

    va_start(ap, pFormat);
8000112a:	02040793          	addi	a5,s0,32
8000112e:	fcf42823          	sw	a5,-48(s0)
80001132:	fd042783          	lw	a5,-48(s0)
80001136:	17b1                	addi	a5,a5,-20
80001138:	fef42423          	sw	a5,-24(s0)
    rc = vsnprintf(pString, length, pFormat, ap);
8000113c:	fe842783          	lw	a5,-24(s0)
80001140:	86be                	mv	a3,a5
80001142:	fd442603          	lw	a2,-44(s0)
80001146:	fd842583          	lw	a1,-40(s0)
8000114a:	fdc42503          	lw	a0,-36(s0)
8000114e:	39f9                	jal	80000e2c <vsnprintf>
80001150:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return rc;
80001154:	fec42783          	lw	a5,-20(s0)
}
80001158:	853e                	mv	a0,a5
8000115a:	50b2                	lw	ra,44(sp)
8000115c:	5422                	lw	s0,40(sp)
8000115e:	6161                	addi	sp,sp,80
80001160:	8082                	ret

80001162 <vsprintf>:
 * @param ap       Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsprintf(char *pString, const char *pFormat, va_list ap)
{
80001162:	1101                	addi	sp,sp,-32
80001164:	ce06                	sw	ra,28(sp)
80001166:	cc22                	sw	s0,24(sp)
80001168:	1000                	addi	s0,sp,32
8000116a:	fea42623          	sw	a0,-20(s0)
8000116e:	feb42423          	sw	a1,-24(s0)
80001172:	fec42223          	sw	a2,-28(s0)
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
80001176:	fe442683          	lw	a3,-28(s0)
8000117a:	fe842603          	lw	a2,-24(s0)
8000117e:	15e00593          	li	a1,350
80001182:	fec42503          	lw	a0,-20(s0)
80001186:	315d                	jal	80000e2c <vsnprintf>
80001188:	87aa                	mv	a5,a0
}
8000118a:	853e                	mv	a0,a5
8000118c:	40f2                	lw	ra,28(sp)
8000118e:	4462                	lw	s0,24(sp)
80001190:	6105                	addi	sp,sp,32
80001192:	8082                	ret

80001194 <vfprintf>:
 * @param pStream  Output stream.
 * @param pFormat  Format string
 * @param ap       Argument list.
 */
signed int vfprintf(FILE *pStream, const char *pFormat, va_list ap)
{
80001194:	7161                	addi	sp,sp,-432
80001196:	1a112623          	sw	ra,428(sp)
8000119a:	1a812423          	sw	s0,424(sp)
8000119e:	1b00                	addi	s0,sp,432
800011a0:	e4a42e23          	sw	a0,-420(s0)
800011a4:	e4b42c23          	sw	a1,-424(s0)
800011a8:	e4c42a23          	sw	a2,-428(s0)
    char pStr[MAX_STRING_SIZE];
    char pError[] = "stdio.c: increase MAX_STRING_SIZE\n\r";
800011ac:	800097b7          	lui	a5,0x80009
800011b0:	4c478793          	addi	a5,a5,1220 # 800094c4 <__data_source_start+0xfffffaa0>
800011b4:	0007a303          	lw	t1,0(a5)
800011b8:	0047a883          	lw	a7,4(a5)
800011bc:	0087a803          	lw	a6,8(a5)
800011c0:	47c8                	lw	a0,12(a5)
800011c2:	4b8c                	lw	a1,16(a5)
800011c4:	4bd0                	lw	a2,20(a5)
800011c6:	4f94                	lw	a3,24(a5)
800011c8:	4fd8                	lw	a4,28(a5)
800011ca:	539c                	lw	a5,32(a5)
800011cc:	e6642623          	sw	t1,-404(s0)
800011d0:	e7142823          	sw	a7,-400(s0)
800011d4:	e7042a23          	sw	a6,-396(s0)
800011d8:	e6a42c23          	sw	a0,-392(s0)
800011dc:	e6b42e23          	sw	a1,-388(s0)
800011e0:	e8c42023          	sw	a2,-384(s0)
800011e4:	e8d42223          	sw	a3,-380(s0)
800011e8:	e8e42423          	sw	a4,-376(s0)
800011ec:	e8f42623          	sw	a5,-372(s0)

    /* Write formatted string in buffer */
    if (vsprintf(pStr, pFormat, ap) >= MAX_STRING_SIZE) {
800011f0:	e9040793          	addi	a5,s0,-368
800011f4:	e5442603          	lw	a2,-428(s0)
800011f8:	e5842583          	lw	a1,-424(s0)
800011fc:	853e                	mv	a0,a5
800011fe:	3795                	jal	80001162 <vsprintf>
80001200:	872a                	mv	a4,a0
80001202:	15d00793          	li	a5,349
80001206:	00e7dc63          	bge	a5,a4,8000121e <vfprintf+0x8a>

        fputs(pError, stderr);
8000120a:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
8000120e:	47d8                	lw	a4,12(a5)
80001210:	e6c40793          	addi	a5,s0,-404
80001214:	85ba                	mv	a1,a4
80001216:	853e                	mv	a0,a5
80001218:	22f1                	jal	800013e4 <fputs>
        while (1); /* Increase MAX_STRING_SIZE */
8000121a:	0001                	nop
8000121c:	bffd                	j	8000121a <vfprintf+0x86>
    }

    /* Display string */
    return fputs(pStr, pStream);
8000121e:	e9040793          	addi	a5,s0,-368
80001222:	e5c42583          	lw	a1,-420(s0)
80001226:	853e                	mv	a0,a5
80001228:	2a75                	jal	800013e4 <fputs>
8000122a:	87aa                	mv	a5,a0
}
8000122c:	853e                	mv	a0,a5
8000122e:	1ac12083          	lw	ra,428(sp)
80001232:	1a812403          	lw	s0,424(sp)
80001236:	615d                	addi	sp,sp,432
80001238:	8082                	ret

8000123a <vprintf>:
 *
 * @param pFormat  Format string.
 * @param ap  Argument list.
 */
signed int vprintf(const char *pFormat, va_list ap)
{
8000123a:	1101                	addi	sp,sp,-32
8000123c:	ce06                	sw	ra,28(sp)
8000123e:	cc22                	sw	s0,24(sp)
80001240:	1000                	addi	s0,sp,32
80001242:	fea42623          	sw	a0,-20(s0)
80001246:	feb42423          	sw	a1,-24(s0)
    return vfprintf(stdout, pFormat, ap);
8000124a:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
8000124e:	479c                	lw	a5,8(a5)
80001250:	fe842603          	lw	a2,-24(s0)
80001254:	fec42583          	lw	a1,-20(s0)
80001258:	853e                	mv	a0,a5
8000125a:	3f2d                	jal	80001194 <vfprintf>
8000125c:	87aa                	mv	a5,a0
}
8000125e:	853e                	mv	a0,a5
80001260:	40f2                	lw	ra,28(sp)
80001262:	4462                	lw	s0,24(sp)
80001264:	6105                	addi	sp,sp,32
80001266:	8082                	ret

80001268 <fprintf>:
 *
 * @param pStream  Output stream.
 * @param pFormat  Format string.
 */
signed int fprintf(FILE *pStream, const char *pFormat, ...)
{
80001268:	715d                	addi	sp,sp,-80
8000126a:	d606                	sw	ra,44(sp)
8000126c:	d422                	sw	s0,40(sp)
8000126e:	1800                	addi	s0,sp,48
80001270:	fca42e23          	sw	a0,-36(s0)
80001274:	fcb42c23          	sw	a1,-40(s0)
80001278:	c410                	sw	a2,8(s0)
8000127a:	c454                	sw	a3,12(s0)
8000127c:	c818                	sw	a4,16(s0)
8000127e:	c85c                	sw	a5,20(s0)
80001280:	01042c23          	sw	a6,24(s0)
80001284:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    /* Forward call to vfprintf */
    va_start(ap, pFormat);
80001288:	02040793          	addi	a5,s0,32
8000128c:	fcf42a23          	sw	a5,-44(s0)
80001290:	fd442783          	lw	a5,-44(s0)
80001294:	17a1                	addi	a5,a5,-24
80001296:	fef42423          	sw	a5,-24(s0)
    result = vfprintf(pStream, pFormat, ap);
8000129a:	fe842783          	lw	a5,-24(s0)
8000129e:	863e                	mv	a2,a5
800012a0:	fd842583          	lw	a1,-40(s0)
800012a4:	fdc42503          	lw	a0,-36(s0)
800012a8:	35f5                	jal	80001194 <vfprintf>
800012aa:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
800012ae:	fec42783          	lw	a5,-20(s0)
}
800012b2:	853e                	mv	a0,a5
800012b4:	50b2                	lw	ra,44(sp)
800012b6:	5422                	lw	s0,40(sp)
800012b8:	6161                	addi	sp,sp,80
800012ba:	8082                	ret

800012bc <printf>:
 *         arguments.
 *
 * @param  pFormat  Format string.
 */
signed int printf(const char *pFormat, ...)
{
800012bc:	715d                	addi	sp,sp,-80
800012be:	d606                	sw	ra,44(sp)
800012c0:	d422                	sw	s0,40(sp)
800012c2:	1800                	addi	s0,sp,48
800012c4:	fca42e23          	sw	a0,-36(s0)
800012c8:	c04c                	sw	a1,4(s0)
800012ca:	c410                	sw	a2,8(s0)
800012cc:	c454                	sw	a3,12(s0)
800012ce:	c818                	sw	a4,16(s0)
800012d0:	c85c                	sw	a5,20(s0)
800012d2:	01042c23          	sw	a6,24(s0)
800012d6:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    /* Forward call to vprintf */
    va_start(ap, pFormat);
800012da:	02040793          	addi	a5,s0,32
800012de:	fcf42c23          	sw	a5,-40(s0)
800012e2:	fd842783          	lw	a5,-40(s0)
800012e6:	1791                	addi	a5,a5,-28
800012e8:	fef42423          	sw	a5,-24(s0)
    result = vprintf(pFormat, ap);
800012ec:	fe842783          	lw	a5,-24(s0)
800012f0:	85be                	mv	a1,a5
800012f2:	fdc42503          	lw	a0,-36(s0)
800012f6:	3791                	jal	8000123a <vprintf>
800012f8:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
800012fc:	fec42783          	lw	a5,-20(s0)
}
80001300:	853e                	mv	a0,a5
80001302:	50b2                	lw	ra,44(sp)
80001304:	5422                	lw	s0,40(sp)
80001306:	6161                	addi	sp,sp,80
80001308:	8082                	ret

8000130a <sprintf>:
 *
 * @param pStr     torage string.
 * @param pFormat  Format string.
 */
signed int sprintf(char *pStr, const char *pFormat, ...)
{
8000130a:	715d                	addi	sp,sp,-80
8000130c:	d606                	sw	ra,44(sp)
8000130e:	d422                	sw	s0,40(sp)
80001310:	1800                	addi	s0,sp,48
80001312:	fca42e23          	sw	a0,-36(s0)
80001316:	fcb42c23          	sw	a1,-40(s0)
8000131a:	c410                	sw	a2,8(s0)
8000131c:	c454                	sw	a3,12(s0)
8000131e:	c818                	sw	a4,16(s0)
80001320:	c85c                	sw	a5,20(s0)
80001322:	01042c23          	sw	a6,24(s0)
80001326:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    // Forward call to vsprintf
    va_start(ap, pFormat);
8000132a:	02040793          	addi	a5,s0,32
8000132e:	fcf42a23          	sw	a5,-44(s0)
80001332:	fd442783          	lw	a5,-44(s0)
80001336:	17a1                	addi	a5,a5,-24
80001338:	fef42423          	sw	a5,-24(s0)
    result = vsprintf(pStr, pFormat, ap);
8000133c:	fe842783          	lw	a5,-24(s0)
80001340:	863e                	mv	a2,a5
80001342:	fd842583          	lw	a1,-40(s0)
80001346:	fdc42503          	lw	a0,-36(s0)
8000134a:	3d21                	jal	80001162 <vsprintf>
8000134c:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
80001350:	fec42783          	lw	a5,-20(s0)
}
80001354:	853e                	mv	a0,a5
80001356:	50b2                	lw	ra,44(sp)
80001358:	5422                	lw	s0,40(sp)
8000135a:	6161                	addi	sp,sp,80
8000135c:	8082                	ret

8000135e <puts>:
 * @brief  Outputs a string on stdout.
 *
 * @param pStr  String to output.
 */
signed int puts(const char *pStr)
{
8000135e:	7179                	addi	sp,sp,-48
80001360:	d606                	sw	ra,44(sp)
80001362:	d422                	sw	s0,40(sp)
80001364:	1800                	addi	s0,sp,48
80001366:	fca42e23          	sw	a0,-36(s0)
    signed int i = fputs(pStr, stdout);
8000136a:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
8000136e:	479c                	lw	a5,8(a5)
80001370:	85be                	mv	a1,a5
80001372:	fdc42503          	lw	a0,-36(s0)
80001376:	20bd                	jal	800013e4 <fputs>
80001378:	fea42623          	sw	a0,-20(s0)
    fputc('\n', stdout);
8000137c:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
80001380:	479c                	lw	a5,8(a5)
80001382:	85be                	mv	a1,a5
80001384:	4529                	li	a0,10
80001386:	2809                	jal	80001398 <fputc>

    return i+1;
80001388:	fec42783          	lw	a5,-20(s0)
8000138c:	0785                	addi	a5,a5,1
}
8000138e:	853e                	mv	a0,a5
80001390:	50b2                	lw	ra,44(sp)
80001392:	5422                	lw	s0,40(sp)
80001394:	6145                	addi	sp,sp,48
80001396:	8082                	ret

80001398 <fputc>:
 * @param pStream  Output stream.
 * @param The character written if successful, or -1 if the output stream is
 *        not stdout or stderr.
 */
signed int fputc(signed int c, FILE *pStream)
{
80001398:	1101                	addi	sp,sp,-32
8000139a:	ce06                	sw	ra,28(sp)
8000139c:	cc22                	sw	s0,24(sp)
8000139e:	1000                	addi	s0,sp,32
800013a0:	fea42623          	sw	a0,-20(s0)
800013a4:	feb42423          	sw	a1,-24(s0)
    if ((pStream == stdout) || (pStream == stderr)) {
800013a8:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
800013ac:	479c                	lw	a5,8(a5)
800013ae:	fe842703          	lw	a4,-24(s0)
800013b2:	00f70963          	beq	a4,a5,800013c4 <fputc+0x2c>
800013b6:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
800013ba:	47dc                	lw	a5,12(a5)
800013bc:	fe842703          	lw	a4,-24(s0)
800013c0:	00f71c63          	bne	a4,a5,800013d8 <fputc+0x40>

    	PrintChar(c);
800013c4:	fec42783          	lw	a5,-20(s0)
800013c8:	0ff7f793          	zext.b	a5,a5
800013cc:	853e                	mv	a0,a5
800013ce:	e74ff0ef          	jal	ra,80000a42 <PrintChar>

        return c;
800013d2:	fec42783          	lw	a5,-20(s0)
800013d6:	a011                	j	800013da <fputc+0x42>
    }
    else {

        return EOF;
800013d8:	57fd                	li	a5,-1
    }
}
800013da:	853e                	mv	a0,a5
800013dc:	40f2                	lw	ra,28(sp)
800013de:	4462                	lw	s0,24(sp)
800013e0:	6105                	addi	sp,sp,32
800013e2:	8082                	ret

800013e4 <fputs>:
 *
 * @return  Number of characters written if successful, or -1 if the output
 *          stream is not stdout or stderr.
 */
signed int fputs(const char *pStr, FILE *pStream)
{
800013e4:	7179                	addi	sp,sp,-48
800013e6:	d606                	sw	ra,44(sp)
800013e8:	d422                	sw	s0,40(sp)
800013ea:	1800                	addi	s0,sp,48
800013ec:	fca42e23          	sw	a0,-36(s0)
800013f0:	fcb42c23          	sw	a1,-40(s0)
    signed int num = 0;
800013f4:	fe042623          	sw	zero,-20(s0)

    while (*pStr != 0) {
800013f8:	a80d                	j	8000142a <fputs+0x46>

        if (fputc(*pStr, pStream) == -1) {
800013fa:	fdc42783          	lw	a5,-36(s0)
800013fe:	0007c783          	lbu	a5,0(a5)
80001402:	fd842583          	lw	a1,-40(s0)
80001406:	853e                	mv	a0,a5
80001408:	3f41                	jal	80001398 <fputc>
8000140a:	872a                	mv	a4,a0
8000140c:	57fd                	li	a5,-1
8000140e:	00f71463          	bne	a4,a5,80001416 <fputs+0x32>

            return -1;
80001412:	57fd                	li	a5,-1
80001414:	a015                	j	80001438 <fputs+0x54>
        }
        num++;
80001416:	fec42783          	lw	a5,-20(s0)
8000141a:	0785                	addi	a5,a5,1
8000141c:	fef42623          	sw	a5,-20(s0)
        pStr++;
80001420:	fdc42783          	lw	a5,-36(s0)
80001424:	0785                	addi	a5,a5,1
80001426:	fcf42e23          	sw	a5,-36(s0)
    while (*pStr != 0) {
8000142a:	fdc42783          	lw	a5,-36(s0)
8000142e:	0007c783          	lbu	a5,0(a5)
80001432:	f7e1                	bnez	a5,800013fa <fputs+0x16>
    }

    return num;
80001434:	fec42783          	lw	a5,-20(s0)
}
80001438:	853e                	mv	a0,a5
8000143a:	50b2                	lw	ra,44(sp)
8000143c:	5422                	lw	s0,40(sp)
8000143e:	6145                	addi	sp,sp,48
80001440:	8082                	ret

80001442 <retarget_init>:
#include "../Include/retarget.h"
// #include "../Include/system_k1921vg015.h"
#define SystemCoreClock_uart	SystemCoreClock
//-- Functions -----------------------------------------------------------------
void retarget_init()
{
80001442:	1101                	addi	sp,sp,-32
80001444:	ce22                	sw	s0,28(sp)
80001446:	1000                	addi	s0,sp,32
#if defined RETARGET
    uint32_t baud_icoef = HSECLK_VAL / (16 * RETARGET_UART_BAUD);
80001448:	47a1                	li	a5,8
8000144a:	fef42423          	sw	a5,-24(s0)
    uint32_t baud_fcoef = ((HSECLK_VAL / (16.0f * RETARGET_UART_BAUD) - baud_icoef) * 64 + 0.5f);
8000144e:	fe842783          	lw	a5,-24(s0)
80001452:	d017f7d3          	fcvt.s.wu	fa5,a5
80001456:	800097b7          	lui	a5,0x80009
8000145a:	4e87a707          	flw	fa4,1256(a5) # 800094e8 <__data_source_start+0xfffffac4>
8000145e:	08f77753          	fsub.s	fa4,fa4,fa5
80001462:	800097b7          	lui	a5,0x80009
80001466:	4ec7a787          	flw	fa5,1260(a5) # 800094ec <__data_source_start+0xfffffac8>
8000146a:	10f77753          	fmul.s	fa4,fa4,fa5
8000146e:	800097b7          	lui	a5,0x80009
80001472:	4f07a787          	flw	fa5,1264(a5) # 800094f0 <__data_source_start+0xfffffacc>
80001476:	00f777d3          	fadd.s	fa5,fa4,fa5
8000147a:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
8000147e:	fef42623          	sw	a5,-20(s0)

    // Настраиваем GPIO
    RCU->CGCFGAHB_bit.GPIOAEN = 1;
80001482:	3000e7b7          	lui	a5,0x3000e
80001486:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
8000148a:	10076713          	ori	a4,a4,256
8000148e:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOAEN = 1;
80001492:	3000e7b7          	lui	a5,0x3000e
80001496:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
8000149a:	10076713          	ori	a4,a4,256
8000149e:	00e79823          	sh	a4,16(a5)
    RCU->RSTDISAPB_bit.UART2EN = 1;
    #elif (RETARGET_UART_NUM == 3)
    RCU->CGCFGAPB_bit.UART3EN = 1;
    RCU->RSTDISAPB_bit.UART3EN = 1;
    #elif (RETARGET_UART_NUM == 4)
    RCU->CGCFGAPB_bit.UART4EN = 1;
800014a2:	3000e7b7          	lui	a5,0x3000e
800014a6:	4798                	lw	a4,8(a5)
800014a8:	40076713          	ori	a4,a4,1024
800014ac:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.UART4EN = 1;
800014ae:	3000e7b7          	lui	a5,0x3000e
800014b2:	4f98                	lw	a4,24(a5)
800014b4:	40076713          	ori	a4,a4,1024
800014b8:	cf98                	sw	a4,24(a5)
    } else if (RETARGET_UART_PIN_TX_POS == 3) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN3 = 1;
    } else if (RETARGET_UART_PIN_TX_POS == 8) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN8 = 1;
    } else if (RETARGET_UART_PIN_TX_POS == 9) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN9 = 1;
800014ba:	280007b7          	lui	a5,0x28000
800014be:	5fd4                	lw	a3,60(a5)
800014c0:	fff40737          	lui	a4,0xfff40
800014c4:	177d                	addi	a4,a4,-1 # fff3ffff <__data_source_start+0x7ff365db>
800014c6:	8ef9                	and	a3,a3,a4
800014c8:	00040737          	lui	a4,0x40
800014cc:	8f55                	or	a4,a4,a3
800014ce:	dfd8                	sw	a4,60(a5)
    if (RETARGET_UART_PIN_RX_POS == 2) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN2 = 1;
    } else if (RETARGET_UART_PIN_RX_POS == 3) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN3 = 1;
    } else if (RETARGET_UART_PIN_RX_POS == 8) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN8 = 1;
800014d0:	280007b7          	lui	a5,0x28000
800014d4:	5fd4                	lw	a3,60(a5)
800014d6:	fffd0737          	lui	a4,0xfffd0
800014da:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc65db>
800014dc:	8ef9                	and	a3,a3,a4
800014de:	6741                	lui	a4,0x10
800014e0:	8f55                	or	a4,a4,a3
800014e2:	dfd8                	sw	a4,60(a5)
    } else if (RETARGET_UART_PIN_RX_POS == 9) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN9 = 1;
    }
    
    RETARGET_UART_PORT->ALTFUNCSET = (1 << RETARGET_UART_PIN_TX_POS) | (1 << RETARGET_UART_PIN_RX_POS);
800014e4:	280007b7          	lui	a5,0x28000
800014e8:	30000713          	li	a4,768
800014ec:	dbd8                	sw	a4,52(a5)

    // Настраиваем UART0 с более детальной конфигурацией
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.CLKSEL = RCU_UARTCLKCFG_CLKSEL_HSE;
800014ee:	3000e7b7          	lui	a5,0x3000e
800014f2:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
800014f6:	fffd0737          	lui	a4,0xfffd0
800014fa:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc65db>
800014fc:	8ef9                	and	a3,a3,a4
800014fe:	6741                	lui	a4,0x10
80001500:	8f55                	or	a4,a4,a3
80001502:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.DIVEN = 0;
80001506:	3000e7b7          	lui	a5,0x3000e
8000150a:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
8000150e:	fff00737          	lui	a4,0xfff00
80001512:	177d                	addi	a4,a4,-1 # ffefffff <__data_source_start+0x7fef65db>
80001514:	8f75                	and	a4,a4,a3
80001516:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.RSTDIS = 1;
8000151a:	3000e7b7          	lui	a5,0x3000e
8000151e:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
80001522:	10076713          	ori	a4,a4,256
80001526:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.CLKEN = 1;
8000152a:	3000e7b7          	lui	a5,0x3000e
8000152e:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
80001532:	00176713          	ori	a4,a4,1
80001536:	08e7a023          	sw	a4,128(a5)

    RETARGET_UART->IBRD = baud_icoef;
8000153a:	3000a7b7          	lui	a5,0x3000a
8000153e:	fe842703          	lw	a4,-24(s0)
80001542:	d3d8                	sw	a4,36(a5)
    RETARGET_UART->FBRD = baud_fcoef;
80001544:	3000a7b7          	lui	a5,0x3000a
80001548:	fec42703          	lw	a4,-20(s0)
8000154c:	d798                	sw	a4,40(a5)
    RETARGET_UART->LCRH = UART_LCRH_FEN_Msk | (3 << UART_LCRH_WLEN_Pos);
8000154e:	3000a7b7          	lui	a5,0x3000a
80001552:	07000713          	li	a4,112
80001556:	d7d8                	sw	a4,44(a5)
    RETARGET_UART->IFLS = 0;  // Настройка уровня прерываний
80001558:	3000a7b7          	lui	a5,0x3000a
8000155c:	0207aa23          	sw	zero,52(a5) # 3000a034 <STACK_SIZE+0x30009834>
    RETARGET_UART->CR = UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
80001560:	3000a7b7          	lui	a5,0x3000a
80001564:	30100713          	li	a4,769
80001568:	db98                	sw	a4,48(a5)
#endif //RETARGET
}
8000156a:	0001                	nop
8000156c:	4472                	lw	s0,28(sp)
8000156e:	6105                	addi	sp,sp,32
80001570:	8082                	ret

80001572 <retarget_get_char>:

int retarget_get_char()
{
80001572:	1141                	addi	sp,sp,-16
80001574:	c622                	sw	s0,12(sp)
80001576:	0800                	addi	s0,sp,16
#if defined RETARGET
    while (RETARGET_UART->FR_bit.RXFE) {
80001578:	0001                	nop
8000157a:	3000a7b7          	lui	a5,0x3000a
8000157e:	4f9c                	lw	a5,24(a5)
80001580:	8391                	srli	a5,a5,0x4
80001582:	8b85                	andi	a5,a5,1
80001584:	0ff7f793          	zext.b	a5,a5
80001588:	fbed                	bnez	a5,8000157a <retarget_get_char+0x8>
    };
    return (int)RETARGET_UART->DR_bit.DATA;
8000158a:	3000a7b7          	lui	a5,0x3000a
8000158e:	0007c783          	lbu	a5,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
80001592:	0ff7f793          	zext.b	a5,a5
#endif //RETARGET
    return -1;
}
80001596:	853e                	mv	a0,a5
80001598:	4432                	lw	s0,12(sp)
8000159a:	0141                	addi	sp,sp,16
8000159c:	8082                	ret

8000159e <retarget_put_char>:

int retarget_put_char(int ch)
{
8000159e:	1101                	addi	sp,sp,-32
800015a0:	ce22                	sw	s0,28(sp)
800015a2:	1000                	addi	s0,sp,32
800015a4:	fea42623          	sw	a0,-20(s0)
#if defined RETARGET
    while (RETARGET_UART->FR_bit.BUSY) {
800015a8:	0001                	nop
800015aa:	3000a7b7          	lui	a5,0x3000a
800015ae:	4f9c                	lw	a5,24(a5)
800015b0:	838d                	srli	a5,a5,0x3
800015b2:	8b85                	andi	a5,a5,1
800015b4:	0ff7f793          	zext.b	a5,a5
800015b8:	fbed                	bnez	a5,800015aa <retarget_put_char+0xc>
    };
    RETARGET_UART->DR = ch;
800015ba:	3000a7b7          	lui	a5,0x3000a
800015be:	fec42703          	lw	a4,-20(s0)
800015c2:	c398                	sw	a4,0(a5)
#endif //RETARGET
    return 0;
800015c4:	4781                	li	a5,0
800015c6:	853e                	mv	a0,a5
800015c8:	4472                	lw	s0,28(sp)
800015ca:	6105                	addi	sp,sp,32
800015cc:	8082                	ret
	...

800015d0 <csr_set_bits_mstatus>:
                      : "r" (new_value)  /* input : register */
                      : /* clobbers: none */);
    return prev_value;
}
/* Register CSR bit set and clear instructions */
static inline void csr_set_bits_mstatus(uint_xlen_t mask) {
800015d0:	1101                	addi	sp,sp,-32
800015d2:	ce22                	sw	s0,28(sp)
800015d4:	1000                	addi	s0,sp,32
800015d6:	fea42623          	sw	a0,-20(s0)
    __asm__ volatile ("csrrs    zero, mstatus, %0"  
800015da:	fec42783          	lw	a5,-20(s0)
800015de:	3007a073          	csrs	mstatus,a5
                      : /* output: none */ 
                      : "r" (mask)  /* input : register */
                      : /* clobbers: none */);
}
800015e2:	0001                	nop
800015e4:	4472                	lw	s0,28(sp)
800015e6:	6105                	addi	sp,sp,32
800015e8:	8082                	ret
800015ea:	0001                	nop

800015ec <csr_clr_bits_mstatus>:
static inline void csr_clr_bits_mstatus(uint_xlen_t mask) {
800015ec:	1101                	addi	sp,sp,-32
800015ee:	ce22                	sw	s0,28(sp)
800015f0:	1000                	addi	s0,sp,32
800015f2:	fea42623          	sw	a0,-20(s0)
    __asm__ volatile ("csrrc    zero, mstatus, %0"  
800015f6:	fec42783          	lw	a5,-20(s0)
800015fa:	3007b073          	csrc	mstatus,a5
                      : /* output: none */ 
                      : "r" (mask)  /* input : register */
                      : /* clobbers: none */);
}
800015fe:	0001                	nop
80001600:	4472                	lw	s0,28(sp)
80001602:	6105                	addi	sp,sp,32
80001604:	8082                	ret
80001606:	0001                	nop

80001608 <csr_write_mtvec>:
                      : "=r" (value)  /* output : register */
                      : /* input : none */
                      : /* clobbers: none */);
    return value;
}
static inline void csr_write_mtvec(uint_xlen_t value) {
80001608:	1101                	addi	sp,sp,-32
8000160a:	ce22                	sw	s0,28(sp)
8000160c:	1000                	addi	s0,sp,32
8000160e:	fea42623          	sw	a0,-20(s0)
    __asm__ volatile ("csrw    mtvec, %0" 
80001612:	fec42783          	lw	a5,-20(s0)
80001616:	30579073          	csrw	mtvec,a5
                      : /* output: none */ 
                      : "r" (value) /* input : from register */
                      : /* clobbers: none */);
}
8000161a:	0001                	nop
8000161c:	4472                	lw	s0,28(sp)
8000161e:	6105                	addi	sp,sp,32
80001620:	8082                	ret
80001622:	0001                	nop

80001624 <csr_set_bits_mie>:
                      : "r" (new_value)  /* input : register */
                      : /* clobbers: none */);
    return prev_value;
}
/* Register CSR bit set and clear instructions */
static inline void csr_set_bits_mie(uint_xlen_t mask) {
80001624:	1101                	addi	sp,sp,-32
80001626:	ce22                	sw	s0,28(sp)
80001628:	1000                	addi	s0,sp,32
8000162a:	fea42623          	sw	a0,-20(s0)
    __asm__ volatile ("csrrs    zero, mie, %0"  
8000162e:	fec42783          	lw	a5,-20(s0)
80001632:	3047a073          	csrs	mie,a5
                      : /* output: none */ 
                      : "r" (mask)  /* input : register */
                      : /* clobbers: none */);
}
80001636:	0001                	nop
80001638:	4472                	lw	s0,28(sp)
8000163a:	6105                	addi	sp,sp,32
8000163c:	8082                	ret
8000163e:	0001                	nop

80001640 <csr_clr_bits_mie>:
static inline void csr_clr_bits_mie(uint_xlen_t mask) {
80001640:	1101                	addi	sp,sp,-32
80001642:	ce22                	sw	s0,28(sp)
80001644:	1000                	addi	s0,sp,32
80001646:	fea42623          	sw	a0,-20(s0)
    __asm__ volatile ("csrrc    zero, mie, %0"  
8000164a:	fec42783          	lw	a5,-20(s0)
8000164e:	3047b073          	csrc	mie,a5
                      : /* output: none */ 
                      : "r" (mask)  /* input : register */
                      : /* clobbers: none */);
}
80001652:	0001                	nop
80001654:	4472                	lw	s0,28(sp)
80001656:	6105                	addi	sp,sp,32
80001658:	8082                	ret
8000165a:	0001                	nop

8000165c <csr_read_mcause>:
}

/*******************************************
 * mcause - MRW - Machine Exception Cause 
 */
static inline uint_xlen_t csr_read_mcause(void) {
8000165c:	1101                	addi	sp,sp,-32
8000165e:	ce22                	sw	s0,28(sp)
80001660:	1000                	addi	s0,sp,32
    uint_xlen_t value;        
    __asm__ volatile ("csrr    %0, mcause" 
80001662:	342027f3          	csrr	a5,mcause
80001666:	fef42623          	sw	a5,-20(s0)
                      : "=r" (value)  /* output : register */
                      : /* input : none */
                      : /* clobbers: none */);
    return value;
8000166a:	fec42783          	lw	a5,-20(s0)
}
8000166e:	853e                	mv	a0,a5
80001670:	4472                	lw	s0,28(sp)
80001672:	6105                	addi	sp,sp,32
80001674:	8082                	ret
80001676:	0001                	nop

80001678 <riscv_irq_init>:
static void irq_entry(void)
    __attribute__((interrupt("machine"), optimize("align-functions=4")));

irqfunc_t* riscv_handler_map[RISCV_IRQ_NUMS];

void riscv_irq_init(void) { 
80001678:	1141                	addi	sp,sp,-16
8000167a:	c606                	sw	ra,12(sp)
8000167c:	c422                	sw	s0,8(sp)
8000167e:	0800                	addi	s0,sp,16
	riscv_irq_global_disable(); 
80001680:	2055                	jal	80001724 <riscv_irq_global_disable>
	csr_write_mtvec((uint32_t)irq_entry);
80001682:	800017b7          	lui	a5,0x80001
80001686:	73c78793          	addi	a5,a5,1852 # 8000173c <__data_source_start+0xffff7d18>
8000168a:	853e                	mv	a0,a5
8000168c:	3fb5                	jal	80001608 <csr_write_mtvec>
	riscv_irq_global_enable(); 
8000168e:	28bd                	jal	8000170c <riscv_irq_global_enable>
}
80001690:	0001                	nop
80001692:	40b2                	lw	ra,12(sp)
80001694:	4422                	lw	s0,8(sp)
80001696:	0141                	addi	sp,sp,16
80001698:	8082                	ret
8000169a:	0001                	nop

8000169c <riscv_irq_enable>:

void riscv_irq_enable(unsigned int irq_num){
8000169c:	1101                	addi	sp,sp,-32
8000169e:	ce06                	sw	ra,28(sp)
800016a0:	cc22                	sw	s0,24(sp)
800016a2:	1000                	addi	s0,sp,32
800016a4:	fea42623          	sw	a0,-20(s0)
	
    csr_set_bits_mie(1 << irq_num);
800016a8:	fec42783          	lw	a5,-20(s0)
800016ac:	4705                	li	a4,1
800016ae:	00f717b3          	sll	a5,a4,a5
800016b2:	853e                	mv	a0,a5
800016b4:	3f85                	jal	80001624 <csr_set_bits_mie>
}
800016b6:	0001                	nop
800016b8:	40f2                	lw	ra,28(sp)
800016ba:	4462                	lw	s0,24(sp)
800016bc:	6105                	addi	sp,sp,32
800016be:	8082                	ret

800016c0 <riscv_irq_disable>:

void riscv_irq_disable(unsigned int irq_num){
800016c0:	1101                	addi	sp,sp,-32
800016c2:	ce06                	sw	ra,28(sp)
800016c4:	cc22                	sw	s0,24(sp)
800016c6:	1000                	addi	s0,sp,32
800016c8:	fea42623          	sw	a0,-20(s0)
	csr_clr_bits_mie(1 << irq_num);
800016cc:	fec42783          	lw	a5,-20(s0)
800016d0:	4705                	li	a4,1
800016d2:	00f717b3          	sll	a5,a4,a5
800016d6:	853e                	mv	a0,a5
800016d8:	37a5                	jal	80001640 <csr_clr_bits_mie>
}
800016da:	0001                	nop
800016dc:	40f2                	lw	ra,28(sp)
800016de:	4462                	lw	s0,24(sp)
800016e0:	6105                	addi	sp,sp,32
800016e2:	8082                	ret

800016e4 <riscv_irq_set_handler>:

void riscv_irq_set_handler(unsigned int irq_num, irqfunc_t *handler){
800016e4:	1101                	addi	sp,sp,-32
800016e6:	ce22                	sw	s0,28(sp)
800016e8:	1000                	addi	s0,sp,32
800016ea:	fea42623          	sw	a0,-20(s0)
800016ee:	feb42423          	sw	a1,-24(s0)
  riscv_handler_map[irq_num] = handler;
800016f2:	e3018713          	addi	a4,gp,-464 # 400005b0 <riscv_handler_map>
800016f6:	fec42783          	lw	a5,-20(s0)
800016fa:	078a                	slli	a5,a5,0x2
800016fc:	97ba                	add	a5,a5,a4
800016fe:	fe842703          	lw	a4,-24(s0)
80001702:	c398                	sw	a4,0(a5)
}
80001704:	0001                	nop
80001706:	4472                	lw	s0,28(sp)
80001708:	6105                	addi	sp,sp,32
8000170a:	8082                	ret

8000170c <riscv_irq_global_enable>:

void riscv_irq_global_enable(void)
{
8000170c:	1141                	addi	sp,sp,-16
8000170e:	c606                	sw	ra,12(sp)
80001710:	c422                	sw	s0,8(sp)
80001712:	0800                	addi	s0,sp,16
    //clear_csr(mstatus, MSTATUS_MPIE);
    csr_set_bits_mstatus(MSTATUS_MIE_BIT_MASK); 
80001714:	4521                	li	a0,8
80001716:	3d6d                	jal	800015d0 <csr_set_bits_mstatus>

}
80001718:	0001                	nop
8000171a:	40b2                	lw	ra,12(sp)
8000171c:	4422                	lw	s0,8(sp)
8000171e:	0141                	addi	sp,sp,16
80001720:	8082                	ret
80001722:	0001                	nop

80001724 <riscv_irq_global_disable>:

void riscv_irq_global_disable(void)
{
80001724:	1141                	addi	sp,sp,-16
80001726:	c606                	sw	ra,12(sp)
80001728:	c422                	sw	s0,8(sp)
8000172a:	0800                	addi	s0,sp,16
    //clear_csr(mstatus, MSTATUS_MPIE);
    csr_clr_bits_mstatus(MSTATUS_MIE_BIT_MASK);
8000172c:	4521                	li	a0,8
8000172e:	3d7d                	jal	800015ec <csr_clr_bits_mstatus>
}
80001730:	0001                	nop
80001732:	40b2                	lw	ra,12(sp)
80001734:	4422                	lw	s0,8(sp)
80001736:	0141                	addi	sp,sp,16
80001738:	8082                	ret
8000173a:	0001                	nop

8000173c <irq_entry>:

// #pragma GCC push_options
// // Force the alignment for mtvec.BASE. A 'C' extension program could be aligned to to bytes.

void irq_entry (void)
{
8000173c:	7171                	addi	sp,sp,-176
8000173e:	d706                	sw	ra,172(sp)
80001740:	d516                	sw	t0,168(sp)
80001742:	d31a                	sw	t1,164(sp)
80001744:	d11e                	sw	t2,160(sp)
80001746:	cf22                	sw	s0,156(sp)
80001748:	cd2a                	sw	a0,152(sp)
8000174a:	cb2e                	sw	a1,148(sp)
8000174c:	c932                	sw	a2,144(sp)
8000174e:	c736                	sw	a3,140(sp)
80001750:	c53a                	sw	a4,136(sp)
80001752:	c33e                	sw	a5,132(sp)
80001754:	c142                	sw	a6,128(sp)
80001756:	dec6                	sw	a7,124(sp)
80001758:	dcf2                	sw	t3,120(sp)
8000175a:	daf6                	sw	t4,116(sp)
8000175c:	d8fa                	sw	t5,112(sp)
8000175e:	d6fe                	sw	t6,108(sp)
80001760:	ee82                	fsw	ft0,92(sp)
80001762:	ec86                	fsw	ft1,88(sp)
80001764:	ea8a                	fsw	ft2,84(sp)
80001766:	e88e                	fsw	ft3,80(sp)
80001768:	e692                	fsw	ft4,76(sp)
8000176a:	e496                	fsw	ft5,72(sp)
8000176c:	e29a                	fsw	ft6,68(sp)
8000176e:	e09e                	fsw	ft7,64(sp)
80001770:	fe2a                	fsw	fa0,60(sp)
80001772:	fc2e                	fsw	fa1,56(sp)
80001774:	fa32                	fsw	fa2,52(sp)
80001776:	f836                	fsw	fa3,48(sp)
80001778:	f63a                	fsw	fa4,44(sp)
8000177a:	f43e                	fsw	fa5,40(sp)
8000177c:	f242                	fsw	fa6,36(sp)
8000177e:	f046                	fsw	fa7,32(sp)
80001780:	ee72                	fsw	ft8,28(sp)
80001782:	ec76                	fsw	ft9,24(sp)
80001784:	ea7a                	fsw	ft10,20(sp)
80001786:	e87e                	fsw	ft11,16(sp)
80001788:	1900                	addi	s0,sp,176
	uint_xlen_t this_cause = csr_read_mcause();
8000178a:	3dc9                	jal	8000165c <csr_read_mcause>
8000178c:	f4a42e23          	sw	a0,-164(s0)

	if((this_cause & MCAUSE_INTERRUPT_BIT_MASK) == 0) {
80001790:	f5c42783          	lw	a5,-164(s0)
80001794:	0207c963          	bltz	a5,800017c6 <irq_entry+0x8a>
		// handle exception
		switch (this_cause & MCAUSE_EXCEPTION_CODE_BIT_MASK)
80001798:	f5c42703          	lw	a4,-164(s0)
8000179c:	400007b7          	lui	a5,0x40000
800017a0:	8ff9                	and	a5,a5,a4
800017a2:	4721                	li	a4,8
800017a4:	00f76b63          	bltu	a4,a5,800017ba <irq_entry+0x7e>
800017a8:	00279713          	slli	a4,a5,0x2
800017ac:	800097b7          	lui	a5,0x80009
800017b0:	4f478793          	addi	a5,a5,1268 # 800094f4 <__data_source_start+0xfffffad0>
800017b4:	97ba                	add	a5,a5,a4
800017b6:	439c                	lw	a5,0(a5)
800017b8:	8782                	jr	a5
			case RISCV_EXCP_ENVIRONMENT_CALL_FROM_U_MODE:
				break;

			default: // MCAUSE_EXCEPT UNKNOWN

				break;
800017ba:	0001                	nop
800017bc:	a019                	j	800017c2 <irq_entry+0x86>
				break;
800017be:	0001                	nop
		}

		while(1) {}; //TRAP
800017c0:	0001                	nop
800017c2:	0001                	nop
800017c4:	bffd                	j	800017c2 <irq_entry+0x86>
	} else {
		//handle interrupt
		this_cause &= 0xFF;
800017c6:	f5c42783          	lw	a5,-164(s0)
800017ca:	0ff7f793          	zext.b	a5,a5
800017ce:	f4f42e23          	sw	a5,-164(s0)
		if(riscv_handler_map[this_cause] != 0) {
800017d2:	e3018713          	addi	a4,gp,-464 # 400005b0 <riscv_handler_map>
800017d6:	f5c42783          	lw	a5,-164(s0)
800017da:	078a                	slli	a5,a5,0x2
800017dc:	97ba                	add	a5,a5,a4
800017de:	439c                	lw	a5,0(a5)
800017e0:	cb91                	beqz	a5,800017f4 <irq_entry+0xb8>
                  riscv_handler_map[this_cause]();
800017e2:	e3018713          	addi	a4,gp,-464 # 400005b0 <riscv_handler_map>
800017e6:	f5c42783          	lw	a5,-164(s0)
800017ea:	078a                	slli	a5,a5,0x2
800017ec:	97ba                	add	a5,a5,a4
800017ee:	439c                	lw	a5,0(a5)
800017f0:	9782                	jalr	a5
		}else{
			while(1) {}; //NO handler
		}
	}
}
800017f2:	a011                	j	800017f6 <irq_entry+0xba>
			while(1) {}; //NO handler
800017f4:	a001                	j	800017f4 <irq_entry+0xb8>
}
800017f6:	50ba                	lw	ra,172(sp)
800017f8:	52aa                	lw	t0,168(sp)
800017fa:	531a                	lw	t1,164(sp)
800017fc:	538a                	lw	t2,160(sp)
800017fe:	447a                	lw	s0,156(sp)
80001800:	456a                	lw	a0,152(sp)
80001802:	45da                	lw	a1,148(sp)
80001804:	464a                	lw	a2,144(sp)
80001806:	46ba                	lw	a3,140(sp)
80001808:	472a                	lw	a4,136(sp)
8000180a:	479a                	lw	a5,132(sp)
8000180c:	480a                	lw	a6,128(sp)
8000180e:	58f6                	lw	a7,124(sp)
80001810:	5e66                	lw	t3,120(sp)
80001812:	5ed6                	lw	t4,116(sp)
80001814:	5f46                	lw	t5,112(sp)
80001816:	5fb6                	lw	t6,108(sp)
80001818:	6076                	flw	ft0,92(sp)
8000181a:	60e6                	flw	ft1,88(sp)
8000181c:	6156                	flw	ft2,84(sp)
8000181e:	61c6                	flw	ft3,80(sp)
80001820:	6236                	flw	ft4,76(sp)
80001822:	62a6                	flw	ft5,72(sp)
80001824:	6316                	flw	ft6,68(sp)
80001826:	6386                	flw	ft7,64(sp)
80001828:	7572                	flw	fa0,60(sp)
8000182a:	75e2                	flw	fa1,56(sp)
8000182c:	7652                	flw	fa2,52(sp)
8000182e:	76c2                	flw	fa3,48(sp)
80001830:	7732                	flw	fa4,44(sp)
80001832:	77a2                	flw	fa5,40(sp)
80001834:	7812                	flw	fa6,36(sp)
80001836:	7882                	flw	fa7,32(sp)
80001838:	6e72                	flw	ft8,28(sp)
8000183a:	6ee2                	flw	ft9,24(sp)
8000183c:	6f52                	flw	ft10,20(sp)
8000183e:	6fc2                	flw	ft11,16(sp)
80001840:	614d                	addi	sp,sp,176
80001842:	30200073          	mret
	...

80001848 <SystemCoreClockUpdate>:
uint32_t SystemPll1Clock; // System PLL1Clock Frequency
uint32_t USBClock; 		  // USB Clock Frequency (USB PLL Clock)

//-- Functions -----------------------------------------------------------------
void SystemCoreClockUpdate(void)
{
80001848:	7175                	addi	sp,sp,-144
8000184a:	c706                	sw	ra,140(sp)
8000184c:	c522                	sw	s0,136(sp)
8000184e:	c34a                	sw	s2,132(sp)
80001850:	c14e                	sw	s3,128(sp)
80001852:	ded2                	sw	s4,124(sp)
80001854:	dcd6                	sw	s5,120(sp)
80001856:	dada                	sw	s6,116(sp)
80001858:	d8de                	sw	s7,112(sp)
8000185a:	d6e2                	sw	s8,108(sp)
8000185c:	d4e6                	sw	s9,104(sp)
8000185e:	d2ea                	sw	s10,100(sp)
80001860:	d0ee                	sw	s11,96(sp)
80001862:	0900                	addi	s0,sp,144
	SystemCoreClock = 0; 	// При ошибке вычислений значения переменных будут равны нулю
80001864:	e001ac23          	sw	zero,-488(gp) # 40000598 <SystemCoreClock>
	SystemPll0Clock = 0; 
80001868:	e001ae23          	sw	zero,-484(gp) # 4000059c <SystemPll0Clock>
	SystemPll1Clock = 0; 
8000186c:	e201a023          	sw	zero,-480(gp) # 400005a0 <SystemPll1Clock>
	USBClock = 0; 		 
80001870:	e201a223          	sw	zero,-476(gp) # 400005a4 <USBClock>
				
	uint8_t refdiv = RCU->PLLSYSCFG0_bit.REFDIV;
80001874:	3000e7b7          	lui	a5,0x3000e
80001878:	4bbc                	lw	a5,80(a5)
8000187a:	839d                	srli	a5,a5,0x7
8000187c:	03f7f793          	andi	a5,a5,63
80001880:	0ff7f793          	zext.b	a5,a5
80001884:	fcf407a3          	sb	a5,-49(s0)
	uint8_t pd0a = RCU->PLLSYSCFG0_bit.PD0A + 1;
80001888:	3000e7b7          	lui	a5,0x3000e
8000188c:	4bbc                	lw	a5,80(a5)
8000188e:	83b5                	srli	a5,a5,0xd
80001890:	8b9d                	andi	a5,a5,7
80001892:	0ff7f793          	zext.b	a5,a5
80001896:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80001898:	fcf40723          	sb	a5,-50(s0)
	uint8_t pd0b = RCU->PLLSYSCFG0_bit.PD0B + 1;
8000189c:	3000e7b7          	lui	a5,0x3000e
800018a0:	4bbc                	lw	a5,80(a5)
800018a2:	83c1                	srli	a5,a5,0x10
800018a4:	03f7f793          	andi	a5,a5,63
800018a8:	0ff7f793          	zext.b	a5,a5
800018ac:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
800018ae:	fcf406a3          	sb	a5,-51(s0)
	uint8_t pd1a = RCU->PLLSYSCFG0_bit.PD1A + 1;
800018b2:	3000e7b7          	lui	a5,0x3000e
800018b6:	4bbc                	lw	a5,80(a5)
800018b8:	83d9                	srli	a5,a5,0x16
800018ba:	8b9d                	andi	a5,a5,7
800018bc:	0ff7f793          	zext.b	a5,a5
800018c0:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
800018c2:	fcf40623          	sb	a5,-52(s0)
	uint8_t pd1b = RCU->PLLSYSCFG0_bit.PD1B + 1;
800018c6:	3000e7b7          	lui	a5,0x3000e
800018ca:	4bbc                	lw	a5,80(a5)
800018cc:	83e5                	srli	a5,a5,0x19
800018ce:	03f7f793          	andi	a5,a5,63
800018d2:	0ff7f793          	zext.b	a5,a5
800018d6:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
800018d8:	fcf405a3          	sb	a5,-53(s0)

	if (RCU->PLLSYSCFG0_bit.PLLEN)		// Если PLL включен
800018dc:	3000e7b7          	lui	a5,0x3000e
800018e0:	4bbc                	lw	a5,80(a5)
800018e2:	8b85                	andi	a5,a5,1
800018e4:	0ff7f793          	zext.b	a5,a5
800018e8:	20078263          	beqz	a5,80001aec <SystemCoreClockUpdate+0x2a4>
	{	
		if (RCU->PLLSYSCFG0_bit.DSMEN)	// Если дробный делитель включен
800018ec:	3000e7b7          	lui	a5,0x3000e
800018f0:	4bbc                	lw	a5,80(a5)
800018f2:	8391                	srli	a5,a5,0x4
800018f4:	8b85                	andi	a5,a5,1
800018f6:	0ff7f793          	zext.b	a5,a5
800018fa:	18078263          	beqz	a5,80001a7e <SystemCoreClockUpdate+0x236>
		{
			uint64_t fbdiv = RCU->PLLSYSCFG2_bit.FBDIV << 24;
800018fe:	3000e7b7          	lui	a5,0x3000e
80001902:	4fbc                	lw	a5,88(a5)
80001904:	873e                	mv	a4,a5
80001906:	6785                	lui	a5,0x1
80001908:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
8000190a:	8ff9                	and	a5,a5,a4
8000190c:	07c2                	slli	a5,a5,0x10
8000190e:	83c1                	srli	a5,a5,0x10
80001910:	07e2                	slli	a5,a5,0x18
80001912:	faf42c23          	sw	a5,-72(s0)
80001916:	87fd                	srai	a5,a5,0x1f
80001918:	faf42e23          	sw	a5,-68(s0)
			uint32_t frac = RCU->PLLSYSCFG1_bit.FRAC;
8000191c:	3000e7b7          	lui	a5,0x3000e
80001920:	4bf8                	lw	a4,84(a5)
80001922:	010007b7          	lui	a5,0x1000
80001926:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
80001928:	8ff9                	and	a5,a5,a4
8000192a:	faf42a23          	sw	a5,-76(s0)
			SystemPll0Clock = (((HSECLK_VAL / refdiv) * (fbdiv + frac)) >> 24) / (pd0a * pd0b);
8000192e:	fcf44703          	lbu	a4,-49(s0)
80001932:	00f427b7          	lui	a5,0xf42
80001936:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
8000193a:	02e7c7b3          	div	a5,a5,a4
8000193e:	8e3e                	mv	t3,a5
80001940:	87fd                	srai	a5,a5,0x1f
80001942:	8ebe                	mv	t4,a5
80001944:	fb442783          	lw	a5,-76(s0)
80001948:	8f3e                	mv	t5,a5
8000194a:	4f81                	li	t6,0
8000194c:	fb842703          	lw	a4,-72(s0)
80001950:	fbc42783          	lw	a5,-68(s0)
80001954:	00ef0533          	add	a0,t5,a4
80001958:	86aa                	mv	a3,a0
8000195a:	01e6b6b3          	sltu	a3,a3,t5
8000195e:	00ff85b3          	add	a1,t6,a5
80001962:	00b687b3          	add	a5,a3,a1
80001966:	85be                	mv	a1,a5
80001968:	872a                	mv	a4,a0
8000196a:	87ae                	mv	a5,a1
8000196c:	02ee8633          	mul	a2,t4,a4
80001970:	03c786b3          	mul	a3,a5,t3
80001974:	96b2                	add	a3,a3,a2
80001976:	02ee0633          	mul	a2,t3,a4
8000197a:	02ee38b3          	mulhu	a7,t3,a4
8000197e:	8832                	mv	a6,a2
80001980:	011687b3          	add	a5,a3,a7
80001984:	88be                	mv	a7,a5
80001986:	00889793          	slli	a5,a7,0x8
8000198a:	01885313          	srli	t1,a6,0x18
8000198e:	0067e333          	or	t1,a5,t1
80001992:	0188d393          	srli	t2,a7,0x18
80001996:	fce44703          	lbu	a4,-50(s0)
8000199a:	fcd44783          	lbu	a5,-51(s0)
8000199e:	02f707b3          	mul	a5,a4,a5
800019a2:	f8f42c23          	sw	a5,-104(s0)
800019a6:	87fd                	srai	a5,a5,0x1f
800019a8:	f8f42e23          	sw	a5,-100(s0)
800019ac:	f9842603          	lw	a2,-104(s0)
800019b0:	f9c42683          	lw	a3,-100(s0)
800019b4:	851a                	mv	a0,t1
800019b6:	859e                	mv	a1,t2
800019b8:	6a6070ef          	jal	ra,8000905e <__udivdi3>
800019bc:	872a                	mv	a4,a0
800019be:	87ae                	mv	a5,a1
800019c0:	e0e1ae23          	sw	a4,-484(gp) # 4000059c <SystemPll0Clock>
			SystemPll1Clock = (((HSECLK_VAL / refdiv) * (fbdiv + frac)) >> 24) / (pd1a * pd1b);
800019c4:	fcf44783          	lbu	a5,-49(s0)
800019c8:	00f42737          	lui	a4,0xf42
800019cc:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
800019d0:	02f747b3          	div	a5,a4,a5
800019d4:	f8f42823          	sw	a5,-112(s0)
800019d8:	87fd                	srai	a5,a5,0x1f
800019da:	f8f42a23          	sw	a5,-108(s0)
800019de:	fb442783          	lw	a5,-76(s0)
800019e2:	f8f42423          	sw	a5,-120(s0)
800019e6:	f8042623          	sw	zero,-116(s0)
800019ea:	fb842603          	lw	a2,-72(s0)
800019ee:	fbc42683          	lw	a3,-68(s0)
800019f2:	f8842803          	lw	a6,-120(s0)
800019f6:	f8c42883          	lw	a7,-116(s0)
800019fa:	85c2                	mv	a1,a6
800019fc:	00c58733          	add	a4,a1,a2
80001a00:	85ba                	mv	a1,a4
80001a02:	8542                	mv	a0,a6
80001a04:	00a5b5b3          	sltu	a1,a1,a0
80001a08:	8546                	mv	a0,a7
80001a0a:	00d507b3          	add	a5,a0,a3
80001a0e:	00f586b3          	add	a3,a1,a5
80001a12:	87b6                	mv	a5,a3
80001a14:	f9042503          	lw	a0,-112(s0)
80001a18:	f9442583          	lw	a1,-108(s0)
80001a1c:	86ae                	mv	a3,a1
80001a1e:	02e68633          	mul	a2,a3,a4
80001a22:	86aa                	mv	a3,a0
80001a24:	02d786b3          	mul	a3,a5,a3
80001a28:	96b2                	add	a3,a3,a2
80001a2a:	862a                	mv	a2,a0
80001a2c:	02e60633          	mul	a2,a2,a4
80001a30:	85aa                	mv	a1,a0
80001a32:	02e5bab3          	mulhu	s5,a1,a4
80001a36:	8a32                	mv	s4,a2
80001a38:	015687b3          	add	a5,a3,s5
80001a3c:	8abe                	mv	s5,a5
80001a3e:	008a9793          	slli	a5,s5,0x8
80001a42:	018a5c13          	srli	s8,s4,0x18
80001a46:	0187ec33          	or	s8,a5,s8
80001a4a:	018adc93          	srli	s9,s5,0x18
80001a4e:	fcc44703          	lbu	a4,-52(s0)
80001a52:	fcb44783          	lbu	a5,-53(s0)
80001a56:	02f707b3          	mul	a5,a4,a5
80001a5a:	f8f42023          	sw	a5,-128(s0)
80001a5e:	87fd                	srai	a5,a5,0x1f
80001a60:	f8f42223          	sw	a5,-124(s0)
80001a64:	f8042603          	lw	a2,-128(s0)
80001a68:	f8442683          	lw	a3,-124(s0)
80001a6c:	8562                	mv	a0,s8
80001a6e:	85e6                	mv	a1,s9
80001a70:	5ee070ef          	jal	ra,8000905e <__udivdi3>
80001a74:	872a                	mv	a4,a0
80001a76:	87ae                	mv	a5,a1
80001a78:	e2e1a023          	sw	a4,-480(gp) # 400005a0 <SystemPll1Clock>
80001a7c:	a885                	j	80001aec <SystemCoreClockUpdate+0x2a4>
		} else { 
			uint32_t fbdiv = RCU->PLLSYSCFG2_bit.FBDIV;			
80001a7e:	3000e7b7          	lui	a5,0x3000e
80001a82:	4fbc                	lw	a5,88(a5)
80001a84:	873e                	mv	a4,a5
80001a86:	6785                	lui	a5,0x1
80001a88:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80001a8a:	8ff9                	and	a5,a5,a4
80001a8c:	07c2                	slli	a5,a5,0x10
80001a8e:	83c1                	srli	a5,a5,0x10
80001a90:	fcf42223          	sw	a5,-60(s0)
			SystemPll0Clock = (HSECLK_VAL * fbdiv) / (refdiv * pd0a * pd0b);
80001a94:	fc442703          	lw	a4,-60(s0)
80001a98:	00f427b7          	lui	a5,0xf42
80001a9c:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80001aa0:	02f707b3          	mul	a5,a4,a5
80001aa4:	fcf44683          	lbu	a3,-49(s0)
80001aa8:	fce44703          	lbu	a4,-50(s0)
80001aac:	02e686b3          	mul	a3,a3,a4
80001ab0:	fcd44703          	lbu	a4,-51(s0)
80001ab4:	02e68733          	mul	a4,a3,a4
80001ab8:	02e7d733          	divu	a4,a5,a4
80001abc:	e0e1ae23          	sw	a4,-484(gp) # 4000059c <SystemPll0Clock>
			SystemPll1Clock = (HSECLK_VAL * fbdiv) / (refdiv * pd1a * pd1b);
80001ac0:	fc442703          	lw	a4,-60(s0)
80001ac4:	00f427b7          	lui	a5,0xf42
80001ac8:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80001acc:	02f707b3          	mul	a5,a4,a5
80001ad0:	fcf44683          	lbu	a3,-49(s0)
80001ad4:	fcc44703          	lbu	a4,-52(s0)
80001ad8:	02e686b3          	mul	a3,a3,a4
80001adc:	fcb44703          	lbu	a4,-53(s0)
80001ae0:	02e68733          	mul	a4,a3,a4
80001ae4:	02e7d733          	divu	a4,a5,a4
80001ae8:	e2e1a023          	sw	a4,-480(gp) # 400005a0 <SystemPll1Clock>
		}
	}

	switch (RCU->CLKSTAT_bit.SRC) {		// Определение источника тактирования ядра
80001aec:	3000e7b7          	lui	a5,0x3000e
80001af0:	5fdc                	lw	a5,60(a5)
80001af2:	8b8d                	andi	a5,a5,3
80001af4:	0ff7f793          	zext.b	a5,a5
80001af8:	470d                	li	a4,3
80001afa:	02e78963          	beq	a5,a4,80001b2c <SystemCoreClockUpdate+0x2e4>
80001afe:	470d                	li	a4,3
80001b00:	00f74863          	blt	a4,a5,80001b10 <SystemCoreClockUpdate+0x2c8>
80001b04:	4705                	li	a4,1
80001b06:	00e78c63          	beq	a5,a4,80001b1e <SystemCoreClockUpdate+0x2d6>
80001b0a:	4709                	li	a4,2
80001b0c:	02e78463          	beq	a5,a4,80001b34 <SystemCoreClockUpdate+0x2ec>
		case RCU_CLKSTAT_SRC_HSICLK:
			SystemCoreClock = HSICLK_VAL;
80001b10:	000f4737          	lui	a4,0xf4
80001b14:	24070713          	addi	a4,a4,576 # f4240 <STACK_SIZE+0xf3a40>
80001b18:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
			break;
80001b1c:	a00d                	j	80001b3e <SystemCoreClockUpdate+0x2f6>
		case RCU_CLKSTAT_SRC_HSECLK:
			SystemCoreClock = HSECLK_VAL;
80001b1e:	00f42737          	lui	a4,0xf42
80001b22:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
80001b26:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
			break;		
80001b2a:	a811                	j	80001b3e <SystemCoreClockUpdate+0x2f6>
		case RCU_CLKSTAT_SRC_LSICLK:
			SystemCoreClock = LSICLK_VAL;
80001b2c:	6721                	lui	a4,0x8
80001b2e:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
			break;
80001b32:	a031                	j	80001b3e <SystemCoreClockUpdate+0x2f6>
		case RCU_CLKSTAT_SRC_SYSPLL0CLK:
			SystemCoreClock = SystemPll0Clock;
80001b34:	e1c1a703          	lw	a4,-484(gp) # 4000059c <SystemPll0Clock>
80001b38:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
			break;	
80001b3c:	0001                	nop
    }
		
	if (RCU->RSTDISAHB_bit.USBEN)	// Если USB используется
80001b3e:	3000e7b7          	lui	a5,0x3000e
80001b42:	4b9c                	lw	a5,16(a5)
80001b44:	8385                	srli	a5,a5,0x1
80001b46:	8b85                	andi	a5,a5,1
80001b48:	0ff7f793          	zext.b	a5,a5
80001b4c:	1a078b63          	beqz	a5,80001d02 <SystemCoreClockUpdate+0x4ba>
	{
		if (USB->PLLUSBCFG3_bit.USBCLKSEL == USB_PLLUSBCFG3_USBCLKSEL_PLLUSBClk)
80001b50:	20010737          	lui	a4,0x20010
80001b54:	6785                	lui	a5,0x1
80001b56:	97ba                	add	a5,a5,a4
80001b58:	80c7a783          	lw	a5,-2036(a5) # 80c <STACK_SIZE+0xc>
80001b5c:	83e1                	srli	a5,a5,0x18
80001b5e:	8b85                	andi	a5,a5,1
80001b60:	0ff7f793          	zext.b	a5,a5
80001b64:	18079b63          	bnez	a5,80001cfa <SystemCoreClockUpdate+0x4b2>
		{	
			refdiv = USB->PLLUSBCFG0_bit.REFDIV;
80001b68:	20010737          	lui	a4,0x20010
80001b6c:	6785                	lui	a5,0x1
80001b6e:	97ba                	add	a5,a5,a4
80001b70:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
80001b74:	839d                	srli	a5,a5,0x7
80001b76:	03f7f793          	andi	a5,a5,63
80001b7a:	0ff7f793          	zext.b	a5,a5
80001b7e:	fcf407a3          	sb	a5,-49(s0)
			pd0a = USB->PLLUSBCFG0_bit.PD0A + 1;
80001b82:	20010737          	lui	a4,0x20010
80001b86:	6785                	lui	a5,0x1
80001b88:	97ba                	add	a5,a5,a4
80001b8a:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
80001b8e:	83b5                	srli	a5,a5,0xd
80001b90:	8b9d                	andi	a5,a5,7
80001b92:	0ff7f793          	zext.b	a5,a5
80001b96:	0785                	addi	a5,a5,1
80001b98:	fcf40723          	sb	a5,-50(s0)
			pd0b = USB->PLLUSBCFG0_bit.PD0B + 1;
80001b9c:	20010737          	lui	a4,0x20010
80001ba0:	6785                	lui	a5,0x1
80001ba2:	97ba                	add	a5,a5,a4
80001ba4:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
80001ba8:	83c1                	srli	a5,a5,0x10
80001baa:	03f7f793          	andi	a5,a5,63
80001bae:	0ff7f793          	zext.b	a5,a5
80001bb2:	0785                	addi	a5,a5,1
80001bb4:	fcf406a3          	sb	a5,-51(s0)

			if (USB->PLLUSBCFG0_bit.DSMEN)		// Если дробный делитель включен
80001bb8:	20010737          	lui	a4,0x20010
80001bbc:	6785                	lui	a5,0x1
80001bbe:	97ba                	add	a5,a5,a4
80001bc0:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
80001bc4:	8391                	srli	a5,a5,0x4
80001bc6:	8b85                	andi	a5,a5,1
80001bc8:	0ff7f793          	zext.b	a5,a5
80001bcc:	c3f5                	beqz	a5,80001cb0 <SystemCoreClockUpdate+0x468>
			{
				uint64_t fbdiv = USB->PLLUSBCFG2_bit.FBDIV << 24;
80001bce:	20010737          	lui	a4,0x20010
80001bd2:	6785                	lui	a5,0x1
80001bd4:	97ba                	add	a5,a5,a4
80001bd6:	8087a783          	lw	a5,-2040(a5) # 808 <STACK_SIZE+0x8>
80001bda:	873e                	mv	a4,a5
80001bdc:	6785                	lui	a5,0x1
80001bde:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80001be0:	8ff9                	and	a5,a5,a4
80001be2:	07c2                	slli	a5,a5,0x10
80001be4:	83c1                	srli	a5,a5,0x10
80001be6:	07e2                	slli	a5,a5,0x18
80001be8:	faf42423          	sw	a5,-88(s0)
80001bec:	87fd                	srai	a5,a5,0x1f
80001bee:	faf42623          	sw	a5,-84(s0)
				uint32_t frac = USB->PLLUSBCFG1_bit.FRAC;
80001bf2:	20010737          	lui	a4,0x20010
80001bf6:	6785                	lui	a5,0x1
80001bf8:	97ba                	add	a5,a5,a4
80001bfa:	8047a703          	lw	a4,-2044(a5) # 804 <STACK_SIZE+0x4>
80001bfe:	010007b7          	lui	a5,0x1000
80001c02:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
80001c04:	8ff9                	and	a5,a5,a4
80001c06:	faf42223          	sw	a5,-92(s0)

				USBClock = (((HSECLK_VAL / refdiv) * (fbdiv + frac)) >> 24) / (pd0a * pd0b);
80001c0a:	fcf44783          	lbu	a5,-49(s0)
80001c0e:	00f42737          	lui	a4,0xf42
80001c12:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
80001c16:	02f747b3          	div	a5,a4,a5
80001c1a:	8d3e                	mv	s10,a5
80001c1c:	87fd                	srai	a5,a5,0x1f
80001c1e:	8dbe                	mv	s11,a5
80001c20:	fa442783          	lw	a5,-92(s0)
80001c24:	f6f42c23          	sw	a5,-136(s0)
80001c28:	f6042e23          	sw	zero,-132(s0)
80001c2c:	fa842603          	lw	a2,-88(s0)
80001c30:	fac42683          	lw	a3,-84(s0)
80001c34:	f7842803          	lw	a6,-136(s0)
80001c38:	f7c42883          	lw	a7,-132(s0)
80001c3c:	85c2                	mv	a1,a6
80001c3e:	00c58733          	add	a4,a1,a2
80001c42:	85ba                	mv	a1,a4
80001c44:	8542                	mv	a0,a6
80001c46:	00a5b5b3          	sltu	a1,a1,a0
80001c4a:	8546                	mv	a0,a7
80001c4c:	00d507b3          	add	a5,a0,a3
80001c50:	00f586b3          	add	a3,a1,a5
80001c54:	87b6                	mv	a5,a3
80001c56:	02ed8633          	mul	a2,s11,a4
80001c5a:	03a786b3          	mul	a3,a5,s10
80001c5e:	96b2                	add	a3,a3,a2
80001c60:	02ed0633          	mul	a2,s10,a4
80001c64:	02ed39b3          	mulhu	s3,s10,a4
80001c68:	8932                	mv	s2,a2
80001c6a:	013687b3          	add	a5,a3,s3
80001c6e:	89be                	mv	s3,a5
80001c70:	00899793          	slli	a5,s3,0x8
80001c74:	01895b13          	srli	s6,s2,0x18
80001c78:	0167eb33          	or	s6,a5,s6
80001c7c:	0189db93          	srli	s7,s3,0x18
80001c80:	fce44703          	lbu	a4,-50(s0)
80001c84:	fcd44783          	lbu	a5,-51(s0)
80001c88:	02f707b3          	mul	a5,a4,a5
80001c8c:	f6f42823          	sw	a5,-144(s0)
80001c90:	87fd                	srai	a5,a5,0x1f
80001c92:	f6f42a23          	sw	a5,-140(s0)
80001c96:	f7042603          	lw	a2,-144(s0)
80001c9a:	f7442683          	lw	a3,-140(s0)
80001c9e:	855a                	mv	a0,s6
80001ca0:	85de                	mv	a1,s7
80001ca2:	3bc070ef          	jal	ra,8000905e <__udivdi3>
80001ca6:	872a                	mv	a4,a0
80001ca8:	87ae                	mv	a5,a1
80001caa:	e2e1a223          	sw	a4,-476(gp) # 400005a4 <USBClock>
				USBClock = (HSECLK_VAL * fbdiv) / (refdiv * pd0a * pd0b);
			}		
		} 
		else USBClock = SystemCoreClock;
	}
}
80001cae:	a891                	j	80001d02 <SystemCoreClockUpdate+0x4ba>
				uint32_t fbdiv = USB->PLLUSBCFG2_bit.FBDIV;			
80001cb0:	20010737          	lui	a4,0x20010
80001cb4:	6785                	lui	a5,0x1
80001cb6:	97ba                	add	a5,a5,a4
80001cb8:	8087a783          	lw	a5,-2040(a5) # 808 <STACK_SIZE+0x8>
80001cbc:	873e                	mv	a4,a5
80001cbe:	6785                	lui	a5,0x1
80001cc0:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80001cc2:	8ff9                	and	a5,a5,a4
80001cc4:	07c2                	slli	a5,a5,0x10
80001cc6:	83c1                	srli	a5,a5,0x10
80001cc8:	faf42823          	sw	a5,-80(s0)
				USBClock = (HSECLK_VAL * fbdiv) / (refdiv * pd0a * pd0b);
80001ccc:	fb042703          	lw	a4,-80(s0)
80001cd0:	00f427b7          	lui	a5,0xf42
80001cd4:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80001cd8:	02f707b3          	mul	a5,a4,a5
80001cdc:	fcf44683          	lbu	a3,-49(s0)
80001ce0:	fce44703          	lbu	a4,-50(s0)
80001ce4:	02e686b3          	mul	a3,a3,a4
80001ce8:	fcd44703          	lbu	a4,-51(s0)
80001cec:	02e68733          	mul	a4,a3,a4
80001cf0:	02e7d733          	divu	a4,a5,a4
80001cf4:	e2e1a223          	sw	a4,-476(gp) # 400005a4 <USBClock>
}
80001cf8:	a029                	j	80001d02 <SystemCoreClockUpdate+0x4ba>
		else USBClock = SystemCoreClock;
80001cfa:	e181a703          	lw	a4,-488(gp) # 40000598 <SystemCoreClock>
80001cfe:	e2e1a223          	sw	a4,-476(gp) # 400005a4 <USBClock>
}
80001d02:	0001                	nop
80001d04:	40ba                	lw	ra,140(sp)
80001d06:	442a                	lw	s0,136(sp)
80001d08:	491a                	lw	s2,132(sp)
80001d0a:	498a                	lw	s3,128(sp)
80001d0c:	5a76                	lw	s4,124(sp)
80001d0e:	5ae6                	lw	s5,120(sp)
80001d10:	5b56                	lw	s6,116(sp)
80001d12:	5bc6                	lw	s7,112(sp)
80001d14:	5c36                	lw	s8,108(sp)
80001d16:	5ca6                	lw	s9,104(sp)
80001d18:	5d16                	lw	s10,100(sp)
80001d1a:	5d86                	lw	s11,96(sp)
80001d1c:	6149                	addi	sp,sp,144
80001d1e:	8082                	ret

80001d20 <ClkInit>:

void ClkInit()
{
80001d20:	1101                	addi	sp,sp,-32
80001d22:	ce22                	sw	s0,28(sp)
80001d24:	1000                	addi	s0,sp,32
    uint32_t timeout_counter = 0;
80001d26:	fe042623          	sw	zero,-20(s0)
    uint32_t sysclk_source;

    //clockout control
    #ifndef CKO_NONE
        //C7 clockout
        RCU->CGCFGAHB_bit.GPIOCEN = 1;
80001d2a:	3000e7b7          	lui	a5,0x3000e
80001d2e:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80001d32:	40076713          	ori	a4,a4,1024
80001d36:	00e79023          	sh	a4,0(a5)
        RCU->RSTDISAHB_bit.GPIOCEN = 1;
80001d3a:	3000e7b7          	lui	a5,0x3000e
80001d3e:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80001d42:	40076713          	ori	a4,a4,1024
80001d46:	00e79823          	sh	a4,16(a5)
        GPIOC->ALTFUNCNUM_bit.PIN7 = 3;
80001d4a:	280027b7          	lui	a5,0x28002
80001d4e:	5fd4                	lw	a3,60(a5)
80001d50:	6731                	lui	a4,0xc
80001d52:	8f55                	or	a4,a4,a3
80001d54:	dfd8                	sw	a4,60(a5)
        GPIOC->ALTFUNCSET_bit.PIN7 = 1;
80001d56:	280027b7          	lui	a5,0x28002
80001d5a:	0347d703          	lhu	a4,52(a5) # 28002034 <STACK_SIZE+0x28001834>
80001d5e:	08076713          	ori	a4,a4,128
80001d62:	02e79a23          	sh	a4,52(a5)
        RCU->CLKOUTCFG = (RCU_CLKOUTCFG_CLKSEL_HSE << RCU_CLKOUTCFG_CLKSEL_Pos) |
				  	  	  (1 << RCU_CLKOUTCFG_DIVN_Pos) |
						  (0 << RCU_CLKOUTCFG_DIVEN_Pos) |
						  RCU_CLKOUTCFG_RSTDIS_Msk | RCU_CLKOUTCFG_CLKEN_Msk; //CKO = HSECLK
    #elif defined CKO_PLL0
        RCU->CLKOUTCFG = (RCU_CLKOUTCFG_CLKSEL_PLL0 << RCU_CLKOUTCFG_CLKSEL_Pos) |
80001d66:	3000e7b7          	lui	a5,0x3000e
80001d6a:	6745                	lui	a4,0x11
80001d6c:	12170713          	addi	a4,a4,289 # 11121 <STACK_SIZE+0x10921>
80001d70:	0ae7ae23          	sw	a4,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
    #endif
    #ifdef RTC_LSE
        // Переключаем RTC на LSE (OSC) (32 768 Гц)
		PMURTC->RTC_CFG0_bit.EXTOSC = 1;
    #endif
		RCU->SYSCLKCFG_bit.SRC = RCU_SYSCLKCFG_SRC_HSICLK;
80001d74:	3000e7b7          	lui	a5,0x3000e
80001d78:	5b98                	lw	a4,48(a5)
80001d7a:	9b71                	andi	a4,a4,-4
80001d7c:	db98                	sw	a4,48(a5)
//select system clock
#ifdef SYSCLK_PLL
	//PLLCLK = REFCLK * (FBDIV+FRAC/2^24) / (REFDIV*(1+PD0A)*(1+PD0B))
	
	//select HSE as source system clock while config PLL
	RCU->SYSCLKCFG = (RCU_SYSCLKCFG_SRC_HSECLK << RCU_SYSCLKCFG_SRC_Pos);
80001d7e:	3000e7b7          	lui	a5,0x3000e
80001d82:	4705                	li	a4,1
80001d84:	db98                	sw	a4,48(a5)
    // Wait switching done
    timeout_counter = 0;
80001d86:	fe042623          	sw	zero,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)){ //SYSCLK_SWITCH_TIMEOUT))
80001d8a:	a031                	j	80001d96 <ClkInit+0x76>
        timeout_counter++;
80001d8c:	fec42783          	lw	a5,-20(s0)
80001d90:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80001d92:	fef42623          	sw	a5,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)){ //SYSCLK_SWITCH_TIMEOUT))
80001d96:	3000e7b7          	lui	a5,0x3000e
80001d9a:	5fdc                	lw	a5,60(a5)
80001d9c:	8b8d                	andi	a5,a5,3
80001d9e:	0ff7f713          	zext.b	a4,a5
80001da2:	3000e7b7          	lui	a5,0x3000e
80001da6:	5b9c                	lw	a5,48(a5)
80001da8:	8b8d                	andi	a5,a5,3
80001daa:	0ff7f793          	zext.b	a5,a5
80001dae:	00f70863          	beq	a4,a5,80001dbe <ClkInit+0x9e>
80001db2:	fec42703          	lw	a4,-20(s0)
80001db6:	06300793          	li	a5,99
80001dba:	fce7f9e3          	bgeu	a5,a4,80001d8c <ClkInit+0x6c>
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
	RCU->PLLSYSCFG2 = 100;         //FBDIV
#elif (HSECLK_VAL == 16000000)
// Fout0 = 50 000 000 Hz
// Fout1 = 25 000 000 Hz
	RCU->PLLSYSCFG0 =( 15 << RCU_PLLSYSCFG0_PD1B_Pos) |  //PD1B
80001dbe:	3000e7b7          	lui	a5,0x3000e
80001dc2:	1ec3e737          	lui	a4,0x1ec3e
80001dc6:	08770713          	addi	a4,a4,135 # 1ec3e087 <STACK_SIZE+0x1ec3d887>
80001dca:	cbb8                	sw	a4,80(a5)
					 ( 0 << RCU_PLLSYSCFG0_FOUTEN_Pos)    |  //fouten
					 ( 0 << RCU_PLLSYSCFG0_DSMEN_Pos)     |  //dsmen
					 ( 0 << RCU_PLLSYSCFG0_DACEN_Pos)     |  //dacen
					 ( 3 << RCU_PLLSYSCFG0_BYP_Pos)       |  //bypass
					 ( 1 << RCU_PLLSYSCFG0_PLLEN_Pos);       //en
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
80001dcc:	3000e7b7          	lui	a5,0x3000e
80001dd0:	0407aa23          	sw	zero,84(a5) # 3000e054 <STACK_SIZE+0x3000d854>
	RCU->PLLSYSCFG2 = 100;         //FBDIV
80001dd4:	3000e7b7          	lui	a5,0x3000e
80001dd8:	06400713          	li	a4,100
80001ddc:	cfb8                	sw	a4,88(a5)
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
	RCU->PLLSYSCFG2 = 100;         //FBDIV
#else
#error "Please define HSECLK_VAL with correct values!"
#endif
	RCU->PLLSYSCFG0_bit.FOUTEN = 1; 	// Fout0 Enable
80001dde:	3000e7b7          	lui	a5,0x3000e
80001de2:	4bb8                	lw	a4,80(a5)
80001de4:	f9f77713          	andi	a4,a4,-97
80001de8:	02076713          	ori	a4,a4,32
80001dec:	cbb8                	sw	a4,80(a5)
	timeout_counter = 1000;
80001dee:	3e800793          	li	a5,1000
80001df2:	fef42623          	sw	a5,-20(s0)
	while(timeout_counter) timeout_counter--;
80001df6:	a031                	j	80001e02 <ClkInit+0xe2>
80001df8:	fec42783          	lw	a5,-20(s0)
80001dfc:	17fd                	addi	a5,a5,-1 # 3000dfff <STACK_SIZE+0x3000d7ff>
80001dfe:	fef42623          	sw	a5,-20(s0)
80001e02:	fec42783          	lw	a5,-20(s0)
80001e06:	fbed                	bnez	a5,80001df8 <ClkInit+0xd8>
	while((RCU->PLLSYSSTAT_bit.LOCK) != 1)
80001e08:	0001                	nop
80001e0a:	3000e7b7          	lui	a5,0x3000e
80001e0e:	53bc                	lw	a5,96(a5)
80001e10:	8b85                	andi	a5,a5,1
80001e12:	0ff7f713          	zext.b	a4,a5
80001e16:	4785                	li	a5,1
80001e18:	fef719e3          	bne	a4,a5,80001e0a <ClkInit+0xea>
	{}; 								// wait lock signal
	RCU->PLLSYSCFG0_bit.BYP = 2; 		// Bypass for Fout1
80001e1c:	3000e7b7          	lui	a5,0x3000e
80001e20:	4bb8                	lw	a4,80(a5)
80001e22:	9b65                	andi	a4,a4,-7
80001e24:	00476713          	ori	a4,a4,4
80001e28:	cbb8                	sw	a4,80(a5)
	//select PLL as source system clock
	sysclk_source = RCU_SYSCLKCFG_SRC_SYSPLL0CLK;
80001e2a:	4789                	li	a5,2
80001e2c:	fef42423          	sw	a5,-24(s0)
    // FLASH control settings
    FLASH->CTRL_bit.LAT = 3;
80001e30:	3000d7b7          	lui	a5,0x3000d
80001e34:	47f4                	lw	a3,76(a5)
80001e36:	fff10737          	lui	a4,0xfff10
80001e3a:	177d                	addi	a4,a4,-1 # fff0ffff <__data_source_start+0x7ff065db>
80001e3c:	8ef9                	and	a3,a3,a4
80001e3e:	00030737          	lui	a4,0x30
80001e42:	8f55                	or	a4,a4,a3
80001e44:	c7f8                	sw	a4,76(a5)
    FLASH->CTRL_bit.CEN = 1;
80001e46:	3000d7b7          	lui	a5,0x3000d
80001e4a:	47f8                	lw	a4,76(a5)
80001e4c:	00276713          	ori	a4,a4,2
80001e50:	c7f8                	sw	a4,76(a5)
#else
#error "Please define SYSCLK source (SYSCLK_PLL | SYSCLK_HSE | SYSCLK_HSI | SYSCLK_LSI)!"
#endif

    //switch sysclk
    RCU->SYSCLKCFG = (sysclk_source << RCU_SYSCLKCFG_SRC_Pos);
80001e52:	3000e7b7          	lui	a5,0x3000e
80001e56:	fe842703          	lw	a4,-24(s0)
80001e5a:	db98                	sw	a4,48(a5)
    // Wait switching done
    timeout_counter = 0;
80001e5c:	fe042623          	sw	zero,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)) //SYSCLK_SWITCH_TIMEOUT))
80001e60:	a031                	j	80001e6c <ClkInit+0x14c>
        timeout_counter++;
80001e62:	fec42783          	lw	a5,-20(s0)
80001e66:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80001e68:	fef42623          	sw	a5,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)) //SYSCLK_SWITCH_TIMEOUT))
80001e6c:	3000e7b7          	lui	a5,0x3000e
80001e70:	5fdc                	lw	a5,60(a5)
80001e72:	8b8d                	andi	a5,a5,3
80001e74:	0ff7f713          	zext.b	a4,a5
80001e78:	3000e7b7          	lui	a5,0x3000e
80001e7c:	5b9c                	lw	a5,48(a5)
80001e7e:	8b8d                	andi	a5,a5,3
80001e80:	0ff7f793          	zext.b	a5,a5
80001e84:	00f70863          	beq	a4,a5,80001e94 <ClkInit+0x174>
80001e88:	fec42703          	lw	a4,-20(s0)
80001e8c:	06300793          	li	a5,99
80001e90:	fce7f9e3          	bgeu	a5,a4,80001e62 <ClkInit+0x142>
/*    if (timeout_counter == SYSCLK_SWITCH_TIMEOUT) //SYSCLK failed to switch
        while (1) {
        };*/

}
80001e94:	0001                	nop
80001e96:	4472                	lw	s0,28(sp)
80001e98:	6105                	addi	sp,sp,32
80001e9a:	8082                	ret

80001e9c <InterruptEnable>:

void InterruptEnable()
{
80001e9c:	1101                	addi	sp,sp,-32
80001e9e:	ce06                	sw	ra,28(sp)
80001ea0:	cc22                	sw	s0,24(sp)
80001ea2:	1000                	addi	s0,sp,32
	// Разрешаем все прерывания в machine mode
	PLIC_SetThreshold (Plic_Mach_Target, 0);
80001ea4:	4581                	li	a1,0
80001ea6:	4501                	li	a0,0
80001ea8:	a9dfe0ef          	jal	ra,80000944 <PLIC_SetThreshold>
    // Выключаем прерывание от MTIMER (если MTIMER используется в проекте - закомментировать следующую строку)
    clear_csr(mie, MIE_MTIMER);
80001eac:	08000793          	li	a5,128
80001eb0:	fef42623          	sw	a5,-20(s0)
80001eb4:	fec42783          	lw	a5,-20(s0)
80001eb8:	3047b7f3          	csrrc	a5,mie,a5
80001ebc:	fef42623          	sw	a5,-20(s0)
    // Разрешаем внешнее прерывание (PLIC) в machine mode
    set_csr(mie, MIE_MEXTERNAL);
80001ec0:	6785                	lui	a5,0x1
80001ec2:	80078793          	addi	a5,a5,-2048 # 800 <STACK_SIZE>
80001ec6:	fef42423          	sw	a5,-24(s0)
80001eca:	fe842783          	lw	a5,-24(s0)
80001ece:	3047a7f3          	csrrs	a5,mie,a5
80001ed2:	fef42423          	sw	a5,-24(s0)
    // Разрешаем прерывания на глобальном уровне
    set_csr(mstatus, MSTATUS_MIE);
80001ed6:	47a1                	li	a5,8
80001ed8:	fef42223          	sw	a5,-28(s0)
80001edc:	fe442783          	lw	a5,-28(s0)
80001ee0:	3007a7f3          	csrrs	a5,mstatus,a5
80001ee4:	fef42223          	sw	a5,-28(s0)
}
80001ee8:	0001                	nop
80001eea:	40f2                	lw	ra,28(sp)
80001eec:	4462                	lw	s0,24(sp)
80001eee:	6105                	addi	sp,sp,32
80001ef0:	8082                	ret

80001ef2 <InterruptDisable>:

void InterruptDisable()
{
80001ef2:	1101                	addi	sp,sp,-32
80001ef4:	ce06                	sw	ra,28(sp)
80001ef6:	cc22                	sw	s0,24(sp)
80001ef8:	1000                	addi	s0,sp,32
	// Запрещаем все прерывания в machine mode
	PLIC_SetThreshold (Plic_Mach_Target, 7);
80001efa:	459d                	li	a1,7
80001efc:	4501                	li	a0,0
80001efe:	a47fe0ef          	jal	ra,80000944 <PLIC_SetThreshold>
    // Выключаем внешнее прерывание (PLIC) в machine mode
    clear_csr(mie, MIE_MEXTERNAL);
80001f02:	6785                	lui	a5,0x1
80001f04:	80078793          	addi	a5,a5,-2048 # 800 <STACK_SIZE>
80001f08:	fef42623          	sw	a5,-20(s0)
80001f0c:	fec42783          	lw	a5,-20(s0)
80001f10:	3047b7f3          	csrrc	a5,mie,a5
80001f14:	fef42623          	sw	a5,-20(s0)
    // Запрещаем прерывания на глобальном уровне
    clear_csr(mstatus, MSTATUS_MIE);
80001f18:	47a1                	li	a5,8
80001f1a:	fef42423          	sw	a5,-24(s0)
80001f1e:	fe842783          	lw	a5,-24(s0)
80001f22:	3007b7f3          	csrrc	a5,mstatus,a5
80001f26:	fef42423          	sw	a5,-24(s0)
}
80001f2a:	0001                	nop
80001f2c:	40f2                	lw	ra,28(sp)
80001f2e:	4462                	lw	s0,24(sp)
80001f30:	6105                	addi	sp,sp,32
80001f32:	8082                	ret

80001f34 <SystemInit>:

void SystemInit(void)
{
80001f34:	1141                	addi	sp,sp,-16
80001f36:	c606                	sw	ra,12(sp)
80001f38:	c422                	sw	s0,8(sp)
80001f3a:	0800                	addi	s0,sp,16
	ClkInit();
80001f3c:	33d5                	jal	80001d20 <ClkInit>
}
80001f3e:	0001                	nop
80001f40:	40b2                	lw	ra,12(sp)
80001f42:	4422                	lw	s0,8(sp)
80001f44:	0141                	addi	sp,sp,16
80001f46:	8082                	ret

80001f48 <TMR32_SetMode>:
  * @brief   Выбор режима счёта
  * @param   mode Режим счёта
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetMode(TMR32_Mode_TypeDef mode)
{
80001f48:	1101                	addi	sp,sp,-32
80001f4a:	ce22                	sw	s0,28(sp)
80001f4c:	1000                	addi	s0,sp,32
80001f4e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_MODE(mode));

  MODIFY_REG(TMR32->CTRL, TMR32_CTRL_MODE_Msk, (uint32_t) mode << TMR32_CTRL_MODE_Pos);
80001f52:	300007b7          	lui	a5,0x30000
80001f56:	439c                	lw	a5,0(a5)
80001f58:	fcf7f693          	andi	a3,a5,-49
80001f5c:	fec42783          	lw	a5,-20(s0)
80001f60:	00479713          	slli	a4,a5,0x4
80001f64:	300007b7          	lui	a5,0x30000
80001f68:	8f55                	or	a4,a4,a3
80001f6a:	c398                	sw	a4,0(a5)
}
80001f6c:	0001                	nop
80001f6e:	4472                	lw	s0,28(sp)
80001f70:	6105                	addi	sp,sp,32
80001f72:	8082                	ret

80001f74 <TMR32_SetDivider>:
  * @brief   Выбор выходного делителя частоты таймера
  * @param   div Делитель частоты
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetDivider(TMR32_Div_TypeDef div)
{
80001f74:	1101                	addi	sp,sp,-32
80001f76:	ce22                	sw	s0,28(sp)
80001f78:	1000                	addi	s0,sp,32
80001f7a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_DIV(div));

  MODIFY_REG(TMR32->CTRL, TMR32_CTRL_DIV_Msk, (uint32_t) div << TMR32_CTRL_DIV_Pos);
80001f7e:	300007b7          	lui	a5,0x30000
80001f82:	439c                	lw	a5,0(a5)
80001f84:	f3f7f693          	andi	a3,a5,-193
80001f88:	fec42783          	lw	a5,-20(s0)
80001f8c:	00679713          	slli	a4,a5,0x6
80001f90:	300007b7          	lui	a5,0x30000
80001f94:	8f55                	or	a4,a4,a3
80001f96:	c398                	sw	a4,0(a5)
}
80001f98:	0001                	nop
80001f9a:	4472                	lw	s0,28(sp)
80001f9c:	6105                	addi	sp,sp,32
80001f9e:	8082                	ret

80001fa0 <TMR32_SetClksel>:
  * @brief   Выбор источника тактированного сигнала
  * @param   sel Источник тактирования
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetClksel(TMR32_Clksel_TypeDef sel)
{
80001fa0:	1101                	addi	sp,sp,-32
80001fa2:	ce22                	sw	s0,28(sp)
80001fa4:	1000                	addi	s0,sp,32
80001fa6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_CLKSEL(sel));

  MODIFY_REG(TMR32->CTRL, TMR32_CTRL_CLKSEL_Msk, (uint32_t) sel << TMR32_CTRL_CLKSEL_Pos);
80001faa:	300007b7          	lui	a5,0x30000
80001fae:	439c                	lw	a5,0(a5)
80001fb0:	eff7f693          	andi	a3,a5,-257
80001fb4:	fec42783          	lw	a5,-20(s0)
80001fb8:	00879713          	slli	a4,a5,0x8
80001fbc:	300007b7          	lui	a5,0x30000
80001fc0:	8f55                	or	a4,a4,a3
80001fc2:	c398                	sw	a4,0(a5)
}
80001fc4:	0001                	nop
80001fc6:	4472                	lw	s0,28(sp)
80001fc8:	6105                	addi	sp,sp,32
80001fca:	8082                	ret

80001fcc <TMR32_SetCounter>:
  * @brief   Установка значения счетчика
  * @param   CountVal  Значение счетчика
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetCounter(uint32_t CountVal)
{
80001fcc:	1101                	addi	sp,sp,-32
80001fce:	ce22                	sw	s0,28(sp)
80001fd0:	1000                	addi	s0,sp,32
80001fd2:	fea42623          	sw	a0,-20(s0)
  WRITE_REG(TMR32->COUNT, CountVal);
80001fd6:	300007b7          	lui	a5,0x30000
80001fda:	fec42703          	lw	a4,-20(s0)
80001fde:	c3d8                	sw	a4,4(a5)
}
80001fe0:	0001                	nop
80001fe2:	4472                	lw	s0,28(sp)
80001fe4:	6105                	addi	sp,sp,32
80001fe6:	8082                	ret

80001fe8 <TMR32_ITCmd>:
  * @param   it Номер маскированного прерывания типа @ref TMR32_IT_TypeDef
  * @param   state Флаг для включения маскированного прерывания
  * @retval  void
  */
__STATIC_INLINE void TMR32_ITCmd(TMR32_IT_TypeDef it, FunctionalState state)
{
80001fe8:	1101                	addi	sp,sp,-32
80001fea:	ce22                	sw	s0,28(sp)
80001fec:	1000                	addi	s0,sp,32
80001fee:	fea42623          	sw	a0,-20(s0)
80001ff2:	feb42423          	sw	a1,-24(s0)
  assert_param(IS_TMR32_IT(it));
  assert_param(IS_FUNCTIONAL_STATE(state));

  MODIFY_REG(TMR32->IM, it, (uint32_t) state * (uint32_t) it);
80001ff6:	300007b7          	lui	a5,0x30000
80001ffa:	4798                	lw	a4,8(a5)
80001ffc:	fec42783          	lw	a5,-20(s0)
80002000:	fff7c793          	not	a5,a5
80002004:	00f776b3          	and	a3,a4,a5
80002008:	fe842703          	lw	a4,-24(s0)
8000200c:	fec42783          	lw	a5,-20(s0)
80002010:	02f70733          	mul	a4,a4,a5
80002014:	300007b7          	lui	a5,0x30000
80002018:	8f55                	or	a4,a4,a3
8000201a:	c798                	sw	a4,8(a5)
}
8000201c:	0001                	nop
8000201e:	4472                	lw	s0,28(sp)
80002020:	6105                	addi	sp,sp,32
80002022:	8082                	ret

80002024 <TMR32_ITClear>:
  * @brief   Сброс прерываний
  * @param   it Маскированное прерывание прерывания типа @ref TMR32_IT_TypeDef
  * @retval  void
  */
__STATIC_INLINE void TMR32_ITClear(TMR32_IT_TypeDef it)
{
80002024:	1101                	addi	sp,sp,-32
80002026:	ce22                	sw	s0,28(sp)
80002028:	1000                	addi	s0,sp,32
8000202a:	fea42623          	sw	a0,-20(s0)
  assert_param(IS_TMR32_IT(it));

  SET_BIT(TMR32->IC, it);
8000202e:	300007b7          	lui	a5,0x30000
80002032:	4bd4                	lw	a3,20(a5)
80002034:	300007b7          	lui	a5,0x30000
80002038:	fec42703          	lw	a4,-20(s0)
8000203c:	8f55                	or	a4,a4,a3
8000203e:	cbd8                	sw	a4,20(a5)
}
80002040:	0001                	nop
80002042:	4472                	lw	s0,28(sp)
80002044:	6105                	addi	sp,sp,32
80002046:	8082                	ret

80002048 <TMR32_CAPCOM_SetComparator>:
  * @param   capcomx номер регистра capcom @ref TMR32_CAPCOM_Num_TypeDef.
  * @param   CapComVal  Значение регистра сравнения
  * @retval  void
  */
__STATIC_INLINE void TMR32_CAPCOM_SetComparator(TMR32_CAPCOM_Num_TypeDef capcomx, uint32_t capcomVal)
{
80002048:	1101                	addi	sp,sp,-32
8000204a:	ce22                	sw	s0,28(sp)
8000204c:	1000                	addi	s0,sp,32
8000204e:	fea42623          	sw	a0,-20(s0)
80002052:	feb42423          	sw	a1,-24(s0)
  assert_param(IS_TMR32_CAPCOM(capcomx));

  WRITE_REG(TMR32->CAPCOM[capcomx].VAL, capcomVal);
80002056:	30000737          	lui	a4,0x30000
8000205a:	fec42783          	lw	a5,-20(s0)
8000205e:	0789                	addi	a5,a5,2 # 30000002 <STACK_SIZE+0x2ffff802>
80002060:	078e                	slli	a5,a5,0x3
80002062:	97ba                	add	a5,a5,a4
80002064:	fe842703          	lw	a4,-24(s0)
80002068:	c7d8                	sw	a4,12(a5)
}
8000206a:	0001                	nop
8000206c:	4472                	lw	s0,28(sp)
8000206e:	6105                	addi	sp,sp,32
80002070:	8082                	ret

80002072 <GPIO_ReadBit>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  State  Состояние Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002072:	1101                	addi	sp,sp,-32
80002074:	ce22                	sw	s0,28(sp)
80002076:	1000                	addi	s0,sp,32
80002078:	fea42623          	sw	a0,-20(s0)
8000207c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
80002080:	fec42783          	lw	a5,-20(s0)
80002084:	4398                	lw	a4,0(a5)
80002086:	fe842783          	lw	a5,-24(s0)
8000208a:	8ff9                	and	a5,a5,a4
8000208c:	c399                	beqz	a5,80002092 <GPIO_ReadBit+0x20>
8000208e:	4785                	li	a5,1
80002090:	a011                	j	80002094 <GPIO_ReadBit+0x22>
80002092:	4781                	li	a5,0
}
80002094:	853e                	mv	a0,a5
80002096:	4472                	lw	s0,28(sp)
80002098:	6105                	addi	sp,sp,32
8000209a:	8082                	ret

8000209c <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
8000209c:	1101                	addi	sp,sp,-32
8000209e:	ce22                	sw	s0,28(sp)
800020a0:	1000                	addi	s0,sp,32
800020a2:	fea42623          	sw	a0,-20(s0)
800020a6:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
800020aa:	fec42783          	lw	a5,-20(s0)
800020ae:	fe842703          	lw	a4,-24(s0)
800020b2:	c798                	sw	a4,8(a5)
}
800020b4:	0001                	nop
800020b6:	4472                	lw	s0,28(sp)
800020b8:	6105                	addi	sp,sp,32
800020ba:	8082                	ret

800020bc <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
800020bc:	1101                	addi	sp,sp,-32
800020be:	ce22                	sw	s0,28(sp)
800020c0:	1000                	addi	s0,sp,32
800020c2:	fea42623          	sw	a0,-20(s0)
800020c6:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
800020ca:	fec42783          	lw	a5,-20(s0)
800020ce:	fe842703          	lw	a4,-24(s0)
800020d2:	c7d8                	sw	a4,12(a5)
}
800020d4:	0001                	nop
800020d6:	4472                	lw	s0,28(sp)
800020d8:	6105                	addi	sp,sp,32
800020da:	8082                	ret

800020dc <GPIO_ITStatus>:
  * @param   GPIOx  выбор порта, где x=A|B|C  
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @retval  Status  Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE FlagStatus GPIO_ITStatus(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
800020dc:	1101                	addi	sp,sp,-32
800020de:	ce22                	sw	s0,28(sp)
800020e0:	1000                	addi	s0,sp,32
800020e2:	fea42623          	sw	a0,-20(s0)
800020e6:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    return (FlagStatus)READ_BIT(GPIOx->INTSTATUS, Pin);
800020ea:	fec42783          	lw	a5,-20(s0)
800020ee:	0807a703          	lw	a4,128(a5)
800020f2:	fe842783          	lw	a5,-24(s0)
800020f6:	8ff9                	and	a5,a5,a4
800020f8:	c399                	beqz	a5,800020fe <GPIO_ITStatus+0x22>
800020fa:	4785                	li	a5,1
800020fc:	a011                	j	80002100 <GPIO_ITStatus+0x24>
800020fe:	4781                	li	a5,0
}
80002100:	853e                	mv	a0,a5
80002102:	4472                	lw	s0,28(sp)
80002104:	6105                	addi	sp,sp,32
80002106:	8082                	ret

80002108 <GPIO_ITStatusClear>:
  * @param   GPIOx  выбор порта, где x=A|B|C    
  * @param   Pin  Выбор пинов
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITStatusClear(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002108:	1101                	addi	sp,sp,-32
8000210a:	ce22                	sw	s0,28(sp)
8000210c:	1000                	addi	s0,sp,32
8000210e:	fea42623          	sw	a0,-20(s0)
80002112:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->INTSTATUS, Pin);
80002116:	fec42783          	lw	a5,-20(s0)
8000211a:	fe842703          	lw	a4,-24(s0)
8000211e:	08e7a023          	sw	a4,128(a5)
}
80002122:	0001                	nop
80002124:	4472                	lw	s0,28(sp)
80002126:	6105                	addi	sp,sp,32
80002128:	8082                	ret

8000212a <UART4_init>:
static void tmr32_init(void);
static void tmr32_irq_handler(void);
static void cfg_store_and_report(void);

void UART4_init()
{
8000212a:	1101                	addi	sp,sp,-32
8000212c:	ce22                	sw	s0,28(sp)
8000212e:	1000                	addi	s0,sp,32
    uint32_t baud_icoef = HSECLK_VAL / (16 * UART4_BAUD);
80002130:	47a1                	li	a5,8
80002132:	fef42623          	sw	a5,-20(s0)
    uint32_t baud_fcoef = ((HSECLK_VAL / (16.0f * UART4_BAUD) - baud_icoef) * 64 + 0.5f);
80002136:	fec42783          	lw	a5,-20(s0)
8000213a:	d017f7d3          	fcvt.s.wu	fa5,a5
8000213e:	800097b7          	lui	a5,0x80009
80002142:	5b07a707          	flw	fa4,1456(a5) # 800095b0 <__data_source_start+0xfffffb8c>
80002146:	08f77753          	fsub.s	fa4,fa4,fa5
8000214a:	800097b7          	lui	a5,0x80009
8000214e:	5b47a787          	flw	fa5,1460(a5) # 800095b4 <__data_source_start+0xfffffb90>
80002152:	10f77753          	fmul.s	fa4,fa4,fa5
80002156:	800097b7          	lui	a5,0x80009
8000215a:	5b87a787          	flw	fa5,1464(a5) # 800095b8 <__data_source_start+0xfffffb94>
8000215e:	00f777d3          	fadd.s	fa5,fa4,fa5
80002162:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80002166:	fef42423          	sw	a5,-24(s0)
    // Настраиваем GPIO
    RCU->CGCFGAHB_bit.GPIOAEN = 1;
8000216a:	3000e7b7          	lui	a5,0x3000e
8000216e:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80002172:	10076713          	ori	a4,a4,256
80002176:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOAEN = 1;
8000217a:	3000e7b7          	lui	a5,0x3000e
8000217e:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80002182:	10076713          	ori	a4,a4,256
80002186:	00e79823          	sh	a4,16(a5)
    RCU->CGCFGAPB_bit.UART4EN = 1;
8000218a:	3000e7b7          	lui	a5,0x3000e
8000218e:	4798                	lw	a4,8(a5)
80002190:	40076713          	ori	a4,a4,1024
80002194:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.UART4EN = 1;
80002196:	3000e7b7          	lui	a5,0x3000e
8000219a:	4f98                	lw	a4,24(a5)
8000219c:	40076713          	ori	a4,a4,1024
800021a0:	cf98                	sw	a4,24(a5)

    // UART4 на пинах PA8 (RX) и PA9 (TX)
    GPIOA->ALTFUNCNUM_bit.PIN8 = 1;
800021a2:	280007b7          	lui	a5,0x28000
800021a6:	5fd4                	lw	a3,60(a5)
800021a8:	fffd0737          	lui	a4,0xfffd0
800021ac:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc65db>
800021ae:	8ef9                	and	a3,a3,a4
800021b0:	6741                	lui	a4,0x10
800021b2:	8f55                	or	a4,a4,a3
800021b4:	dfd8                	sw	a4,60(a5)
    GPIOA->ALTFUNCNUM_bit.PIN9 = 1;
800021b6:	280007b7          	lui	a5,0x28000
800021ba:	5fd4                	lw	a3,60(a5)
800021bc:	fff40737          	lui	a4,0xfff40
800021c0:	177d                	addi	a4,a4,-1 # fff3ffff <__data_source_start+0x7ff365db>
800021c2:	8ef9                	and	a3,a3,a4
800021c4:	00040737          	lui	a4,0x40
800021c8:	8f55                	or	a4,a4,a3
800021ca:	dfd8                	sw	a4,60(a5)
    GPIOA->ALTFUNCSET = GPIO_ALTFUNCSET_PIN8_Msk | GPIO_ALTFUNCSET_PIN9_Msk;
800021cc:	280007b7          	lui	a5,0x28000
800021d0:	30000713          	li	a4,768
800021d4:	dbd8                	sw	a4,52(a5)

    // Настраиваем UART4
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.CLKSEL = RCU_UARTCLKCFG_CLKSEL_HSE;
800021d6:	3000e7b7          	lui	a5,0x3000e
800021da:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
800021de:	fffd0737          	lui	a4,0xfffd0
800021e2:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc65db>
800021e4:	8ef9                	and	a3,a3,a4
800021e6:	6741                	lui	a4,0x10
800021e8:	8f55                	or	a4,a4,a3
800021ea:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.DIVEN = 0;
800021ee:	3000e7b7          	lui	a5,0x3000e
800021f2:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
800021f6:	fff00737          	lui	a4,0xfff00
800021fa:	177d                	addi	a4,a4,-1 # ffefffff <__data_source_start+0x7fef65db>
800021fc:	8f75                	and	a4,a4,a3
800021fe:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.RSTDIS = 1;
80002202:	3000e7b7          	lui	a5,0x3000e
80002206:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
8000220a:	10076713          	ori	a4,a4,256
8000220e:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.CLKEN = 1;
80002212:	3000e7b7          	lui	a5,0x3000e
80002216:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
8000221a:	00176713          	ori	a4,a4,1
8000221e:	08e7a023          	sw	a4,128(a5)

    UART4->IBRD = baud_icoef;
80002222:	3000a7b7          	lui	a5,0x3000a
80002226:	fec42703          	lw	a4,-20(s0)
8000222a:	d3d8                	sw	a4,36(a5)
    UART4->FBRD = baud_fcoef;
8000222c:	3000a7b7          	lui	a5,0x3000a
80002230:	fe842703          	lw	a4,-24(s0)
80002234:	d798                	sw	a4,40(a5)
    UART4->LCRH = UART_LCRH_FEN_Msk | (3 << UART_LCRH_WLEN_Pos);
80002236:	3000a7b7          	lui	a5,0x3000a
8000223a:	07000713          	li	a4,112
8000223e:	d7d8                	sw	a4,44(a5)
    UART4->IFLS = 0;
80002240:	3000a7b7          	lui	a5,0x3000a
80002244:	0207aa23          	sw	zero,52(a5) # 3000a034 <STACK_SIZE+0x30009834>
    UART4->CR = UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
80002248:	3000a7b7          	lui	a5,0x3000a
8000224c:	30100713          	li	a4,769
80002250:	db98                	sw	a4,48(a5)
}
80002252:	0001                	nop
80002254:	4472                	lw	s0,28(sp)
80002256:	6105                	addi	sp,sp,32
80002258:	8082                	ret

8000225a <periph_init>:



//-- Peripheral init functions -------------------------------------------------
void periph_init()
{
8000225a:	1141                	addi	sp,sp,-16
8000225c:	c606                	sw	ra,12(sp)
8000225e:	c422                	sw	s0,8(sp)
80002260:	0800                	addi	s0,sp,16
  SystemInit();
80002262:	39c9                	jal	80001f34 <SystemInit>
  SystemCoreClockUpdate();
80002264:	de4ff0ef          	jal	ra,80001848 <SystemCoreClockUpdate>
  retarget_init();
80002268:	9daff0ef          	jal	ra,80001442 <retarget_init>
  adcsar_init();
8000226c:	057000ef          	jal	ra,80002ac2 <adcsar_init>
  eeprom_init();
80002270:	59f000ef          	jal	ra,8000300e <eeprom_init>
  gpio_init();
80002274:	2221                	jal	8000237c <gpio_init>
  tmr32_init();
80002276:	2911                	jal	8000268a <tmr32_init>
  uart_irq_init();
80002278:	2895                	jal	800022ec <uart_irq_init>
  gpio_irq_init();
8000227a:	22ad                	jal	800023e4 <gpio_irq_init>
  InterruptEnable();
8000227c:	3105                	jal	80001e9c <InterruptEnable>
  osdp_init();
8000227e:	609020ef          	jal	ra,80005086 <osdp_init>
  cfg_store_and_report();
80002282:	2801                	jal	80002292 <cfg_store_and_report>
  adcsar_start();
80002284:	1fb000ef          	jal	ra,80002c7e <adcsar_start>
}
80002288:	0001                	nop
8000228a:	40b2                	lw	ra,12(sp)
8000228c:	4422                	lw	s0,8(sp)
8000228e:	0141                	addi	sp,sp,16
80002290:	8082                	ret

80002292 <cfg_store_and_report>:

static void cfg_store_and_report(void)
{
80002292:	1141                	addi	sp,sp,-16
80002294:	c606                	sw	ra,12(sp)
80002296:	c422                	sw	s0,8(sp)
80002298:	0800                	addi	s0,sp,16
  // Пытаемся загрузить конфиг; если невалиден — пишем дефолтный и перезагружаем
  //if (!config_storage_load(&g_cfg)) {
  printf("CFG invalid, writing defaults\r\n");
8000229a:	800097b7          	lui	a5,0x80009
8000229e:	51878513          	addi	a0,a5,1304 # 80009518 <__data_source_start+0xfffffaf4>
800022a2:	8bcff0ef          	jal	ra,8000135e <puts>
  config_storage_default(&g_cfg);
800022a6:	e7818513          	addi	a0,gp,-392 # 400005f8 <g_cfg>
800022aa:	29f000ef          	jal	ra,80002d48 <config_storage_default>
  config_storage_save(&g_cfg);
800022ae:	e7818513          	addi	a0,gp,-392 # 400005f8 <g_cfg>
800022b2:	455000ef          	jal	ra,80002f06 <config_storage_save>
  //}

  printf("CFG active: addr=%u baud=%u\r\n", g_cfg.osdp_addr, (unsigned)g_cfg.osdp_baud);
800022b6:	e7818793          	addi	a5,gp,-392 # 400005f8 <g_cfg>
800022ba:	0007c783          	lbu	a5,0(a5)
800022be:	86be                	mv	a3,a5
800022c0:	e7818793          	addi	a5,gp,-392 # 400005f8 <g_cfg>
800022c4:	4398                	lw	a4,0(a5)
800022c6:	8321                	srli	a4,a4,0x8
800022c8:	43dc                	lw	a5,4(a5)
800022ca:	0ff7f793          	zext.b	a5,a5
800022ce:	07e2                	slli	a5,a5,0x18
800022d0:	8fd9                	or	a5,a5,a4
800022d2:	863e                	mv	a2,a5
800022d4:	85b6                	mv	a1,a3
800022d6:	800097b7          	lui	a5,0x80009
800022da:	53878513          	addi	a0,a5,1336 # 80009538 <__data_source_start+0xfffffb14>
800022de:	fdffe0ef          	jal	ra,800012bc <printf>
}
800022e2:	0001                	nop
800022e4:	40b2                	lw	ra,12(sp)
800022e6:	4422                	lw	s0,8(sp)
800022e8:	0141                	addi	sp,sp,16
800022ea:	8082                	ret

800022ec <uart_irq_init>:

//--- USER FUNCTIONS ----------------------------------------------------------------------

// Инициализация прерываний UART4 и регистрация обработчика в PLIC
static void uart_irq_init(void)
{
800022ec:	1141                	addi	sp,sp,-16
800022ee:	c606                	sw	ra,12(sp)
800022f0:	c422                	sw	s0,8(sp)
800022f2:	0800                	addi	s0,sp,16
  // Очистить возможные висящие флаги прерываний
  RETARGET_UART->ICR = UART_ICR_RXIC_Msk |
800022f4:	3000a7b7          	lui	a5,0x3000a
800022f8:	7d000713          	li	a4,2000
800022fc:	c3f8                	sw	a4,68(a5)
                       UART_ICR_FEIC_Msk |
                       UART_ICR_PEIC_Msk |
                       UART_ICR_BEIC_Msk;

  // Включить источники прерываний по приёму и таймауту
  RETARGET_UART->IMSC |= (UART_IMSC_RXIM_Msk |
800022fe:	3000a7b7          	lui	a5,0x3000a
80002302:	5f98                	lw	a4,56(a5)
80002304:	3000a7b7          	lui	a5,0x3000a
80002308:	7d076713          	ori	a4,a4,2000
8000230c:	df98                	sw	a4,56(a5)
                          UART_IMSC_FERIM_Msk |
                          UART_IMSC_PERIM_Msk |
                          UART_IMSC_BERIM_Msk);

  // Зарегистрировать обработчик в PLIC и включить линию прерываний UART4
  PLIC_SetPriority(PLIC_UART4_VECTNUM, 1);
8000230e:	4585                	li	a1,1
80002310:	4569                	li	a0,26
80002312:	c3cfe0ef          	jal	ra,8000074e <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_UART4_VECTNUM, uart4_irq_handler);
80002316:	800027b7          	lui	a5,0x80002
8000231a:	33878613          	addi	a2,a5,824 # 80002338 <__data_source_start+0xffff8914>
8000231e:	45e9                	li	a1,26
80002320:	4501                	li	a0,0
80002322:	be0fe0ef          	jal	ra,80000702 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_UART4_VECTNUM);
80002326:	45e9                	li	a1,26
80002328:	4501                	li	a0,0
8000232a:	c4efe0ef          	jal	ra,80000778 <PLIC_IntEnable>
}
8000232e:	0001                	nop
80002330:	40b2                	lw	ra,12(sp)
80002332:	4422                	lw	s0,8(sp)
80002334:	0141                	addi	sp,sp,16
80002336:	8082                	ret

80002338 <uart4_irq_handler>:

// Обработчик прерывания UART4 (через PLIC)
static void uart4_irq_handler(void)
{
80002338:	1101                	addi	sp,sp,-32
8000233a:	ce06                	sw	ra,28(sp)
8000233c:	cc22                	sw	s0,24(sp)
8000233e:	1000                	addi	s0,sp,32
  while (!RETARGET_UART->FR_bit.RXFE) {
80002340:	a821                	j	80002358 <uart4_irq_handler+0x20>
    uint8_t ch = (uint8_t)RETARGET_UART->DR_bit.DATA;
80002342:	3000a7b7          	lui	a5,0x3000a
80002346:	0007c783          	lbu	a5,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
8000234a:	fef407a3          	sb	a5,-17(s0)
    osdp_on_rx_byte(ch);
8000234e:	fef44783          	lbu	a5,-17(s0)
80002352:	853e                	mv	a0,a5
80002354:	5df020ef          	jal	ra,80005132 <osdp_on_rx_byte>
  while (!RETARGET_UART->FR_bit.RXFE) {
80002358:	3000a7b7          	lui	a5,0x3000a
8000235c:	4f9c                	lw	a5,24(a5)
8000235e:	8391                	srli	a5,a5,0x4
80002360:	8b85                	andi	a5,a5,1
80002362:	0ff7f793          	zext.b	a5,a5
80002366:	dff1                	beqz	a5,80002342 <uart4_irq_handler+0xa>
  }

  // Очистить флаги источников прерываний
  RETARGET_UART->ICR = UART_ICR_RXIC_Msk |
80002368:	3000a7b7          	lui	a5,0x3000a
8000236c:	7d000713          	li	a4,2000
80002370:	c3f8                	sw	a4,68(a5)
                       UART_ICR_RTIC_Msk |
                       UART_ICR_OEIC_Msk |
                       UART_ICR_FEIC_Msk |
                       UART_ICR_PEIC_Msk |
                       UART_ICR_BEIC_Msk;
}
80002372:	0001                	nop
80002374:	40f2                	lw	ra,28(sp)
80002376:	4462                	lw	s0,24(sp)
80002378:	6105                	addi	sp,sp,32
8000237a:	8082                	ret

8000237c <gpio_init>:


static void gpio_init(void)
{
8000237c:	1141                	addi	sp,sp,-16
8000237e:	c606                	sw	ra,12(sp)
80002380:	c422                	sw	s0,8(sp)
80002382:	0800                	addi	s0,sp,16
  // Включить тактирование GPIOA
  RCU->CGCFGAHB_bit.GPIOAEN = 1;
80002384:	3000e7b7          	lui	a5,0x3000e
80002388:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
8000238c:	10076713          	ori	a4,a4,256
80002390:	00e79023          	sh	a4,0(a5)
  RCU->RSTDISAHB_bit.GPIOAEN = 1;
80002394:	3000e7b7          	lui	a5,0x3000e
80002398:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
8000239c:	10076713          	ori	a4,a4,256
800023a0:	00e79823          	sh	a4,16(a5)

  // LED на PA4-PA7 (начальное состояние: все выключены)
  gpio_init_output(GPIOA, GPIO_Pin_4, 0);
800023a4:	4601                	li	a2,0
800023a6:	45c1                	li	a1,16
800023a8:	28000537          	lui	a0,0x28000
800023ac:	428010ef          	jal	ra,800037d4 <gpio_init_output>
  gpio_init_output(GPIOA, GPIO_Pin_5, 0);
800023b0:	4601                	li	a2,0
800023b2:	02000593          	li	a1,32
800023b6:	28000537          	lui	a0,0x28000
800023ba:	41a010ef          	jal	ra,800037d4 <gpio_init_output>
  gpio_init_output(GPIOA, GPIO_Pin_6, 0);
800023be:	4601                	li	a2,0
800023c0:	04000593          	li	a1,64
800023c4:	28000537          	lui	a0,0x28000
800023c8:	40c010ef          	jal	ra,800037d4 <gpio_init_output>
  gpio_init_output(GPIOA, GPIO_Pin_7, 0);
800023cc:	4601                	li	a2,0
800023ce:	08000593          	li	a1,128
800023d2:	28000537          	lui	a0,0x28000
800023d6:	3fe010ef          	jal	ra,800037d4 <gpio_init_output>
}
800023da:	0001                	nop
800023dc:	40b2                	lw	ra,12(sp)
800023de:	4422                	lw	s0,8(sp)
800023e0:	0141                	addi	sp,sp,16
800023e2:	8082                	ret

800023e4 <gpio_irq_init>:

// Инициализация прерываний GPIO для кнопок
static void gpio_irq_init(void)
{
800023e4:	1141                	addi	sp,sp,-16
800023e6:	c606                	sw	ra,12(sp)
800023e8:	c422                	sw	s0,8(sp)
800023ea:	0800                	addi	s0,sp,16
  // Кнопки PA0-PA3
  gpio_init_input_irq(GPIOA, GPIO_Pin_0, GPIO_PullMode_PU, &g_btn_last_state[0]);
800023ec:	88018693          	addi	a3,gp,-1920 # 40000000 <g_btn_last_state>
800023f0:	4605                	li	a2,1
800023f2:	4585                	li	a1,1
800023f4:	28000537          	lui	a0,0x28000
800023f8:	4f2010ef          	jal	ra,800038ea <gpio_init_input_irq>
  gpio_init_input_irq(GPIOA, GPIO_Pin_1, GPIO_PullMode_PU, &g_btn_last_state[1]);
800023fc:	88118693          	addi	a3,gp,-1919 # 40000001 <g_btn_last_state+0x1>
80002400:	4605                	li	a2,1
80002402:	4589                	li	a1,2
80002404:	28000537          	lui	a0,0x28000
80002408:	4e2010ef          	jal	ra,800038ea <gpio_init_input_irq>
  gpio_init_input_irq(GPIOA, GPIO_Pin_2, GPIO_PullMode_PU, &g_btn_last_state[2]);
8000240c:	88218693          	addi	a3,gp,-1918 # 40000002 <g_btn_last_state+0x2>
80002410:	4605                	li	a2,1
80002412:	4591                	li	a1,4
80002414:	28000537          	lui	a0,0x28000
80002418:	4d2010ef          	jal	ra,800038ea <gpio_init_input_irq>
  gpio_init_input_irq(GPIOA, GPIO_Pin_3, GPIO_PullMode_PU, &g_btn_last_state[3]);
8000241c:	88318693          	addi	a3,gp,-1917 # 40000003 <g_btn_last_state+0x3>
80002420:	4605                	li	a2,1
80002422:	45a1                	li	a1,8
80002424:	28000537          	lui	a0,0x28000
80002428:	4c2010ef          	jal	ra,800038ea <gpio_init_input_irq>
  
  // Зарегистрировать обработчик в PLIC и включить линию прерываний GPIO
  PLIC_SetPriority(PLIC_GPIO_VECTNUM, 1);
8000242c:	4585                	li	a1,1
8000242e:	4515                	li	a0,5
80002430:	b1efe0ef          	jal	ra,8000074e <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_GPIO_VECTNUM, gpio_irq_handler);
80002434:	800027b7          	lui	a5,0x80002
80002438:	45678613          	addi	a2,a5,1110 # 80002456 <__data_source_start+0xffff8a32>
8000243c:	4595                	li	a1,5
8000243e:	4501                	li	a0,0
80002440:	ac2fe0ef          	jal	ra,80000702 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_GPIO_VECTNUM);
80002444:	4595                	li	a1,5
80002446:	4501                	li	a0,0
80002448:	b30fe0ef          	jal	ra,80000778 <PLIC_IntEnable>
}
8000244c:	0001                	nop
8000244e:	40b2                	lw	ra,12(sp)
80002450:	4422                	lw	s0,8(sp)
80002452:	0141                	addi	sp,sp,16
80002454:	8082                	ret

80002456 <gpio_irq_handler>:
// Простой самотест EEPROM: запись и чтение известного шаблона


// Обработчик прерывания GPIO (кнопки)
static void gpio_irq_handler(void)
{
80002456:	7139                	addi	sp,sp,-64
80002458:	de06                	sw	ra,60(sp)
8000245a:	dc22                	sw	s0,56(sp)
8000245c:	0080                	addi	s0,sp,64
  uint32_t now = ms_ticks;
8000245e:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
80002462:	fef42423          	sw	a5,-24(s0)
  
  const uint32_t btn_pins[4] = {GPIO_Pin_0, GPIO_Pin_1, GPIO_Pin_2, GPIO_Pin_3};
80002466:	800097b7          	lui	a5,0x80009
8000246a:	58078793          	addi	a5,a5,1408 # 80009580 <__data_source_start+0xfffffb5c>
8000246e:	4390                	lw	a2,0(a5)
80002470:	43d4                	lw	a3,4(a5)
80002472:	4798                	lw	a4,8(a5)
80002474:	47dc                	lw	a5,12(a5)
80002476:	fcc42a23          	sw	a2,-44(s0)
8000247a:	fcd42c23          	sw	a3,-40(s0)
8000247e:	fce42e23          	sw	a4,-36(s0)
80002482:	fef42023          	sw	a5,-32(s0)
  const uint32_t led_pins[4] = {GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7};
80002486:	800097b7          	lui	a5,0x80009
8000248a:	59078793          	addi	a5,a5,1424 # 80009590 <__data_source_start+0xfffffb6c>
8000248e:	4390                	lw	a2,0(a5)
80002490:	43d4                	lw	a3,4(a5)
80002492:	4798                	lw	a4,8(a5)
80002494:	47dc                	lw	a5,12(a5)
80002496:	fcc42223          	sw	a2,-60(s0)
8000249a:	fcd42423          	sw	a3,-56(s0)
8000249e:	fce42623          	sw	a4,-52(s0)
800024a2:	fcf42823          	sw	a5,-48(s0)
  
  // Обработка всех 4 кнопок PA0-PA3
  for (uint8_t i = 0; i < 4; i++) {
800024a6:	fe0407a3          	sb	zero,-17(s0)
800024aa:	a2e9                	j	80002674 <gpio_irq_handler+0x21e>
    if (GPIO_ITStatus(GPIOA, btn_pins[i]) == SET) {
800024ac:	fef44783          	lbu	a5,-17(s0)
800024b0:	078a                	slli	a5,a5,0x2
800024b2:	17c1                	addi	a5,a5,-16
800024b4:	97a2                	add	a5,a5,s0
800024b6:	fe47a783          	lw	a5,-28(a5)
800024ba:	85be                	mv	a1,a5
800024bc:	28000537          	lui	a0,0x28000
800024c0:	3931                	jal	800020dc <GPIO_ITStatus>
800024c2:	872a                	mv	a4,a0
800024c4:	4785                	li	a5,1
800024c6:	1af71263          	bne	a4,a5,8000266a <gpio_irq_handler+0x214>
      uint8_t btn_current = GPIO_ReadBit(GPIOA, btn_pins[i]) ? 1 : 0;
800024ca:	fef44783          	lbu	a5,-17(s0)
800024ce:	078a                	slli	a5,a5,0x2
800024d0:	17c1                	addi	a5,a5,-16
800024d2:	97a2                	add	a5,a5,s0
800024d4:	fe47a783          	lw	a5,-28(a5)
800024d8:	85be                	mv	a1,a5
800024da:	28000537          	lui	a0,0x28000
800024de:	3e51                	jal	80002072 <GPIO_ReadBit>
800024e0:	87aa                	mv	a5,a0
800024e2:	00f037b3          	snez	a5,a5
800024e6:	0ff7f793          	zext.b	a5,a5
800024ea:	fef403a3          	sb	a5,-25(s0)
      
      if (g_btn_last_state[i] == 1 && btn_current == 0) {
800024ee:	fef44703          	lbu	a4,-17(s0)
800024f2:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
800024f6:	97ba                	add	a5,a5,a4
800024f8:	0007c783          	lbu	a5,0(a5)
800024fc:	0ff7f713          	zext.b	a4,a5
80002500:	4785                	li	a5,1
80002502:	0ef71a63          	bne	a4,a5,800025f6 <gpio_irq_handler+0x1a0>
80002506:	fe744783          	lbu	a5,-25(s0)
8000250a:	0e079663          	bnez	a5,800025f6 <gpio_irq_handler+0x1a0>
        // Кнопка нажата (переход из 1 в 0)
        if ((now - g_btn_last_ms[i]) >= g_debounce_ms) {
8000250e:	fef44783          	lbu	a5,-17(s0)
80002512:	e6418713          	addi	a4,gp,-412 # 400005e4 <g_btn_last_ms>
80002516:	078a                	slli	a5,a5,0x2
80002518:	97ba                	add	a5,a5,a4
8000251a:	439c                	lw	a5,0(a5)
8000251c:	fe842703          	lw	a4,-24(s0)
80002520:	8f1d                	sub	a4,a4,a5
80002522:	03200793          	li	a5,50
80002526:	12f76763          	bltu	a4,a5,80002654 <gpio_irq_handler+0x1fe>
          // Переключаем состояние соответствующего LED (PA4-PA7)
          led_state[i] ^= 1u;
8000252a:	fef44703          	lbu	a4,-17(s0)
8000252e:	e6018793          	addi	a5,gp,-416 # 400005e0 <led_state>
80002532:	97ba                	add	a5,a5,a4
80002534:	0007c783          	lbu	a5,0(a5)
80002538:	0ff7f793          	zext.b	a5,a5
8000253c:	fef44683          	lbu	a3,-17(s0)
80002540:	0017c793          	xori	a5,a5,1
80002544:	0ff7f713          	zext.b	a4,a5
80002548:	e6018793          	addi	a5,gp,-416 # 400005e0 <led_state>
8000254c:	97b6                	add	a5,a5,a3
8000254e:	00e78023          	sb	a4,0(a5)
          if (led_state[i]) {
80002552:	fef44703          	lbu	a4,-17(s0)
80002556:	e6018793          	addi	a5,gp,-416 # 400005e0 <led_state>
8000255a:	97ba                	add	a5,a5,a4
8000255c:	0007c783          	lbu	a5,0(a5)
80002560:	0ff7f793          	zext.b	a5,a5
80002564:	cf85                	beqz	a5,8000259c <gpio_irq_handler+0x146>
            GPIO_SetBits(GPIOA, led_pins[i]);
80002566:	fef44783          	lbu	a5,-17(s0)
8000256a:	078a                	slli	a5,a5,0x2
8000256c:	17c1                	addi	a5,a5,-16
8000256e:	97a2                	add	a5,a5,s0
80002570:	fd47a783          	lw	a5,-44(a5)
80002574:	85be                	mv	a1,a5
80002576:	28000537          	lui	a0,0x28000
8000257a:	360d                	jal	8000209c <GPIO_SetBits>
            printf("LED%d ON (PA%d)\r\n", i+1, i+4);
8000257c:	fef44783          	lbu	a5,-17(s0)
80002580:	00178713          	addi	a4,a5,1
80002584:	fef44783          	lbu	a5,-17(s0)
80002588:	0791                	addi	a5,a5,4
8000258a:	863e                	mv	a2,a5
8000258c:	85ba                	mv	a1,a4
8000258e:	800097b7          	lui	a5,0x80009
80002592:	55878513          	addi	a0,a5,1368 # 80009558 <__data_source_start+0xfffffb34>
80002596:	d27fe0ef          	jal	ra,800012bc <printf>
8000259a:	a81d                	j	800025d0 <gpio_irq_handler+0x17a>
          } else {
            GPIO_ClearBits(GPIOA, led_pins[i]);
8000259c:	fef44783          	lbu	a5,-17(s0)
800025a0:	078a                	slli	a5,a5,0x2
800025a2:	17c1                	addi	a5,a5,-16
800025a4:	97a2                	add	a5,a5,s0
800025a6:	fd47a783          	lw	a5,-44(a5)
800025aa:	85be                	mv	a1,a5
800025ac:	28000537          	lui	a0,0x28000
800025b0:	3631                	jal	800020bc <GPIO_ClearBits>
            printf("LED%d OFF (PA%d)\r\n", i+1, i+4);
800025b2:	fef44783          	lbu	a5,-17(s0)
800025b6:	00178713          	addi	a4,a5,1
800025ba:	fef44783          	lbu	a5,-17(s0)
800025be:	0791                	addi	a5,a5,4
800025c0:	863e                	mv	a2,a5
800025c2:	85ba                	mv	a1,a4
800025c4:	800097b7          	lui	a5,0x80009
800025c8:	56c78513          	addi	a0,a5,1388 # 8000956c <__data_source_start+0xfffffb48>
800025cc:	cf1fe0ef          	jal	ra,800012bc <printf>
          }
          g_btn_last_ms[i] = now;
800025d0:	fef44783          	lbu	a5,-17(s0)
800025d4:	e6418713          	addi	a4,gp,-412 # 400005e4 <g_btn_last_ms>
800025d8:	078a                	slli	a5,a5,0x2
800025da:	97ba                	add	a5,a5,a4
800025dc:	fe842703          	lw	a4,-24(s0)
800025e0:	c398                	sw	a4,0(a5)
          g_btn_last_state[i] = btn_current;
800025e2:	fef44703          	lbu	a4,-17(s0)
800025e6:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
800025ea:	97ba                	add	a5,a5,a4
800025ec:	fe744703          	lbu	a4,-25(s0)
800025f0:	00e78023          	sb	a4,0(a5)
        if ((now - g_btn_last_ms[i]) >= g_debounce_ms) {
800025f4:	a085                	j	80002654 <gpio_irq_handler+0x1fe>
        }
      } else if (g_btn_last_state[i] == 0 && btn_current == 1) {
800025f6:	fef44703          	lbu	a4,-17(s0)
800025fa:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
800025fe:	97ba                	add	a5,a5,a4
80002600:	0007c783          	lbu	a5,0(a5)
80002604:	0ff7f793          	zext.b	a5,a5
80002608:	e7b1                	bnez	a5,80002654 <gpio_irq_handler+0x1fe>
8000260a:	fe744703          	lbu	a4,-25(s0)
8000260e:	4785                	li	a5,1
80002610:	04f71263          	bne	a4,a5,80002654 <gpio_irq_handler+0x1fe>
        // Кнопка отпущена (переход из 0 в 1)
        if ((now - g_btn_last_ms[i]) >= g_debounce_ms) {
80002614:	fef44783          	lbu	a5,-17(s0)
80002618:	e6418713          	addi	a4,gp,-412 # 400005e4 <g_btn_last_ms>
8000261c:	078a                	slli	a5,a5,0x2
8000261e:	97ba                	add	a5,a5,a4
80002620:	439c                	lw	a5,0(a5)
80002622:	fe842703          	lw	a4,-24(s0)
80002626:	8f1d                	sub	a4,a4,a5
80002628:	03200793          	li	a5,50
8000262c:	02f76463          	bltu	a4,a5,80002654 <gpio_irq_handler+0x1fe>
          g_btn_last_state[i] = btn_current;
80002630:	fef44703          	lbu	a4,-17(s0)
80002634:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80002638:	97ba                	add	a5,a5,a4
8000263a:	fe744703          	lbu	a4,-25(s0)
8000263e:	00e78023          	sb	a4,0(a5)
          g_btn_last_ms[i] = now;
80002642:	fef44783          	lbu	a5,-17(s0)
80002646:	e6418713          	addi	a4,gp,-412 # 400005e4 <g_btn_last_ms>
8000264a:	078a                	slli	a5,a5,0x2
8000264c:	97ba                	add	a5,a5,a4
8000264e:	fe842703          	lw	a4,-24(s0)
80002652:	c398                	sw	a4,0(a5)
        }
      }
      
      GPIO_ITStatusClear(GPIOA, btn_pins[i]);
80002654:	fef44783          	lbu	a5,-17(s0)
80002658:	078a                	slli	a5,a5,0x2
8000265a:	17c1                	addi	a5,a5,-16
8000265c:	97a2                	add	a5,a5,s0
8000265e:	fe47a783          	lw	a5,-28(a5)
80002662:	85be                	mv	a1,a5
80002664:	28000537          	lui	a0,0x28000
80002668:	3445                	jal	80002108 <GPIO_ITStatusClear>
  for (uint8_t i = 0; i < 4; i++) {
8000266a:	fef44783          	lbu	a5,-17(s0)
8000266e:	0785                	addi	a5,a5,1
80002670:	fef407a3          	sb	a5,-17(s0)
80002674:	fef44703          	lbu	a4,-17(s0)
80002678:	478d                	li	a5,3
8000267a:	e2e7f9e3          	bgeu	a5,a4,800024ac <gpio_irq_handler+0x56>
    }
  }
}
8000267e:	0001                	nop
80002680:	0001                	nop
80002682:	50f2                	lw	ra,60(sp)
80002684:	5462                	lw	s0,56(sp)
80002686:	6121                	addi	sp,sp,64
80002688:	8082                	ret

8000268a <tmr32_init>:

static void tmr32_init(void) 
{
8000268a:	1101                	addi	sp,sp,-32
8000268c:	ce06                	sw	ra,28(sp)
8000268e:	cc22                	sw	s0,24(sp)
80002690:	1000                	addi	s0,sp,32
  // Тактирование TMR32
  RCU->CGCFGAPB_bit.TMR32EN = 1;
80002692:	3000e7b7          	lui	a5,0x3000e
80002696:	4798                	lw	a4,8(a5)
80002698:	00176713          	ori	a4,a4,1
8000269c:	c798                	sw	a4,8(a5)
  RCU->RSTDISAPB_bit.TMR32EN = 1;
8000269e:	3000e7b7          	lui	a5,0x3000e
800026a2:	4f98                	lw	a4,24(a5)
800026a4:	00176713          	ori	a4,a4,1
800026a8:	cf98                	sw	a4,24(a5)

  // Настройка таймера: SYSCLK / 8, режим Up до CAPCOM0, период ~1 мс
  TMR32_SetClksel(TMR32_Clksel_SysClk);
800026aa:	4501                	li	a0,0
800026ac:	38d5                	jal	80001fa0 <TMR32_SetClksel>
  TMR32_SetDivider(TMR32_Div_8);
800026ae:	450d                	li	a0,3
800026b0:	30d1                	jal	80001f74 <TMR32_SetDivider>
  TMR32_SetMode(TMR32_Mode_Capcom_Up);
800026b2:	4505                	li	a0,1
800026b4:	3851                	jal	80001f48 <TMR32_SetMode>
  uint32_t cmp = (SystemCoreClock / 8u) / 1000u; // 1 мс
800026b6:	e181a703          	lw	a4,-488(gp) # 40000598 <SystemCoreClock>
800026ba:	6789                	lui	a5,0x2
800026bc:	f4078793          	addi	a5,a5,-192 # 1f40 <STACK_SIZE+0x1740>
800026c0:	02f757b3          	divu	a5,a4,a5
800026c4:	fef42623          	sw	a5,-20(s0)
  if (cmp == 0) cmp = 1;
800026c8:	fec42783          	lw	a5,-20(s0)
800026cc:	e781                	bnez	a5,800026d4 <tmr32_init+0x4a>
800026ce:	4785                	li	a5,1
800026d0:	fef42623          	sw	a5,-20(s0)
  TMR32_CAPCOM_SetComparator(TMR32_CAPCOM_0, cmp);
800026d4:	fec42583          	lw	a1,-20(s0)
800026d8:	4501                	li	a0,0
800026da:	32bd                	jal	80002048 <TMR32_CAPCOM_SetComparator>
  TMR32_SetCounter(0);
800026dc:	4501                	li	a0,0
800026de:	30fd                	jal	80001fcc <TMR32_SetCounter>

  // Прерывание по переполнению таймера (обновление)
  TMR32_ITCmd(TMR32_IT_TimerUpdate, ENABLE);
800026e0:	4585                	li	a1,1
800026e2:	4501                	li	a0,0
800026e4:	3211                	jal	80001fe8 <TMR32_ITCmd>

  // Регистрация обработчика в PLIC
  PLIC_SetPriority(PLIC_TMR32_VECTNUM, 1);
800026e6:	4585                	li	a1,1
800026e8:	4519                	li	a0,6
800026ea:	864fe0ef          	jal	ra,8000074e <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_TMR32_VECTNUM, tmr32_irq_handler);
800026ee:	800027b7          	lui	a5,0x80002
800026f2:	71078613          	addi	a2,a5,1808 # 80002710 <__data_source_start+0xffff8cec>
800026f6:	4599                	li	a1,6
800026f8:	4501                	li	a0,0
800026fa:	808fe0ef          	jal	ra,80000702 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_TMR32_VECTNUM);
800026fe:	4599                	li	a1,6
80002700:	4501                	li	a0,0
80002702:	876fe0ef          	jal	ra,80000778 <PLIC_IntEnable>
}
80002706:	0001                	nop
80002708:	40f2                	lw	ra,28(sp)
8000270a:	4462                	lw	s0,24(sp)
8000270c:	6105                	addi	sp,sp,32
8000270e:	8082                	ret

80002710 <tmr32_irq_handler>:

static void tmr32_irq_handler(void)
{
80002710:	1141                	addi	sp,sp,-16
80002712:	c606                	sw	ra,12(sp)
80002714:	c422                	sw	s0,8(sp)
80002716:	0800                	addi	s0,sp,16
  // Инкремент тиков, сброс флага
  ms_ticks++;
80002718:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
8000271c:	00178713          	addi	a4,a5,1
80002720:	e2e1a423          	sw	a4,-472(gp) # 400005a8 <ms_ticks>
  // 1 мс тик для OSDP (временное управление LED)
  osdp_tick_1ms();
80002724:	2bc020ef          	jal	ra,800049e0 <osdp_tick_1ms>
  TMR32_ITClear(TMR32_IT_TimerUpdate);
80002728:	4501                	li	a0,0
8000272a:	38ed                	jal	80002024 <TMR32_ITClear>
}
8000272c:	0001                	nop
8000272e:	40b2                	lw	ra,12(sp)
80002730:	4422                	lw	s0,8(sp)
80002732:	0141                	addi	sp,sp,16
80002734:	8082                	ret

80002736 <main>:



//-- Main ----------------------------------------------------------------------
int main(void)
{
80002736:	1101                	addi	sp,sp,-32
80002738:	ce06                	sw	ra,28(sp)
8000273a:	cc22                	sw	s0,24(sp)
8000273c:	1000                	addi	s0,sp,32
  periph_init();
8000273e:	3e31                	jal	8000225a <periph_init>
  
  while(1)
  {
    adcsar_sample_t sample;
    if (adcsar_poll(&sample)) {
80002740:	fe440793          	addi	a5,s0,-28
80002744:	853e                	mv	a0,a5
80002746:	23b1                	jal	80002c92 <adcsar_poll>
80002748:	87aa                	mv	a5,a0
8000274a:	c7ad                	beqz	a5,800027b4 <main+0x7e>
      if (sample.state_char != g_adc_last_state) {
8000274c:	fec44703          	lbu	a4,-20(s0)
80002750:	8841c783          	lbu	a5,-1916(gp) # 40000004 <g_adc_last_state>
80002754:	04f70863          	beq	a4,a5,800027a4 <main+0x6e>
        if (g_adc_candidate_state != sample.state_char) {
80002758:	fec44703          	lbu	a4,-20(s0)
8000275c:	8851c783          	lbu	a5,-1915(gp) # 40000005 <g_adc_candidate_state>
80002760:	00f70b63          	beq	a4,a5,80002776 <main+0x40>
          g_adc_candidate_state = sample.state_char;
80002764:	fec44703          	lbu	a4,-20(s0)
80002768:	88e182a3          	sb	a4,-1915(gp) # 40000005 <g_adc_candidate_state>
          g_adc_candidate_ms = ms_ticks;
8000276c:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80002770:	e6e1aa23          	sw	a4,-396(gp) # 400005f4 <g_adc_candidate_ms>
80002774:	a081                	j	800027b4 <main+0x7e>
        } else if ((ms_ticks - g_adc_candidate_ms) >= g_adc_state_confirm_ms) {
80002776:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
8000277a:	e741a783          	lw	a5,-396(gp) # 400005f4 <g_adc_candidate_ms>
8000277e:	8f1d                	sub	a4,a4,a5
80002780:	03200793          	li	a5,50
80002784:	02f76863          	bltu	a4,a5,800027b4 <main+0x7e>
          printf("ADC state: %c\r\n", sample.state_char);
80002788:	fec44783          	lbu	a5,-20(s0)
8000278c:	85be                	mv	a1,a5
8000278e:	800097b7          	lui	a5,0x80009
80002792:	5a078513          	addi	a0,a5,1440 # 800095a0 <__data_source_start+0xfffffb7c>
80002796:	b27fe0ef          	jal	ra,800012bc <printf>
          g_adc_last_state = sample.state_char;
8000279a:	fec44703          	lbu	a4,-20(s0)
8000279e:	88e18223          	sb	a4,-1916(gp) # 40000004 <g_adc_last_state>
800027a2:	a809                	j	800027b4 <main+0x7e>
        }
      } else {
        g_adc_candidate_state = sample.state_char;
800027a4:	fec44703          	lbu	a4,-20(s0)
800027a8:	88e182a3          	sb	a4,-1915(gp) # 40000005 <g_adc_candidate_state>
        g_adc_candidate_ms = ms_ticks;
800027ac:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
800027b0:	e6e1aa23          	sw	a4,-396(gp) # 400005f4 <g_adc_candidate_ms>
      }
    }
    __asm volatile("wfi");
800027b4:	10500073          	wfi
  {
800027b8:	b761                	j	80002740 <main+0xa>

800027ba <ADCSAR_SEQ_SwStartEnCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SwStartEnCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
800027ba:	1101                	addi	sp,sp,-32
800027bc:	ce22                	sw	s0,28(sp)
800027be:	1000                	addi	s0,sp,32
800027c0:	fea42623          	sw	a0,-20(s0)
800027c4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQSYNC, 1 << (uint32_t)SEQ_Num, State << (uint32_t)SEQ_Num);
800027c8:	300107b7          	lui	a5,0x30010
800027cc:	43dc                	lw	a5,4(a5)
800027ce:	fec42703          	lw	a4,-20(s0)
800027d2:	4685                	li	a3,1
800027d4:	00e69733          	sll	a4,a3,a4
800027d8:	fff74713          	not	a4,a4
800027dc:	00e7f6b3          	and	a3,a5,a4
800027e0:	fec42783          	lw	a5,-20(s0)
800027e4:	fe842703          	lw	a4,-24(s0)
800027e8:	00f71733          	sll	a4,a4,a5
800027ec:	300107b7          	lui	a5,0x30010
800027f0:	8f55                	or	a4,a4,a3
800027f2:	c3d8                	sw	a4,4(a5)
}
800027f4:	0001                	nop
800027f6:	4472                	lw	s0,28(sp)
800027f8:	6105                	addi	sp,sp,32
800027fa:	8082                	ret

800027fc <ADCSAR_SEQ_SwStartCmd>:
/**
  * @brief   Генерация импульса программного запуска
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SwStartCmd(void)
{
800027fc:	1141                	addi	sp,sp,-16
800027fe:	c622                	sw	s0,12(sp)
80002800:	0800                	addi	s0,sp,16
    WRITE_REG(ADCSAR->SEQSYNC_bit.GSYNC, 1);
80002802:	300107b7          	lui	a5,0x30010
80002806:	43d4                	lw	a3,4(a5)
80002808:	80000737          	lui	a4,0x80000
8000280c:	8f55                	or	a4,a4,a3
8000280e:	c3d8                	sw	a4,4(a5)
}
80002810:	0001                	nop
80002812:	4432                	lw	s0,12(sp)
80002814:	0141                	addi	sp,sp,16
80002816:	8082                	ret

80002818 <ADCSAR_SEQ_FIFOFullStatusClear>:
  * @brief   Сброс статуса заполнения буфера секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_FIFOFullStatusClear(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
80002818:	1101                	addi	sp,sp,-32
8000281a:	ce22                	sw	s0,28(sp)
8000281c:	1000                	addi	s0,sp,32
8000281e:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    WRITE_REG(ADCSAR->FSTAT, 1 << ((uint32_t)SEQ_Num + ADCSAR_FSTAT_OV0_Pos));
80002822:	fec42783          	lw	a5,-20(s0)
80002826:	4705                	li	a4,1
80002828:	00f71733          	sll	a4,a4,a5
8000282c:	300107b7          	lui	a5,0x30010
80002830:	c798                	sw	a4,8(a5)
}
80002832:	0001                	nop
80002834:	4472                	lw	s0,28(sp)
80002836:	6105                	addi	sp,sp,32
80002838:	8082                	ret

8000283a <ADCSAR_SEQ_FIFOEmptyStatusClear>:
  * @brief   Сброс статуса пустоты буфера секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_FIFOEmptyStatusClear(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
8000283a:	1101                	addi	sp,sp,-32
8000283c:	ce22                	sw	s0,28(sp)
8000283e:	1000                	addi	s0,sp,32
80002840:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    WRITE_REG(ADCSAR->FSTAT, 1 << ((uint32_t)SEQ_Num + ADCSAR_FSTAT_UN0_Pos));
80002844:	fec42783          	lw	a5,-20(s0)
80002848:	07a1                	addi	a5,a5,8 # 30010008 <STACK_SIZE+0x3000f808>
8000284a:	4705                	li	a4,1
8000284c:	00f71733          	sll	a4,a4,a5
80002850:	300107b7          	lui	a5,0x30010
80002854:	c798                	sw	a4,8(a5)
}
80002856:	0001                	nop
80002858:	4472                	lw	s0,28(sp)
8000285a:	6105                	addi	sp,sp,32
8000285c:	8082                	ret

8000285e <ADCSAR_SEQ_StartEventConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   StartEvent  Выбор события
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_StartEventConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_StartEvent_TypeDef StartEvent)
{
8000285e:	1101                	addi	sp,sp,-32
80002860:	ce22                	sw	s0,28(sp)
80002862:	1000                	addi	s0,sp,32
80002864:	fea42623          	sw	a0,-20(s0)
80002868:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    MODIFY_REG(ADCSAR->EMUX, 0xF << ((uint32_t)SEQ_Num * 4), StartEvent << ((uint32_t)SEQ_Num * 4));
8000286c:	300107b7          	lui	a5,0x30010
80002870:	4fdc                	lw	a5,28(a5)
80002872:	fec42703          	lw	a4,-20(s0)
80002876:	070a                	slli	a4,a4,0x2
80002878:	46bd                	li	a3,15
8000287a:	00e69733          	sll	a4,a3,a4
8000287e:	fff74713          	not	a4,a4
80002882:	00e7f6b3          	and	a3,a5,a4
80002886:	fec42783          	lw	a5,-20(s0)
8000288a:	078a                	slli	a5,a5,0x2
8000288c:	fe842703          	lw	a4,-24(s0)
80002890:	00f71733          	sll	a4,a4,a5
80002894:	300107b7          	lui	a5,0x30010
80002898:	8f55                	or	a4,a4,a3
8000289a:	cfd8                	sw	a4,28(a5)
}
8000289c:	0001                	nop
8000289e:	4472                	lw	s0,28(sp)
800028a0:	6105                	addi	sp,sp,32
800028a2:	8082                	ret

800028a4 <ADCSAR_SEQ_GetFIFOLoad>:
  * @brief   Получение текущего значения количества результатов в буфере секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  Val  Значение
  */
__STATIC_INLINE uint32_t ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
800028a4:	1101                	addi	sp,sp,-32
800028a6:	ce22                	sw	s0,28(sp)
800028a8:	1000                	addi	s0,sp,32
800028aa:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    return READ_REG(ADCSAR->SEQ[SEQ_Num].SFLOAD_bit.VAL);
800028ae:	300106b7          	lui	a3,0x30010
800028b2:	fec42703          	lw	a4,-20(s0)
800028b6:	87ba                	mv	a5,a4
800028b8:	0792                	slli	a5,a5,0x4
800028ba:	8f99                	sub	a5,a5,a4
800028bc:	078a                	slli	a5,a5,0x2
800028be:	97b6                	add	a5,a5,a3
800028c0:	5bfc                	lw	a5,116(a5)
800028c2:	03f7f793          	andi	a5,a5,63
800028c6:	0ff7f793          	zext.b	a5,a5
}
800028ca:	853e                	mv	a0,a5
800028cc:	4472                	lw	s0,28(sp)
800028ce:	6105                	addi	sp,sp,32
800028d0:	8082                	ret

800028d2 <ADCSAR_SEQ_GetFIFOData>:
  * @brief   Получение результата измерения из буфера секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  Val  Значение
  */
__STATIC_INLINE uint32_t ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
800028d2:	1101                	addi	sp,sp,-32
800028d4:	ce22                	sw	s0,28(sp)
800028d6:	1000                	addi	s0,sp,32
800028d8:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    return READ_REG(ADCSAR->SEQ[SEQ_Num].SFIFO_bit.DATA);
800028dc:	300106b7          	lui	a3,0x30010
800028e0:	fec42703          	lw	a4,-20(s0)
800028e4:	87ba                	mv	a5,a4
800028e6:	0792                	slli	a5,a5,0x4
800028e8:	8f99                	sub	a5,a5,a4
800028ea:	078a                	slli	a5,a5,0x2
800028ec:	97b6                	add	a5,a5,a3
800028ee:	5fbc                	lw	a5,120(a5)
800028f0:	873e                	mv	a4,a5
800028f2:	6785                	lui	a5,0x1
800028f4:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
800028f6:	8ff9                	and	a5,a5,a4
800028f8:	07c2                	slli	a5,a5,0x10
800028fa:	83c1                	srli	a5,a5,0x10
}
800028fc:	853e                	mv	a0,a5
800028fe:	4472                	lw	s0,28(sp)
80002900:	6105                	addi	sp,sp,32
80002902:	8082                	ret

80002904 <ADCSAR_SEQ_ITCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ITCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80002904:	1101                	addi	sp,sp,-32
80002906:	ce22                	sw	s0,28(sp)
80002908:	1000                	addi	s0,sp,32
8000290a:	fea42623          	sw	a0,-20(s0)
8000290e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->IM, 1 << ((uint32_t)SEQ_Num + ADCSAR_IM_SEQIM0_Pos), State << ((uint32_t)SEQ_Num + ADCSAR_IM_SEQIM0_Pos));
80002912:	300107b7          	lui	a5,0x30010
80002916:	53dc                	lw	a5,36(a5)
80002918:	fec42703          	lw	a4,-20(s0)
8000291c:	4685                	li	a3,1
8000291e:	00e69733          	sll	a4,a3,a4
80002922:	fff74713          	not	a4,a4
80002926:	00e7f6b3          	and	a3,a5,a4
8000292a:	fec42783          	lw	a5,-20(s0)
8000292e:	fe842703          	lw	a4,-24(s0)
80002932:	00f71733          	sll	a4,a4,a5
80002936:	300107b7          	lui	a5,0x30010
8000293a:	8f55                	or	a4,a4,a3
8000293c:	d3d8                	sw	a4,36(a5)
}
8000293e:	0001                	nop
80002940:	4472                	lw	s0,28(sp)
80002942:	6105                	addi	sp,sp,32
80002944:	8082                	ret

80002946 <ADCSAR_SEQ_ITConfig>:
  *                   0 - по каждому запросу, 0xFF - каждые 256 запросов.
  * @param   ITCountNoRst  Активация режима, где счетчик прерывания не будет сбрасываться по запуску секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ITConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t ITCount, FunctionalState ITCountNoRst)
{
80002946:	1101                	addi	sp,sp,-32
80002948:	ce22                	sw	s0,28(sp)
8000294a:	1000                	addi	s0,sp,32
8000294c:	fea42623          	sw	a0,-20(s0)
80002950:	feb42423          	sw	a1,-24(s0)
80002954:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_IT_COUNT_VAL(ITCount));
    assert_param(IS_FUNCTIONAL_STATE(ITCountNoRst));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.ICNT, ITCount);
80002958:	30010637          	lui	a2,0x30010
8000295c:	fe842783          	lw	a5,-24(s0)
80002960:	0ff7f693          	zext.b	a3,a5
80002964:	fec42703          	lw	a4,-20(s0)
80002968:	87ba                	mv	a5,a4
8000296a:	0792                	slli	a5,a5,0x4
8000296c:	8f99                	sub	a5,a5,a4
8000296e:	078a                	slli	a5,a5,0x2
80002970:	97b2                	add	a5,a5,a2
80002972:	06d78323          	sb	a3,102(a5) # 30010066 <STACK_SIZE+0x3000f866>
    MODIFY_REG(ADCSAR->CICNT, 1 << ((uint32_t)SEQ_Num + ADCSAR_CICNT_ICNT0_Pos), ITCountNoRst << ((uint32_t)SEQ_Num + ADCSAR_CICNT_ICNT0_Pos));
80002976:	300107b7          	lui	a5,0x30010
8000297a:	4f9c                	lw	a5,24(a5)
8000297c:	fec42703          	lw	a4,-20(s0)
80002980:	4685                	li	a3,1
80002982:	00e69733          	sll	a4,a3,a4
80002986:	fff74713          	not	a4,a4
8000298a:	00e7f6b3          	and	a3,a5,a4
8000298e:	fec42783          	lw	a5,-20(s0)
80002992:	fe442703          	lw	a4,-28(s0)
80002996:	00f71733          	sll	a4,a4,a5
8000299a:	300107b7          	lui	a5,0x30010
8000299e:	8f55                	or	a4,a4,a3
800029a0:	cf98                	sw	a4,24(a5)
}
800029a2:	0001                	nop
800029a4:	4472                	lw	s0,28(sp)
800029a6:	6105                	addi	sp,sp,32
800029a8:	8082                	ret

800029aa <ADCSAR_SEQ_ITStatusClear>:
  * @brief   Сброс флага прерывания секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ITStatusClear(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
800029aa:	1101                	addi	sp,sp,-32
800029ac:	ce22                	sw	s0,28(sp)
800029ae:	1000                	addi	s0,sp,32
800029b0:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    WRITE_REG(ADCSAR->IC, 1 << ((uint32_t)SEQ_Num + ADCSAR_IC_SEQIC0_Pos));
800029b4:	fec42783          	lw	a5,-20(s0)
800029b8:	4705                	li	a4,1
800029ba:	00f71733          	sll	a4,a4,a5
800029be:	300107b7          	lui	a5,0x30010
800029c2:	d7d8                	sw	a4,44(a5)
}
800029c4:	0001                	nop
800029c6:	4472                	lw	s0,28(sp)
800029c8:	6105                	addi	sp,sp,32
800029ca:	8082                	ret

800029cc <classify_code_char>:
void ADC_IRQHandler(void);

static volatile uint8_t s_adc_irq_flag = 0;

static char classify_code_char(uint16_t code)
{
800029cc:	1101                	addi	sp,sp,-32
800029ce:	ce22                	sw	s0,28(sp)
800029d0:	1000                	addi	s0,sp,32
800029d2:	87aa                	mv	a5,a0
800029d4:	fef41723          	sh	a5,-18(s0)
    if (code <= ADCSAR_THR_SHORT_MAX) return 'T';
800029d8:	fee45703          	lhu	a4,-18(s0)
800029dc:	03100793          	li	a5,49
800029e0:	00e7e563          	bltu	a5,a4,800029ea <classify_code_char+0x1e>
800029e4:	05400793          	li	a5,84
800029e8:	a891                	j	80002a3c <classify_code_char+0x70>
    if (code >= ADCSAR_THR_TAMPER_MIN) return 'S';
800029ea:	fee45703          	lhu	a4,-18(s0)
800029ee:	0f000793          	li	a5,240
800029f2:	00e7f563          	bgeu	a5,a4,800029fc <classify_code_char+0x30>
800029f6:	05300793          	li	a5,83
800029fa:	a089                	j	80002a3c <classify_code_char+0x70>
    if (code >= ADCSAR_THR_ALARM_MIN && code <= ADCSAR_THR_ALARM_MAX) return 'A';
800029fc:	fee45703          	lhu	a4,-18(s0)
80002a00:	03100793          	li	a5,49
80002a04:	00e7fb63          	bgeu	a5,a4,80002a1a <classify_code_char+0x4e>
80002a08:	fee45703          	lhu	a4,-18(s0)
80002a0c:	07800793          	li	a5,120
80002a10:	00e7e563          	bltu	a5,a4,80002a1a <classify_code_char+0x4e>
80002a14:	04100793          	li	a5,65
80002a18:	a015                	j	80002a3c <classify_code_char+0x70>
    if (code >= ADCSAR_THR_NORMAL_MIN && code <= ADCSAR_THR_NORMAL_MAX) return 'N';
80002a1a:	fee45703          	lhu	a4,-18(s0)
80002a1e:	07800793          	li	a5,120
80002a22:	00e7fb63          	bgeu	a5,a4,80002a38 <classify_code_char+0x6c>
80002a26:	fee45703          	lhu	a4,-18(s0)
80002a2a:	0f000793          	li	a5,240
80002a2e:	00e7e563          	bltu	a5,a4,80002a38 <classify_code_char+0x6c>
80002a32:	04e00793          	li	a5,78
80002a36:	a019                	j	80002a3c <classify_code_char+0x70>
    return 'U';
80002a38:	05500793          	li	a5,85
}
80002a3c:	853e                	mv	a0,a5
80002a3e:	4472                	lw	s0,28(sp)
80002a40:	6105                	addi	sp,sp,32
80002a42:	8082                	ret

80002a44 <adcsar_classify_code>:

char adcsar_classify_code(uint16_t code)
{
80002a44:	1101                	addi	sp,sp,-32
80002a46:	ce06                	sw	ra,28(sp)
80002a48:	cc22                	sw	s0,24(sp)
80002a4a:	1000                	addi	s0,sp,32
80002a4c:	87aa                	mv	a5,a0
80002a4e:	fef41723          	sh	a5,-18(s0)
    return classify_code_char(code);
80002a52:	fee45783          	lhu	a5,-18(s0)
80002a56:	853e                	mv	a0,a5
80002a58:	3f95                	jal	800029cc <classify_code_char>
80002a5a:	87aa                	mv	a5,a0
}
80002a5c:	853e                	mv	a0,a5
80002a5e:	40f2                	lw	ra,28(sp)
80002a60:	4462                	lw	s0,24(sp)
80002a62:	6105                	addi	sp,sp,32
80002a64:	8082                	ret

80002a66 <state_from_char>:

static adcsar_state_t state_from_char(char c)
{
80002a66:	1101                	addi	sp,sp,-32
80002a68:	ce22                	sw	s0,28(sp)
80002a6a:	1000                	addi	s0,sp,32
80002a6c:	87aa                	mv	a5,a0
80002a6e:	fef407a3          	sb	a5,-17(s0)
    switch (c) {
80002a72:	fef44783          	lbu	a5,-17(s0)
80002a76:	05400713          	li	a4,84
80002a7a:	02e78763          	beq	a5,a4,80002aa8 <state_from_char+0x42>
80002a7e:	05400713          	li	a4,84
80002a82:	02f74b63          	blt	a4,a5,80002ab8 <state_from_char+0x52>
80002a86:	05300713          	li	a4,83
80002a8a:	02e78563          	beq	a5,a4,80002ab4 <state_from_char+0x4e>
80002a8e:	05300713          	li	a4,83
80002a92:	02f74363          	blt	a4,a5,80002ab8 <state_from_char+0x52>
80002a96:	04100713          	li	a4,65
80002a9a:	00e78963          	beq	a5,a4,80002aac <state_from_char+0x46>
80002a9e:	04e00713          	li	a4,78
80002aa2:	00e78763          	beq	a5,a4,80002ab0 <state_from_char+0x4a>
80002aa6:	a809                	j	80002ab8 <state_from_char+0x52>
    case 'T': return ADCSAR_STATE_SHORT;
80002aa8:	4785                	li	a5,1
80002aaa:	a801                	j	80002aba <state_from_char+0x54>
    case 'A': return ADCSAR_STATE_ALARM;
80002aac:	4789                	li	a5,2
80002aae:	a031                	j	80002aba <state_from_char+0x54>
    case 'N': return ADCSAR_STATE_NORMAL;
80002ab0:	478d                	li	a5,3
80002ab2:	a021                	j	80002aba <state_from_char+0x54>
    case 'S': return ADCSAR_STATE_TAMPER;
80002ab4:	4791                	li	a5,4
80002ab6:	a011                	j	80002aba <state_from_char+0x54>
    default:  return ADCSAR_STATE_UNDEF;
80002ab8:	4781                	li	a5,0
    }
}
80002aba:	853e                	mv	a0,a5
80002abc:	4472                	lw	s0,28(sp)
80002abe:	6105                	addi	sp,sp,32
80002ac0:	8082                	ret

80002ac2 <adcsar_init>:

void adcsar_init(void)
{
80002ac2:	1101                	addi	sp,sp,-32
80002ac4:	ce06                	sw	ra,28(sp)
80002ac6:	cc22                	sw	s0,24(sp)
80002ac8:	1000                	addi	s0,sp,32
    PMUSYS->ADCPWRCFG_bit.LDOEN = 1;
80002aca:	3000f7b7          	lui	a5,0x3000f
80002ace:	0107c703          	lbu	a4,16(a5) # 3000f010 <STACK_SIZE+0x3000e810>
80002ad2:	00176713          	ori	a4,a4,1
80002ad6:	00e78823          	sb	a4,16(a5)
    PMUSYS->ADCPWRCFG_bit.LVLDIS = 0;
80002ada:	3000f7b7          	lui	a5,0x3000f
80002ade:	0107c703          	lbu	a4,16(a5) # 3000f010 <STACK_SIZE+0x3000e810>
80002ae2:	9b75                	andi	a4,a4,-3
80002ae4:	00e78823          	sb	a4,16(a5)

    RCU->ADCSARCLKCFG_bit.CLKSEL = 1;
80002ae8:	3000e7b7          	lui	a5,0x3000e
80002aec:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80002af0:	fffd0737          	lui	a4,0xfffd0
80002af4:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc65db>
80002af6:	8ef9                	and	a3,a3,a4
80002af8:	6741                	lui	a4,0x10
80002afa:	8f55                	or	a4,a4,a3
80002afc:	0ae7a823          	sw	a4,176(a5)
    RCU->ADCSARCLKCFG_bit.DIVN = 2;
80002b00:	3000e7b7          	lui	a5,0x3000e
80002b04:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80002b08:	c1000737          	lui	a4,0xc1000
80002b0c:	177d                	addi	a4,a4,-1 # c0ffffff <__data_source_start+0x40ff65db>
80002b0e:	8ef9                	and	a3,a3,a4
80002b10:	02000737          	lui	a4,0x2000
80002b14:	8f55                	or	a4,a4,a3
80002b16:	0ae7a823          	sw	a4,176(a5)
    RCU->ADCSARCLKCFG_bit.DIVEN = 1;
80002b1a:	3000e7b7          	lui	a5,0x3000e
80002b1e:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80002b22:	00100737          	lui	a4,0x100
80002b26:	8f55                	or	a4,a4,a3
80002b28:	0ae7a823          	sw	a4,176(a5)

    RCU->CGCFGAPB_bit.ADCSAREN = 1;
80002b2c:	3000e7b7          	lui	a5,0x3000e
80002b30:	4794                	lw	a3,8(a5)
80002b32:	6741                	lui	a4,0x10
80002b34:	8f55                	or	a4,a4,a3
80002b36:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.ADCSAREN = 1;
80002b38:	3000e7b7          	lui	a5,0x3000e
80002b3c:	4f94                	lw	a3,24(a5)
80002b3e:	6741                	lui	a4,0x10
80002b40:	8f55                	or	a4,a4,a3
80002b42:	cf98                	sw	a4,24(a5)
    RCU->ADCSARCLKCFG_bit.CLKEN = 1;
80002b44:	3000e7b7          	lui	a5,0x3000e
80002b48:	0b07a703          	lw	a4,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80002b4c:	00176713          	ori	a4,a4,1
80002b50:	0ae7a823          	sw	a4,176(a5)
    RCU->ADCSARCLKCFG_bit.RSTDIS = 1;
80002b54:	3000e7b7          	lui	a5,0x3000e
80002b58:	0b07a703          	lw	a4,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80002b5c:	10076713          	ori	a4,a4,256
80002b60:	0ae7a823          	sw	a4,176(a5)

    ADCSAR->ACTL_bit.SELRES = ADCSAR_ACTL_SELRES_8bit;
80002b64:	300107b7          	lui	a5,0x30010
80002b68:	5407a703          	lw	a4,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
80002b6c:	fcf77713          	andi	a4,a4,-49
80002b70:	01076713          	ori	a4,a4,16
80002b74:	54e7a023          	sw	a4,1344(a5)
    ADCSAR->ACTL_bit.CALEN = 1;
80002b78:	300107b7          	lui	a5,0x30010
80002b7c:	5407a703          	lw	a4,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
80002b80:	10076713          	ori	a4,a4,256
80002b84:	54e7a023          	sw	a4,1344(a5)
    ADCSAR->ACTL_bit.ADCEN = 1;
80002b88:	300107b7          	lui	a5,0x30010
80002b8c:	5407a703          	lw	a4,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
80002b90:	00176713          	ori	a4,a4,1
80002b94:	54e7a023          	sw	a4,1344(a5)

    ADCSAR->EMUX_bit.EM0 = 0;
80002b98:	300107b7          	lui	a5,0x30010
80002b9c:	01c7c703          	lbu	a4,28(a5) # 3001001c <STACK_SIZE+0x3000f81c>
80002ba0:	9b41                	andi	a4,a4,-16
80002ba2:	00e78e23          	sb	a4,28(a5)
    ADCSAR->SEQ[0].SRQCTL_bit.RQMAX = 0x0;
80002ba6:	300107b7          	lui	a5,0x30010
80002baa:	0587d703          	lhu	a4,88(a5) # 30010058 <STACK_SIZE+0x3000f858>
80002bae:	9b61                	andi	a4,a4,-8
80002bb0:	04e79c23          	sh	a4,88(a5)
    ADCSAR->SEQ[0].SRQSEL_bit.RQ0 = 0x0;
80002bb4:	300107b7          	lui	a5,0x30010
80002bb8:	43b8                	lw	a4,64(a5)
80002bba:	9b41                	andi	a4,a4,-16
80002bbc:	c3b8                	sw	a4,64(a5)
    ADCSAR->SEQEN_bit.SEQEN0 = 1;
80002bbe:	300107b7          	lui	a5,0x30010
80002bc2:	0007c703          	lbu	a4,0(a5) # 30010000 <STACK_SIZE+0x3000f800>
80002bc6:	00176713          	ori	a4,a4,1
80002bca:	00e78023          	sb	a4,0(a5)
    ADCSAR_SEQ_StartEventConfig(ADCSAR_SEQ_Num_0, ADCSAR_SEQ_StartEvent_SwReq);
80002bce:	4581                	li	a1,0
80002bd0:	4501                	li	a0,0
80002bd2:	3171                	jal	8000285e <ADCSAR_SEQ_StartEventConfig>
    ADCSAR_SEQ_SwStartEnCmd(ADCSAR_SEQ_Num_0, ENABLE);
80002bd4:	4585                	li	a1,1
80002bd6:	4501                	li	a0,0
80002bd8:	36cd                	jal	800027ba <ADCSAR_SEQ_SwStartEnCmd>

    {
        uint32_t guard = 1000000;
80002bda:	000f47b7          	lui	a5,0xf4
80002bde:	24078793          	addi	a5,a5,576 # f4240 <STACK_SIZE+0xf3a40>
80002be2:	fef42623          	sw	a5,-20(s0)
        while (!ADCSAR->ACTL_bit.ADCRDY && guard--) ;
80002be6:	0001                	nop
80002be8:	300107b7          	lui	a5,0x30010
80002bec:	5407a783          	lw	a5,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
80002bf0:	8385                	srli	a5,a5,0x1
80002bf2:	8b85                	andi	a5,a5,1
80002bf4:	0ff7f793          	zext.b	a5,a5
80002bf8:	eb81                	bnez	a5,80002c08 <adcsar_init+0x146>
80002bfa:	fec42783          	lw	a5,-20(s0)
80002bfe:	fff78713          	addi	a4,a5,-1
80002c02:	fee42623          	sw	a4,-20(s0)
80002c06:	f3ed                	bnez	a5,80002be8 <adcsar_init+0x126>
    }
    ADCSAR->SEQSYNC_bit.SYNC0 = 1;
80002c08:	300107b7          	lui	a5,0x30010
80002c0c:	43d8                	lw	a4,4(a5)
80002c0e:	00176713          	ori	a4,a4,1
80002c12:	c3d8                	sw	a4,4(a5)
    ADCSAR->SEQSYNC_bit.GSYNC = 1;
80002c14:	300107b7          	lui	a5,0x30010
80002c18:	43d4                	lw	a3,4(a5)
80002c1a:	80000737          	lui	a4,0x80000
80002c1e:	8f55                	or	a4,a4,a3
80002c20:	c3d8                	sw	a4,4(a5)

    ADCSAR_SEQ_ITConfig(ADCSAR_SEQ_Num_0, ADCSAR_SEQ_ReqNum_0, ENABLE);
80002c22:	4605                	li	a2,1
80002c24:	4581                	li	a1,0
80002c26:	4501                	li	a0,0
80002c28:	3b39                	jal	80002946 <ADCSAR_SEQ_ITConfig>
    ADCSAR_SEQ_ITCmd(ADCSAR_SEQ_Num_0, ENABLE);
80002c2a:	4585                	li	a1,1
80002c2c:	4501                	li	a0,0
80002c2e:	39d9                	jal	80002904 <ADCSAR_SEQ_ITCmd>
    ADCSAR_SEQ_ITStatusClear(ADCSAR_SEQ_Num_0);
80002c30:	4501                	li	a0,0
80002c32:	3ba5                	jal	800029aa <ADCSAR_SEQ_ITStatusClear>
    ADCSAR_SEQ_FIFOFullStatusClear(ADCSAR_SEQ_Num_0);
80002c34:	4501                	li	a0,0
80002c36:	36cd                	jal	80002818 <ADCSAR_SEQ_FIFOFullStatusClear>
    ADCSAR_SEQ_FIFOEmptyStatusClear(ADCSAR_SEQ_Num_0);
80002c38:	4501                	li	a0,0
80002c3a:	3101                	jal	8000283a <ADCSAR_SEQ_FIFOEmptyStatusClear>

    PLIC_SetIrqHandler(Plic_Mach_Target, IsrVect_IRQ_ADC, ADC_IRQHandler);
80002c3c:	800037b7          	lui	a5,0x80003
80002c40:	d2c78613          	addi	a2,a5,-724 # 80002d2c <__data_source_start+0xffff9308>
80002c44:	45f5                	li	a1,29
80002c46:	4501                	li	a0,0
80002c48:	abbfd0ef          	jal	ra,80000702 <PLIC_SetIrqHandler>
    PLIC_SetPriority(IsrVect_IRQ_ADC, 1);
80002c4c:	4585                	li	a1,1
80002c4e:	4575                	li	a0,29
80002c50:	afffd0ef          	jal	ra,8000074e <PLIC_SetPriority>
    PLIC_IntEnable(Plic_Mach_Target, IsrVect_IRQ_ADC);
80002c54:	45f5                	li	a1,29
80002c56:	4501                	li	a0,0
80002c58:	b21fd0ef          	jal	ra,80000778 <PLIC_IntEnable>
    PLIC_SetThreshold(Plic_Mach_Target, 0);
80002c5c:	4581                	li	a1,0
80002c5e:	4501                	li	a0,0
80002c60:	ce5fd0ef          	jal	ra,80000944 <PLIC_SetThreshold>

    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
80002c64:	a019                	j	80002c6a <adcsar_init+0x1a8>
        (void)ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_0);
80002c66:	4501                	li	a0,0
80002c68:	31ad                	jal	800028d2 <ADCSAR_SEQ_GetFIFOData>
    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
80002c6a:	4501                	li	a0,0
80002c6c:	3925                	jal	800028a4 <ADCSAR_SEQ_GetFIFOLoad>
80002c6e:	87aa                	mv	a5,a0
80002c70:	fbfd                	bnez	a5,80002c66 <adcsar_init+0x1a4>
    }
}
80002c72:	0001                	nop
80002c74:	0001                	nop
80002c76:	40f2                	lw	ra,28(sp)
80002c78:	4462                	lw	s0,24(sp)
80002c7a:	6105                	addi	sp,sp,32
80002c7c:	8082                	ret

80002c7e <adcsar_start>:

void adcsar_start(void)
{
80002c7e:	1141                	addi	sp,sp,-16
80002c80:	c606                	sw	ra,12(sp)
80002c82:	c422                	sw	s0,8(sp)
80002c84:	0800                	addi	s0,sp,16
    ADCSAR_SEQ_SwStartCmd();
80002c86:	3e9d                	jal	800027fc <ADCSAR_SEQ_SwStartCmd>
}
80002c88:	0001                	nop
80002c8a:	40b2                	lw	ra,12(sp)
80002c8c:	4422                	lw	s0,8(sp)
80002c8e:	0141                	addi	sp,sp,16
80002c90:	8082                	ret

80002c92 <adcsar_poll>:

bool adcsar_poll(adcsar_sample_t *out_sample)
{
80002c92:	7179                	addi	sp,sp,-48
80002c94:	d606                	sw	ra,44(sp)
80002c96:	d422                	sw	s0,40(sp)
80002c98:	1800                	addi	s0,sp,48
80002c9a:	fca42e23          	sw	a0,-36(s0)
    if (!s_adc_irq_flag) {
80002c9e:	e8f1c783          	lbu	a5,-369(gp) # 4000060f <s_adc_irq_flag>
80002ca2:	0ff7f793          	zext.b	a5,a5
80002ca6:	e399                	bnez	a5,80002cac <adcsar_poll+0x1a>
        return false;
80002ca8:	4781                	li	a5,0
80002caa:	a8a5                	j	80002d22 <adcsar_poll+0x90>
    }

    s_adc_irq_flag = 0;
80002cac:	e80187a3          	sb	zero,-369(gp) # 4000060f <s_adc_irq_flag>

    uint32_t load = ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0);
80002cb0:	4501                	li	a0,0
80002cb2:	3ecd                	jal	800028a4 <ADCSAR_SEQ_GetFIFOLoad>
80002cb4:	fea42623          	sw	a0,-20(s0)
    if (!load) {
80002cb8:	fec42783          	lw	a5,-20(s0)
80002cbc:	e399                	bnez	a5,80002cc2 <adcsar_poll+0x30>
        return false;
80002cbe:	4781                	li	a5,0
80002cc0:	a08d                	j	80002d22 <adcsar_poll+0x90>
    }

    uint32_t raw = ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_0);
80002cc2:	4501                	li	a0,0
80002cc4:	3139                	jal	800028d2 <ADCSAR_SEQ_GetFIFOData>
80002cc6:	fea42423          	sw	a0,-24(s0)

    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
80002cca:	a019                	j	80002cd0 <adcsar_poll+0x3e>
        (void)ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_0);
80002ccc:	4501                	li	a0,0
80002cce:	3111                	jal	800028d2 <ADCSAR_SEQ_GetFIFOData>
    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
80002cd0:	4501                	li	a0,0
80002cd2:	3ec9                	jal	800028a4 <ADCSAR_SEQ_GetFIFOLoad>
80002cd4:	87aa                	mv	a5,a0
80002cd6:	fbfd                	bnez	a5,80002ccc <adcsar_poll+0x3a>
    }

    char state_char = classify_code_char((uint16_t)raw);
80002cd8:	fe842783          	lw	a5,-24(s0)
80002cdc:	07c2                	slli	a5,a5,0x10
80002cde:	83c1                	srli	a5,a5,0x10
80002ce0:	853e                	mv	a0,a5
80002ce2:	31ed                	jal	800029cc <classify_code_char>
80002ce4:	87aa                	mv	a5,a0
80002ce6:	fef403a3          	sb	a5,-25(s0)
    if (out_sample) {
80002cea:	fdc42783          	lw	a5,-36(s0)
80002cee:	cb85                	beqz	a5,80002d1e <adcsar_poll+0x8c>
        out_sample->raw_code = (uint16_t)raw;
80002cf0:	fe842783          	lw	a5,-24(s0)
80002cf4:	01079713          	slli	a4,a5,0x10
80002cf8:	8341                	srli	a4,a4,0x10
80002cfa:	fdc42783          	lw	a5,-36(s0)
80002cfe:	00e79023          	sh	a4,0(a5)
        out_sample->state_char = state_char;
80002d02:	fdc42783          	lw	a5,-36(s0)
80002d06:	fe744703          	lbu	a4,-25(s0)
80002d0a:	00e78423          	sb	a4,8(a5)
        out_sample->state = state_from_char(state_char);
80002d0e:	fe744783          	lbu	a5,-25(s0)
80002d12:	853e                	mv	a0,a5
80002d14:	3b89                	jal	80002a66 <state_from_char>
80002d16:	872a                	mv	a4,a0
80002d18:	fdc42783          	lw	a5,-36(s0)
80002d1c:	c3d8                	sw	a4,4(a5)
    }

    ADCSAR_SEQ_SwStartCmd();
80002d1e:	3cf9                	jal	800027fc <ADCSAR_SEQ_SwStartCmd>
    return true;
80002d20:	4785                	li	a5,1
}
80002d22:	853e                	mv	a0,a5
80002d24:	50b2                	lw	ra,44(sp)
80002d26:	5422                	lw	s0,40(sp)
80002d28:	6145                	addi	sp,sp,48
80002d2a:	8082                	ret

80002d2c <ADC_IRQHandler>:

void ADC_IRQHandler(void)
{
80002d2c:	1141                	addi	sp,sp,-16
80002d2e:	c606                	sw	ra,12(sp)
80002d30:	c422                	sw	s0,8(sp)
80002d32:	0800                	addi	s0,sp,16
    ADCSAR_SEQ_ITStatusClear(ADCSAR_SEQ_Num_0);
80002d34:	4501                	li	a0,0
80002d36:	3995                	jal	800029aa <ADCSAR_SEQ_ITStatusClear>
    s_adc_irq_flag = 1;
80002d38:	4705                	li	a4,1
80002d3a:	e8e187a3          	sb	a4,-369(gp) # 4000060f <s_adc_irq_flag>
}
80002d3e:	0001                	nop
80002d40:	40b2                	lw	ra,12(sp)
80002d42:	4422                	lw	s0,8(sp)
80002d44:	0141                	addi	sp,sp,16
80002d46:	8082                	ret

80002d48 <config_storage_default>:
// Глобальный счётчик миллисекунд из main.c
extern volatile uint32_t ms_ticks;
#include "../../device/Include/system_k1921vg015.h"

void config_storage_default(config_storage_t *cfg) //загружаем дефолтный конфиг
{
80002d48:	1101                	addi	sp,sp,-32
80002d4a:	ce06                	sw	ra,28(sp)
80002d4c:	cc22                	sw	s0,24(sp)
80002d4e:	1000                	addi	s0,sp,32
80002d50:	fea42623          	sw	a0,-20(s0)
    if (!cfg) return;
80002d54:	fec42783          	lw	a5,-20(s0)
80002d58:	c7b9                	beqz	a5,80002da6 <config_storage_default+0x5e>
    memset(cfg, 0, sizeof(*cfg));
80002d5a:	4655                	li	a2,21
80002d5c:	4581                	li	a1,0
80002d5e:	fec42503          	lw	a0,-20(s0)
80002d62:	2ec060ef          	jal	ra,8000904e <memset>
    cfg->osdp_addr = 0x01; 
80002d66:	fec42783          	lw	a5,-20(s0)
80002d6a:	4705                	li	a4,1
80002d6c:	00e78023          	sb	a4,0(a5)
    cfg->osdp_baud = 115200;  
80002d70:	fec42783          	lw	a5,-20(s0)
80002d74:	0017c703          	lbu	a4,1(a5)
80002d78:	8b01                	andi	a4,a4,0
80002d7a:	00e780a3          	sb	a4,1(a5)
80002d7e:	0027c703          	lbu	a4,2(a5)
80002d82:	8b01                	andi	a4,a4,0
80002d84:	fc276713          	ori	a4,a4,-62
80002d88:	00e78123          	sb	a4,2(a5)
80002d8c:	0037c703          	lbu	a4,3(a5)
80002d90:	8b01                	andi	a4,a4,0
80002d92:	00176713          	ori	a4,a4,1
80002d96:	00e781a3          	sb	a4,3(a5)
80002d9a:	0047c703          	lbu	a4,4(a5)
80002d9e:	8b01                	andi	a4,a4,0
80002da0:	00e78223          	sb	a4,4(a5)
80002da4:	a011                	j	80002da8 <config_storage_default+0x60>
    if (!cfg) return;
80002da6:	0001                	nop
}
80002da8:	40f2                	lw	ra,28(sp)
80002daa:	4462                	lw	s0,24(sp)
80002dac:	6105                	addi	sp,sp,32
80002dae:	8082                	ret

80002db0 <config_storage_load>:

bool config_storage_load(config_storage_t *cfg) //читаем конфиг с самого eeprom и проверяем его правильность
{
80002db0:	715d                	addi	sp,sp,-80
80002db2:	c686                	sw	ra,76(sp)
80002db4:	c4a2                	sw	s0,72(sp)
80002db6:	0880                	addi	s0,sp,80
80002db8:	faa42e23          	sw	a0,-68(s0)
    if (!cfg) return false;
80002dbc:	fbc42783          	lw	a5,-68(s0)
80002dc0:	e399                	bnez	a5,80002dc6 <config_storage_load+0x16>
80002dc2:	4781                	li	a5,0
80002dc4:	aa25                	j	80002efc <config_storage_load+0x14c>

    config_storage_t tmp;
    // Инициализируем буфер нулями на случай ошибки чтения
    memset(&tmp, 0, sizeof(tmp));
80002dc6:	fc440793          	addi	a5,s0,-60
80002dca:	4655                	li	a2,21
80002dcc:	4581                	li	a1,0
80002dce:	853e                	mv	a0,a5
80002dd0:	27e060ef          	jal	ra,8000904e <memset>
    
    // Первая попытка чтения (может не пройти сразу после инициализации)
    eeprom_read_bytes(CONFIG_EEPROM_BASE, (uint8_t *)&tmp, sizeof(tmp));
80002dd4:	fc440793          	addi	a5,s0,-60
80002dd8:	4655                	li	a2,21
80002dda:	85be                	mv	a1,a5
80002ddc:	4501                	li	a0,0
80002dde:	23fd                	jal	800033cc <eeprom_read_bytes>

    // Ждём завершения асинхронной операции с таймаутом по ms_ticks
    uint32_t start_ms = ms_ticks;
80002de0:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
80002de4:	fef42023          	sw	a5,-32(s0)
    while (eeprom_is_busy()) {
80002de8:	a821                	j	80002e00 <config_storage_load+0x50>
        if ((ms_ticks - start_ms) > 50u) { // 50 мс таймаут на чтение
80002dea:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80002dee:	fe042783          	lw	a5,-32(s0)
80002df2:	8f1d                	sub	a4,a4,a5
80002df4:	03200793          	li	a5,50
80002df8:	00e7f463          	bgeu	a5,a4,80002e00 <config_storage_load+0x50>
            return false;
80002dfc:	4781                	li	a5,0
80002dfe:	a8fd                	j	80002efc <config_storage_load+0x14c>
    while (eeprom_is_busy()) {
80002e00:	227d                	jal	80002fae <eeprom_is_busy>
80002e02:	87aa                	mv	a5,a0
80002e04:	f3fd                	bnez	a5,80002dea <config_storage_load+0x3a>
        }
    }
    if (eeprom_had_error()) {
80002e06:	2a7d                	jal	80002fc4 <eeprom_had_error>
80002e08:	87aa                	mv	a5,a0
80002e0a:	c399                	beqz	a5,80002e10 <config_storage_load+0x60>
        return false;
80002e0c:	4781                	li	a5,0
80002e0e:	a0fd                	j	80002efc <config_storage_load+0x14c>
    }
    
    // Если первое чтение вернуло только нули, пробуем ещё раз через небольшую паузу
    bool first_read_all_zero = true;
80002e10:	4785                	li	a5,1
80002e12:	fef407a3          	sb	a5,-17(s0)
    for (size_t i = 0; i < sizeof(tmp); i++) {
80002e16:	fe042423          	sw	zero,-24(s0)
80002e1a:	a00d                	j	80002e3c <config_storage_load+0x8c>
        if (((uint8_t*)&tmp)[i] != 0) {
80002e1c:	fc440713          	addi	a4,s0,-60
80002e20:	fe842783          	lw	a5,-24(s0)
80002e24:	97ba                	add	a5,a5,a4
80002e26:	0007c783          	lbu	a5,0(a5)
80002e2a:	c781                	beqz	a5,80002e32 <config_storage_load+0x82>
            first_read_all_zero = false;
80002e2c:	fe0407a3          	sb	zero,-17(s0)
            break;
80002e30:	a819                	j	80002e46 <config_storage_load+0x96>
    for (size_t i = 0; i < sizeof(tmp); i++) {
80002e32:	fe842783          	lw	a5,-24(s0)
80002e36:	0785                	addi	a5,a5,1
80002e38:	fef42423          	sw	a5,-24(s0)
80002e3c:	fe842703          	lw	a4,-24(s0)
80002e40:	47d1                	li	a5,20
80002e42:	fce7fde3          	bgeu	a5,a4,80002e1c <config_storage_load+0x6c>
        }
    }
    
    if (first_read_all_zero) {
80002e46:	fef44783          	lbu	a5,-17(s0)
80002e4a:	cfc9                	beqz	a5,80002ee4 <config_storage_load+0x134>
        // Задержка для стабилизации шины перед повторной попыткой (5 мс достаточно)
        uint32_t cpu_freq = SystemCoreClock;
80002e4c:	e181a783          	lw	a5,-488(gp) # 40000598 <SystemCoreClock>
80002e50:	fef42223          	sw	a5,-28(s0)
        if (cpu_freq == 0) cpu_freq = 16000000;
80002e54:	fe442783          	lw	a5,-28(s0)
80002e58:	e799                	bnez	a5,80002e66 <config_storage_load+0xb6>
80002e5a:	00f427b7          	lui	a5,0xf42
80002e5e:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80002e62:	fef42223          	sw	a5,-28(s0)
        uint32_t delay_5ms = (5 * cpu_freq) / 1000; // 5 мс
80002e66:	fe442703          	lw	a4,-28(s0)
80002e6a:	87ba                	mv	a5,a4
80002e6c:	078a                	slli	a5,a5,0x2
80002e6e:	973e                	add	a4,a4,a5
80002e70:	3e800793          	li	a5,1000
80002e74:	02f757b3          	divu	a5,a4,a5
80002e78:	fcf42e23          	sw	a5,-36(s0)
        for (volatile uint32_t i = 0; i < delay_5ms; ++i) {
80002e7c:	fc042023          	sw	zero,-64(s0)
80002e80:	a039                	j	80002e8e <config_storage_load+0xde>
            __asm volatile("nop");
80002e82:	0001                	nop
        for (volatile uint32_t i = 0; i < delay_5ms; ++i) {
80002e84:	fc042783          	lw	a5,-64(s0)
80002e88:	0785                	addi	a5,a5,1
80002e8a:	fcf42023          	sw	a5,-64(s0)
80002e8e:	fc042783          	lw	a5,-64(s0)
80002e92:	fdc42703          	lw	a4,-36(s0)
80002e96:	fee7e6e3          	bltu	a5,a4,80002e82 <config_storage_load+0xd2>
        }
        
        // Повторная попытка чтения
        memset(&tmp, 0, sizeof(tmp));
80002e9a:	fc440793          	addi	a5,s0,-60
80002e9e:	4655                	li	a2,21
80002ea0:	4581                	li	a1,0
80002ea2:	853e                	mv	a0,a5
80002ea4:	1aa060ef          	jal	ra,8000904e <memset>
        eeprom_read_bytes(CONFIG_EEPROM_BASE, (uint8_t *)&tmp, sizeof(tmp));
80002ea8:	fc440793          	addi	a5,s0,-60
80002eac:	4655                	li	a2,21
80002eae:	85be                	mv	a1,a5
80002eb0:	4501                	li	a0,0
80002eb2:	2b29                	jal	800033cc <eeprom_read_bytes>

        start_ms = ms_ticks;
80002eb4:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
80002eb8:	fef42023          	sw	a5,-32(s0)
        while (eeprom_is_busy()) {
80002ebc:	a821                	j	80002ed4 <config_storage_load+0x124>
            if ((ms_ticks - start_ms) > 50u) {
80002ebe:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80002ec2:	fe042783          	lw	a5,-32(s0)
80002ec6:	8f1d                	sub	a4,a4,a5
80002ec8:	03200793          	li	a5,50
80002ecc:	00e7f463          	bgeu	a5,a4,80002ed4 <config_storage_load+0x124>
                return false;
80002ed0:	4781                	li	a5,0
80002ed2:	a02d                	j	80002efc <config_storage_load+0x14c>
        while (eeprom_is_busy()) {
80002ed4:	28e9                	jal	80002fae <eeprom_is_busy>
80002ed6:	87aa                	mv	a5,a0
80002ed8:	f3fd                	bnez	a5,80002ebe <config_storage_load+0x10e>
            }
        }
        if (eeprom_had_error()) {
80002eda:	20ed                	jal	80002fc4 <eeprom_had_error>
80002edc:	87aa                	mv	a5,a0
80002ede:	c399                	beqz	a5,80002ee4 <config_storage_load+0x134>
            return false;
80002ee0:	4781                	li	a5,0
80002ee2:	a829                	j	80002efc <config_storage_load+0x14c>
        }
    }

    // Никакой дополнительной валидации (magic/CRC) больше нет — просто копируем
    memcpy(cfg, &tmp, sizeof(tmp));
80002ee4:	fbc42783          	lw	a5,-68(s0)
80002ee8:	86be                	mv	a3,a5
80002eea:	fc440793          	addi	a5,s0,-60
80002eee:	4755                	li	a4,21
80002ef0:	863a                	mv	a2,a4
80002ef2:	85be                	mv	a1,a5
80002ef4:	8536                	mv	a0,a3
80002ef6:	142060ef          	jal	ra,80009038 <memcpy>

    return true;
80002efa:	4785                	li	a5,1
}
80002efc:	853e                	mv	a0,a5
80002efe:	40b6                	lw	ra,76(sp)
80002f00:	4426                	lw	s0,72(sp)
80002f02:	6161                	addi	sp,sp,80
80002f04:	8082                	ret

80002f06 <config_storage_save>:

void config_storage_save(const config_storage_t *cfg_in)  //загружаем изменённый конфиг
{
80002f06:	7139                	addi	sp,sp,-64
80002f08:	de06                	sw	ra,60(sp)
80002f0a:	dc22                	sw	s0,56(sp)
80002f0c:	0080                	addi	s0,sp,64
80002f0e:	fca42623          	sw	a0,-52(s0)
    if (!cfg_in) return;
80002f12:	fcc42783          	lw	a5,-52(s0)
80002f16:	c7a9                	beqz	a5,80002f60 <config_storage_save+0x5a>

    config_storage_t tmp;
    memcpy(&tmp, cfg_in, sizeof(tmp));
80002f18:	fcc42703          	lw	a4,-52(s0)
80002f1c:	fd440793          	addi	a5,s0,-44
80002f20:	86ba                	mv	a3,a4
80002f22:	4755                	li	a4,21
80002f24:	863a                	mv	a2,a4
80002f26:	85b6                	mv	a1,a3
80002f28:	853e                	mv	a0,a5
80002f2a:	10e060ef          	jal	ra,80009038 <memcpy>

    eeprom_write_bytes(CONFIG_EEPROM_BASE, (const uint8_t *)&tmp, sizeof(tmp));
80002f2e:	fd440793          	addi	a5,s0,-44
80002f32:	4655                	li	a2,21
80002f34:	85be                	mv	a1,a5
80002f36:	4501                	li	a0,0
80002f38:	26a5                	jal	800032a0 <eeprom_write_bytes>

    // Ожидание завершения записи с таймаутом
    uint32_t start_ms = ms_ticks;
80002f3a:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
80002f3e:	fef42623          	sw	a5,-20(s0)
    while (eeprom_is_busy()) {
80002f42:	a811                	j	80002f56 <config_storage_save+0x50>
        if ((ms_ticks - start_ms) > 50u) { // 50 мс на запись конфигурации
80002f44:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80002f48:	fec42783          	lw	a5,-20(s0)
80002f4c:	8f1d                	sub	a4,a4,a5
80002f4e:	03200793          	li	a5,50
80002f52:	00e7e963          	bltu	a5,a4,80002f64 <config_storage_save+0x5e>
    while (eeprom_is_busy()) {
80002f56:	28a1                	jal	80002fae <eeprom_is_busy>
80002f58:	87aa                	mv	a5,a0
80002f5a:	f7ed                	bnez	a5,80002f44 <config_storage_save+0x3e>
            return;
        }
    }
    if (eeprom_had_error()) {
80002f5c:	20a5                	jal	80002fc4 <eeprom_had_error>
80002f5e:	a021                	j	80002f66 <config_storage_save+0x60>
    if (!cfg_in) return;
80002f60:	0001                	nop
80002f62:	a011                	j	80002f66 <config_storage_save+0x60>
            return;
80002f64:	0001                	nop
        return;
    }
}
80002f66:	50f2                	lw	ra,60(sp)
80002f68:	5462                	lw	s0,56(sp)
80002f6a:	6121                	addi	sp,sp,64
80002f6c:	8082                	ret

80002f6e <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002f6e:	1101                	addi	sp,sp,-32
80002f70:	ce22                	sw	s0,28(sp)
80002f72:	1000                	addi	s0,sp,32
80002f74:	fea42623          	sw	a0,-20(s0)
80002f78:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
80002f7c:	fec42783          	lw	a5,-20(s0)
80002f80:	fe842703          	lw	a4,-24(s0)
80002f84:	c798                	sw	a4,8(a5)
}
80002f86:	0001                	nop
80002f88:	4472                	lw	s0,28(sp)
80002f8a:	6105                	addi	sp,sp,32
80002f8c:	8082                	ret

80002f8e <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002f8e:	1101                	addi	sp,sp,-32
80002f90:	ce22                	sw	s0,28(sp)
80002f92:	1000                	addi	s0,sp,32
80002f94:	fea42623          	sw	a0,-20(s0)
80002f98:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
80002f9c:	fec42783          	lw	a5,-20(s0)
80002fa0:	fe842703          	lw	a4,-24(s0)
80002fa4:	c7d8                	sw	a4,12(a5)
}
80002fa6:	0001                	nop
80002fa8:	4472                	lw	s0,28(sp)
80002faa:	6105                	addi	sp,sp,32
80002fac:	8082                	ret

80002fae <eeprom_is_busy>:
// Простейший статус для SPI-ветки (чтобы config.c мог вызывать eeprom_is_busy/eeprom_had_error)
static volatile bool g_eeprom_spi_busy  = false;
static volatile bool g_eeprom_spi_error = false;

bool eeprom_is_busy(void)
{
80002fae:	1141                	addi	sp,sp,-16
80002fb0:	c622                	sw	s0,12(sp)
80002fb2:	0800                	addi	s0,sp,16
    return g_eeprom_spi_busy;
80002fb4:	e901c783          	lbu	a5,-368(gp) # 40000610 <g_eeprom_spi_busy>
80002fb8:	0ff7f793          	zext.b	a5,a5
}
80002fbc:	853e                	mv	a0,a5
80002fbe:	4432                	lw	s0,12(sp)
80002fc0:	0141                	addi	sp,sp,16
80002fc2:	8082                	ret

80002fc4 <eeprom_had_error>:

bool eeprom_had_error(void)
{
80002fc4:	1141                	addi	sp,sp,-16
80002fc6:	c622                	sw	s0,12(sp)
80002fc8:	0800                	addi	s0,sp,16
    return g_eeprom_spi_error;
80002fca:	e911c783          	lbu	a5,-367(gp) # 40000611 <g_eeprom_spi_error>
80002fce:	0ff7f793          	zext.b	a5,a5
}
80002fd2:	853e                	mv	a0,a5
80002fd4:	4432                	lw	s0,12(sp)
80002fd6:	0141                	addi	sp,sp,16
80002fd8:	8082                	ret

80002fda <eeprom_spi_cs_low>:

void eeprom_spi_cs_low(void)
{
80002fda:	1141                	addi	sp,sp,-16
80002fdc:	c606                	sw	ra,12(sp)
80002fde:	c422                	sw	s0,8(sp)
80002fe0:	0800                	addi	s0,sp,16
    GPIO_ClearBits(CS_PORT, CS_PIN);
80002fe2:	4589                	li	a1,2
80002fe4:	28001537          	lui	a0,0x28001
80002fe8:	375d                	jal	80002f8e <GPIO_ClearBits>
}
80002fea:	0001                	nop
80002fec:	40b2                	lw	ra,12(sp)
80002fee:	4422                	lw	s0,8(sp)
80002ff0:	0141                	addi	sp,sp,16
80002ff2:	8082                	ret

80002ff4 <eeprom_spi_cs_high>:

void eeprom_spi_cs_high(void)
{
80002ff4:	1141                	addi	sp,sp,-16
80002ff6:	c606                	sw	ra,12(sp)
80002ff8:	c422                	sw	s0,8(sp)
80002ffa:	0800                	addi	s0,sp,16
    GPIO_SetBits(CS_PORT, CS_PIN);
80002ffc:	4589                	li	a1,2
80002ffe:	28001537          	lui	a0,0x28001
80003002:	37b5                	jal	80002f6e <GPIO_SetBits>
}
80003004:	0001                	nop
80003006:	40b2                	lw	ra,12(sp)
80003008:	4422                	lw	s0,8(sp)
8000300a:	0141                	addi	sp,sp,16
8000300c:	8082                	ret

8000300e <eeprom_init>:

void eeprom_init(void)
{
8000300e:	1141                	addi	sp,sp,-16
80003010:	c606                	sw	ra,12(sp)
80003012:	c422                	sw	s0,8(sp)
80003014:	0800                	addi	s0,sp,16
    spi0_init();
80003016:	2031                	jal	80003022 <spi0_init>
}
80003018:	0001                	nop
8000301a:	40b2                	lw	ra,12(sp)
8000301c:	4422                	lw	s0,8(sp)
8000301e:	0141                	addi	sp,sp,16
80003020:	8082                	ret

80003022 <spi0_init>:

static void spi0_init(void)
{
80003022:	1141                	addi	sp,sp,-16
80003024:	c606                	sw	ra,12(sp)
80003026:	c422                	sw	s0,8(sp)
80003028:	0800                	addi	s0,sp,16
    RCU->CGCFGAHB_bit.GPIOBEN = 1;                                                                                                 // Разрешение тактирования порта GPIOB
8000302a:	3000e7b7          	lui	a5,0x3000e
8000302e:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80003032:	20076713          	ori	a4,a4,512
80003036:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOBEN = 1;                                                                                                // Вывод из состояния сброса порта GPIOB
8000303a:	3000e7b7          	lui	a5,0x3000e
8000303e:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80003042:	20076713          	ori	a4,a4,512
80003046:	00e79823          	sh	a4,16(a5)
    RCU->CGCFGAHB_bit.SPI0EN = 1;                                                                                                  // Разрешение тактирования SPI0
8000304a:	3000e7b7          	lui	a5,0x3000e
8000304e:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80003052:	02076713          	ori	a4,a4,32
80003056:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.SPI0EN = 1;                                                                                                 // Вывод из состояния сброса SPI0
8000305a:	3000e7b7          	lui	a5,0x3000e
8000305e:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80003062:	02076713          	ori	a4,a4,32
80003066:	00e79823          	sh	a4,16(a5)
    RCU->SPICLKCFG[0].SPICLKCFG_bit.CLKSEL = RCU_SPICLKCFG_CLKSEL_HSE;                                                             // Источник сигнала внешний кварц
8000306a:	3000e7b7          	lui	a5,0x3000e
8000306e:	0947a683          	lw	a3,148(a5) # 3000e094 <STACK_SIZE+0x3000d894>
80003072:	fffd0737          	lui	a4,0xfffd0
80003076:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc65db>
80003078:	8ef9                	and	a3,a3,a4
8000307a:	6741                	lui	a4,0x10
8000307c:	8f55                	or	a4,a4,a3
8000307e:	08e7aa23          	sw	a4,148(a5)
    RCU->SPICLKCFG[0].SPICLKCFG_bit.CLKEN = 1;                                                                                     // Разрешение тактирования
80003082:	3000e7b7          	lui	a5,0x3000e
80003086:	0947a703          	lw	a4,148(a5) # 3000e094 <STACK_SIZE+0x3000d894>
8000308a:	00176713          	ori	a4,a4,1
8000308e:	08e7aa23          	sw	a4,148(a5)
    RCU->SPICLKCFG[0].SPICLKCFG_bit.RSTDIS = 1;                                                                                    // Вывод из сброса
80003092:	3000e7b7          	lui	a5,0x3000e
80003096:	0947a703          	lw	a4,148(a5) # 3000e094 <STACK_SIZE+0x3000d894>
8000309a:	10076713          	ori	a4,a4,256
8000309e:	08e7aa23          	sw	a4,148(a5)
    SPI0->CPSR_bit.CPSDVSR = 8;                                                                                                    // Коэффициент деления первого делителя
800030a2:	200507b7          	lui	a5,0x20050
800030a6:	4721                	li	a4,8
800030a8:	00e78823          	sb	a4,16(a5) # 20050010 <STACK_SIZE+0x2004f810>
    SPI0->CR0_bit.SCR = 1;                                                                                                         // Коэффициент деления второго делителя. Результирующий коэффициент SCK/((SCR+1)*CPSDVSR) 16/((1+1)*8)=1МГц
800030ac:	200507b7          	lui	a5,0x20050
800030b0:	4705                	li	a4,1
800030b2:	00e780a3          	sb	a4,1(a5) # 20050001 <STACK_SIZE+0x2004f801>
    SPI0->CR0_bit.SPO = 0;                                                                                                         // Полярность сигнала. В режиме ожидания линия в состоянии логического нуля.
800030b6:	200507b7          	lui	a5,0x20050
800030ba:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
800030be:	fbf77713          	andi	a4,a4,-65
800030c2:	00e79023          	sh	a4,0(a5)
    SPI0->CR0_bit.SPH = 0;                                                                                                         // Фаза: выборка на первом фронте (CPHA=0)
800030c6:	200507b7          	lui	a5,0x20050
800030ca:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
800030ce:	f7f77713          	andi	a4,a4,-129
800030d2:	00e79023          	sh	a4,0(a5)
    SPI0->CR0_bit.FRF = 0;                                                                                                         // Выбор протокола обмена информацией 0-SPI
800030d6:	200507b7          	lui	a5,0x20050
800030da:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
800030de:	fcf77713          	andi	a4,a4,-49
800030e2:	00e79023          	sh	a4,0(a5)
    SPI0->CR0_bit.DSS = 7;                                                                                                         // Размер слова данных 8 бит
800030e6:	200507b7          	lui	a5,0x20050
800030ea:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
800030ee:	9b41                	andi	a4,a4,-16
800030f0:	00776713          	ori	a4,a4,7
800030f4:	00e79023          	sh	a4,0(a5)
    SPI0->CR1_bit.MS = 0;                                                                                                          // Режим работы - Мастер
800030f8:	200507b7          	lui	a5,0x20050
800030fc:	0047d703          	lhu	a4,4(a5) # 20050004 <STACK_SIZE+0x2004f804>
80003100:	9b6d                	andi	a4,a4,-5
80003102:	00e79223          	sh	a4,4(a5)
    gpio_init_spi_pins();
80003106:	2091                	jal	8000314a <gpio_init_spi_pins>
    SPI0->IMSC = 0x1;                                                                                                                    // Разрешаем прерывания по переполнению приемного буфера
80003108:	200507b7          	lui	a5,0x20050
8000310c:	4705                	li	a4,1
8000310e:	cbd8                	sw	a4,20(a5)
    // Настраиваем обработчик прерывания для SPI0
    PLIC_SetIrqHandler(Plic_Mach_Target, IsrVect_IRQ_SPI0, SPI0_IRQHandler);
80003110:	800037b7          	lui	a5,0x80003
80003114:	47478613          	addi	a2,a5,1140 # 80003474 <__data_source_start+0xffff9a50>
80003118:	45ad                	li	a1,11
8000311a:	4501                	li	a0,0
8000311c:	de6fd0ef          	jal	ra,80000702 <PLIC_SetIrqHandler>
    PLIC_SetPriority(IsrVect_IRQ_SPI0, 0x1);
80003120:	4585                	li	a1,1
80003122:	452d                	li	a0,11
80003124:	e2afd0ef          	jal	ra,8000074e <PLIC_SetPriority>
    PLIC_IntEnable(Plic_Mach_Target, IsrVect_IRQ_SPI0);
80003128:	45ad                	li	a1,11
8000312a:	4501                	li	a0,0
8000312c:	e4cfd0ef          	jal	ra,80000778 <PLIC_IntEnable>

    SPI0->CR1_bit.SSE = 1; // Разрешение работы приемопередатчика
80003130:	200507b7          	lui	a5,0x20050
80003134:	0047d703          	lhu	a4,4(a5) # 20050004 <STACK_SIZE+0x2004f804>
80003138:	00276713          	ori	a4,a4,2
8000313c:	00e79223          	sh	a4,4(a5)
}
80003140:	0001                	nop
80003142:	40b2                	lw	ra,12(sp)
80003144:	4422                	lw	s0,8(sp)
80003146:	0141                	addi	sp,sp,16
80003148:	8082                	ret

8000314a <gpio_init_spi_pins>:

static void gpio_init_spi_pins(void)
{
8000314a:	7179                	addi	sp,sp,-48
8000314c:	d606                	sw	ra,44(sp)
8000314e:	d422                	sw	s0,40(sp)
80003150:	1800                	addi	s0,sp,48
    GPIOB->ALTFUNCSET = GPIO_ALTFUNCSET_PIN0_Msk |  // SCK
80003152:	280017b7          	lui	a5,0x28001
80003156:	4735                	li	a4,13
80003158:	dbd8                	sw	a4,52(a5)
                        GPIO_ALTFUNCSET_PIN2_Msk |  // MISO (RX)
                        GPIO_ALTFUNCSET_PIN3_Msk;   // MOSI (TX)
    GPIOB->ALTFUNCNUM = (GPIO_ALTFUNCNUM_PIN0_AF1 << GPIO_ALTFUNCNUM_PIN0_Pos) |
8000315a:	280017b7          	lui	a5,0x28001
8000315e:	05100713          	li	a4,81
80003162:	dfd8                	sw	a4,60(a5)
                        (GPIO_ALTFUNCNUM_PIN2_AF1 << GPIO_ALTFUNCNUM_PIN2_Pos) |
                        (GPIO_ALTFUNCNUM_PIN3_AF1 << GPIO_ALTFUNCNUM_PIN3_Pos);

    // CS (PB1) как GPIO выход, держим в "1"
    GPIO_Init_TypeDef gpio;
    GPIO_StructInit(&gpio);
80003164:	fd840793          	addi	a5,s0,-40
80003168:	853e                	mv	a0,a5
8000316a:	02a040ef          	jal	ra,80007194 <GPIO_StructInit>
    gpio.Out = ENABLE;
8000316e:	4785                	li	a5,1
80003170:	fcf42e23          	sw	a5,-36(s0)
    gpio.AltFunc = DISABLE;
80003174:	fe042023          	sw	zero,-32(s0)
    gpio.Pin = CS_PIN;
80003178:	4789                	li	a5,2
8000317a:	fcf42c23          	sw	a5,-40(s0)
    GPIO_Init(CS_PORT, &gpio);
8000317e:	fd840793          	addi	a5,s0,-40
80003182:	85be                	mv	a1,a5
80003184:	28001537          	lui	a0,0x28001
80003188:	785030ef          	jal	ra,8000710c <GPIO_Init>
    GPIO_SetBits(CS_PORT, CS_PIN);
8000318c:	4589                	li	a1,2
8000318e:	28001537          	lui	a0,0x28001
80003192:	3bf1                	jal	80002f6e <GPIO_SetBits>
}
80003194:	0001                	nop
80003196:	50b2                	lw	ra,44(sp)
80003198:	5422                	lw	s0,40(sp)
8000319a:	6145                	addi	sp,sp,48
8000319c:	8082                	ret

8000319e <eeprom_spi_xfer>:

uint8_t eeprom_spi_xfer(uint8_t byte)
{
8000319e:	1101                	addi	sp,sp,-32
800031a0:	ce22                	sw	s0,28(sp)
800031a2:	1000                	addi	s0,sp,32
800031a4:	87aa                	mv	a5,a0
800031a6:	fef407a3          	sb	a5,-17(s0)
    // Ждём свободное место в TX FIFO
    while (!(SPI0->SR & SPI_SR_TNF_Msk)) {
800031aa:	0001                	nop
800031ac:	200507b7          	lui	a5,0x20050
800031b0:	47dc                	lw	a5,12(a5)
800031b2:	8b89                	andi	a5,a5,2
800031b4:	dfe5                	beqz	a5,800031ac <eeprom_spi_xfer+0xe>
    }
    SPI0->DR = byte;
800031b6:	200507b7          	lui	a5,0x20050
800031ba:	fef44703          	lbu	a4,-17(s0)
800031be:	c798                	sw	a4,8(a5)

    // Ждём байт в RX FIFO
    while (!(SPI0->SR & SPI_SR_RNE_Msk)) {
800031c0:	0001                	nop
800031c2:	200507b7          	lui	a5,0x20050
800031c6:	47dc                	lw	a5,12(a5)
800031c8:	8b91                	andi	a5,a5,4
800031ca:	dfe5                	beqz	a5,800031c2 <eeprom_spi_xfer+0x24>
    }
    return (uint8_t)SPI0->DR;
800031cc:	200507b7          	lui	a5,0x20050
800031d0:	479c                	lw	a5,8(a5)
800031d2:	0ff7f793          	zext.b	a5,a5
}
800031d6:	853e                	mv	a0,a5
800031d8:	4472                	lw	s0,28(sp)
800031da:	6105                	addi	sp,sp,32
800031dc:	8082                	ret

800031de <eeprom_spi_read_status>:

uint8_t eeprom_spi_read_status(void)
{
800031de:	1101                	addi	sp,sp,-32
800031e0:	ce06                	sw	ra,28(sp)
800031e2:	cc22                	sw	s0,24(sp)
800031e4:	1000                	addi	s0,sp,32
    eeprom_spi_cs_low();
800031e6:	3bd5                	jal	80002fda <eeprom_spi_cs_low>
    eeprom_spi_xfer(SPI_CMD_RDSR);
800031e8:	4515                	li	a0,5
800031ea:	3f55                	jal	8000319e <eeprom_spi_xfer>
    uint8_t sr = eeprom_spi_xfer(0xFF);
800031ec:	0ff00513          	li	a0,255
800031f0:	377d                	jal	8000319e <eeprom_spi_xfer>
800031f2:	87aa                	mv	a5,a0
800031f4:	fef407a3          	sb	a5,-17(s0)
    eeprom_spi_cs_high();
800031f8:	3bf5                	jal	80002ff4 <eeprom_spi_cs_high>
    return sr;
800031fa:	fef44783          	lbu	a5,-17(s0)
}
800031fe:	853e                	mv	a0,a5
80003200:	40f2                	lw	ra,28(sp)
80003202:	4462                	lw	s0,24(sp)
80003204:	6105                	addi	sp,sp,32
80003206:	8082                	ret

80003208 <eeprom_spi_wait_ready>:

bool eeprom_spi_wait_ready(uint32_t timeout_ms)
{
80003208:	7139                	addi	sp,sp,-64
8000320a:	de06                	sw	ra,60(sp)
8000320c:	dc22                	sw	s0,56(sp)
8000320e:	0080                	addi	s0,sp,64
80003210:	fca42623          	sw	a0,-52(s0)
    extern uint32_t SystemCoreClock;
    uint32_t cpu_hz = SystemCoreClock;
80003214:	e181a783          	lw	a5,-488(gp) # 40000598 <SystemCoreClock>
80003218:	fef42423          	sw	a5,-24(s0)
    
    const uint32_t cycles_per_iter = 30u;
8000321c:	47f9                	li	a5,30
8000321e:	fef42223          	sw	a5,-28(s0)
    uint32_t total_cycles = (cpu_hz / 1000u) * timeout_ms;
80003222:	fe842703          	lw	a4,-24(s0)
80003226:	3e800793          	li	a5,1000
8000322a:	02f757b3          	divu	a5,a4,a5
8000322e:	fcc42703          	lw	a4,-52(s0)
80003232:	02f707b3          	mul	a5,a4,a5
80003236:	fef42023          	sw	a5,-32(s0)
    uint32_t iters = total_cycles / cycles_per_iter;
8000323a:	fe042703          	lw	a4,-32(s0)
8000323e:	fe442783          	lw	a5,-28(s0)
80003242:	02f757b3          	divu	a5,a4,a5
80003246:	fef42623          	sw	a5,-20(s0)
    if (iters == 0u) {
8000324a:	fec42783          	lw	a5,-20(s0)
8000324e:	ef99                	bnez	a5,8000326c <eeprom_spi_wait_ready+0x64>
        iters = 1u;
80003250:	4785                	li	a5,1
80003252:	fef42623          	sw	a5,-20(s0)
    }

    while (iters--) {
80003256:	a819                	j	8000326c <eeprom_spi_wait_ready+0x64>
        uint8_t sr = eeprom_spi_read_status();
80003258:	3759                	jal	800031de <eeprom_spi_read_status>
8000325a:	87aa                	mv	a5,a0
8000325c:	fcf40fa3          	sb	a5,-33(s0)
        if ((sr & SPI_STATUS_BUSY) == 0u) {
80003260:	fdf44783          	lbu	a5,-33(s0)
80003264:	8b85                	andi	a5,a5,1
80003266:	e399                	bnez	a5,8000326c <eeprom_spi_wait_ready+0x64>
            return true;
80003268:	4785                	li	a5,1
8000326a:	a809                	j	8000327c <eeprom_spi_wait_ready+0x74>
    while (iters--) {
8000326c:	fec42783          	lw	a5,-20(s0)
80003270:	fff78713          	addi	a4,a5,-1 # 2004ffff <STACK_SIZE+0x2004f7ff>
80003274:	fee42623          	sw	a4,-20(s0)
80003278:	f3e5                	bnez	a5,80003258 <eeprom_spi_wait_ready+0x50>
        }
    }
    return false;
8000327a:	4781                	li	a5,0
}
8000327c:	853e                	mv	a0,a5
8000327e:	50f2                	lw	ra,60(sp)
80003280:	5462                	lw	s0,56(sp)
80003282:	6121                	addi	sp,sp,64
80003284:	8082                	ret

80003286 <eeprom_spi_write_enable>:


static void eeprom_spi_write_enable(void)
{
80003286:	1141                	addi	sp,sp,-16
80003288:	c606                	sw	ra,12(sp)
8000328a:	c422                	sw	s0,8(sp)
8000328c:	0800                	addi	s0,sp,16
    eeprom_spi_cs_low();
8000328e:	33b1                	jal	80002fda <eeprom_spi_cs_low>
    eeprom_spi_xfer(SPI_CMD_WREN);
80003290:	4519                	li	a0,6
80003292:	3731                	jal	8000319e <eeprom_spi_xfer>
    eeprom_spi_cs_high();
80003294:	3385                	jal	80002ff4 <eeprom_spi_cs_high>
}
80003296:	0001                	nop
80003298:	40b2                	lw	ra,12(sp)
8000329a:	4422                	lw	s0,8(sp)
8000329c:	0141                	addi	sp,sp,16
8000329e:	8082                	ret

800032a0 <eeprom_write_bytes>:

void eeprom_write_bytes(uint16_t addr, const uint8_t* data, size_t len)
{
800032a0:	7179                	addi	sp,sp,-48
800032a2:	d606                	sw	ra,44(sp)
800032a4:	d422                	sw	s0,40(sp)
800032a6:	1800                	addi	s0,sp,48
800032a8:	87aa                	mv	a5,a0
800032aa:	fcb42c23          	sw	a1,-40(s0)
800032ae:	fcc42a23          	sw	a2,-44(s0)
800032b2:	fcf41f23          	sh	a5,-34(s0)
    if (!data || !len) {
800032b6:	fd842783          	lw	a5,-40(s0)
800032ba:	10078263          	beqz	a5,800033be <eeprom_write_bytes+0x11e>
800032be:	fd442783          	lw	a5,-44(s0)
800032c2:	0e078e63          	beqz	a5,800033be <eeprom_write_bytes+0x11e>
        return;
    }
    if (g_eeprom_spi_busy) {
800032c6:	e901c783          	lbu	a5,-368(gp) # 40000610 <g_eeprom_spi_busy>
800032ca:	0ff7f793          	zext.b	a5,a5
800032ce:	0e079a63          	bnez	a5,800033c2 <eeprom_write_bytes+0x122>
        return;
    }

    g_eeprom_spi_error = false;
800032d2:	e80188a3          	sb	zero,-367(gp) # 40000611 <g_eeprom_spi_error>
    g_eeprom_spi_busy  = true;
800032d6:	4705                	li	a4,1
800032d8:	e8e18823          	sb	a4,-368(gp) # 40000610 <g_eeprom_spi_busy>

    while (len) {
800032dc:	a8d1                	j	800033b0 <eeprom_write_bytes+0x110>
        size_t page_off = addr % EEPROM_PAGE_SIZE;
800032de:	fde45783          	lhu	a5,-34(s0)
800032e2:	03f7f793          	andi	a5,a5,63
800032e6:	fef42223          	sw	a5,-28(s0)
        size_t chunk = EEPROM_PAGE_SIZE - page_off;
800032ea:	04000713          	li	a4,64
800032ee:	fe442783          	lw	a5,-28(s0)
800032f2:	40f707b3          	sub	a5,a4,a5
800032f6:	fef42623          	sw	a5,-20(s0)
        if (chunk > len) {
800032fa:	fec42703          	lw	a4,-20(s0)
800032fe:	fd442783          	lw	a5,-44(s0)
80003302:	00e7f663          	bgeu	a5,a4,8000330e <eeprom_write_bytes+0x6e>
            chunk = len;
80003306:	fd442783          	lw	a5,-44(s0)
8000330a:	fef42623          	sw	a5,-20(s0)
        }

        eeprom_spi_write_enable();
8000330e:	3fa5                	jal	80003286 <eeprom_spi_write_enable>

        eeprom_spi_cs_low();
80003310:	31e9                	jal	80002fda <eeprom_spi_cs_low>
        eeprom_spi_xfer(SPI_CMD_WRITE);
80003312:	4509                	li	a0,2
80003314:	3569                	jal	8000319e <eeprom_spi_xfer>
        eeprom_spi_xfer(addr >> 8);
80003316:	fde45783          	lhu	a5,-34(s0)
8000331a:	83a1                	srli	a5,a5,0x8
8000331c:	07c2                	slli	a5,a5,0x10
8000331e:	83c1                	srli	a5,a5,0x10
80003320:	0ff7f793          	zext.b	a5,a5
80003324:	853e                	mv	a0,a5
80003326:	3da5                	jal	8000319e <eeprom_spi_xfer>
        eeprom_spi_xfer(addr & 0xFF);
80003328:	fde45783          	lhu	a5,-34(s0)
8000332c:	0ff7f793          	zext.b	a5,a5
80003330:	853e                	mv	a0,a5
80003332:	35b5                	jal	8000319e <eeprom_spi_xfer>
        for (size_t i = 0; i < chunk; ++i) {
80003334:	fe042423          	sw	zero,-24(s0)
80003338:	a839                	j	80003356 <eeprom_write_bytes+0xb6>
            eeprom_spi_xfer(data[i]);
8000333a:	fd842703          	lw	a4,-40(s0)
8000333e:	fe842783          	lw	a5,-24(s0)
80003342:	97ba                	add	a5,a5,a4
80003344:	0007c783          	lbu	a5,0(a5)
80003348:	853e                	mv	a0,a5
8000334a:	3d91                	jal	8000319e <eeprom_spi_xfer>
        for (size_t i = 0; i < chunk; ++i) {
8000334c:	fe842783          	lw	a5,-24(s0)
80003350:	0785                	addi	a5,a5,1
80003352:	fef42423          	sw	a5,-24(s0)
80003356:	fe842703          	lw	a4,-24(s0)
8000335a:	fec42783          	lw	a5,-20(s0)
8000335e:	fcf76ee3          	bltu	a4,a5,8000333a <eeprom_write_bytes+0x9a>
        }
        eeprom_spi_cs_high();
80003362:	3949                	jal	80002ff4 <eeprom_spi_cs_high>

        if (!eeprom_spi_wait_ready(EEPROM_SPI_TIMEOUT_MS)) {
80003364:	4551                	li	a0,20
80003366:	354d                	jal	80003208 <eeprom_spi_wait_ready>
80003368:	87aa                	mv	a5,a0
8000336a:	0017c793          	xori	a5,a5,1
8000336e:	0ff7f793          	zext.b	a5,a5
80003372:	c799                	beqz	a5,80003380 <eeprom_write_bytes+0xe0>
            // не дождались — выходим, чтобы не повиснуть
            g_eeprom_spi_error = true;
80003374:	4705                	li	a4,1
80003376:	e8e188a3          	sb	a4,-367(gp) # 40000611 <g_eeprom_spi_error>
            g_eeprom_spi_busy  = false;
8000337a:	e8018823          	sb	zero,-368(gp) # 40000610 <g_eeprom_spi_busy>
            return;
8000337e:	a099                	j	800033c4 <eeprom_write_bytes+0x124>
        }

        addr += (uint16_t)chunk;
80003380:	fec42783          	lw	a5,-20(s0)
80003384:	07c2                	slli	a5,a5,0x10
80003386:	83c1                	srli	a5,a5,0x10
80003388:	fde45703          	lhu	a4,-34(s0)
8000338c:	97ba                	add	a5,a5,a4
8000338e:	fcf41f23          	sh	a5,-34(s0)
        data += chunk;
80003392:	fd842703          	lw	a4,-40(s0)
80003396:	fec42783          	lw	a5,-20(s0)
8000339a:	97ba                	add	a5,a5,a4
8000339c:	fcf42c23          	sw	a5,-40(s0)
        len  -= chunk;
800033a0:	fd442703          	lw	a4,-44(s0)
800033a4:	fec42783          	lw	a5,-20(s0)
800033a8:	40f707b3          	sub	a5,a4,a5
800033ac:	fcf42a23          	sw	a5,-44(s0)
    while (len) {
800033b0:	fd442783          	lw	a5,-44(s0)
800033b4:	f20795e3          	bnez	a5,800032de <eeprom_write_bytes+0x3e>
    }

    g_eeprom_spi_busy = false;
800033b8:	e8018823          	sb	zero,-368(gp) # 40000610 <g_eeprom_spi_busy>
800033bc:	a021                	j	800033c4 <eeprom_write_bytes+0x124>
        return;
800033be:	0001                	nop
800033c0:	a011                	j	800033c4 <eeprom_write_bytes+0x124>
        return;
800033c2:	0001                	nop
}
800033c4:	50b2                	lw	ra,44(sp)
800033c6:	5422                	lw	s0,40(sp)
800033c8:	6145                	addi	sp,sp,48
800033ca:	8082                	ret

800033cc <eeprom_read_bytes>:

void eeprom_read_bytes(uint16_t addr, uint8_t* data, size_t len)
{
800033cc:	7179                	addi	sp,sp,-48
800033ce:	d606                	sw	ra,44(sp)
800033d0:	d422                	sw	s0,40(sp)
800033d2:	d226                	sw	s1,36(sp)
800033d4:	1800                	addi	s0,sp,48
800033d6:	87aa                	mv	a5,a0
800033d8:	fcb42c23          	sw	a1,-40(s0)
800033dc:	fcc42a23          	sw	a2,-44(s0)
800033e0:	fcf41f23          	sh	a5,-34(s0)
    if (!data || !len) {
800033e4:	fd842783          	lw	a5,-40(s0)
800033e8:	cfb5                	beqz	a5,80003464 <eeprom_read_bytes+0x98>
800033ea:	fd442783          	lw	a5,-44(s0)
800033ee:	cbbd                	beqz	a5,80003464 <eeprom_read_bytes+0x98>
        return;
    }

    if (g_eeprom_spi_busy) {
800033f0:	e901c783          	lbu	a5,-368(gp) # 40000610 <g_eeprom_spi_busy>
800033f4:	0ff7f793          	zext.b	a5,a5
800033f8:	eba5                	bnez	a5,80003468 <eeprom_read_bytes+0x9c>
        return;
    }

    g_eeprom_spi_error = false;
800033fa:	e80188a3          	sb	zero,-367(gp) # 40000611 <g_eeprom_spi_error>
    g_eeprom_spi_busy  = true;
800033fe:	4705                	li	a4,1
80003400:	e8e18823          	sb	a4,-368(gp) # 40000610 <g_eeprom_spi_busy>

    eeprom_spi_cs_low();
80003404:	3ed9                	jal	80002fda <eeprom_spi_cs_low>
    eeprom_spi_xfer(SPI_CMD_READ);
80003406:	450d                	li	a0,3
80003408:	3b59                	jal	8000319e <eeprom_spi_xfer>
    eeprom_spi_xfer(addr >> 8);
8000340a:	fde45783          	lhu	a5,-34(s0)
8000340e:	83a1                	srli	a5,a5,0x8
80003410:	07c2                	slli	a5,a5,0x10
80003412:	83c1                	srli	a5,a5,0x10
80003414:	0ff7f793          	zext.b	a5,a5
80003418:	853e                	mv	a0,a5
8000341a:	3351                	jal	8000319e <eeprom_spi_xfer>
    eeprom_spi_xfer(addr & 0xFF);
8000341c:	fde45783          	lhu	a5,-34(s0)
80003420:	0ff7f793          	zext.b	a5,a5
80003424:	853e                	mv	a0,a5
80003426:	3ba5                	jal	8000319e <eeprom_spi_xfer>
    for (size_t i = 0; i < len; ++i) {
80003428:	fe042623          	sw	zero,-20(s0)
8000342c:	a015                	j	80003450 <eeprom_read_bytes+0x84>
        data[i] = eeprom_spi_xfer(0xFF);
8000342e:	fd842703          	lw	a4,-40(s0)
80003432:	fec42783          	lw	a5,-20(s0)
80003436:	00f704b3          	add	s1,a4,a5
8000343a:	0ff00513          	li	a0,255
8000343e:	3385                	jal	8000319e <eeprom_spi_xfer>
80003440:	87aa                	mv	a5,a0
80003442:	00f48023          	sb	a5,0(s1)
    for (size_t i = 0; i < len; ++i) {
80003446:	fec42783          	lw	a5,-20(s0)
8000344a:	0785                	addi	a5,a5,1
8000344c:	fef42623          	sw	a5,-20(s0)
80003450:	fec42703          	lw	a4,-20(s0)
80003454:	fd442783          	lw	a5,-44(s0)
80003458:	fcf76be3          	bltu	a4,a5,8000342e <eeprom_read_bytes+0x62>
    }
    eeprom_spi_cs_high();
8000345c:	3e61                	jal	80002ff4 <eeprom_spi_cs_high>

    g_eeprom_spi_busy = false;
8000345e:	e8018823          	sb	zero,-368(gp) # 40000610 <g_eeprom_spi_busy>
80003462:	a021                	j	8000346a <eeprom_read_bytes+0x9e>
        return;
80003464:	0001                	nop
80003466:	a011                	j	8000346a <eeprom_read_bytes+0x9e>
        return;
80003468:	0001                	nop
}
8000346a:	50b2                	lw	ra,44(sp)
8000346c:	5422                	lw	s0,40(sp)
8000346e:	5492                	lw	s1,36(sp)
80003470:	6145                	addi	sp,sp,48
80003472:	8082                	ret

80003474 <SPI0_IRQHandler>:

static void SPI0_IRQHandler(void)
{
80003474:	1141                	addi	sp,sp,-16
80003476:	c622                	sw	s0,12(sp)
80003478:	0800                	addi	s0,sp,16
    SPI0->ICR = 0x3;
8000347a:	200507b7          	lui	a5,0x20050
8000347e:	470d                	li	a4,3
80003480:	d398                	sw	a4,32(a5)
}
80003482:	0001                	nop
80003484:	4432                	lw	s0,12(sp)
80003486:	0141                	addi	sp,sp,16
80003488:	8082                	ret

8000348a <GPIO_OutCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_OutCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
8000348a:	1101                	addi	sp,sp,-32
8000348c:	ce22                	sw	s0,28(sp)
8000348e:	1000                	addi	s0,sp,32
80003490:	fea42623          	sw	a0,-20(s0)
80003494:	feb42423          	sw	a1,-24(s0)
80003498:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000349c:	fe442703          	lw	a4,-28(s0)
800034a0:	4785                	li	a5,1
800034a2:	00f71863          	bne	a4,a5,800034b2 <GPIO_OutCmd+0x28>
        WRITE_REG(GPIOx->OUTENSET, Pin);
800034a6:	fec42783          	lw	a5,-20(s0)
800034aa:	fe842703          	lw	a4,-24(s0)
800034ae:	d7d8                	sw	a4,44(a5)
    else
        WRITE_REG(GPIOx->OUTENCLR, Pin);
}
800034b0:	a031                	j	800034bc <GPIO_OutCmd+0x32>
        WRITE_REG(GPIOx->OUTENCLR, Pin);
800034b2:	fec42783          	lw	a5,-20(s0)
800034b6:	fe842703          	lw	a4,-24(s0)
800034ba:	db98                	sw	a4,48(a5)
}
800034bc:	0001                	nop
800034be:	4472                	lw	s0,28(sp)
800034c0:	6105                	addi	sp,sp,32
800034c2:	8082                	ret

800034c4 <GPIO_AltFuncCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_AltFuncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
800034c4:	1101                	addi	sp,sp,-32
800034c6:	ce22                	sw	s0,28(sp)
800034c8:	1000                	addi	s0,sp,32
800034ca:	fea42623          	sw	a0,-20(s0)
800034ce:	feb42423          	sw	a1,-24(s0)
800034d2:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800034d6:	fe442703          	lw	a4,-28(s0)
800034da:	4785                	li	a5,1
800034dc:	00f71863          	bne	a4,a5,800034ec <GPIO_AltFuncCmd+0x28>
        WRITE_REG(GPIOx->ALTFUNCSET, Pin);
800034e0:	fec42783          	lw	a5,-20(s0)
800034e4:	fe842703          	lw	a4,-24(s0)
800034e8:	dbd8                	sw	a4,52(a5)
    else
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
}
800034ea:	a031                	j	800034f6 <GPIO_AltFuncCmd+0x32>
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
800034ec:	fec42783          	lw	a5,-20(s0)
800034f0:	fe842703          	lw	a4,-24(s0)
800034f4:	df98                	sw	a4,56(a5)
}
800034f6:	0001                	nop
800034f8:	4472                	lw	s0,28(sp)
800034fa:	6105                	addi	sp,sp,32
800034fc:	8082                	ret

800034fe <GPIO_ReadBit>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  State  Состояние Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
800034fe:	1101                	addi	sp,sp,-32
80003500:	ce22                	sw	s0,28(sp)
80003502:	1000                	addi	s0,sp,32
80003504:	fea42623          	sw	a0,-20(s0)
80003508:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
8000350c:	fec42783          	lw	a5,-20(s0)
80003510:	4398                	lw	a4,0(a5)
80003512:	fe842783          	lw	a5,-24(s0)
80003516:	8ff9                	and	a5,a5,a4
80003518:	c399                	beqz	a5,8000351e <GPIO_ReadBit+0x20>
8000351a:	4785                	li	a5,1
8000351c:	a011                	j	80003520 <GPIO_ReadBit+0x22>
8000351e:	4781                	li	a5,0
}
80003520:	853e                	mv	a0,a5
80003522:	4472                	lw	s0,28(sp)
80003524:	6105                	addi	sp,sp,32
80003526:	8082                	ret

80003528 <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003528:	1101                	addi	sp,sp,-32
8000352a:	ce22                	sw	s0,28(sp)
8000352c:	1000                	addi	s0,sp,32
8000352e:	fea42623          	sw	a0,-20(s0)
80003532:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
80003536:	fec42783          	lw	a5,-20(s0)
8000353a:	fe842703          	lw	a4,-24(s0)
8000353e:	c798                	sw	a4,8(a5)
}
80003540:	0001                	nop
80003542:	4472                	lw	s0,28(sp)
80003544:	6105                	addi	sp,sp,32
80003546:	8082                	ret

80003548 <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003548:	1101                	addi	sp,sp,-32
8000354a:	ce22                	sw	s0,28(sp)
8000354c:	1000                	addi	s0,sp,32
8000354e:	fea42623          	sw	a0,-20(s0)
80003552:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
80003556:	fec42783          	lw	a5,-20(s0)
8000355a:	fe842703          	lw	a4,-24(s0)
8000355e:	c7d8                	sw	a4,12(a5)
}
80003560:	0001                	nop
80003562:	4472                	lw	s0,28(sp)
80003564:	6105                	addi	sp,sp,32
80003566:	8082                	ret

80003568 <GPIO_QualModeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   Mode  Выбор режима
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_QualMode_TypeDef Mode)
{
80003568:	1101                	addi	sp,sp,-32
8000356a:	ce22                	sw	s0,28(sp)
8000356c:	1000                	addi	s0,sp,32
8000356e:	fea42623          	sw	a0,-20(s0)
80003572:	feb42423          	sw	a1,-24(s0)
80003576:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_QUAL_MODE(Mode));

    if (Mode == GPIO_QualMode_6Sample)
8000357a:	fe442703          	lw	a4,-28(s0)
8000357e:	4785                	li	a5,1
80003580:	00f71863          	bne	a4,a5,80003590 <GPIO_QualModeConfig+0x28>
        WRITE_REG(GPIOx->QUALMODESET, Pin);
80003584:	fec42783          	lw	a5,-20(s0)
80003588:	fe842703          	lw	a4,-24(s0)
8000358c:	cbf8                	sw	a4,84(a5)
    else
        WRITE_REG(GPIOx->QUALMODECLR, Pin);
}
8000358e:	a031                	j	8000359a <GPIO_QualModeConfig+0x32>
        WRITE_REG(GPIOx->QUALMODECLR, Pin);
80003590:	fec42783          	lw	a5,-20(s0)
80003594:	fe842703          	lw	a4,-24(s0)
80003598:	cfb8                	sw	a4,88(a5)
}
8000359a:	0001                	nop
8000359c:	4472                	lw	s0,28(sp)
8000359e:	6105                	addi	sp,sp,32
800035a0:	8082                	ret

800035a2 <GPIO_QualSampleConfig>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   SamplePerod  Количество тактов системной частоты между отсчетами фильтра
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualSampleConfig(GPIO_TypeDef* GPIOx, uint32_t SamplePerod)
{
800035a2:	1101                	addi	sp,sp,-32
800035a4:	ce22                	sw	s0,28(sp)
800035a6:	1000                	addi	s0,sp,32
800035a8:	fea42623          	sw	a0,-20(s0)
800035ac:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_QUAL_PERIOD(SamplePerod));

    WRITE_REG(GPIOx->QUALSAMPLE, SamplePerod);
800035b0:	fec42783          	lw	a5,-20(s0)
800035b4:	fe842703          	lw	a4,-24(s0)
800035b8:	cff8                	sw	a4,92(a5)
}
800035ba:	0001                	nop
800035bc:	4472                	lw	s0,28(sp)
800035be:	6105                	addi	sp,sp,32
800035c0:	8082                	ret

800035c2 <GPIO_QualCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
800035c2:	1101                	addi	sp,sp,-32
800035c4:	ce22                	sw	s0,28(sp)
800035c6:	1000                	addi	s0,sp,32
800035c8:	fea42623          	sw	a0,-20(s0)
800035cc:	feb42423          	sw	a1,-24(s0)
800035d0:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800035d4:	fe442703          	lw	a4,-28(s0)
800035d8:	4785                	li	a5,1
800035da:	00f71863          	bne	a4,a5,800035ea <GPIO_QualCmd+0x28>
        WRITE_REG(GPIOx->QUALSET, Pin);
800035de:	fec42783          	lw	a5,-20(s0)
800035e2:	fe842703          	lw	a4,-24(s0)
800035e6:	c7f8                	sw	a4,76(a5)
    else
        WRITE_REG(GPIOx->QUALCLR, Pin);
}
800035e8:	a031                	j	800035f4 <GPIO_QualCmd+0x32>
        WRITE_REG(GPIOx->QUALCLR, Pin);
800035ea:	fec42783          	lw	a5,-20(s0)
800035ee:	fe842703          	lw	a4,-24(s0)
800035f2:	cbb8                	sw	a4,80(a5)
}
800035f4:	0001                	nop
800035f6:	4472                	lw	s0,28(sp)
800035f8:	6105                	addi	sp,sp,32
800035fa:	8082                	ret

800035fc <GPIO_SyncCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_SyncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
800035fc:	1101                	addi	sp,sp,-32
800035fe:	ce22                	sw	s0,28(sp)
80003600:	1000                	addi	s0,sp,32
80003602:	fea42623          	sw	a0,-20(s0)
80003606:	feb42423          	sw	a1,-24(s0)
8000360a:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000360e:	fe442703          	lw	a4,-28(s0)
80003612:	4785                	li	a5,1
80003614:	00f71863          	bne	a4,a5,80003624 <GPIO_SyncCmd+0x28>
        WRITE_REG(GPIOx->SYNCSET, Pin);
80003618:	fec42783          	lw	a5,-20(s0)
8000361c:	fe842703          	lw	a4,-24(s0)
80003620:	c3f8                	sw	a4,68(a5)
    else
        WRITE_REG(GPIOx->SYNCCLR, Pin);
}
80003622:	a031                	j	8000362e <GPIO_SyncCmd+0x32>
        WRITE_REG(GPIOx->SYNCCLR, Pin);
80003624:	fec42783          	lw	a5,-20(s0)
80003628:	fe842703          	lw	a4,-24(s0)
8000362c:	c7b8                	sw	a4,72(a5)
}
8000362e:	0001                	nop
80003630:	4472                	lw	s0,28(sp)
80003632:	6105                	addi	sp,sp,32
80003634:	8082                	ret

80003636 <GPIO_ITTypeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   IntType  Выбор режима генерации
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITTypeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_IntType_TypeDef IntType)
{
80003636:	1101                	addi	sp,sp,-32
80003638:	ce22                	sw	s0,28(sp)
8000363a:	1000                	addi	s0,sp,32
8000363c:	fea42623          	sw	a0,-20(s0)
80003640:	feb42423          	sw	a1,-24(s0)
80003644:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_INT_TYPE(IntType));

    if (IntType == GPIO_IntType_Edge)
80003648:	fe442703          	lw	a4,-28(s0)
8000364c:	4785                	li	a5,1
8000364e:	00f71863          	bne	a4,a5,8000365e <GPIO_ITTypeConfig+0x28>
        WRITE_REG(GPIOx->INTTYPESET, Pin);
80003652:	fec42783          	lw	a5,-20(s0)
80003656:	fe842703          	lw	a4,-24(s0)
8000365a:	d7b8                	sw	a4,104(a5)
    else
        WRITE_REG(GPIOx->INTTYPECLR, Pin);
}
8000365c:	a031                	j	80003668 <GPIO_ITTypeConfig+0x32>
        WRITE_REG(GPIOx->INTTYPECLR, Pin);
8000365e:	fec42783          	lw	a5,-20(s0)
80003662:	fe842703          	lw	a4,-24(s0)
80003666:	d7f8                	sw	a4,108(a5)
}
80003668:	0001                	nop
8000366a:	4472                	lw	s0,28(sp)
8000366c:	6105                	addi	sp,sp,32
8000366e:	8082                	ret

80003670 <GPIO_ITPolConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   IntPol  Выбор полярности
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITPolConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_IntPol_TypeDef IntPol)
{
80003670:	1101                	addi	sp,sp,-32
80003672:	ce22                	sw	s0,28(sp)
80003674:	1000                	addi	s0,sp,32
80003676:	fea42623          	sw	a0,-20(s0)
8000367a:	feb42423          	sw	a1,-24(s0)
8000367e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_INT_POL(IntPol));

    if (IntPol == GPIO_IntPol_Positive)
80003682:	fe442703          	lw	a4,-28(s0)
80003686:	4785                	li	a5,1
80003688:	00f71863          	bne	a4,a5,80003698 <GPIO_ITPolConfig+0x28>
        WRITE_REG(GPIOx->INTPOLSET, Pin);
8000368c:	fec42783          	lw	a5,-20(s0)
80003690:	fe842703          	lw	a4,-24(s0)
80003694:	dbb8                	sw	a4,112(a5)
    else
        WRITE_REG(GPIOx->INTPOLCLR, Pin);
}
80003696:	a031                	j	800036a2 <GPIO_ITPolConfig+0x32>
        WRITE_REG(GPIOx->INTPOLCLR, Pin);
80003698:	fec42783          	lw	a5,-20(s0)
8000369c:	fe842703          	lw	a4,-24(s0)
800036a0:	dbf8                	sw	a4,116(a5)
}
800036a2:	0001                	nop
800036a4:	4472                	lw	s0,28(sp)
800036a6:	6105                	addi	sp,sp,32
800036a8:	8082                	ret

800036aa <GPIO_ITEdgeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   IntEdge  Выбор режима
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITEdgeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_IntEdge_TypeDef IntEdge)
{
800036aa:	1101                	addi	sp,sp,-32
800036ac:	ce22                	sw	s0,28(sp)
800036ae:	1000                	addi	s0,sp,32
800036b0:	fea42623          	sw	a0,-20(s0)
800036b4:	feb42423          	sw	a1,-24(s0)
800036b8:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_INT_EDGE(IntEdge));

    if (IntEdge == GPIO_IntEdge_Any)
800036bc:	fe442703          	lw	a4,-28(s0)
800036c0:	4785                	li	a5,1
800036c2:	00f71863          	bne	a4,a5,800036d2 <GPIO_ITEdgeConfig+0x28>
        WRITE_REG(GPIOx->INTEDGESET, Pin);
800036c6:	fec42783          	lw	a5,-20(s0)
800036ca:	fe842703          	lw	a4,-24(s0)
800036ce:	dfb8                	sw	a4,120(a5)
    else
        WRITE_REG(GPIOx->INTEDGECLR, Pin);
}
800036d0:	a031                	j	800036dc <GPIO_ITEdgeConfig+0x32>
        WRITE_REG(GPIOx->INTEDGECLR, Pin);
800036d2:	fec42783          	lw	a5,-20(s0)
800036d6:	fe842703          	lw	a4,-24(s0)
800036da:	dff8                	sw	a4,124(a5)
}
800036dc:	0001                	nop
800036de:	4472                	lw	s0,28(sp)
800036e0:	6105                	addi	sp,sp,32
800036e2:	8082                	ret

800036e4 <GPIO_ITCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
800036e4:	1101                	addi	sp,sp,-32
800036e6:	ce22                	sw	s0,28(sp)
800036e8:	1000                	addi	s0,sp,32
800036ea:	fea42623          	sw	a0,-20(s0)
800036ee:	feb42423          	sw	a1,-24(s0)
800036f2:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800036f6:	fe442703          	lw	a4,-28(s0)
800036fa:	4785                	li	a5,1
800036fc:	00f71863          	bne	a4,a5,8000370c <GPIO_ITCmd+0x28>
        WRITE_REG(GPIOx->INTENSET, Pin);
80003700:	fec42783          	lw	a5,-20(s0)
80003704:	fe842703          	lw	a4,-24(s0)
80003708:	d3b8                	sw	a4,96(a5)
    else
        WRITE_REG(GPIOx->INTENCLR, Pin);
}
8000370a:	a031                	j	80003716 <GPIO_ITCmd+0x32>
        WRITE_REG(GPIOx->INTENCLR, Pin);
8000370c:	fec42783          	lw	a5,-20(s0)
80003710:	fe842703          	lw	a4,-24(s0)
80003714:	d3f8                	sw	a4,100(a5)
}
80003716:	0001                	nop
80003718:	4472                	lw	s0,28(sp)
8000371a:	6105                	addi	sp,sp,32
8000371c:	8082                	ret

8000371e <GPIO_ITStatusClear>:
  * @param   GPIOx  выбор порта, где x=A|B|C    
  * @param   Pin  Выбор пинов
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITStatusClear(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
8000371e:	1101                	addi	sp,sp,-32
80003720:	ce22                	sw	s0,28(sp)
80003722:	1000                	addi	s0,sp,32
80003724:	fea42623          	sw	a0,-20(s0)
80003728:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->INTSTATUS, Pin);
8000372c:	fec42783          	lw	a5,-20(s0)
80003730:	fe842703          	lw	a4,-24(s0)
80003734:	08e7a023          	sw	a4,128(a5) # 20050080 <STACK_SIZE+0x2004f880>
}
80003738:	0001                	nop
8000373a:	4472                	lw	s0,28(sp)
8000373c:	6105                	addi	sp,sp,32
8000373e:	8082                	ret

80003740 <gpio_reset_pin>:
#include "gpio_helpers.h"
#include <stddef.h>

void gpio_reset_pin(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003740:	1101                	addi	sp,sp,-32
80003742:	ce06                	sw	ra,28(sp)
80003744:	cc22                	sw	s0,24(sp)
80003746:	1000                	addi	s0,sp,32
80003748:	fea42623          	sw	a0,-20(s0)
8000374c:	feb42423          	sw	a1,-24(s0)
    // 1. Отключить выход (OUTENCLR)
    GPIO_OutCmd(GPIOx, Pin, DISABLE);
80003750:	4601                	li	a2,0
80003752:	fe842583          	lw	a1,-24(s0)
80003756:	fec42503          	lw	a0,-20(s0)
8000375a:	3b05                	jal	8000348a <GPIO_OutCmd>
    // 2. Очистить данные выхода (DATAOUTCLR)
    GPIO_ClearBits(GPIOx, Pin);
8000375c:	fe842583          	lw	a1,-24(s0)
80003760:	fec42503          	lw	a0,-20(s0)
80003764:	33d5                	jal	80003548 <GPIO_ClearBits>
    // 3. Отключить альтернативную функцию (ALTFUNCCLR)
    GPIO_AltFuncCmd(GPIOx, Pin, DISABLE); 
80003766:	4601                	li	a2,0
80003768:	fe842583          	lw	a1,-24(s0)
8000376c:	fec42503          	lw	a0,-20(s0)
80003770:	3b91                	jal	800034c4 <GPIO_AltFuncCmd>
    // 4. Сбросить номер альтернативной функции (ALTFUNCNUM = 0)
    GPIO_AltFuncNumConfig(GPIOx, Pin, GPIO_AltFuncNum_None);
80003772:	4601                	li	a2,0
80003774:	fe842583          	lw	a1,-24(s0)
80003778:	fec42503          	lw	a0,-20(s0)
8000377c:	09d030ef          	jal	ra,80007018 <GPIO_AltFuncNumConfig>
    // 5. Сбросить режимы в значения по умолчанию
    // В новой версии PLIB нет отдельного InMode, поэтому ограничимся
    // отключением подтяжки и установкой push‑pull для выхода.
    GPIO_PullModeConfig(GPIOx, Pin, GPIO_PullMode_Disable);
80003780:	4601                	li	a2,0
80003782:	fe842583          	lw	a1,-24(s0)
80003786:	fec42503          	lw	a0,-20(s0)
8000378a:	059030ef          	jal	ra,80006fe2 <GPIO_PullModeConfig>
    GPIO_OutModeConfig(GPIOx, Pin, GPIO_OutMode_PP);
8000378e:	4601                	li	a2,0
80003790:	fe842583          	lw	a1,-24(s0)
80003794:	fec42503          	lw	a0,-20(s0)
80003798:	019030ef          	jal	ra,80006fb0 <GPIO_OutModeConfig>
    // 6. Отключить прерывания, если были включены
    GPIO_ITCmd(GPIOx, Pin, DISABLE);
8000379c:	4601                	li	a2,0
8000379e:	fe842583          	lw	a1,-24(s0)
800037a2:	fec42503          	lw	a0,-20(s0)
800037a6:	3f3d                	jal	800036e4 <GPIO_ITCmd>
    GPIO_ITStatusClear(GPIOx, Pin);
800037a8:	fe842583          	lw	a1,-24(s0)
800037ac:	fec42503          	lw	a0,-20(s0)
800037b0:	37bd                	jal	8000371e <GPIO_ITStatusClear>
    // 7. Отключить квалификатор входа
    GPIO_QualCmd(GPIOx, Pin, DISABLE);
800037b2:	4601                	li	a2,0
800037b4:	fe842583          	lw	a1,-24(s0)
800037b8:	fec42503          	lw	a0,-20(s0)
800037bc:	3519                	jal	800035c2 <GPIO_QualCmd>
    GPIO_SyncCmd(GPIOx, Pin, DISABLE);
800037be:	4601                	li	a2,0
800037c0:	fe842583          	lw	a1,-24(s0)
800037c4:	fec42503          	lw	a0,-20(s0)
800037c8:	3d15                	jal	800035fc <GPIO_SyncCmd>
}
800037ca:	0001                	nop
800037cc:	40f2                	lw	ra,28(sp)
800037ce:	4462                	lw	s0,24(sp)
800037d0:	6105                	addi	sp,sp,32
800037d2:	8082                	ret

800037d4 <gpio_init_output>:

void gpio_init_output(GPIO_TypeDef* GPIOx, uint32_t Pin, uint8_t initial_state)
{
800037d4:	7139                	addi	sp,sp,-64
800037d6:	de06                	sw	ra,60(sp)
800037d8:	dc22                	sw	s0,56(sp)
800037da:	0080                	addi	s0,sp,64
800037dc:	fca42623          	sw	a0,-52(s0)
800037e0:	fcb42423          	sw	a1,-56(s0)
800037e4:	87b2                	mv	a5,a2
800037e6:	fcf403a3          	sb	a5,-57(s0)
    // Сначала сбрасываем состояние пина
    gpio_reset_pin(GPIOx, Pin);
800037ea:	fc842583          	lw	a1,-56(s0)
800037ee:	fcc42503          	lw	a0,-52(s0)
800037f2:	37b9                	jal	80003740 <gpio_reset_pin>
    
    GPIO_Init_TypeDef gpio;
    GPIO_StructInit(&gpio);
800037f4:	fd840793          	addi	a5,s0,-40
800037f8:	853e                	mv	a0,a5
800037fa:	19b030ef          	jal	ra,80007194 <GPIO_StructInit>
    gpio.Pin = Pin;
800037fe:	fc842783          	lw	a5,-56(s0)
80003802:	fcf42c23          	sw	a5,-40(s0)
    gpio.Out = ENABLE;                // включить выход
80003806:	4785                	li	a5,1
80003808:	fcf42e23          	sw	a5,-36(s0)
    gpio.AltFunc = DISABLE;           // обычный GPIO
8000380c:	fe042023          	sw	zero,-32(s0)
    gpio.AltFuncNum = GPIO_AltFuncNum_None;
80003810:	fe042223          	sw	zero,-28(s0)
    gpio.OutMode = GPIO_OutMode_PP;   // push-pull
80003814:	fe042423          	sw	zero,-24(s0)
    gpio.PullMode = GPIO_PullMode_Disable;
80003818:	fe042623          	sw	zero,-20(s0)
    GPIO_Init(GPIOx, &gpio);
8000381c:	fd840793          	addi	a5,s0,-40
80003820:	85be                	mv	a1,a5
80003822:	fcc42503          	lw	a0,-52(s0)
80003826:	0e7030ef          	jal	ra,8000710c <GPIO_Init>
    
    // Устанавливаем начальное состояние
    if (initial_state) {
8000382a:	fc744783          	lbu	a5,-57(s0)
8000382e:	c799                	beqz	a5,8000383c <gpio_init_output+0x68>
      GPIO_SetBits(GPIOx, Pin);
80003830:	fc842583          	lw	a1,-56(s0)
80003834:	fcc42503          	lw	a0,-52(s0)
80003838:	39c5                	jal	80003528 <GPIO_SetBits>
    } else {
      GPIO_ClearBits(GPIOx, Pin);
    }
}
8000383a:	a031                	j	80003846 <gpio_init_output+0x72>
      GPIO_ClearBits(GPIOx, Pin);
8000383c:	fc842583          	lw	a1,-56(s0)
80003840:	fcc42503          	lw	a0,-52(s0)
80003844:	3311                	jal	80003548 <GPIO_ClearBits>
}
80003846:	0001                	nop
80003848:	50f2                	lw	ra,60(sp)
8000384a:	5462                	lw	s0,56(sp)
8000384c:	6121                	addi	sp,sp,64
8000384e:	8082                	ret

80003850 <gpio_init_input>:

static uint8_t gpio_qual_initialized = 0;

void gpio_init_input(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_PullMode_TypeDef pull_mode)
{
80003850:	7139                	addi	sp,sp,-64
80003852:	de06                	sw	ra,60(sp)
80003854:	dc22                	sw	s0,56(sp)
80003856:	0080                	addi	s0,sp,64
80003858:	fca42623          	sw	a0,-52(s0)
8000385c:	fcb42423          	sw	a1,-56(s0)
80003860:	fcc42223          	sw	a2,-60(s0)
    // Сначала сбрасываем состояние пина
    gpio_reset_pin(GPIOx, Pin);
80003864:	fc842583          	lw	a1,-56(s0)
80003868:	fcc42503          	lw	a0,-52(s0)
8000386c:	3dd1                	jal	80003740 <gpio_reset_pin>
    
    GPIO_Init_TypeDef gpio;
    GPIO_StructInit(&gpio);
8000386e:	fd840793          	addi	a5,s0,-40
80003872:	853e                	mv	a0,a5
80003874:	121030ef          	jal	ra,80007194 <GPIO_StructInit>
    gpio.Pin = Pin;
80003878:	fc842783          	lw	a5,-56(s0)
8000387c:	fcf42c23          	sw	a5,-40(s0)
    gpio.Out = DISABLE;
80003880:	fc042e23          	sw	zero,-36(s0)
    gpio.AltFunc = DISABLE;
80003884:	fe042023          	sw	zero,-32(s0)
    gpio.AltFuncNum = GPIO_AltFuncNum_None;
80003888:	fe042223          	sw	zero,-28(s0)
    gpio.OutMode = GPIO_OutMode_PP;
8000388c:	fe042423          	sw	zero,-24(s0)
    gpio.PullMode = pull_mode;
80003890:	fc442783          	lw	a5,-60(s0)
80003894:	fef42623          	sw	a5,-20(s0)
    GPIO_Init(GPIOx, &gpio);
80003898:	fd840793          	addi	a5,s0,-40
8000389c:	85be                	mv	a1,a5
8000389e:	fcc42503          	lw	a0,-52(s0)
800038a2:	06b030ef          	jal	ra,8000710c <GPIO_Init>

    // Аппаратная фильтрация дребезга: пересинхронизация + квалификатор входа
    GPIO_SyncCmd(GPIOx, Pin, ENABLE);
800038a6:	4605                	li	a2,1
800038a8:	fc842583          	lw	a1,-56(s0)
800038ac:	fcc42503          	lw	a0,-52(s0)
800038b0:	33b1                	jal	800035fc <GPIO_SyncCmd>

    // Устанавливаем период выборки фильтра один раз на порт (по сути, можно
    // делать и каждый раз, но оставим лёгкую оптимизацию по флагу).
    if (!gpio_qual_initialized) {
800038b2:	e921c783          	lbu	a5,-366(gp) # 40000612 <gpio_qual_initialized>
800038b6:	eb89                	bnez	a5,800038c8 <gpio_init_input+0x78>
      GPIO_QualSampleConfig(GPIOx, 1000); // период дискретизации в тактах SystemCoreClock
800038b8:	3e800593          	li	a1,1000
800038bc:	fcc42503          	lw	a0,-52(s0)
800038c0:	31cd                	jal	800035a2 <GPIO_QualSampleConfig>
      gpio_qual_initialized = 1;
800038c2:	4705                	li	a4,1
800038c4:	e8e18923          	sb	a4,-366(gp) # 40000612 <gpio_qual_initialized>
    }

    GPIO_QualModeConfig(GPIOx, Pin, GPIO_QualMode_6Sample); // более жёсткая фильтрация
800038c8:	4605                	li	a2,1
800038ca:	fc842583          	lw	a1,-56(s0)
800038ce:	fcc42503          	lw	a0,-52(s0)
800038d2:	3959                	jal	80003568 <GPIO_QualModeConfig>
    GPIO_QualCmd(GPIOx, Pin, ENABLE);
800038d4:	4605                	li	a2,1
800038d6:	fc842583          	lw	a1,-56(s0)
800038da:	fcc42503          	lw	a0,-52(s0)
800038de:	31d5                	jal	800035c2 <GPIO_QualCmd>
}
800038e0:	0001                	nop
800038e2:	50f2                	lw	ra,60(sp)
800038e4:	5462                	lw	s0,56(sp)
800038e6:	6121                	addi	sp,sp,64
800038e8:	8082                	ret

800038ea <gpio_init_input_irq>:

void gpio_init_input_irq(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_PullMode_TypeDef pull_mode, volatile uint8_t* last_state)
{
800038ea:	1101                	addi	sp,sp,-32
800038ec:	ce06                	sw	ra,28(sp)
800038ee:	cc22                	sw	s0,24(sp)
800038f0:	1000                	addi	s0,sp,32
800038f2:	fea42623          	sw	a0,-20(s0)
800038f6:	feb42423          	sw	a1,-24(s0)
800038fa:	fec42223          	sw	a2,-28(s0)
800038fe:	fed42023          	sw	a3,-32(s0)
    // Сначала инициализируем как обычный вход
    gpio_init_input(GPIOx, Pin, pull_mode);
80003902:	fe442603          	lw	a2,-28(s0)
80003906:	fe842583          	lw	a1,-24(s0)
8000390a:	fec42503          	lw	a0,-20(s0)
8000390e:	3789                	jal	80003850 <gpio_init_input>
    
    // Настраиваем прерывания
    GPIO_ITTypeConfig(GPIOx, Pin, GPIO_IntType_Edge);
80003910:	4605                	li	a2,1
80003912:	fe842583          	lw	a1,-24(s0)
80003916:	fec42503          	lw	a0,-20(s0)
8000391a:	3b31                	jal	80003636 <GPIO_ITTypeConfig>
    GPIO_ITPolConfig(GPIOx, Pin, GPIO_IntPol_Negative);
8000391c:	4601                	li	a2,0
8000391e:	fe842583          	lw	a1,-24(s0)
80003922:	fec42503          	lw	a0,-20(s0)
80003926:	33a9                	jal	80003670 <GPIO_ITPolConfig>
    GPIO_ITEdgeConfig(GPIOx, Pin, GPIO_IntEdge_Any); // прерывание по обоим фронтам
80003928:	4605                	li	a2,1
8000392a:	fe842583          	lw	a1,-24(s0)
8000392e:	fec42503          	lw	a0,-20(s0)
80003932:	3ba5                	jal	800036aa <GPIO_ITEdgeConfig>
    GPIO_ITStatusClear(GPIOx, Pin);
80003934:	fe842583          	lw	a1,-24(s0)
80003938:	fec42503          	lw	a0,-20(s0)
8000393c:	33cd                	jal	8000371e <GPIO_ITStatusClear>
    
    // Инициализировать предыдущее состояние кнопки (отпущена = 1)
    if (last_state != NULL) {
8000393e:	fe042783          	lw	a5,-32(s0)
80003942:	c385                	beqz	a5,80003962 <gpio_init_input_irq+0x78>
      *last_state = GPIO_ReadBit(GPIOx, Pin) ? 1 : 0;
80003944:	fe842583          	lw	a1,-24(s0)
80003948:	fec42503          	lw	a0,-20(s0)
8000394c:	3e4d                	jal	800034fe <GPIO_ReadBit>
8000394e:	87aa                	mv	a5,a0
80003950:	00f037b3          	snez	a5,a5
80003954:	0ff7f793          	zext.b	a5,a5
80003958:	873e                	mv	a4,a5
8000395a:	fe042783          	lw	a5,-32(s0)
8000395e:	00e78023          	sb	a4,0(a5)
    }
    
    // Включить прерывание
    GPIO_ITCmd(GPIOx, Pin, ENABLE);
80003962:	4605                	li	a2,1
80003964:	fe842583          	lw	a1,-24(s0)
80003968:	fec42503          	lw	a0,-20(s0)
8000396c:	3ba5                	jal	800036e4 <GPIO_ITCmd>
}
8000396e:	0001                	nop
80003970:	40f2                	lw	ra,28(sp)
80003972:	4462                	lw	s0,24(sp)
80003974:	6105                	addi	sp,sp,32
80003976:	8082                	ret

80003978 <ccitt_crc16_update>:
0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};

uint16_t ccitt_crc16_update(uint16_t crc, uint8_t byte)
{
80003978:	1101                	addi	sp,sp,-32
8000397a:	ce22                	sw	s0,28(sp)
8000397c:	1000                	addi	s0,sp,32
8000397e:	87aa                	mv	a5,a0
80003980:	872e                	mv	a4,a1
80003982:	fef41723          	sh	a5,-18(s0)
80003986:	87ba                	mv	a5,a4
80003988:	fef406a3          	sb	a5,-19(s0)
	crc = (crc << 8) ^ crc_table[((crc >> 8) ^ byte) & 0x00FF];
8000398c:	fee45783          	lhu	a5,-18(s0)
80003990:	07a2                	slli	a5,a5,0x8
80003992:	01079713          	slli	a4,a5,0x10
80003996:	8741                	srai	a4,a4,0x10
80003998:	fee45783          	lhu	a5,-18(s0)
8000399c:	83a1                	srli	a5,a5,0x8
8000399e:	07c2                	slli	a5,a5,0x10
800039a0:	83c1                	srli	a5,a5,0x10
800039a2:	86be                	mv	a3,a5
800039a4:	fed44783          	lbu	a5,-19(s0)
800039a8:	8fb5                	xor	a5,a5,a3
800039aa:	0ff7f793          	zext.b	a5,a5
800039ae:	800096b7          	lui	a3,0x80009
800039b2:	5bc68693          	addi	a3,a3,1468 # 800095bc <__data_source_start+0xfffffb98>
800039b6:	0786                	slli	a5,a5,0x1
800039b8:	97b6                	add	a5,a5,a3
800039ba:	0007d783          	lhu	a5,0(a5)
800039be:	07c2                	slli	a5,a5,0x10
800039c0:	87c1                	srai	a5,a5,0x10
800039c2:	8fb9                	xor	a5,a5,a4
800039c4:	07c2                	slli	a5,a5,0x10
800039c6:	87c1                	srai	a5,a5,0x10
800039c8:	fef41723          	sh	a5,-18(s0)
	return crc;
800039cc:	fee45783          	lhu	a5,-18(s0)
}
800039d0:	853e                	mv	a0,a5
800039d2:	4472                	lw	s0,28(sp)
800039d4:	6105                	addi	sp,sp,32
800039d6:	8082                	ret

800039d8 <ccitt_crc16_calc>:

uint16_t ccitt_crc16_calc(uint16_t initcrc, const uint8_t *data, uint16_t len)
{
800039d8:	7179                	addi	sp,sp,-48
800039da:	d622                	sw	s0,44(sp)
800039dc:	1800                	addi	s0,sp,48
800039de:	87aa                	mv	a5,a0
800039e0:	fcb42c23          	sw	a1,-40(s0)
800039e4:	8732                	mv	a4,a2
800039e6:	fcf41f23          	sh	a5,-34(s0)
800039ea:	87ba                	mv	a5,a4
800039ec:	fcf41e23          	sh	a5,-36(s0)
	uint16_t crc = initcrc;
800039f0:	fde45783          	lhu	a5,-34(s0)
800039f4:	fef41723          	sh	a5,-18(s0)
	for (uint16_t i = 0; i < len; i++) {
800039f8:	fe041623          	sh	zero,-20(s0)
800039fc:	a899                	j	80003a52 <ccitt_crc16_calc+0x7a>
		crc = (crc << 8) ^ crc_table[((crc >> 8) ^ data[i]) & 0x00FF];
800039fe:	fee45783          	lhu	a5,-18(s0)
80003a02:	07a2                	slli	a5,a5,0x8
80003a04:	01079713          	slli	a4,a5,0x10
80003a08:	8741                	srai	a4,a4,0x10
80003a0a:	fee45783          	lhu	a5,-18(s0)
80003a0e:	83a1                	srli	a5,a5,0x8
80003a10:	07c2                	slli	a5,a5,0x10
80003a12:	83c1                	srli	a5,a5,0x10
80003a14:	863e                	mv	a2,a5
80003a16:	fec45783          	lhu	a5,-20(s0)
80003a1a:	fd842683          	lw	a3,-40(s0)
80003a1e:	97b6                	add	a5,a5,a3
80003a20:	0007c783          	lbu	a5,0(a5)
80003a24:	8fb1                	xor	a5,a5,a2
80003a26:	0ff7f793          	zext.b	a5,a5
80003a2a:	800096b7          	lui	a3,0x80009
80003a2e:	5bc68693          	addi	a3,a3,1468 # 800095bc <__data_source_start+0xfffffb98>
80003a32:	0786                	slli	a5,a5,0x1
80003a34:	97b6                	add	a5,a5,a3
80003a36:	0007d783          	lhu	a5,0(a5)
80003a3a:	07c2                	slli	a5,a5,0x10
80003a3c:	87c1                	srai	a5,a5,0x10
80003a3e:	8fb9                	xor	a5,a5,a4
80003a40:	07c2                	slli	a5,a5,0x10
80003a42:	87c1                	srai	a5,a5,0x10
80003a44:	fef41723          	sh	a5,-18(s0)
	for (uint16_t i = 0; i < len; i++) {
80003a48:	fec45783          	lhu	a5,-20(s0)
80003a4c:	0785                	addi	a5,a5,1
80003a4e:	fef41623          	sh	a5,-20(s0)
80003a52:	fec45703          	lhu	a4,-20(s0)
80003a56:	fdc45783          	lhu	a5,-36(s0)
80003a5a:	faf762e3          	bltu	a4,a5,800039fe <ccitt_crc16_calc+0x26>
	}
	return crc;
80003a5e:	fee45783          	lhu	a5,-18(s0)
}
80003a62:	853e                	mv	a0,a5
80003a64:	5432                	lw	s0,44(sp)
80003a66:	6145                	addi	sp,sp,48
80003a68:	8082                	ret

80003a6a <osdp_crc_is_ok>:

int osdp_crc_is_ok(const uint8_t *data, uint16_t len)
{
80003a6a:	7179                	addi	sp,sp,-48
80003a6c:	d606                	sw	ra,44(sp)
80003a6e:	d422                	sw	s0,40(sp)
80003a70:	1800                	addi	s0,sp,48
80003a72:	fca42e23          	sw	a0,-36(s0)
80003a76:	87ae                	mv	a5,a1
80003a78:	fcf41d23          	sh	a5,-38(s0)
	if (len < 2) return 0;
80003a7c:	fda45703          	lhu	a4,-38(s0)
80003a80:	4785                	li	a5,1
80003a82:	00e7e463          	bltu	a5,a4,80003a8a <osdp_crc_is_ok+0x20>
80003a86:	4781                	li	a5,0
80003a88:	a0ad                	j	80003af2 <osdp_crc_is_ok+0x88>
	uint16_t src_crc = ((uint16_t)data[len - 1] << 8) | data[len - 2];
80003a8a:	fda45783          	lhu	a5,-38(s0)
80003a8e:	17fd                	addi	a5,a5,-1
80003a90:	fdc42703          	lw	a4,-36(s0)
80003a94:	97ba                	add	a5,a5,a4
80003a96:	0007c783          	lbu	a5,0(a5)
80003a9a:	07a2                	slli	a5,a5,0x8
80003a9c:	01079713          	slli	a4,a5,0x10
80003aa0:	8741                	srai	a4,a4,0x10
80003aa2:	fda45783          	lhu	a5,-38(s0)
80003aa6:	17f9                	addi	a5,a5,-2
80003aa8:	fdc42683          	lw	a3,-36(s0)
80003aac:	97b6                	add	a5,a5,a3
80003aae:	0007c783          	lbu	a5,0(a5)
80003ab2:	07c2                	slli	a5,a5,0x10
80003ab4:	87c1                	srai	a5,a5,0x10
80003ab6:	8fd9                	or	a5,a5,a4
80003ab8:	07c2                	slli	a5,a5,0x10
80003aba:	87c1                	srai	a5,a5,0x10
80003abc:	fef41723          	sh	a5,-18(s0)
	uint16_t calc = ccitt_crc16_calc(OSDP_INIT_CRC16, data, (uint16_t)(len - 2));
80003ac0:	fda45783          	lhu	a5,-38(s0)
80003ac4:	17f9                	addi	a5,a5,-2
80003ac6:	07c2                	slli	a5,a5,0x10
80003ac8:	83c1                	srli	a5,a5,0x10
80003aca:	863e                	mv	a2,a5
80003acc:	fdc42583          	lw	a1,-36(s0)
80003ad0:	6789                	lui	a5,0x2
80003ad2:	d0f78513          	addi	a0,a5,-753 # 1d0f <STACK_SIZE+0x150f>
80003ad6:	3709                	jal	800039d8 <ccitt_crc16_calc>
80003ad8:	87aa                	mv	a5,a0
80003ada:	fef41623          	sh	a5,-20(s0)
	return (src_crc == calc) ? 1 : 0;
80003ade:	fee45703          	lhu	a4,-18(s0)
80003ae2:	fec45783          	lhu	a5,-20(s0)
80003ae6:	40f707b3          	sub	a5,a4,a5
80003aea:	0017b793          	seqz	a5,a5
80003aee:	0ff7f793          	zext.b	a5,a5
}
80003af2:	853e                	mv	a0,a5
80003af4:	50b2                	lw	ra,44(sp)
80003af6:	5422                	lw	s0,40(sp)
80003af8:	6145                	addi	sp,sp,48
80003afa:	8082                	ret

80003afc <GPIO_ReadBit>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  State  Состояние Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003afc:	1101                	addi	sp,sp,-32
80003afe:	ce22                	sw	s0,28(sp)
80003b00:	1000                	addi	s0,sp,32
80003b02:	fea42623          	sw	a0,-20(s0)
80003b06:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
80003b0a:	fec42783          	lw	a5,-20(s0)
80003b0e:	4398                	lw	a4,0(a5)
80003b10:	fe842783          	lw	a5,-24(s0)
80003b14:	8ff9                	and	a5,a5,a4
80003b16:	c399                	beqz	a5,80003b1c <GPIO_ReadBit+0x20>
80003b18:	4785                	li	a5,1
80003b1a:	a011                	j	80003b1e <GPIO_ReadBit+0x22>
80003b1c:	4781                	li	a5,0
}
80003b1e:	853e                	mv	a0,a5
80003b20:	4472                	lw	s0,28(sp)
80003b22:	6105                	addi	sp,sp,32
80003b24:	8082                	ret

80003b26 <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003b26:	1101                	addi	sp,sp,-32
80003b28:	ce22                	sw	s0,28(sp)
80003b2a:	1000                	addi	s0,sp,32
80003b2c:	fea42623          	sw	a0,-20(s0)
80003b30:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
80003b34:	fec42783          	lw	a5,-20(s0)
80003b38:	fe842703          	lw	a4,-24(s0)
80003b3c:	c798                	sw	a4,8(a5)
}
80003b3e:	0001                	nop
80003b40:	4472                	lw	s0,28(sp)
80003b42:	6105                	addi	sp,sp,32
80003b44:	8082                	ret

80003b46 <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003b46:	1101                	addi	sp,sp,-32
80003b48:	ce22                	sw	s0,28(sp)
80003b4a:	1000                	addi	s0,sp,32
80003b4c:	fea42623          	sw	a0,-20(s0)
80003b50:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
80003b54:	fec42783          	lw	a5,-20(s0)
80003b58:	fe842703          	lw	a4,-24(s0)
80003b5c:	c7d8                	sw	a4,12(a5)
}
80003b5e:	0001                	nop
80003b60:	4472                	lw	s0,28(sp)
80003b62:	6105                	addi	sp,sp,32
80003b64:	8082                	ret

80003b66 <osdp_load_addr_baud>:
// Текущий адрес в RAM
static uint8_t g_addr;
static uint32_t g_baud;

static void osdp_load_addr_baud(void)
{
80003b66:	7179                	addi	sp,sp,-48
80003b68:	d606                	sw	ra,44(sp)
80003b6a:	d422                	sw	s0,40(sp)
80003b6c:	1800                	addi	s0,sp,48
	// Всегда задаём значения по умолчанию — иначе при неудачной загрузке
	// из EEPROM g_addr и g_baud остаются 0 и устройство не отвечает на POLL
	g_addr = 0x01;
80003b6e:	4705                	li	a4,1
80003b70:	e8e18a23          	sb	a4,-364(gp) # 40000614 <g_addr>
	g_baud = 115200;
80003b74:	6771                	lui	a4,0x1c
80003b76:	20070713          	addi	a4,a4,512 # 1c200 <STACK_SIZE+0x1ba00>
80003b7a:	e8e1ac23          	sw	a4,-360(gp) # 40000618 <g_baud>

	config_storage_t cfg;
	if (config_storage_load(&cfg)) {
80003b7e:	fd840793          	addi	a5,s0,-40
80003b82:	853e                	mv	a0,a5
80003b84:	a2cff0ef          	jal	ra,80002db0 <config_storage_load>
80003b88:	87aa                	mv	a5,a0
80003b8a:	cbad                	beqz	a5,80003bfc <osdp_load_addr_baud+0x96>
		if (cfg.osdp_addr > 0 && cfg.osdp_addr <= 0x7F) {
80003b8c:	fd844783          	lbu	a5,-40(s0)
80003b90:	cb99                	beqz	a5,80003ba6 <osdp_load_addr_baud+0x40>
80003b92:	fd844783          	lbu	a5,-40(s0)
80003b96:	07e2                	slli	a5,a5,0x18
80003b98:	87e1                	srai	a5,a5,0x18
80003b9a:	0007c663          	bltz	a5,80003ba6 <osdp_load_addr_baud+0x40>
			g_addr = cfg.osdp_addr;
80003b9e:	fd844703          	lbu	a4,-40(s0)
80003ba2:	e8e18a23          	sb	a4,-364(gp) # 40000614 <g_addr>
		}
		if (cfg.osdp_baud >= 9600 && cfg.osdp_baud <= 1000000) {
80003ba6:	fd842783          	lw	a5,-40(s0)
80003baa:	83a1                	srli	a5,a5,0x8
80003bac:	fdc42703          	lw	a4,-36(s0)
80003bb0:	0ff77713          	zext.b	a4,a4
80003bb4:	0762                	slli	a4,a4,0x18
80003bb6:	8fd9                	or	a5,a5,a4
80003bb8:	873e                	mv	a4,a5
80003bba:	6789                	lui	a5,0x2
80003bbc:	57f78793          	addi	a5,a5,1407 # 257f <STACK_SIZE+0x1d7f>
80003bc0:	02e7fe63          	bgeu	a5,a4,80003bfc <osdp_load_addr_baud+0x96>
80003bc4:	fd842783          	lw	a5,-40(s0)
80003bc8:	83a1                	srli	a5,a5,0x8
80003bca:	fdc42703          	lw	a4,-36(s0)
80003bce:	0ff77713          	zext.b	a4,a4
80003bd2:	0762                	slli	a4,a4,0x18
80003bd4:	8fd9                	or	a5,a5,a4
80003bd6:	873e                	mv	a4,a5
80003bd8:	000f47b7          	lui	a5,0xf4
80003bdc:	24078793          	addi	a5,a5,576 # f4240 <STACK_SIZE+0xf3a40>
80003be0:	00e7ee63          	bltu	a5,a4,80003bfc <osdp_load_addr_baud+0x96>
			g_baud = cfg.osdp_baud;
80003be4:	fd842783          	lw	a5,-40(s0)
80003be8:	83a1                	srli	a5,a5,0x8
80003bea:	fdc42703          	lw	a4,-36(s0)
80003bee:	0ff77713          	zext.b	a4,a4
80003bf2:	0762                	slli	a4,a4,0x18
80003bf4:	8fd9                	or	a5,a5,a4
80003bf6:	873e                	mv	a4,a5
80003bf8:	e8e1ac23          	sw	a4,-360(gp) # 40000618 <g_baud>
		}
	}
	// ВАЖНО: здесь baud только сохраняем в RAM / cfg.
	// Реальную смену скорости UART делаем ТОЛЬКО по команде osdp_COMSET,
	// чтобы не ломать консольный вывод при старте.
}
80003bfc:	0001                	nop
80003bfe:	50b2                	lw	ra,44(sp)
80003c00:	5422                	lw	s0,40(sp)
80003c02:	6145                	addi	sp,sp,48
80003c04:	8082                	ret

80003c06 <osdp_send_blocking>:
static uint16_t   rx_expected_len = 0;
static uint16_t   rx_pos = 0;
static uint8_t    rx_buf[64];

static void osdp_send_blocking(const uint8_t *data, uint16_t len)
{
80003c06:	7179                	addi	sp,sp,-48
80003c08:	d622                	sw	s0,44(sp)
80003c0a:	1800                	addi	s0,sp,48
80003c0c:	fca42e23          	sw	a0,-36(s0)
80003c10:	87ae                	mv	a5,a1
80003c12:	fcf41d23          	sh	a5,-38(s0)
	for (uint16_t i = 0; i < len; i++) {
80003c16:	fe041723          	sh	zero,-18(s0)
80003c1a:	a815                	j	80003c4e <osdp_send_blocking+0x48>
		while (RETARGET_UART->FR_bit.TXFF) { }
80003c1c:	0001                	nop
80003c1e:	3000a7b7          	lui	a5,0x3000a
80003c22:	4f9c                	lw	a5,24(a5)
80003c24:	8395                	srli	a5,a5,0x5
80003c26:	8b85                	andi	a5,a5,1
80003c28:	0ff7f793          	zext.b	a5,a5
80003c2c:	fbed                	bnez	a5,80003c1e <osdp_send_blocking+0x18>
		RETARGET_UART->DR_bit.DATA = data[i];
80003c2e:	fee45783          	lhu	a5,-18(s0)
80003c32:	fdc42703          	lw	a4,-36(s0)
80003c36:	973e                	add	a4,a4,a5
80003c38:	3000a7b7          	lui	a5,0x3000a
80003c3c:	00074703          	lbu	a4,0(a4)
80003c40:	00e78023          	sb	a4,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
	for (uint16_t i = 0; i < len; i++) {
80003c44:	fee45783          	lhu	a5,-18(s0)
80003c48:	0785                	addi	a5,a5,1
80003c4a:	fef41723          	sh	a5,-18(s0)
80003c4e:	fee45703          	lhu	a4,-18(s0)
80003c52:	fda45783          	lhu	a5,-38(s0)
80003c56:	fcf763e3          	bltu	a4,a5,80003c1c <osdp_send_blocking+0x16>
	}
	while (!RETARGET_UART->FR_bit.TXFE) { }
80003c5a:	0001                	nop
80003c5c:	3000a7b7          	lui	a5,0x3000a
80003c60:	4f9c                	lw	a5,24(a5)
80003c62:	839d                	srli	a5,a5,0x7
80003c64:	8b85                	andi	a5,a5,1
80003c66:	0ff7f793          	zext.b	a5,a5
80003c6a:	dbed                	beqz	a5,80003c5c <osdp_send_blocking+0x56>
}
80003c6c:	0001                	nop
80003c6e:	0001                	nop
80003c70:	5432                	lw	s0,44(sp)
80003c72:	6145                	addi	sp,sp,48
80003c74:	8082                	ret

80003c76 <osdp_build_header>:

// Вспомогательная функция для записи заголовка ответа.
static uint16_t osdp_build_header(uint8_t *tx, uint16_t dlen, uint8_t seq)
{
80003c76:	7179                	addi	sp,sp,-48
80003c78:	d622                	sw	s0,44(sp)
80003c7a:	1800                	addi	s0,sp,48
80003c7c:	fca42e23          	sw	a0,-36(s0)
80003c80:	87ae                	mv	a5,a1
80003c82:	8732                	mv	a4,a2
80003c84:	fcf41d23          	sh	a5,-38(s0)
80003c88:	87ba                	mv	a5,a4
80003c8a:	fcf40ca3          	sb	a5,-39(s0)
	uint16_t i = 0;
80003c8e:	fe041723          	sh	zero,-18(s0)
	tx[i++] = OSDP_SOM;
80003c92:	fee45783          	lhu	a5,-18(s0)
80003c96:	00178713          	addi	a4,a5,1 # 3000a001 <STACK_SIZE+0x30009801>
80003c9a:	fee41723          	sh	a4,-18(s0)
80003c9e:	873e                	mv	a4,a5
80003ca0:	fdc42783          	lw	a5,-36(s0)
80003ca4:	97ba                	add	a5,a5,a4
80003ca6:	05300713          	li	a4,83
80003caa:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)(g_addr | 0x80);
80003cae:	e941c703          	lbu	a4,-364(gp) # 40000614 <g_addr>
80003cb2:	fee45783          	lhu	a5,-18(s0)
80003cb6:	00178693          	addi	a3,a5,1
80003cba:	fed41723          	sh	a3,-18(s0)
80003cbe:	86be                	mv	a3,a5
80003cc0:	fdc42783          	lw	a5,-36(s0)
80003cc4:	97b6                	add	a5,a5,a3
80003cc6:	f8076713          	ori	a4,a4,-128
80003cca:	0ff77713          	zext.b	a4,a4
80003cce:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)(dlen & 0xFF);
80003cd2:	fee45783          	lhu	a5,-18(s0)
80003cd6:	00178713          	addi	a4,a5,1
80003cda:	fee41723          	sh	a4,-18(s0)
80003cde:	873e                	mv	a4,a5
80003ce0:	fdc42783          	lw	a5,-36(s0)
80003ce4:	97ba                	add	a5,a5,a4
80003ce6:	fda45703          	lhu	a4,-38(s0)
80003cea:	0ff77713          	zext.b	a4,a4
80003cee:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)((dlen >> 8) & 0xFF);
80003cf2:	fda45783          	lhu	a5,-38(s0)
80003cf6:	83a1                	srli	a5,a5,0x8
80003cf8:	01079693          	slli	a3,a5,0x10
80003cfc:	82c1                	srli	a3,a3,0x10
80003cfe:	fee45783          	lhu	a5,-18(s0)
80003d02:	00178713          	addi	a4,a5,1
80003d06:	fee41723          	sh	a4,-18(s0)
80003d0a:	873e                	mv	a4,a5
80003d0c:	fdc42783          	lw	a5,-36(s0)
80003d10:	97ba                	add	a5,a5,a4
80003d12:	0ff6f713          	zext.b	a4,a3
80003d16:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)((seq & 0x03) | 0x04);
80003d1a:	fd940783          	lb	a5,-39(s0)
80003d1e:	8b8d                	andi	a5,a5,3
80003d20:	07e2                	slli	a5,a5,0x18
80003d22:	87e1                	srai	a5,a5,0x18
80003d24:	0047e793          	ori	a5,a5,4
80003d28:	01879693          	slli	a3,a5,0x18
80003d2c:	86e1                	srai	a3,a3,0x18
80003d2e:	fee45783          	lhu	a5,-18(s0)
80003d32:	00178713          	addi	a4,a5,1
80003d36:	fee41723          	sh	a4,-18(s0)
80003d3a:	873e                	mv	a4,a5
80003d3c:	fdc42783          	lw	a5,-36(s0)
80003d40:	97ba                	add	a5,a5,a4
80003d42:	0ff6f713          	zext.b	a4,a3
80003d46:	00e78023          	sb	a4,0(a5)
	return i;
80003d4a:	fee45783          	lhu	a5,-18(s0)
}
80003d4e:	853e                	mv	a0,a5
80003d50:	5432                	lw	s0,44(sp)
80003d52:	6145                	addi	sp,sp,48
80003d54:	8082                	ret

80003d56 <osdp_build_crc_and_send>:

// Универсальное завершение кадра: добавить CRC и отправить
static void osdp_build_crc_and_send(uint8_t *tx, uint16_t dlen)
{
80003d56:	7179                	addi	sp,sp,-48
80003d58:	d606                	sw	ra,44(sp)
80003d5a:	d422                	sw	s0,40(sp)
80003d5c:	1800                	addi	s0,sp,48
80003d5e:	fca42e23          	sw	a0,-36(s0)
80003d62:	87ae                	mv	a5,a1
80003d64:	fcf41d23          	sh	a5,-38(s0)
	uint16_t crc = ccitt_crc16_calc(OSDP_INIT_CRC16, tx, dlen);
80003d68:	fda45783          	lhu	a5,-38(s0)
80003d6c:	863e                	mv	a2,a5
80003d6e:	fdc42583          	lw	a1,-36(s0)
80003d72:	6789                	lui	a5,0x2
80003d74:	d0f78513          	addi	a0,a5,-753 # 1d0f <STACK_SIZE+0x150f>
80003d78:	c61ff0ef          	jal	ra,800039d8 <ccitt_crc16_calc>
80003d7c:	87aa                	mv	a5,a0
80003d7e:	fef41723          	sh	a5,-18(s0)
	tx[dlen++] = (uint8_t)(crc & 0xFF);
80003d82:	fda45783          	lhu	a5,-38(s0)
80003d86:	00178713          	addi	a4,a5,1
80003d8a:	fce41d23          	sh	a4,-38(s0)
80003d8e:	873e                	mv	a4,a5
80003d90:	fdc42783          	lw	a5,-36(s0)
80003d94:	97ba                	add	a5,a5,a4
80003d96:	fee45703          	lhu	a4,-18(s0)
80003d9a:	0ff77713          	zext.b	a4,a4
80003d9e:	00e78023          	sb	a4,0(a5)
	tx[dlen++] = (uint8_t)((crc >> 8) & 0xFF);
80003da2:	fee45783          	lhu	a5,-18(s0)
80003da6:	83a1                	srli	a5,a5,0x8
80003da8:	01079693          	slli	a3,a5,0x10
80003dac:	82c1                	srli	a3,a3,0x10
80003dae:	fda45783          	lhu	a5,-38(s0)
80003db2:	00178713          	addi	a4,a5,1
80003db6:	fce41d23          	sh	a4,-38(s0)
80003dba:	873e                	mv	a4,a5
80003dbc:	fdc42783          	lw	a5,-36(s0)
80003dc0:	97ba                	add	a5,a5,a4
80003dc2:	0ff6f713          	zext.b	a4,a3
80003dc6:	00e78023          	sb	a4,0(a5)
	osdp_send_blocking(tx, dlen);
80003dca:	fda45783          	lhu	a5,-38(s0)
80003dce:	85be                	mv	a1,a5
80003dd0:	fdc42503          	lw	a0,-36(s0)
80003dd4:	3d0d                	jal	80003c06 <osdp_send_blocking>
}
80003dd6:	0001                	nop
80003dd8:	50b2                	lw	ra,44(sp)
80003dda:	5422                	lw	s0,40(sp)
80003ddc:	6145                	addi	sp,sp,48
80003dde:	8082                	ret

80003de0 <osdp_build_and_send_ack>:

static void osdp_build_and_send_ack(uint8_t seq)
{
80003de0:	7139                	addi	sp,sp,-64
80003de2:	de06                	sw	ra,60(sp)
80003de4:	dc22                	sw	s0,56(sp)
80003de6:	0080                	addi	s0,sp,64
80003de8:	87aa                	mv	a5,a0
80003dea:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t dlen = OSDP_HEADER_LEN; // заголовок(5) + ответ(1) + crc(2)
80003dee:	47a1                	li	a5,8
80003df0:	fef41723          	sh	a5,-18(s0)
	uint16_t i = 0;
80003df4:	fe041623          	sh	zero,-20(s0)
	// Заголовок
	i = osdp_build_header(tx, dlen, seq);
80003df8:	fcf44683          	lbu	a3,-49(s0)
80003dfc:	fee45703          	lhu	a4,-18(s0)
80003e00:	fdc40793          	addi	a5,s0,-36
80003e04:	8636                	mv	a2,a3
80003e06:	85ba                	mv	a1,a4
80003e08:	853e                	mv	a0,a5
80003e0a:	35b5                	jal	80003c76 <osdp_build_header>
80003e0c:	87aa                	mv	a5,a0
80003e0e:	fef41623          	sh	a5,-20(s0)
	// Ответ
	tx[i++] = osdp_ACK;
80003e12:	fec45783          	lhu	a5,-20(s0)
80003e16:	00178713          	addi	a4,a5,1
80003e1a:	fee41623          	sh	a4,-20(s0)
80003e1e:	17c1                	addi	a5,a5,-16
80003e20:	97a2                	add	a5,a5,s0
80003e22:	04000713          	li	a4,64
80003e26:	fee78623          	sb	a4,-20(a5)
	// CRC + отправка
	osdp_build_crc_and_send(tx, i);
80003e2a:	fec45703          	lhu	a4,-20(s0)
80003e2e:	fdc40793          	addi	a5,s0,-36
80003e32:	85ba                	mv	a1,a4
80003e34:	853e                	mv	a0,a5
80003e36:	3705                	jal	80003d56 <osdp_build_crc_and_send>
}
80003e38:	0001                	nop
80003e3a:	50f2                	lw	ra,60(sp)
80003e3c:	5462                	lw	s0,56(sp)
80003e3e:	6121                	addi	sp,sp,64
80003e40:	8082                	ret

80003e42 <osdp_build_and_send_nak>:

static void osdp_build_and_send_nak(uint8_t seq, uint8_t reason)
{
80003e42:	7139                	addi	sp,sp,-64
80003e44:	de06                	sw	ra,60(sp)
80003e46:	dc22                	sw	s0,56(sp)
80003e48:	0080                	addi	s0,sp,64
80003e4a:	87aa                	mv	a5,a0
80003e4c:	872e                	mv	a4,a1
80003e4e:	fcf407a3          	sb	a5,-49(s0)
80003e52:	87ba                	mv	a5,a4
80003e54:	fcf40723          	sb	a5,-50(s0)
	uint8_t tx[16];
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1); // +1 байт причины
80003e58:	47a5                	li	a5,9
80003e5a:	fef41723          	sh	a5,-18(s0)
	uint16_t i = 0;
80003e5e:	fe041623          	sh	zero,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80003e62:	fcf44683          	lbu	a3,-49(s0)
80003e66:	fee45703          	lhu	a4,-18(s0)
80003e6a:	fdc40793          	addi	a5,s0,-36
80003e6e:	8636                	mv	a2,a3
80003e70:	85ba                	mv	a1,a4
80003e72:	853e                	mv	a0,a5
80003e74:	3509                	jal	80003c76 <osdp_build_header>
80003e76:	87aa                	mv	a5,a0
80003e78:	fef41623          	sh	a5,-20(s0)
	tx[i++] = osdp_NAK;
80003e7c:	fec45783          	lhu	a5,-20(s0)
80003e80:	00178713          	addi	a4,a5,1
80003e84:	fee41623          	sh	a4,-20(s0)
80003e88:	17c1                	addi	a5,a5,-16
80003e8a:	97a2                	add	a5,a5,s0
80003e8c:	04100713          	li	a4,65
80003e90:	fee78623          	sb	a4,-20(a5)
	tx[i++] = reason; // причина NAK
80003e94:	fec45783          	lhu	a5,-20(s0)
80003e98:	00178713          	addi	a4,a5,1
80003e9c:	fee41623          	sh	a4,-20(s0)
80003ea0:	17c1                	addi	a5,a5,-16
80003ea2:	97a2                	add	a5,a5,s0
80003ea4:	fce44703          	lbu	a4,-50(s0)
80003ea8:	fee78623          	sb	a4,-20(a5)
	osdp_build_crc_and_send(tx, i);
80003eac:	fec45703          	lhu	a4,-20(s0)
80003eb0:	fdc40793          	addi	a5,s0,-36
80003eb4:	85ba                	mv	a1,a4
80003eb6:	853e                	mv	a0,a5
80003eb8:	3d79                	jal	80003d56 <osdp_build_crc_and_send>
}
80003eba:	0001                	nop
80003ebc:	50f2                	lw	ra,60(sp)
80003ebe:	5462                	lw	s0,56(sp)
80003ec0:	6121                	addi	sp,sp,64
80003ec2:	8082                	ret

80003ec4 <osdp_build_and_send_pdid>:

static void osdp_build_and_send_pdid(uint8_t seq)
{
80003ec4:	7159                	addi	sp,sp,-112
80003ec6:	d686                	sw	ra,108(sp)
80003ec8:	d4a2                	sw	s0,104(sp)
80003eca:	1880                	addi	s0,sp,112
80003ecc:	87aa                	mv	a5,a0
80003ece:	f8f40fa3          	sb	a5,-97(s0)
	uint8_t tx[64];
	uint16_t i = 0;
80003ed2:	fe041723          	sh	zero,-18(s0)
	uint8_t pdid[12] = {
80003ed6:	015357b7          	lui	a5,0x1535
80003eda:	25078793          	addi	a5,a5,592 # 1535250 <STACK_SIZE+0x1534a50>
80003ede:	faf42023          	sw	a5,-96(s0)
80003ee2:	10100793          	li	a5,257
80003ee6:	faf42223          	sw	a5,-92(s0)
80003eea:	010107b7          	lui	a5,0x1010
80003eee:	10078793          	addi	a5,a5,256 # 1010100 <STACK_SIZE+0x100f900>
80003ef2:	faf42423          	sw	a5,-88(s0)
		1,                       // модель
		1,                       // версия
		0x01,0x00,0x00,0x00,     // серийный
		1,1,1                    
	};
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + sizeof(pdid));
80003ef6:	47d1                	li	a5,20
80003ef8:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80003efc:	f9f44683          	lbu	a3,-97(s0)
80003f00:	fec45703          	lhu	a4,-20(s0)
80003f04:	fac40793          	addi	a5,s0,-84
80003f08:	8636                	mv	a2,a3
80003f0a:	85ba                	mv	a1,a4
80003f0c:	853e                	mv	a0,a5
80003f0e:	33a5                	jal	80003c76 <osdp_build_header>
80003f10:	87aa                	mv	a5,a0
80003f12:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_PDID;
80003f16:	fee45783          	lhu	a5,-18(s0)
80003f1a:	00178713          	addi	a4,a5,1
80003f1e:	fee41723          	sh	a4,-18(s0)
80003f22:	17c1                	addi	a5,a5,-16
80003f24:	97a2                	add	a5,a5,s0
80003f26:	04500713          	li	a4,69
80003f2a:	fae78e23          	sb	a4,-68(a5)
	memcpy(&tx[i], pdid, sizeof(pdid));             // копируем данные в буфер начиная с позиции i, т.е. после заголовка и ctrl
80003f2e:	fee45783          	lhu	a5,-18(s0)
80003f32:	fac40713          	addi	a4,s0,-84
80003f36:	97ba                	add	a5,a5,a4
80003f38:	fa044703          	lbu	a4,-96(s0)
80003f3c:	8fba                	mv	t6,a4
80003f3e:	fa144703          	lbu	a4,-95(s0)
80003f42:	8f3a                	mv	t5,a4
80003f44:	fa244703          	lbu	a4,-94(s0)
80003f48:	8eba                	mv	t4,a4
80003f4a:	fa344703          	lbu	a4,-93(s0)
80003f4e:	8e3a                	mv	t3,a4
80003f50:	fa444703          	lbu	a4,-92(s0)
80003f54:	833a                	mv	t1,a4
80003f56:	fa544703          	lbu	a4,-91(s0)
80003f5a:	88ba                	mv	a7,a4
80003f5c:	fa644703          	lbu	a4,-90(s0)
80003f60:	883a                	mv	a6,a4
80003f62:	fa744703          	lbu	a4,-89(s0)
80003f66:	853a                	mv	a0,a4
80003f68:	fa844703          	lbu	a4,-88(s0)
80003f6c:	85ba                	mv	a1,a4
80003f6e:	fa944703          	lbu	a4,-87(s0)
80003f72:	863a                	mv	a2,a4
80003f74:	faa44703          	lbu	a4,-86(s0)
80003f78:	86ba                	mv	a3,a4
80003f7a:	fab44703          	lbu	a4,-85(s0)
80003f7e:	01f78023          	sb	t6,0(a5)
80003f82:	01e780a3          	sb	t5,1(a5)
80003f86:	01d78123          	sb	t4,2(a5)
80003f8a:	01c781a3          	sb	t3,3(a5)
80003f8e:	00678223          	sb	t1,4(a5)
80003f92:	011782a3          	sb	a7,5(a5)
80003f96:	01078323          	sb	a6,6(a5)
80003f9a:	00a783a3          	sb	a0,7(a5)
80003f9e:	00b78423          	sb	a1,8(a5)
80003fa2:	00c784a3          	sb	a2,9(a5)
80003fa6:	00d78523          	sb	a3,10(a5)
80003faa:	00e785a3          	sb	a4,11(a5)
	i += (uint16_t)sizeof(pdid);
80003fae:	fee45783          	lhu	a5,-18(s0)
80003fb2:	07b1                	addi	a5,a5,12
80003fb4:	fef41723          	sh	a5,-18(s0)
	osdp_build_crc_and_send(tx, i);
80003fb8:	fee45703          	lhu	a4,-18(s0)
80003fbc:	fac40793          	addi	a5,s0,-84
80003fc0:	85ba                	mv	a1,a4
80003fc2:	853e                	mv	a0,a5
80003fc4:	3b49                	jal	80003d56 <osdp_build_crc_and_send>
}
80003fc6:	0001                	nop
80003fc8:	50b6                	lw	ra,108(sp)
80003fca:	5426                	lw	s0,104(sp)
80003fcc:	6165                	addi	sp,sp,112
80003fce:	8082                	ret

80003fd0 <osdp_build_and_send_pdcap>:

static void osdp_build_and_send_pdcap(uint8_t seq)
{
80003fd0:	7135                	addi	sp,sp,-160
80003fd2:	cf06                	sw	ra,156(sp)
80003fd4:	cd22                	sw	s0,152(sp)
80003fd6:	1100                	addi	s0,sp,160
80003fd8:	87aa                	mv	a5,a0
80003fda:	f6f407a3          	sb	a5,-145(s0)
	uint8_t tx[64];
	uint16_t i = 0;
80003fde:	fe041723          	sh	zero,-18(s0)
	// Включены коды 0x01..0x10; неподдерживаемые помечены CL=0 и Number=0.
	uint8_t caps[] = {
80003fe2:	800097b7          	lui	a5,0x80009
80003fe6:	7bc78793          	addi	a5,a5,1980 # 800097bc <__data_source_start+0xfffffd98>
80003fea:	0007af03          	lw	t5,0(a5)
80003fee:	0047ae83          	lw	t4,4(a5)
80003ff2:	0087ae03          	lw	t3,8(a5)
80003ff6:	00c7a303          	lw	t1,12(a5)
80003ffa:	0107a883          	lw	a7,16(a5)
80003ffe:	0147a803          	lw	a6,20(a5)
80004002:	4f88                	lw	a0,24(a5)
80004004:	4fcc                	lw	a1,28(a5)
80004006:	5390                	lw	a2,32(a5)
80004008:	53d4                	lw	a3,36(a5)
8000400a:	5798                	lw	a4,40(a5)
8000400c:	57dc                	lw	a5,44(a5)
8000400e:	f7e42e23          	sw	t5,-132(s0)
80004012:	f9d42023          	sw	t4,-128(s0)
80004016:	f9c42223          	sw	t3,-124(s0)
8000401a:	f8642423          	sw	t1,-120(s0)
8000401e:	f9142623          	sw	a7,-116(s0)
80004022:	f9042823          	sw	a6,-112(s0)
80004026:	f8a42a23          	sw	a0,-108(s0)
8000402a:	f8b42c23          	sw	a1,-104(s0)
8000402e:	f8c42e23          	sw	a2,-100(s0)
80004032:	fad42023          	sw	a3,-96(s0)
80004036:	fae42223          	sw	a4,-92(s0)
8000403a:	faf42423          	sw	a5,-88(s0)
		0x0D, 0x00, 0x00, // 13 Readers: none
		0x0E, 0x00, 0x00, // 14 Biometrics: none
		0x0F, 0x00, 0x00, // 15 Secure PIN entry: not supported
		0x10, 0x01, 0x00  // 16 OSDP version: IEC 60839-11-5(почему-то не отображается в утилите osdp client)
	};
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + sizeof(caps));
8000403e:	03800793          	li	a5,56
80004042:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80004046:	f6f44683          	lbu	a3,-145(s0)
8000404a:	fec45703          	lhu	a4,-20(s0)
8000404e:	fac40793          	addi	a5,s0,-84
80004052:	8636                	mv	a2,a3
80004054:	85ba                	mv	a1,a4
80004056:	853e                	mv	a0,a5
80004058:	3939                	jal	80003c76 <osdp_build_header>
8000405a:	87aa                	mv	a5,a0
8000405c:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_PDCAP;
80004060:	fee45783          	lhu	a5,-18(s0)
80004064:	00178713          	addi	a4,a5,1
80004068:	fee41723          	sh	a4,-18(s0)
8000406c:	17c1                	addi	a5,a5,-16
8000406e:	97a2                	add	a5,a5,s0
80004070:	04600713          	li	a4,70
80004074:	fae78e23          	sb	a4,-68(a5)
	memcpy(&tx[i], caps, sizeof(caps));
80004078:	fee45783          	lhu	a5,-18(s0)
8000407c:	fac40713          	addi	a4,s0,-84
80004080:	97ba                	add	a5,a5,a4
80004082:	86be                	mv	a3,a5
80004084:	f7c40793          	addi	a5,s0,-132
80004088:	03000713          	li	a4,48
8000408c:	863a                	mv	a2,a4
8000408e:	85be                	mv	a1,a5
80004090:	8536                	mv	a0,a3
80004092:	7a7040ef          	jal	ra,80009038 <memcpy>
	i += (uint16_t)sizeof(caps);
80004096:	fee45783          	lhu	a5,-18(s0)
8000409a:	03078793          	addi	a5,a5,48
8000409e:	fef41723          	sh	a5,-18(s0)
	osdp_build_crc_and_send(tx, i);
800040a2:	fee45703          	lhu	a4,-18(s0)
800040a6:	fac40793          	addi	a5,s0,-84
800040aa:	85ba                	mv	a1,a4
800040ac:	853e                	mv	a0,a5
800040ae:	3165                	jal	80003d56 <osdp_build_crc_and_send>
}
800040b0:	0001                	nop
800040b2:	40fa                	lw	ra,156(sp)
800040b4:	446a                	lw	s0,152(sp)
800040b6:	610d                	addi	sp,sp,160
800040b8:	8082                	ret

800040ba <osdp_build_and_send_com>:

static void osdp_build_and_send_com(uint8_t seq, uint8_t new_addr, uint32_t new_baud)
{
800040ba:	715d                	addi	sp,sp,-80
800040bc:	c686                	sw	ra,76(sp)
800040be:	c4a2                	sw	s0,72(sp)
800040c0:	0880                	addi	s0,sp,80
800040c2:	87aa                	mv	a5,a0
800040c4:	872e                	mv	a4,a1
800040c6:	fac42c23          	sw	a2,-72(s0)
800040ca:	faf40fa3          	sb	a5,-65(s0)
800040ce:	87ba                	mv	a5,a4
800040d0:	faf40f23          	sb	a5,-66(s0)
	uint8_t tx[16];
	uint16_t i = 0;
800040d4:	fe041723          	sh	zero,-18(s0)
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 5); 
800040d8:	47b5                	li	a5,13
800040da:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
800040de:	fbf44683          	lbu	a3,-65(s0)
800040e2:	fec45703          	lhu	a4,-20(s0)
800040e6:	fdc40793          	addi	a5,s0,-36
800040ea:	8636                	mv	a2,a3
800040ec:	85ba                	mv	a1,a4
800040ee:	853e                	mv	a0,a5
800040f0:	3659                	jal	80003c76 <osdp_build_header>
800040f2:	87aa                	mv	a5,a0
800040f4:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_COM;
800040f8:	fee45783          	lhu	a5,-18(s0)
800040fc:	00178713          	addi	a4,a5,1
80004100:	fee41723          	sh	a4,-18(s0)
80004104:	17c1                	addi	a5,a5,-16
80004106:	97a2                	add	a5,a5,s0
80004108:	06500713          	li	a4,101
8000410c:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)(new_addr & 0x7F);
80004110:	fee45783          	lhu	a5,-18(s0)
80004114:	00178713          	addi	a4,a5,1
80004118:	fee41723          	sh	a4,-18(s0)
8000411c:	fbe44703          	lbu	a4,-66(s0)
80004120:	07f77713          	andi	a4,a4,127
80004124:	0ff77713          	zext.b	a4,a4
80004128:	17c1                	addi	a5,a5,-16
8000412a:	97a2                	add	a5,a5,s0
8000412c:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)(new_baud & 0xFF);
80004130:	fee45783          	lhu	a5,-18(s0)
80004134:	00178713          	addi	a4,a5,1
80004138:	fee41723          	sh	a4,-18(s0)
8000413c:	fb842703          	lw	a4,-72(s0)
80004140:	0ff77713          	zext.b	a4,a4
80004144:	17c1                	addi	a5,a5,-16
80004146:	97a2                	add	a5,a5,s0
80004148:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 8) & 0xFF);
8000414c:	fb842783          	lw	a5,-72(s0)
80004150:	0087d693          	srli	a3,a5,0x8
80004154:	fee45783          	lhu	a5,-18(s0)
80004158:	00178713          	addi	a4,a5,1
8000415c:	fee41723          	sh	a4,-18(s0)
80004160:	0ff6f713          	zext.b	a4,a3
80004164:	17c1                	addi	a5,a5,-16
80004166:	97a2                	add	a5,a5,s0
80004168:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 16) & 0xFF);
8000416c:	fb842783          	lw	a5,-72(s0)
80004170:	0107d693          	srli	a3,a5,0x10
80004174:	fee45783          	lhu	a5,-18(s0)
80004178:	00178713          	addi	a4,a5,1
8000417c:	fee41723          	sh	a4,-18(s0)
80004180:	0ff6f713          	zext.b	a4,a3
80004184:	17c1                	addi	a5,a5,-16
80004186:	97a2                	add	a5,a5,s0
80004188:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 24) & 0xFF);
8000418c:	fb842783          	lw	a5,-72(s0)
80004190:	0187d693          	srli	a3,a5,0x18
80004194:	fee45783          	lhu	a5,-18(s0)
80004198:	00178713          	addi	a4,a5,1
8000419c:	fee41723          	sh	a4,-18(s0)
800041a0:	0ff6f713          	zext.b	a4,a3
800041a4:	17c1                	addi	a5,a5,-16
800041a6:	97a2                	add	a5,a5,s0
800041a8:	fee78623          	sb	a4,-20(a5)
	osdp_build_crc_and_send(tx, i);
800041ac:	fee45703          	lhu	a4,-18(s0)
800041b0:	fdc40793          	addi	a5,s0,-36
800041b4:	85ba                	mv	a1,a4
800041b6:	853e                	mv	a0,a5
800041b8:	3e79                	jal	80003d56 <osdp_build_crc_and_send>

	// Сохранить новые адрес и скорость в EEPROM
	config_storage_t cfg;
	if (!config_storage_load(&cfg)) {
800041ba:	fc440793          	addi	a5,s0,-60
800041be:	853e                	mv	a0,a5
800041c0:	bf1fe0ef          	jal	ra,80002db0 <config_storage_load>
800041c4:	87aa                	mv	a5,a0
800041c6:	0017c793          	xori	a5,a5,1
800041ca:	0ff7f793          	zext.b	a5,a5
800041ce:	c791                	beqz	a5,800041da <osdp_build_and_send_com+0x120>
		config_storage_default(&cfg);
800041d0:	fc440793          	addi	a5,s0,-60
800041d4:	853e                	mv	a0,a5
800041d6:	b73fe0ef          	jal	ra,80002d48 <config_storage_default>
	}
	cfg.osdp_addr = (uint8_t)(new_addr & 0x7F);
800041da:	fbe44783          	lbu	a5,-66(s0)
800041de:	07f7f793          	andi	a5,a5,127
800041e2:	0ff7f793          	zext.b	a5,a5
800041e6:	fcf40223          	sb	a5,-60(s0)
	cfg.osdp_baud = new_baud;
800041ea:	fb842783          	lw	a5,-72(s0)
800041ee:	0ff7f793          	zext.b	a5,a5
800041f2:	fc544703          	lbu	a4,-59(s0)
800041f6:	8b01                	andi	a4,a4,0
800041f8:	8fd9                	or	a5,a5,a4
800041fa:	fcf402a3          	sb	a5,-59(s0)
800041fe:	fb842783          	lw	a5,-72(s0)
80004202:	83a1                	srli	a5,a5,0x8
80004204:	0ff7f793          	zext.b	a5,a5
80004208:	fc644703          	lbu	a4,-58(s0)
8000420c:	8b01                	andi	a4,a4,0
8000420e:	8fd9                	or	a5,a5,a4
80004210:	fcf40323          	sb	a5,-58(s0)
80004214:	fb842783          	lw	a5,-72(s0)
80004218:	83c1                	srli	a5,a5,0x10
8000421a:	0ff7f793          	zext.b	a5,a5
8000421e:	fc744703          	lbu	a4,-57(s0)
80004222:	8b01                	andi	a4,a4,0
80004224:	8fd9                	or	a5,a5,a4
80004226:	fcf403a3          	sb	a5,-57(s0)
8000422a:	fb842783          	lw	a5,-72(s0)
8000422e:	83e1                	srli	a5,a5,0x18
80004230:	fc844703          	lbu	a4,-56(s0)
80004234:	8b01                	andi	a4,a4,0
80004236:	8fd9                	or	a5,a5,a4
80004238:	fcf40423          	sb	a5,-56(s0)
	config_storage_save(&cfg);
8000423c:	fc440793          	addi	a5,s0,-60
80004240:	853e                	mv	a0,a5
80004242:	cc5fe0ef          	jal	ra,80002f06 <config_storage_save>

	// Обновить текущие значения в RAM
	g_addr = cfg.osdp_addr;
80004246:	fc444703          	lbu	a4,-60(s0)
8000424a:	e8e18a23          	sb	a4,-364(gp) # 40000614 <g_addr>
	g_baud = cfg.osdp_baud;
8000424e:	fc442783          	lw	a5,-60(s0)
80004252:	83a1                	srli	a5,a5,0x8
80004254:	fc842703          	lw	a4,-56(s0)
80004258:	0ff77713          	zext.b	a4,a4
8000425c:	0762                	slli	a4,a4,0x18
8000425e:	8fd9                	or	a5,a5,a4
80004260:	873e                	mv	a4,a5
80004262:	e8e1ac23          	sw	a4,-360(gp) # 40000618 <g_baud>
}
80004266:	0001                	nop
80004268:	40b6                	lw	ra,76(sp)
8000426a:	4426                	lw	s0,72(sp)
8000426c:	6161                	addi	sp,sp,80
8000426e:	8082                	ret

80004270 <set_led_state>:

static void set_led_state(uint8_t on)
{
80004270:	1101                	addi	sp,sp,-32
80004272:	ce06                	sw	ra,28(sp)
80004274:	cc22                	sw	s0,24(sp)
80004276:	1000                	addi	s0,sp,32
80004278:	87aa                	mv	a5,a0
8000427a:	fef407a3          	sb	a5,-17(s0)
	if (on) {
8000427e:	fef44783          	lbu	a5,-17(s0)
80004282:	c78d                	beqz	a5,800042ac <set_led_state+0x3c>
		GPIO_SetBits(GPIOA, GPIO_Pin_7);
80004284:	08000593          	li	a1,128
80004288:	28000537          	lui	a0,0x28000
8000428c:	3869                	jal	80003b26 <GPIO_SetBits>
		GPIO_SetBits(GPIOA, GPIO_Pin_6);
8000428e:	04000593          	li	a1,64
80004292:	28000537          	lui	a0,0x28000
80004296:	3841                	jal	80003b26 <GPIO_SetBits>
		GPIO_SetBits(GPIOA, GPIO_Pin_5);
80004298:	02000593          	li	a1,32
8000429c:	28000537          	lui	a0,0x28000
800042a0:	3059                	jal	80003b26 <GPIO_SetBits>
		GPIO_SetBits(GPIOA, GPIO_Pin_4);
800042a2:	45c1                	li	a1,16
800042a4:	28000537          	lui	a0,0x28000
800042a8:	38bd                	jal	80003b26 <GPIO_SetBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_7);
		GPIO_ClearBits(GPIOA, GPIO_Pin_6);
		GPIO_ClearBits(GPIOA, GPIO_Pin_5);
		GPIO_ClearBits(GPIOA, GPIO_Pin_4);
	}
}
800042aa:	a025                	j	800042d2 <set_led_state+0x62>
		GPIO_ClearBits(GPIOA, GPIO_Pin_7);
800042ac:	08000593          	li	a1,128
800042b0:	28000537          	lui	a0,0x28000
800042b4:	3849                	jal	80003b46 <GPIO_ClearBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_6);
800042b6:	04000593          	li	a1,64
800042ba:	28000537          	lui	a0,0x28000
800042be:	3061                	jal	80003b46 <GPIO_ClearBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_5);
800042c0:	02000593          	li	a1,32
800042c4:	28000537          	lui	a0,0x28000
800042c8:	38bd                	jal	80003b46 <GPIO_ClearBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_4);
800042ca:	45c1                	li	a1,16
800042cc:	28000537          	lui	a0,0x28000
800042d0:	389d                	jal	80003b46 <GPIO_ClearBits>
}
800042d2:	0001                	nop
800042d4:	40f2                	lw	ra,28(sp)
800042d6:	4462                	lw	s0,24(sp)
800042d8:	6105                	addi	sp,sp,32
800042da:	8082                	ret

800042dc <osdp_build_and_send_istat>:
} output_ctrl_t;

static output_ctrl_t output_ctrl[4]; // Состояние для 4 выходов (PA12-PA15)

static void osdp_build_and_send_istat(uint8_t seq)
{
800042dc:	7139                	addi	sp,sp,-64
800042de:	de06                	sw	ra,60(sp)
800042e0:	dc22                	sw	s0,56(sp)
800042e2:	0080                	addi	s0,sp,64
800042e4:	87aa                	mv	a5,a0
800042e6:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t i = 0;
800042ea:	fe041723          	sh	zero,-18(s0)
	// Дополнительных данных 1 байт:
	//  - бит0 = состояние входа 0 (PA0)
	//  - бит1 = состояние входа 1 (PA1)
	//  - бит2 = состояние входа 2 (PA2)
	//  - бит3 = состояние входа 3 (PA3)
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1);
800042ee:	47a5                	li	a5,9
800042f0:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
800042f4:	fcf44683          	lbu	a3,-49(s0)
800042f8:	fec45703          	lhu	a4,-20(s0)
800042fc:	fd840793          	addi	a5,s0,-40
80004300:	8636                	mv	a2,a3
80004302:	85ba                	mv	a1,a4
80004304:	853e                	mv	a0,a5
80004306:	3a85                	jal	80003c76 <osdp_build_header>
80004308:	87aa                	mv	a5,a0
8000430a:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_ISTATR;
8000430e:	fee45783          	lhu	a5,-18(s0)
80004312:	00178713          	addi	a4,a5,1
80004316:	fee41723          	sh	a4,-18(s0)
8000431a:	17c1                	addi	a5,a5,-16
8000431c:	97a2                	add	a5,a5,s0
8000431e:	04900713          	li	a4,73
80004322:	fee78423          	sb	a4,-24(a5)
	uint8_t inputs = 0;
80004326:	fe0405a3          	sb	zero,-21(s0)
	// Кнопки с PU активны уровнем 0 → инвертируем, чтобы 1 означало "замкнуто/нажато"
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_0) ? 0u : 1u) << 0; 
8000432a:	4585                	li	a1,1
8000432c:	28000537          	lui	a0,0x28000
80004330:	fccff0ef          	jal	ra,80003afc <GPIO_ReadBit>
80004334:	87aa                	mv	a5,a0
80004336:	0017b793          	seqz	a5,a5
8000433a:	0ff7f793          	zext.b	a5,a5
8000433e:	0ff7f793          	zext.b	a5,a5
80004342:	feb44703          	lbu	a4,-21(s0)
80004346:	8fd9                	or	a5,a5,a4
80004348:	fef405a3          	sb	a5,-21(s0)
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_1) ? 0u : 1u) << 1; 
8000434c:	4589                	li	a1,2
8000434e:	28000537          	lui	a0,0x28000
80004352:	faaff0ef          	jal	ra,80003afc <GPIO_ReadBit>
80004356:	87aa                	mv	a5,a0
80004358:	e399                	bnez	a5,8000435e <osdp_build_and_send_istat+0x82>
8000435a:	4789                	li	a5,2
8000435c:	a011                	j	80004360 <osdp_build_and_send_istat+0x84>
8000435e:	4781                	li	a5,0
80004360:	0ff7f793          	zext.b	a5,a5
80004364:	feb44703          	lbu	a4,-21(s0)
80004368:	8fd9                	or	a5,a5,a4
8000436a:	fef405a3          	sb	a5,-21(s0)
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_2) ? 0u : 1u) << 2; 
8000436e:	4591                	li	a1,4
80004370:	28000537          	lui	a0,0x28000
80004374:	f88ff0ef          	jal	ra,80003afc <GPIO_ReadBit>
80004378:	87aa                	mv	a5,a0
8000437a:	e399                	bnez	a5,80004380 <osdp_build_and_send_istat+0xa4>
8000437c:	4791                	li	a5,4
8000437e:	a011                	j	80004382 <osdp_build_and_send_istat+0xa6>
80004380:	4781                	li	a5,0
80004382:	0ff7f793          	zext.b	a5,a5
80004386:	feb44703          	lbu	a4,-21(s0)
8000438a:	8fd9                	or	a5,a5,a4
8000438c:	fef405a3          	sb	a5,-21(s0)
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_3) ? 0u : 1u) << 3; 
80004390:	45a1                	li	a1,8
80004392:	28000537          	lui	a0,0x28000
80004396:	f66ff0ef          	jal	ra,80003afc <GPIO_ReadBit>
8000439a:	87aa                	mv	a5,a0
8000439c:	e399                	bnez	a5,800043a2 <osdp_build_and_send_istat+0xc6>
8000439e:	47a1                	li	a5,8
800043a0:	a011                	j	800043a4 <osdp_build_and_send_istat+0xc8>
800043a2:	4781                	li	a5,0
800043a4:	0ff7f793          	zext.b	a5,a5
800043a8:	feb44703          	lbu	a4,-21(s0)
800043ac:	8fd9                	or	a5,a5,a4
800043ae:	fef405a3          	sb	a5,-21(s0)
	tx[i++] = inputs;
800043b2:	fee45783          	lhu	a5,-18(s0)
800043b6:	00178713          	addi	a4,a5,1
800043ba:	fee41723          	sh	a4,-18(s0)
800043be:	17c1                	addi	a5,a5,-16
800043c0:	97a2                	add	a5,a5,s0
800043c2:	feb44703          	lbu	a4,-21(s0)
800043c6:	fee78423          	sb	a4,-24(a5)
	osdp_build_crc_and_send(tx, i);
800043ca:	fee45703          	lhu	a4,-18(s0)
800043ce:	fd840793          	addi	a5,s0,-40
800043d2:	85ba                	mv	a1,a4
800043d4:	853e                	mv	a0,a5
800043d6:	3241                	jal	80003d56 <osdp_build_crc_and_send>
}
800043d8:	0001                	nop
800043da:	50f2                	lw	ra,60(sp)
800043dc:	5462                	lw	s0,56(sp)
800043de:	6121                	addi	sp,sp,64
800043e0:	8082                	ret

800043e2 <osdp_build_and_send_ostat>:

static void osdp_build_and_send_ostat(uint8_t seq)
{
800043e2:	7139                	addi	sp,sp,-64
800043e4:	de06                	sw	ra,60(sp)
800043e6:	dc22                	sw	s0,56(sp)
800043e8:	0080                	addi	s0,sp,64
800043ea:	87aa                	mv	a5,a0
800043ec:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t i = 0;
800043f0:	fe041723          	sh	zero,-18(s0)
	// Дополнительных данных 1 байт:

	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1);
800043f4:	47a5                	li	a5,9
800043f6:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
800043fa:	fcf44683          	lbu	a3,-49(s0)
800043fe:	fec45703          	lhu	a4,-20(s0)
80004402:	fd840793          	addi	a5,s0,-40
80004406:	8636                	mv	a2,a3
80004408:	85ba                	mv	a1,a4
8000440a:	853e                	mv	a0,a5
8000440c:	30ad                	jal	80003c76 <osdp_build_header>
8000440e:	87aa                	mv	a5,a0
80004410:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_OSTATR;
80004414:	fee45783          	lhu	a5,-18(s0)
80004418:	00178713          	addi	a4,a5,1
8000441c:	fee41723          	sh	a4,-18(s0)
80004420:	17c1                	addi	a5,a5,-16
80004422:	97a2                	add	a5,a5,s0
80004424:	04a00713          	li	a4,74
80004428:	fee78423          	sb	a4,-24(a5)
	uint8_t outputs = 0;
8000442c:	fe0405a3          	sb	zero,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_4) ? 1u : 0u) << 0; 
80004430:	45c1                	li	a1,16
80004432:	28000537          	lui	a0,0x28000
80004436:	ec6ff0ef          	jal	ra,80003afc <GPIO_ReadBit>
8000443a:	87aa                	mv	a5,a0
8000443c:	c399                	beqz	a5,80004442 <osdp_build_and_send_ostat+0x60>
8000443e:	4785                	li	a5,1
80004440:	a011                	j	80004444 <osdp_build_and_send_ostat+0x62>
80004442:	4781                	li	a5,0
80004444:	0ff7f793          	zext.b	a5,a5
80004448:	feb44703          	lbu	a4,-21(s0)
8000444c:	8fd9                	or	a5,a5,a4
8000444e:	fef405a3          	sb	a5,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_5) ? 1u : 0u) << 1; 
80004452:	02000593          	li	a1,32
80004456:	28000537          	lui	a0,0x28000
8000445a:	ea2ff0ef          	jal	ra,80003afc <GPIO_ReadBit>
8000445e:	87aa                	mv	a5,a0
80004460:	c399                	beqz	a5,80004466 <osdp_build_and_send_ostat+0x84>
80004462:	4789                	li	a5,2
80004464:	a011                	j	80004468 <osdp_build_and_send_ostat+0x86>
80004466:	4781                	li	a5,0
80004468:	0ff7f793          	zext.b	a5,a5
8000446c:	feb44703          	lbu	a4,-21(s0)
80004470:	8fd9                	or	a5,a5,a4
80004472:	fef405a3          	sb	a5,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_6) ? 1u : 0u) << 2; 
80004476:	04000593          	li	a1,64
8000447a:	28000537          	lui	a0,0x28000
8000447e:	e7eff0ef          	jal	ra,80003afc <GPIO_ReadBit>
80004482:	87aa                	mv	a5,a0
80004484:	c399                	beqz	a5,8000448a <osdp_build_and_send_ostat+0xa8>
80004486:	4791                	li	a5,4
80004488:	a011                	j	8000448c <osdp_build_and_send_ostat+0xaa>
8000448a:	4781                	li	a5,0
8000448c:	0ff7f793          	zext.b	a5,a5
80004490:	feb44703          	lbu	a4,-21(s0)
80004494:	8fd9                	or	a5,a5,a4
80004496:	fef405a3          	sb	a5,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_7) ? 1u : 0u) << 3; 
8000449a:	08000593          	li	a1,128
8000449e:	28000537          	lui	a0,0x28000
800044a2:	e5aff0ef          	jal	ra,80003afc <GPIO_ReadBit>
800044a6:	87aa                	mv	a5,a0
800044a8:	c399                	beqz	a5,800044ae <osdp_build_and_send_ostat+0xcc>
800044aa:	47a1                	li	a5,8
800044ac:	a011                	j	800044b0 <osdp_build_and_send_ostat+0xce>
800044ae:	4781                	li	a5,0
800044b0:	0ff7f793          	zext.b	a5,a5
800044b4:	feb44703          	lbu	a4,-21(s0)
800044b8:	8fd9                	or	a5,a5,a4
800044ba:	fef405a3          	sb	a5,-21(s0)
	tx[i++] = outputs;
800044be:	fee45783          	lhu	a5,-18(s0)
800044c2:	00178713          	addi	a4,a5,1
800044c6:	fee41723          	sh	a4,-18(s0)
800044ca:	17c1                	addi	a5,a5,-16
800044cc:	97a2                	add	a5,a5,s0
800044ce:	feb44703          	lbu	a4,-21(s0)
800044d2:	fee78423          	sb	a4,-24(a5)
	osdp_build_crc_and_send(tx, i);
800044d6:	fee45703          	lhu	a4,-18(s0)
800044da:	fd840793          	addi	a5,s0,-40
800044de:	85ba                	mv	a1,a4
800044e0:	853e                	mv	a0,a5
800044e2:	3895                	jal	80003d56 <osdp_build_crc_and_send>
}
800044e4:	0001                	nop
800044e6:	50f2                	lw	ra,60(sp)
800044e8:	5462                	lw	s0,56(sp)
800044ea:	6121                	addi	sp,sp,64
800044ec:	8082                	ret

800044ee <handle_osdp_out>:
//   0x03: set the permanent state to OFF, allow timed operation to complete
//   0x04: set the permanent state to ON, allow timed operation to complete
//   0x05: set the temporary state to ON, resume permanent state on timeout
//   0x06: set the temporary state to OFF, resume permanent state on timeout
static void handle_osdp_out(uint8_t *data, uint16_t data_len)
{
800044ee:	7139                	addi	sp,sp,-64
800044f0:	de06                	sw	ra,60(sp)
800044f2:	dc22                	sw	s0,56(sp)
800044f4:	0080                	addi	s0,sp,64
800044f6:	fca42623          	sw	a0,-52(s0)
800044fa:	87ae                	mv	a5,a1
800044fc:	fcf41523          	sh	a5,-54(s0)
	// Массив пинов для выходов: PA4, PA5, PA6, PA7
	const uint32_t output_pins[4] = {GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7};
80004500:	800097b7          	lui	a5,0x80009
80004504:	7ec78793          	addi	a5,a5,2028 # 800097ec <__data_source_start+0xfffffdc8>
80004508:	4390                	lw	a2,0(a5)
8000450a:	43d4                	lw	a3,4(a5)
8000450c:	4798                	lw	a4,8(a5)
8000450e:	47dc                	lw	a5,12(a5)
80004510:	fcc42823          	sw	a2,-48(s0)
80004514:	fcd42a23          	sw	a3,-44(s0)
80004518:	fce42c23          	sw	a4,-40(s0)
8000451c:	fcf42e23          	sw	a5,-36(s0)
	
	// Проверяем, что длина данных кратна 4 (стандартный формат OSDP)
	if ((data_len % 4) != 0 || data_len < 4) {
80004520:	fca45783          	lhu	a5,-54(s0)
80004524:	8b8d                	andi	a5,a5,3
80004526:	07c2                	slli	a5,a5,0x10
80004528:	83c1                	srli	a5,a5,0x10
8000452a:	38079f63          	bnez	a5,800048c8 <handle_osdp_out+0x3da>
8000452e:	fca45703          	lhu	a4,-54(s0)
80004532:	478d                	li	a5,3
80004534:	38e7fa63          	bgeu	a5,a4,800048c8 <handle_osdp_out+0x3da>
		// Неправильный формат - игнорируем
		return;
	}
	
	// Обрабатываем данные по 4 байта на каждый выход
	uint16_t count = (uint16_t)(data_len / 4u);
80004538:	fca45783          	lhu	a5,-54(s0)
8000453c:	8389                	srli	a5,a5,0x2
8000453e:	fef41623          	sh	a5,-20(s0)
	for (uint16_t i = 0; i < count; i++) {
80004542:	fe041723          	sh	zero,-18(s0)
80004546:	ae95                	j	800048ba <handle_osdp_out+0x3cc>
		uint8_t *p = &data[i * 4u];
80004548:	fee45783          	lhu	a5,-18(s0)
8000454c:	078a                	slli	a5,a5,0x2
8000454e:	fcc42703          	lw	a4,-52(s0)
80004552:	97ba                	add	a5,a5,a4
80004554:	fef42423          	sw	a5,-24(s0)
		uint8_t output_num = p[0];
80004558:	fe842783          	lw	a5,-24(s0)
8000455c:	0007c783          	lbu	a5,0(a5)
80004560:	fef403a3          	sb	a5,-25(s0)
		uint8_t control_code = p[1];
80004564:	fe842783          	lw	a5,-24(s0)
80004568:	0017c783          	lbu	a5,1(a5)
8000456c:	fef40323          	sb	a5,-26(s0)
		uint16_t timer_100ms = (uint16_t)p[2] | ((uint16_t)p[3] << 8);
80004570:	fe842783          	lw	a5,-24(s0)
80004574:	0789                	addi	a5,a5,2
80004576:	0007c783          	lbu	a5,0(a5)
8000457a:	01079713          	slli	a4,a5,0x10
8000457e:	8741                	srai	a4,a4,0x10
80004580:	fe842783          	lw	a5,-24(s0)
80004584:	078d                	addi	a5,a5,3
80004586:	0007c783          	lbu	a5,0(a5)
8000458a:	07a2                	slli	a5,a5,0x8
8000458c:	07c2                	slli	a5,a5,0x10
8000458e:	87c1                	srai	a5,a5,0x10
80004590:	8fd9                	or	a5,a5,a4
80004592:	07c2                	slli	a5,a5,0x10
80004594:	87c1                	srai	a5,a5,0x10
80004596:	fef41223          	sh	a5,-28(s0)
		
		// Проверяем, что номер выхода в допустимом диапазоне (0-3)
		if (output_num >= 4) continue;
8000459a:	fe744703          	lbu	a4,-25(s0)
8000459e:	478d                	li	a5,3
800045a0:	2ee7ef63          	bltu	a5,a4,8000489e <handle_osdp_out+0x3b0>
		
		uint32_t pin = output_pins[output_num];
800045a4:	fe744783          	lbu	a5,-25(s0)
800045a8:	078a                	slli	a5,a5,0x2
800045aa:	17c1                	addi	a5,a5,-16
800045ac:	97a2                	add	a5,a5,s0
800045ae:	fe07a783          	lw	a5,-32(a5)
800045b2:	fef42023          	sw	a5,-32(s0)
		
		// Обработка команд управления выходом согласно стандарту OSDP Table 14
		switch (control_code) {
800045b6:	fe644783          	lbu	a5,-26(s0)
800045ba:	4719                	li	a4,6
800045bc:	2ef76363          	bltu	a4,a5,800048a2 <handle_osdp_out+0x3b4>
800045c0:	00279713          	slli	a4,a5,0x2
800045c4:	800097b7          	lui	a5,0x80009
800045c8:	7fc78793          	addi	a5,a5,2044 # 800097fc <__data_source_start+0xfffffdd8>
800045cc:	97ba                	add	a5,a5,a4
800045ce:	439c                	lw	a5,0(a5)
800045d0:	8782                	jr	a5
		case 0x00: // NOP – do not alter this output
			break;
			
		case 0x01: // set the permanent state to OFF, abort timed operation (if any)
			output_ctrl[output_num].permanent_state = 0;
800045d2:	fe744703          	lbu	a4,-25(s0)
800045d6:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800045da:	87ba                	mv	a5,a4
800045dc:	0786                	slli	a5,a5,0x1
800045de:	97ba                	add	a5,a5,a4
800045e0:	078a                	slli	a5,a5,0x2
800045e2:	97b6                	add	a5,a5,a3
800045e4:	00078023          	sb	zero,0(a5)
			output_ctrl[output_num].temp_active = 0; // Прервать временную операцию
800045e8:	fe744703          	lbu	a4,-25(s0)
800045ec:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800045f0:	87ba                	mv	a5,a4
800045f2:	0786                	slli	a5,a5,0x1
800045f4:	97ba                	add	a5,a5,a4
800045f6:	078a                	slli	a5,a5,0x2
800045f8:	97b6                	add	a5,a5,a3
800045fa:	000780a3          	sb	zero,1(a5)
			output_ctrl[output_num].timer_ms_left = 0;
800045fe:	fe744703          	lbu	a4,-25(s0)
80004602:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004606:	87ba                	mv	a5,a4
80004608:	0786                	slli	a5,a5,0x1
8000460a:	97ba                	add	a5,a5,a4
8000460c:	078a                	slli	a5,a5,0x2
8000460e:	97b6                	add	a5,a5,a3
80004610:	0007a223          	sw	zero,4(a5)
			GPIO_ClearBits(GPIOA, pin);
80004614:	fe042583          	lw	a1,-32(s0)
80004618:	28000537          	lui	a0,0x28000
8000461c:	d2aff0ef          	jal	ra,80003b46 <GPIO_ClearBits>
			break;
80004620:	ac41                	j	800048b0 <handle_osdp_out+0x3c2>
			
		case 0x02: // set the permanent state to ON, abort timed operation (if any)
			output_ctrl[output_num].permanent_state = 1;
80004622:	fe744703          	lbu	a4,-25(s0)
80004626:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
8000462a:	87ba                	mv	a5,a4
8000462c:	0786                	slli	a5,a5,0x1
8000462e:	97ba                	add	a5,a5,a4
80004630:	078a                	slli	a5,a5,0x2
80004632:	97b6                	add	a5,a5,a3
80004634:	4705                	li	a4,1
80004636:	00e78023          	sb	a4,0(a5)
			output_ctrl[output_num].temp_active = 0; // Прервать временную операцию
8000463a:	fe744703          	lbu	a4,-25(s0)
8000463e:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004642:	87ba                	mv	a5,a4
80004644:	0786                	slli	a5,a5,0x1
80004646:	97ba                	add	a5,a5,a4
80004648:	078a                	slli	a5,a5,0x2
8000464a:	97b6                	add	a5,a5,a3
8000464c:	000780a3          	sb	zero,1(a5)
			output_ctrl[output_num].timer_ms_left = 0;
80004650:	fe744703          	lbu	a4,-25(s0)
80004654:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004658:	87ba                	mv	a5,a4
8000465a:	0786                	slli	a5,a5,0x1
8000465c:	97ba                	add	a5,a5,a4
8000465e:	078a                	slli	a5,a5,0x2
80004660:	97b6                	add	a5,a5,a3
80004662:	0007a223          	sw	zero,4(a5)
			GPIO_SetBits(GPIOA, pin);
80004666:	fe042583          	lw	a1,-32(s0)
8000466a:	28000537          	lui	a0,0x28000
8000466e:	cb8ff0ef          	jal	ra,80003b26 <GPIO_SetBits>
			break;
80004672:	ac3d                	j	800048b0 <handle_osdp_out+0x3c2>
			
		case 0x03: // set the permanent state to OFF, allow timed operation to complete
			output_ctrl[output_num].permanent_state = 0;
80004674:	fe744703          	lbu	a4,-25(s0)
80004678:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
8000467c:	87ba                	mv	a5,a4
8000467e:	0786                	slli	a5,a5,0x1
80004680:	97ba                	add	a5,a5,a4
80004682:	078a                	slli	a5,a5,0x2
80004684:	97b6                	add	a5,a5,a3
80004686:	00078023          	sb	zero,0(a5)
			output_ctrl[output_num].allow_completion = 1; // Разрешить завершение временной операции
8000468a:	fe744703          	lbu	a4,-25(s0)
8000468e:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004692:	87ba                	mv	a5,a4
80004694:	0786                	slli	a5,a5,0x1
80004696:	97ba                	add	a5,a5,a4
80004698:	078a                	slli	a5,a5,0x2
8000469a:	97b6                	add	a5,a5,a3
8000469c:	4705                	li	a4,1
8000469e:	00e78423          	sb	a4,8(a5)
			// Если временная операция не активна, сразу установить постоянное состояние
			if (!output_ctrl[output_num].temp_active) {
800046a2:	fe744703          	lbu	a4,-25(s0)
800046a6:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800046aa:	87ba                	mv	a5,a4
800046ac:	0786                	slli	a5,a5,0x1
800046ae:	97ba                	add	a5,a5,a4
800046b0:	078a                	slli	a5,a5,0x2
800046b2:	97b6                	add	a5,a5,a3
800046b4:	0017c783          	lbu	a5,1(a5)
800046b8:	1e079963          	bnez	a5,800048aa <handle_osdp_out+0x3bc>
				GPIO_ClearBits(GPIOA, pin);
800046bc:	fe042583          	lw	a1,-32(s0)
800046c0:	28000537          	lui	a0,0x28000
800046c4:	c82ff0ef          	jal	ra,80003b46 <GPIO_ClearBits>
			}
			break;
800046c8:	a2cd                	j	800048aa <handle_osdp_out+0x3bc>
			
		case 0x04: // set the permanent state to ON, allow timed operation to complete
			output_ctrl[output_num].permanent_state = 1;
800046ca:	fe744703          	lbu	a4,-25(s0)
800046ce:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800046d2:	87ba                	mv	a5,a4
800046d4:	0786                	slli	a5,a5,0x1
800046d6:	97ba                	add	a5,a5,a4
800046d8:	078a                	slli	a5,a5,0x2
800046da:	97b6                	add	a5,a5,a3
800046dc:	4705                	li	a4,1
800046de:	00e78023          	sb	a4,0(a5)
			output_ctrl[output_num].allow_completion = 1; // Разрешить завершение временной операции
800046e2:	fe744703          	lbu	a4,-25(s0)
800046e6:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800046ea:	87ba                	mv	a5,a4
800046ec:	0786                	slli	a5,a5,0x1
800046ee:	97ba                	add	a5,a5,a4
800046f0:	078a                	slli	a5,a5,0x2
800046f2:	97b6                	add	a5,a5,a3
800046f4:	4705                	li	a4,1
800046f6:	00e78423          	sb	a4,8(a5)
			// Если временная операция не активна, сразу установить постоянное состояние
			if (!output_ctrl[output_num].temp_active) {
800046fa:	fe744703          	lbu	a4,-25(s0)
800046fe:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004702:	87ba                	mv	a5,a4
80004704:	0786                	slli	a5,a5,0x1
80004706:	97ba                	add	a5,a5,a4
80004708:	078a                	slli	a5,a5,0x2
8000470a:	97b6                	add	a5,a5,a3
8000470c:	0017c783          	lbu	a5,1(a5)
80004710:	18079f63          	bnez	a5,800048ae <handle_osdp_out+0x3c0>
				GPIO_SetBits(GPIOA, pin);
80004714:	fe042583          	lw	a1,-32(s0)
80004718:	28000537          	lui	a0,0x28000
8000471c:	c0aff0ef          	jal	ra,80003b26 <GPIO_SetBits>
			}
			break;
80004720:	a279                	j	800048ae <handle_osdp_out+0x3c0>
			
		case 0x05: // set the temporary state to ON, resume permanent state on timeout
			output_ctrl[output_num].temp_active = 1;
80004722:	fe744703          	lbu	a4,-25(s0)
80004726:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
8000472a:	87ba                	mv	a5,a4
8000472c:	0786                	slli	a5,a5,0x1
8000472e:	97ba                	add	a5,a5,a4
80004730:	078a                	slli	a5,a5,0x2
80004732:	97b6                	add	a5,a5,a3
80004734:	4705                	li	a4,1
80004736:	00e780a3          	sb	a4,1(a5)
			output_ctrl[output_num].temp_state = 1;
8000473a:	fe744703          	lbu	a4,-25(s0)
8000473e:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004742:	87ba                	mv	a5,a4
80004744:	0786                	slli	a5,a5,0x1
80004746:	97ba                	add	a5,a5,a4
80004748:	078a                	slli	a5,a5,0x2
8000474a:	97b6                	add	a5,a5,a3
8000474c:	4705                	li	a4,1
8000474e:	00e78123          	sb	a4,2(a5)
			output_ctrl[output_num].allow_completion = 0;
80004752:	fe744703          	lbu	a4,-25(s0)
80004756:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
8000475a:	87ba                	mv	a5,a4
8000475c:	0786                	slli	a5,a5,0x1
8000475e:	97ba                	add	a5,a5,a4
80004760:	078a                	slli	a5,a5,0x2
80004762:	97b6                	add	a5,a5,a3
80004764:	00078423          	sb	zero,8(a5)
			if (timer_100ms == 0) {
80004768:	fe445783          	lhu	a5,-28(s0)
8000476c:	e7a1                	bnez	a5,800047b4 <handle_osdp_out+0x2c6>
				// Таймер = 0 означает "навсегда" - устанавливаем как постоянное состояние
				output_ctrl[output_num].permanent_state = 1;
8000476e:	fe744703          	lbu	a4,-25(s0)
80004772:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004776:	87ba                	mv	a5,a4
80004778:	0786                	slli	a5,a5,0x1
8000477a:	97ba                	add	a5,a5,a4
8000477c:	078a                	slli	a5,a5,0x2
8000477e:	97b6                	add	a5,a5,a3
80004780:	4705                	li	a4,1
80004782:	00e78023          	sb	a4,0(a5)
				output_ctrl[output_num].temp_active = 0;
80004786:	fe744703          	lbu	a4,-25(s0)
8000478a:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
8000478e:	87ba                	mv	a5,a4
80004790:	0786                	slli	a5,a5,0x1
80004792:	97ba                	add	a5,a5,a4
80004794:	078a                	slli	a5,a5,0x2
80004796:	97b6                	add	a5,a5,a3
80004798:	000780a3          	sb	zero,1(a5)
				output_ctrl[output_num].timer_ms_left = 0;
8000479c:	fe744703          	lbu	a4,-25(s0)
800047a0:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800047a4:	87ba                	mv	a5,a4
800047a6:	0786                	slli	a5,a5,0x1
800047a8:	97ba                	add	a5,a5,a4
800047aa:	078a                	slli	a5,a5,0x2
800047ac:	97b6                	add	a5,a5,a3
800047ae:	0007a223          	sw	zero,4(a5)
800047b2:	a00d                	j	800047d4 <handle_osdp_out+0x2e6>
			} else {
				output_ctrl[output_num].timer_ms_left = (uint32_t)timer_100ms * 100u; // Конвертируем в миллисекунды
800047b4:	fe445683          	lhu	a3,-28(s0)
800047b8:	fe744703          	lbu	a4,-25(s0)
800047bc:	06400793          	li	a5,100
800047c0:	02f686b3          	mul	a3,a3,a5
800047c4:	ee418613          	addi	a2,gp,-284 # 40000664 <output_ctrl>
800047c8:	87ba                	mv	a5,a4
800047ca:	0786                	slli	a5,a5,0x1
800047cc:	97ba                	add	a5,a5,a4
800047ce:	078a                	slli	a5,a5,0x2
800047d0:	97b2                	add	a5,a5,a2
800047d2:	c3d4                	sw	a3,4(a5)
			}
			GPIO_SetBits(GPIOA, pin);
800047d4:	fe042583          	lw	a1,-32(s0)
800047d8:	28000537          	lui	a0,0x28000
800047dc:	b4aff0ef          	jal	ra,80003b26 <GPIO_SetBits>
			break;
800047e0:	a8c1                	j	800048b0 <handle_osdp_out+0x3c2>
			
		case 0x06: // set the temporary state to OFF, resume permanent state on timeout
			output_ctrl[output_num].temp_active = 1;
800047e2:	fe744703          	lbu	a4,-25(s0)
800047e6:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800047ea:	87ba                	mv	a5,a4
800047ec:	0786                	slli	a5,a5,0x1
800047ee:	97ba                	add	a5,a5,a4
800047f0:	078a                	slli	a5,a5,0x2
800047f2:	97b6                	add	a5,a5,a3
800047f4:	4705                	li	a4,1
800047f6:	00e780a3          	sb	a4,1(a5)
			output_ctrl[output_num].temp_state = 0;
800047fa:	fe744703          	lbu	a4,-25(s0)
800047fe:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004802:	87ba                	mv	a5,a4
80004804:	0786                	slli	a5,a5,0x1
80004806:	97ba                	add	a5,a5,a4
80004808:	078a                	slli	a5,a5,0x2
8000480a:	97b6                	add	a5,a5,a3
8000480c:	00078123          	sb	zero,2(a5)
			output_ctrl[output_num].allow_completion = 0;
80004810:	fe744703          	lbu	a4,-25(s0)
80004814:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004818:	87ba                	mv	a5,a4
8000481a:	0786                	slli	a5,a5,0x1
8000481c:	97ba                	add	a5,a5,a4
8000481e:	078a                	slli	a5,a5,0x2
80004820:	97b6                	add	a5,a5,a3
80004822:	00078423          	sb	zero,8(a5)
			if (timer_100ms == 0) {
80004826:	fe445783          	lhu	a5,-28(s0)
8000482a:	e3b9                	bnez	a5,80004870 <handle_osdp_out+0x382>
				// Таймер = 0 означает "навсегда" - устанавливаем как постоянное состояние
				output_ctrl[output_num].permanent_state = 0;
8000482c:	fe744703          	lbu	a4,-25(s0)
80004830:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004834:	87ba                	mv	a5,a4
80004836:	0786                	slli	a5,a5,0x1
80004838:	97ba                	add	a5,a5,a4
8000483a:	078a                	slli	a5,a5,0x2
8000483c:	97b6                	add	a5,a5,a3
8000483e:	00078023          	sb	zero,0(a5)
				output_ctrl[output_num].temp_active = 0;
80004842:	fe744703          	lbu	a4,-25(s0)
80004846:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
8000484a:	87ba                	mv	a5,a4
8000484c:	0786                	slli	a5,a5,0x1
8000484e:	97ba                	add	a5,a5,a4
80004850:	078a                	slli	a5,a5,0x2
80004852:	97b6                	add	a5,a5,a3
80004854:	000780a3          	sb	zero,1(a5)
				output_ctrl[output_num].timer_ms_left = 0;
80004858:	fe744703          	lbu	a4,-25(s0)
8000485c:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004860:	87ba                	mv	a5,a4
80004862:	0786                	slli	a5,a5,0x1
80004864:	97ba                	add	a5,a5,a4
80004866:	078a                	slli	a5,a5,0x2
80004868:	97b6                	add	a5,a5,a3
8000486a:	0007a223          	sw	zero,4(a5)
8000486e:	a00d                	j	80004890 <handle_osdp_out+0x3a2>
			} else {
				output_ctrl[output_num].timer_ms_left = (uint32_t)timer_100ms * 100u; // Конвертируем в миллисекунды
80004870:	fe445683          	lhu	a3,-28(s0)
80004874:	fe744703          	lbu	a4,-25(s0)
80004878:	06400793          	li	a5,100
8000487c:	02f686b3          	mul	a3,a3,a5
80004880:	ee418613          	addi	a2,gp,-284 # 40000664 <output_ctrl>
80004884:	87ba                	mv	a5,a4
80004886:	0786                	slli	a5,a5,0x1
80004888:	97ba                	add	a5,a5,a4
8000488a:	078a                	slli	a5,a5,0x2
8000488c:	97b2                	add	a5,a5,a2
8000488e:	c3d4                	sw	a3,4(a5)
			}
			GPIO_ClearBits(GPIOA, pin);
80004890:	fe042583          	lw	a1,-32(s0)
80004894:	28000537          	lui	a0,0x28000
80004898:	aaeff0ef          	jal	ra,80003b46 <GPIO_ClearBits>
			break;
8000489c:	a811                	j	800048b0 <handle_osdp_out+0x3c2>
		if (output_num >= 4) continue;
8000489e:	0001                	nop
800048a0:	a801                	j	800048b0 <handle_osdp_out+0x3c2>
			
		default:
			// Неизвестный код управления - игнорируем согласно стандарту
			break;
800048a2:	0001                	nop
800048a4:	a031                	j	800048b0 <handle_osdp_out+0x3c2>
			break;
800048a6:	0001                	nop
800048a8:	a021                	j	800048b0 <handle_osdp_out+0x3c2>
			break;
800048aa:	0001                	nop
800048ac:	a011                	j	800048b0 <handle_osdp_out+0x3c2>
			break;
800048ae:	0001                	nop
	for (uint16_t i = 0; i < count; i++) {
800048b0:	fee45783          	lhu	a5,-18(s0)
800048b4:	0785                	addi	a5,a5,1
800048b6:	fef41723          	sh	a5,-18(s0)
800048ba:	fee45703          	lhu	a4,-18(s0)
800048be:	fec45783          	lhu	a5,-20(s0)
800048c2:	c8f763e3          	bltu	a4,a5,80004548 <handle_osdp_out+0x5a>
800048c6:	a011                	j	800048ca <handle_osdp_out+0x3dc>
		return;
800048c8:	0001                	nop
		}
	}
}
800048ca:	50f2                	lw	ra,60(sp)
800048cc:	5462                	lw	s0,56(sp)
800048ce:	6121                	addi	sp,sp,64
800048d0:	8082                	ret

800048d2 <set_uart_baud>:

static void set_uart_baud(uint32_t baud)
{
800048d2:	7139                	addi	sp,sp,-64
800048d4:	de22                	sw	s0,60(sp)
800048d6:	0080                	addi	s0,sp,64
800048d8:	fca42623          	sw	a0,-52(s0)
	// Настроить делители UART4 по формуле из UART4_init()
	// Предполагаем источник тактирования HSE, как в init
	uint32_t baud_icoef = HSECLK_VAL / (16u * baud);
800048dc:	fcc42783          	lw	a5,-52(s0)
800048e0:	0792                	slli	a5,a5,0x4
800048e2:	00f42737          	lui	a4,0xf42
800048e6:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
800048ea:	02f757b3          	divu	a5,a4,a5
800048ee:	fef42623          	sw	a5,-20(s0)
	float    f = (float)HSECLK_VAL / (16.0f * (float)baud) - (float)baud_icoef;
800048f2:	fcc42783          	lw	a5,-52(s0)
800048f6:	d017f753          	fcvt.s.wu	fa4,a5
800048fa:	8000a7b7          	lui	a5,0x8000a
800048fe:	8b07a787          	flw	fa5,-1872(a5) # 800098b0 <__data_source_start+0xfffffe8c>
80004902:	10f777d3          	fmul.s	fa5,fa4,fa5
80004906:	8000a7b7          	lui	a5,0x8000a
8000490a:	8b47a707          	flw	fa4,-1868(a5) # 800098b4 <__data_source_start+0xfffffe90>
8000490e:	18f77753          	fdiv.s	fa4,fa4,fa5
80004912:	fec42783          	lw	a5,-20(s0)
80004916:	d017f7d3          	fcvt.s.wu	fa5,a5
8000491a:	08f777d3          	fsub.s	fa5,fa4,fa5
8000491e:	fef42427          	fsw	fa5,-24(s0)
	uint32_t baud_fcoef = (uint32_t)(f * 64.0f + 0.5f);
80004922:	fe842707          	flw	fa4,-24(s0)
80004926:	8000a7b7          	lui	a5,0x8000a
8000492a:	8b87a787          	flw	fa5,-1864(a5) # 800098b8 <__data_source_start+0xfffffe94>
8000492e:	10f77753          	fmul.s	fa4,fa4,fa5
80004932:	8000a7b7          	lui	a5,0x8000a
80004936:	8bc7a787          	flw	fa5,-1860(a5) # 800098bc <__data_source_start+0xfffffe98>
8000493a:	00f777d3          	fadd.s	fa5,fa4,fa5
8000493e:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80004942:	fef42223          	sw	a5,-28(s0)
	uint32_t cr_saved   = UART4->CR;
80004946:	3000a7b7          	lui	a5,0x3000a
8000494a:	5b9c                	lw	a5,48(a5)
8000494c:	fef42023          	sw	a5,-32(s0)
	uint32_t lcrh_saved = UART4->LCRH;
80004950:	3000a7b7          	lui	a5,0x3000a
80004954:	57dc                	lw	a5,44(a5)
80004956:	fcf42e23          	sw	a5,-36(s0)
	uint32_t imsc_saved = UART4->IMSC;
8000495a:	3000a7b7          	lui	a5,0x3000a
8000495e:	5f9c                	lw	a5,56(a5)
80004960:	fcf42c23          	sw	a5,-40(s0)
	// Дождаться окончания текущей передачи/приёма, чтобы не обрывать ответ
	while (UART4->FR_bit.BUSY) { }
80004964:	0001                	nop
80004966:	3000a7b7          	lui	a5,0x3000a
8000496a:	4f9c                	lw	a5,24(a5)
8000496c:	838d                	srli	a5,a5,0x3
8000496e:	8b85                	andi	a5,a5,1
80004970:	0ff7f793          	zext.b	a5,a5
80004974:	fbed                	bnez	a5,80004966 <set_uart_baud+0x94>
	// Остановить UART
	UART4->CR = 0;
80004976:	3000a7b7          	lui	a5,0x3000a
8000497a:	0207a823          	sw	zero,48(a5) # 3000a030 <STACK_SIZE+0x30009830>
	UART4->IBRD = baud_icoef;
8000497e:	3000a7b7          	lui	a5,0x3000a
80004982:	fec42703          	lw	a4,-20(s0)
80004986:	d3d8                	sw	a4,36(a5)
	UART4->FBRD = baud_fcoef;
80004988:	3000a7b7          	lui	a5,0x3000a
8000498c:	fe442703          	lw	a4,-28(s0)
80004990:	d798                	sw	a4,40(a5)
	// Перезаписать формат кадра и включить FIFO как в init (8N1, FIFO EN)
	UART4->LCRH = UART_LCRH_FEN_Msk | (3u << UART_LCRH_WLEN_Pos);
80004992:	3000a7b7          	lui	a5,0x3000a
80004996:	07000713          	li	a4,112
8000499a:	d7d8                	sw	a4,44(a5)
	// Очистить все флаги прерываний
	UART4->ICR = 0x7FF;
8000499c:	3000a7b7          	lui	a5,0x3000a
800049a0:	7ff00713          	li	a4,2047
800049a4:	c3f8                	sw	a4,68(a5)
	while (!UART4->FR_bit.RXFE) { (void)UART4->DR_bit.DATA; }
800049a6:	a029                	j	800049b0 <set_uart_baud+0xde>
800049a8:	3000a7b7          	lui	a5,0x3000a
800049ac:	0007c783          	lbu	a5,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
800049b0:	3000a7b7          	lui	a5,0x3000a
800049b4:	4f9c                	lw	a5,24(a5)
800049b6:	8391                	srli	a5,a5,0x4
800049b8:	8b85                	andi	a5,a5,1
800049ba:	0ff7f793          	zext.b	a5,a5
800049be:	d7ed                	beqz	a5,800049a8 <set_uart_baud+0xd6>
	// Восстановить маску прерываний (на случай, если аппаратно сбросилась)
	UART4->IMSC = imsc_saved;
800049c0:	3000a7b7          	lui	a5,0x3000a
800049c4:	fd842703          	lw	a4,-40(s0)
800049c8:	df98                	sw	a4,56(a5)
	// Включить обратно (TX, RX, UARTEN)
	UART4->CR = cr_saved | UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
800049ca:	3000a7b7          	lui	a5,0x3000a
800049ce:	fe042703          	lw	a4,-32(s0)
800049d2:	30176713          	ori	a4,a4,769
800049d6:	db98                	sw	a4,48(a5)
}
800049d8:	0001                	nop
800049da:	5472                	lw	s0,60(sp)
800049dc:	6121                	addi	sp,sp,64
800049de:	8082                	ret

800049e0 <osdp_tick_1ms>:
} led_ctrl_t;

static led_ctrl_t led_ctrl;

void osdp_tick_1ms(void) // вызывается каждую мс из main.c
{
800049e0:	7179                	addi	sp,sp,-48
800049e2:	d606                	sw	ra,44(sp)
800049e4:	d422                	sw	s0,40(sp)
800049e6:	1800                	addi	s0,sp,48
	// Обработка таймеров выходов OSDP
	const uint32_t output_pins[4] = {GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7};
800049e8:	800097b7          	lui	a5,0x80009
800049ec:	7ec78793          	addi	a5,a5,2028 # 800097ec <__data_source_start+0xfffffdc8>
800049f0:	4390                	lw	a2,0(a5)
800049f2:	43d4                	lw	a3,4(a5)
800049f4:	4798                	lw	a4,8(a5)
800049f6:	47dc                	lw	a5,12(a5)
800049f8:	fcc42e23          	sw	a2,-36(s0)
800049fc:	fed42023          	sw	a3,-32(s0)
80004a00:	fee42223          	sw	a4,-28(s0)
80004a04:	fef42423          	sw	a5,-24(s0)
	for (uint8_t i = 0; i < 4; i++) {
80004a08:	fe0407a3          	sb	zero,-17(s0)
80004a0c:	a8e1                	j	80004ae4 <osdp_tick_1ms+0x104>
		if (output_ctrl[i].temp_active && output_ctrl[i].timer_ms_left > 0) {
80004a0e:	fef44703          	lbu	a4,-17(s0)
80004a12:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004a16:	87ba                	mv	a5,a4
80004a18:	0786                	slli	a5,a5,0x1
80004a1a:	97ba                	add	a5,a5,a4
80004a1c:	078a                	slli	a5,a5,0x2
80004a1e:	97b6                	add	a5,a5,a3
80004a20:	0017c783          	lbu	a5,1(a5)
80004a24:	cbdd                	beqz	a5,80004ada <osdp_tick_1ms+0xfa>
80004a26:	fef44703          	lbu	a4,-17(s0)
80004a2a:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004a2e:	87ba                	mv	a5,a4
80004a30:	0786                	slli	a5,a5,0x1
80004a32:	97ba                	add	a5,a5,a4
80004a34:	078a                	slli	a5,a5,0x2
80004a36:	97b6                	add	a5,a5,a3
80004a38:	43dc                	lw	a5,4(a5)
80004a3a:	c3c5                	beqz	a5,80004ada <osdp_tick_1ms+0xfa>
			--output_ctrl[i].timer_ms_left;
80004a3c:	fef44703          	lbu	a4,-17(s0)
80004a40:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004a44:	87ba                	mv	a5,a4
80004a46:	0786                	slli	a5,a5,0x1
80004a48:	97ba                	add	a5,a5,a4
80004a4a:	078a                	slli	a5,a5,0x2
80004a4c:	97b6                	add	a5,a5,a3
80004a4e:	43dc                	lw	a5,4(a5)
80004a50:	fff78693          	addi	a3,a5,-1
80004a54:	ee418613          	addi	a2,gp,-284 # 40000664 <output_ctrl>
80004a58:	87ba                	mv	a5,a4
80004a5a:	0786                	slli	a5,a5,0x1
80004a5c:	97ba                	add	a5,a5,a4
80004a5e:	078a                	slli	a5,a5,0x2
80004a60:	97b2                	add	a5,a5,a2
80004a62:	c3d4                	sw	a3,4(a5)
			if (output_ctrl[i].timer_ms_left == 0) {
80004a64:	fef44703          	lbu	a4,-17(s0)
80004a68:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004a6c:	87ba                	mv	a5,a4
80004a6e:	0786                	slli	a5,a5,0x1
80004a70:	97ba                	add	a5,a5,a4
80004a72:	078a                	slli	a5,a5,0x2
80004a74:	97b6                	add	a5,a5,a3
80004a76:	43dc                	lw	a5,4(a5)
80004a78:	e3ad                	bnez	a5,80004ada <osdp_tick_1ms+0xfa>
				// Таймер истек - возвращаем постоянное состояние
				output_ctrl[i].temp_active = 0;
80004a7a:	fef44703          	lbu	a4,-17(s0)
80004a7e:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004a82:	87ba                	mv	a5,a4
80004a84:	0786                	slli	a5,a5,0x1
80004a86:	97ba                	add	a5,a5,a4
80004a88:	078a                	slli	a5,a5,0x2
80004a8a:	97b6                	add	a5,a5,a3
80004a8c:	000780a3          	sb	zero,1(a5)
				if (output_ctrl[i].permanent_state) {
80004a90:	fef44703          	lbu	a4,-17(s0)
80004a94:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80004a98:	87ba                	mv	a5,a4
80004a9a:	0786                	slli	a5,a5,0x1
80004a9c:	97ba                	add	a5,a5,a4
80004a9e:	078a                	slli	a5,a5,0x2
80004aa0:	97b6                	add	a5,a5,a3
80004aa2:	0007c783          	lbu	a5,0(a5)
80004aa6:	cf91                	beqz	a5,80004ac2 <osdp_tick_1ms+0xe2>
					GPIO_SetBits(GPIOA, output_pins[i]);
80004aa8:	fef44783          	lbu	a5,-17(s0)
80004aac:	078a                	slli	a5,a5,0x2
80004aae:	17c1                	addi	a5,a5,-16
80004ab0:	97a2                	add	a5,a5,s0
80004ab2:	fec7a783          	lw	a5,-20(a5)
80004ab6:	85be                	mv	a1,a5
80004ab8:	28000537          	lui	a0,0x28000
80004abc:	86aff0ef          	jal	ra,80003b26 <GPIO_SetBits>
80004ac0:	a829                	j	80004ada <osdp_tick_1ms+0xfa>
				} else {
					GPIO_ClearBits(GPIOA, output_pins[i]);
80004ac2:	fef44783          	lbu	a5,-17(s0)
80004ac6:	078a                	slli	a5,a5,0x2
80004ac8:	17c1                	addi	a5,a5,-16
80004aca:	97a2                	add	a5,a5,s0
80004acc:	fec7a783          	lw	a5,-20(a5)
80004ad0:	85be                	mv	a1,a5
80004ad2:	28000537          	lui	a0,0x28000
80004ad6:	870ff0ef          	jal	ra,80003b46 <GPIO_ClearBits>
	for (uint8_t i = 0; i < 4; i++) {
80004ada:	fef44783          	lbu	a5,-17(s0)
80004ade:	0785                	addi	a5,a5,1
80004ae0:	fef407a3          	sb	a5,-17(s0)
80004ae4:	fef44703          	lbu	a4,-17(s0)
80004ae8:	478d                	li	a5,3
80004aea:	f2e7f2e3          	bgeu	a5,a4,80004a0e <osdp_tick_1ms+0x2e>
			}
		}
	}
	
	// Обработка таймеров LED
	if (led_ctrl.phase_ms_left > 0) {
80004aee:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004af2:	4b9c                	lw	a5,16(a5)
80004af4:	cb91                	beqz	a5,80004b08 <osdp_tick_1ms+0x128>
		--led_ctrl.phase_ms_left;
80004af6:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004afa:	4b9c                	lw	a5,16(a5)
80004afc:	fff78713          	addi	a4,a5,-1
80004b00:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b04:	cb98                	sw	a4,16(a5)
80004b06:	aa85                	j	80004c76 <osdp_tick_1ms+0x296>
		return;
	}

	if (led_ctrl.temp_active) {  // проверка на профиль temp/perm
80004b08:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b0c:	0007c783          	lbu	a5,0(a5)
80004b10:	0e078a63          	beqz	a5,80004c04 <osdp_tick_1ms+0x224>
		// Управление temp профилем
		if (led_ctrl.current_state) {
80004b14:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b18:	0027c783          	lbu	a5,2(a5)
80004b1c:	c79d                	beqz	a5,80004b4a <osdp_tick_1ms+0x16a>
			// ON -> OFF
			led_ctrl.current_state = 0;
80004b1e:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b22:	00078123          	sb	zero,2(a5)
			set_led_state(led_ctrl.temp_off_color_is_on ? 1 : 0);
80004b26:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b2a:	01d7c783          	lbu	a5,29(a5)
80004b2e:	00f037b3          	snez	a5,a5
80004b32:	0ff7f793          	zext.b	a5,a5
80004b36:	853e                	mv	a0,a5
80004b38:	f38ff0ef          	jal	ra,80004270 <set_led_state>
			led_ctrl.phase_ms_left = (led_ctrl.off_ms > 0) ? led_ctrl.off_ms : 0;
80004b3c:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b40:	4798                	lw	a4,8(a5)
80004b42:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b46:	cb98                	sw	a4,16(a5)
80004b48:	a23d                	j	80004c76 <osdp_tick_1ms+0x296>
		} else {
			// OFF -> ON
			led_ctrl.current_state = 1;
80004b4a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b4e:	4705                	li	a4,1
80004b50:	00e78123          	sb	a4,2(a5)
			set_led_state(led_ctrl.temp_on_color_is_on ? 1 : 0);
80004b54:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b58:	01c7c783          	lbu	a5,28(a5)
80004b5c:	00f037b3          	snez	a5,a5
80004b60:	0ff7f793          	zext.b	a5,a5
80004b64:	853e                	mv	a0,a5
80004b66:	f0aff0ef          	jal	ra,80004270 <set_led_state>
			led_ctrl.phase_ms_left = (led_ctrl.on_ms > 0) ? led_ctrl.on_ms : 0;
80004b6a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b6e:	43d8                	lw	a4,4(a5)
80004b70:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b74:	cb98                	sw	a4,16(a5)
			// Считаем циклы по фронту включения
			if (led_ctrl.cycles_left > 0) {
80004b76:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b7a:	00c7d783          	lhu	a5,12(a5)
80004b7e:	0e078c63          	beqz	a5,80004c76 <osdp_tick_1ms+0x296>
				--led_ctrl.cycles_left;
80004b82:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b86:	00c7d783          	lhu	a5,12(a5)
80004b8a:	17fd                	addi	a5,a5,-1
80004b8c:	01079713          	slli	a4,a5,0x10
80004b90:	8341                	srli	a4,a4,0x10
80004b92:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b96:	00e79623          	sh	a4,12(a5)
				if (led_ctrl.cycles_left == 0) {
80004b9a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004b9e:	00c7d783          	lhu	a5,12(a5)
80004ba2:	0c079a63          	bnez	a5,80004c76 <osdp_tick_1ms+0x296>
					// Конец временного режима – восстановить постоянный
					led_ctrl.temp_active = 0;
80004ba6:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004baa:	00078023          	sb	zero,0(a5)
					// Запустить постоянный профиль
					if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
80004bae:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004bb2:	4bdc                	lw	a5,20(a5)
80004bb4:	cf85                	beqz	a5,80004bec <osdp_tick_1ms+0x20c>
80004bb6:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004bba:	4f9c                	lw	a5,24(a5)
80004bbc:	cb85                	beqz	a5,80004bec <osdp_tick_1ms+0x20c>
						led_ctrl.current_state = 1;
80004bbe:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004bc2:	4705                	li	a4,1
80004bc4:	00e78123          	sb	a4,2(a5)
						set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
80004bc8:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004bcc:	01e7c783          	lbu	a5,30(a5)
80004bd0:	00f037b3          	snez	a5,a5
80004bd4:	0ff7f793          	zext.b	a5,a5
80004bd8:	853e                	mv	a0,a5
80004bda:	e96ff0ef          	jal	ra,80004270 <set_led_state>
						led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
80004bde:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004be2:	4bd8                	lw	a4,20(a5)
80004be4:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004be8:	cb98                	sw	a4,16(a5)
80004bea:	a071                	j	80004c76 <osdp_tick_1ms+0x296>
					} else {
						set_led_state(led_ctrl.perm_state);
80004bec:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004bf0:	0017c783          	lbu	a5,1(a5)
80004bf4:	853e                	mv	a0,a5
80004bf6:	e7aff0ef          	jal	ra,80004270 <set_led_state>
						led_ctrl.phase_ms_left = 0;
80004bfa:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004bfe:	0007a823          	sw	zero,16(a5)
80004c02:	a895                	j	80004c76 <osdp_tick_1ms+0x296>
				}
			}
		}
	} else {
		// Постоянный профиль: мигание, если задано perm_on/off
		if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
80004c04:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c08:	4bdc                	lw	a5,20(a5)
80004c0a:	c7b5                	beqz	a5,80004c76 <osdp_tick_1ms+0x296>
80004c0c:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c10:	4f9c                	lw	a5,24(a5)
80004c12:	c3b5                	beqz	a5,80004c76 <osdp_tick_1ms+0x296>
			if (led_ctrl.current_state) {
80004c14:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c18:	0027c783          	lbu	a5,2(a5)
80004c1c:	c79d                	beqz	a5,80004c4a <osdp_tick_1ms+0x26a>
				led_ctrl.current_state = 0;
80004c1e:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c22:	00078123          	sb	zero,2(a5)
				set_led_state(led_ctrl.perm_off_color_is_on ? 1 : 0);
80004c26:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c2a:	01f7c783          	lbu	a5,31(a5)
80004c2e:	00f037b3          	snez	a5,a5
80004c32:	0ff7f793          	zext.b	a5,a5
80004c36:	853e                	mv	a0,a5
80004c38:	e38ff0ef          	jal	ra,80004270 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_off_ms;
80004c3c:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c40:	4f98                	lw	a4,24(a5)
80004c42:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c46:	cb98                	sw	a4,16(a5)
80004c48:	a03d                	j	80004c76 <osdp_tick_1ms+0x296>
			} else {
				led_ctrl.current_state = 1;
80004c4a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c4e:	4705                	li	a4,1
80004c50:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
80004c54:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c58:	01e7c783          	lbu	a5,30(a5)
80004c5c:	00f037b3          	snez	a5,a5
80004c60:	0ff7f793          	zext.b	a5,a5
80004c64:	853e                	mv	a0,a5
80004c66:	e0aff0ef          	jal	ra,80004270 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
80004c6a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c6e:	4bd8                	lw	a4,20(a5)
80004c70:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004c74:	cb98                	sw	a4,16(a5)
			}
		}
	}
}
80004c76:	50b2                	lw	ra,44(sp)
80004c78:	5422                	lw	s0,40(sp)
80004c7a:	6145                	addi	sp,sp,48
80004c7c:	8082                	ret

80004c7e <handle_osdp_led>:

static void handle_osdp_led(uint8_t *data, uint16_t data_len)
{
80004c7e:	711d                	addi	sp,sp,-96
80004c80:	ce86                	sw	ra,92(sp)
80004c82:	cca2                	sw	s0,88(sp)
80004c84:	1080                	addi	s0,sp,96
80004c86:	faa42623          	sw	a0,-84(s0)
80004c8a:	87ae                	mv	a5,a1
80004c8c:	faf41523          	sh	a5,-86(s0)
	// Стандартный формат: 14 байт на одну запись (Temporary+Permanent)
	// Temporary: code, on, off, on_color, off_color, timerLSB, timerMSB
	// Permanent: code, on, off, on_color, off_color
	if (data_len < 14) return;
80004c90:	faa45703          	lhu	a4,-86(s0)
80004c94:	47b5                	li	a5,13
80004c96:	3ee7f363          	bgeu	a5,a4,8000507c <handle_osdp_led+0x3fe>
	uint16_t count = (uint16_t)(data_len / 14u);
80004c9a:	faa45703          	lhu	a4,-86(s0)
80004c9e:	47b9                	li	a5,14
80004ca0:	02f757b3          	divu	a5,a4,a5
80004ca4:	fef41123          	sh	a5,-30(s0)
	for (uint16_t rec = 0; rec < count; rec++) {     // rec - запись
80004ca8:	fe041723          	sh	zero,-18(s0)
80004cac:	a6c9                	j	8000506e <handle_osdp_led+0x3f0>
		uint8_t *p = &data[rec * 14u];
80004cae:	fee45703          	lhu	a4,-18(s0)
80004cb2:	87ba                	mv	a5,a4
80004cb4:	078e                	slli	a5,a5,0x3
80004cb6:	8f99                	sub	a5,a5,a4
80004cb8:	0786                	slli	a5,a5,0x1
80004cba:	873e                	mv	a4,a5
80004cbc:	fac42783          	lw	a5,-84(s0)
80004cc0:	97ba                	add	a5,a5,a4
80004cc2:	fcf42e23          	sw	a5,-36(s0)
		uint8_t reader = p[0];
80004cc6:	fdc42783          	lw	a5,-36(s0)
80004cca:	0007c783          	lbu	a5,0(a5)
80004cce:	fcf40da3          	sb	a5,-37(s0)
		uint8_t lednum  = p[1];
80004cd2:	fdc42783          	lw	a5,-36(s0)
80004cd6:	0017c783          	lbu	a5,1(a5)
80004cda:	fcf40d23          	sb	a5,-38(s0)
		if (!(reader == 0 && lednum == 0)) continue; // у нас пока один LED: reader0, led0
80004cde:	fdb44783          	lbu	a5,-37(s0)
80004ce2:	38079063          	bnez	a5,80005062 <handle_osdp_led+0x3e4>
80004ce6:	fda44783          	lbu	a5,-38(s0)
80004cea:	36079c63          	bnez	a5,80005062 <handle_osdp_led+0x3e4>

		uint8_t tcode  = p[2];  // 0 - NOP, 1 - cancel, 2 - start now
80004cee:	fdc42783          	lw	a5,-36(s0)
80004cf2:	0027c783          	lbu	a5,2(a5)
80004cf6:	fcf40ca3          	sb	a5,-39(s0)
		uint8_t tOn100ms = p[3];
80004cfa:	fdc42783          	lw	a5,-36(s0)
80004cfe:	0037c783          	lbu	a5,3(a5)
80004d02:	fcf40c23          	sb	a5,-40(s0)
		uint8_t tOff100ms = p[4];
80004d06:	fdc42783          	lw	a5,-36(s0)
80004d0a:	0047c783          	lbu	a5,4(a5)
80004d0e:	fcf40ba3          	sb	a5,-41(s0)
		uint8_t tOnColor  = p[5];
80004d12:	fdc42783          	lw	a5,-36(s0)
80004d16:	0057c783          	lbu	a5,5(a5)
80004d1a:	fcf40b23          	sb	a5,-42(s0)
		uint8_t tOffColor = p[6];
80004d1e:	fdc42783          	lw	a5,-36(s0)
80004d22:	0067c783          	lbu	a5,6(a5)
80004d26:	fcf40aa3          	sb	a5,-43(s0)
		uint16_t timer100ms = (uint16_t)p[7] | ((uint16_t)p[8] << 8);
80004d2a:	fdc42783          	lw	a5,-36(s0)
80004d2e:	079d                	addi	a5,a5,7
80004d30:	0007c783          	lbu	a5,0(a5)
80004d34:	01079713          	slli	a4,a5,0x10
80004d38:	8741                	srai	a4,a4,0x10
80004d3a:	fdc42783          	lw	a5,-36(s0)
80004d3e:	07a1                	addi	a5,a5,8
80004d40:	0007c783          	lbu	a5,0(a5)
80004d44:	07a2                	slli	a5,a5,0x8
80004d46:	07c2                	slli	a5,a5,0x10
80004d48:	87c1                	srai	a5,a5,0x10
80004d4a:	8fd9                	or	a5,a5,a4
80004d4c:	07c2                	slli	a5,a5,0x10
80004d4e:	87c1                	srai	a5,a5,0x10
80004d50:	fcf41923          	sh	a5,-46(s0)

		uint8_t pcode  = p[9];  // 0 - NOP, 1 - start now
80004d54:	fdc42783          	lw	a5,-36(s0)
80004d58:	0097c783          	lbu	a5,9(a5)
80004d5c:	fcf408a3          	sb	a5,-47(s0)
		uint8_t pOn100ms = p[10];
80004d60:	fdc42783          	lw	a5,-36(s0)
80004d64:	00a7c783          	lbu	a5,10(a5)
80004d68:	fcf40823          	sb	a5,-48(s0)
		uint8_t pOff100ms= p[11];
80004d6c:	fdc42783          	lw	a5,-36(s0)
80004d70:	00b7c783          	lbu	a5,11(a5)
80004d74:	fcf407a3          	sb	a5,-49(s0)
		uint8_t pOnColor  = p[12];
80004d78:	fdc42783          	lw	a5,-36(s0)
80004d7c:	00c7c783          	lbu	a5,12(a5)
80004d80:	fcf40723          	sb	a5,-50(s0)
		uint8_t pOffColor = p[13];
80004d84:	fdc42783          	lw	a5,-36(s0)
80004d88:	00d7c783          	lbu	a5,13(a5)
80004d8c:	fcf406a3          	sb	a5,-51(s0)

		// Обновим постоянный профиль, если требуется
		if (pcode == 0x01) {
80004d90:	fd144703          	lbu	a4,-47(s0)
80004d94:	4785                	li	a5,1
80004d96:	0ef71d63          	bne	a4,a5,80004e90 <handle_osdp_led+0x212>
			uint32_t pOn_ms  = (uint32_t)pOn100ms  * 100u;
80004d9a:	fd044703          	lbu	a4,-48(s0)
80004d9e:	06400793          	li	a5,100
80004da2:	02f707b3          	mul	a5,a4,a5
80004da6:	fcf42423          	sw	a5,-56(s0)
			uint32_t pOff_ms = (uint32_t)pOff100ms * 100u;
80004daa:	fcf44703          	lbu	a4,-49(s0)
80004dae:	06400793          	li	a5,100
80004db2:	02f707b3          	mul	a5,a4,a5
80004db6:	fcf42223          	sw	a5,-60(s0)
			led_ctrl.perm_on_ms  = pOn_ms;
80004dba:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004dbe:	fc842703          	lw	a4,-56(s0)
80004dc2:	cbd8                	sw	a4,20(a5)
			led_ctrl.perm_off_ms = pOff_ms;
80004dc4:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004dc8:	fc442703          	lw	a4,-60(s0)
80004dcc:	cf98                	sw	a4,24(a5)
			led_ctrl.perm_on_color_is_on  = (pOnColor  != 0);
80004dce:	fce44783          	lbu	a5,-50(s0)
80004dd2:	00f037b3          	snez	a5,a5
80004dd6:	0ff7f793          	zext.b	a5,a5
80004dda:	873e                	mv	a4,a5
80004ddc:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004de0:	00e78f23          	sb	a4,30(a5)
			led_ctrl.perm_off_color_is_on = (pOffColor != 0);
80004de4:	fcd44783          	lbu	a5,-51(s0)
80004de8:	00f037b3          	snez	a5,a5
80004dec:	0ff7f793          	zext.b	a5,a5
80004df0:	873e                	mv	a4,a5
80004df2:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004df6:	00e78fa3          	sb	a4,31(a5)
			if (pOn_ms > 0 && pOff_ms == 0) {
80004dfa:	fc842783          	lw	a5,-56(s0)
80004dfe:	c385                	beqz	a5,80004e1e <handle_osdp_led+0x1a0>
80004e00:	fc442783          	lw	a5,-60(s0)
80004e04:	ef89                	bnez	a5,80004e1e <handle_osdp_led+0x1a0>
				led_ctrl.perm_state = (pOnColor != 0) ? 1 : 0; // цветом управляем "включённостью"
80004e06:	fce44783          	lbu	a5,-50(s0)
80004e0a:	00f037b3          	snez	a5,a5
80004e0e:	0ff7f793          	zext.b	a5,a5
80004e12:	873e                	mv	a4,a5
80004e14:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004e18:	00e780a3          	sb	a4,1(a5)
80004e1c:	a015                	j	80004e40 <handle_osdp_led+0x1c2>
			} else if (pOn_ms == 0 && pOff_ms > 0) {
80004e1e:	fc842783          	lw	a5,-56(s0)
80004e22:	ef99                	bnez	a5,80004e40 <handle_osdp_led+0x1c2>
80004e24:	fc442783          	lw	a5,-60(s0)
80004e28:	cf81                	beqz	a5,80004e40 <handle_osdp_led+0x1c2>
				led_ctrl.perm_state = (pOffColor != 0) ? 1 : 0;
80004e2a:	fcd44783          	lbu	a5,-51(s0)
80004e2e:	00f037b3          	snez	a5,a5
80004e32:	0ff7f793          	zext.b	a5,a5
80004e36:	873e                	mv	a4,a5
80004e38:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004e3c:	00e780a3          	sb	a4,1(a5)
			}
			// Если temp режима нет – применим сразу
			if (!led_ctrl.temp_active) {
80004e40:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004e44:	0007c783          	lbu	a5,0(a5)
80004e48:	e7a1                	bnez	a5,80004e90 <handle_osdp_led+0x212>
				if (pOn_ms > 0 && pOff_ms > 0) {
80004e4a:	fc842783          	lw	a5,-56(s0)
80004e4e:	cb95                	beqz	a5,80004e82 <handle_osdp_led+0x204>
80004e50:	fc442783          	lw	a5,-60(s0)
80004e54:	c79d                	beqz	a5,80004e82 <handle_osdp_led+0x204>
					led_ctrl.current_state = 1;
80004e56:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004e5a:	4705                	li	a4,1
80004e5c:	00e78123          	sb	a4,2(a5)
					set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
80004e60:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004e64:	01e7c783          	lbu	a5,30(a5)
80004e68:	00f037b3          	snez	a5,a5
80004e6c:	0ff7f793          	zext.b	a5,a5
80004e70:	853e                	mv	a0,a5
80004e72:	bfeff0ef          	jal	ra,80004270 <set_led_state>
					led_ctrl.phase_ms_left = pOn_ms;
80004e76:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004e7a:	fc842703          	lw	a4,-56(s0)
80004e7e:	cb98                	sw	a4,16(a5)
80004e80:	a801                	j	80004e90 <handle_osdp_led+0x212>
				} else {
					set_led_state(led_ctrl.perm_state);
80004e82:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004e86:	0017c783          	lbu	a5,1(a5)
80004e8a:	853e                	mv	a0,a5
80004e8c:	be4ff0ef          	jal	ra,80004270 <set_led_state>
		} else if (pcode == 0x00) {
			// Not use: NOP по стандарту — не изменяем постоянные настройки
		}

		// Temporary в соответствии со стандартом
		if (tcode == 0x00) {
80004e90:	fd944783          	lbu	a5,-39(s0)
80004e94:	1c078863          	beqz	a5,80005064 <handle_osdp_led+0x3e6>
			// NOP – не изменяем текущий временный режим
		} else if (tcode == 0x01) {
80004e98:	fd944703          	lbu	a4,-39(s0)
80004e9c:	4785                	li	a5,1
80004e9e:	06f71963          	bne	a4,a5,80004f10 <handle_osdp_led+0x292>
			// выключить temp и показать permanent немедленно
			led_ctrl.temp_active = 0;
80004ea2:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004ea6:	00078023          	sb	zero,0(a5)
			if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
80004eaa:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004eae:	4bdc                	lw	a5,20(a5)
80004eb0:	cf85                	beqz	a5,80004ee8 <handle_osdp_led+0x26a>
80004eb2:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004eb6:	4f9c                	lw	a5,24(a5)
80004eb8:	cb85                	beqz	a5,80004ee8 <handle_osdp_led+0x26a>
				led_ctrl.current_state = 1;
80004eba:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004ebe:	4705                	li	a4,1
80004ec0:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
80004ec4:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004ec8:	01e7c783          	lbu	a5,30(a5)
80004ecc:	00f037b3          	snez	a5,a5
80004ed0:	0ff7f793          	zext.b	a5,a5
80004ed4:	853e                	mv	a0,a5
80004ed6:	b9aff0ef          	jal	ra,80004270 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
80004eda:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004ede:	4bd8                	lw	a4,20(a5)
80004ee0:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004ee4:	cb98                	sw	a4,16(a5)
80004ee6:	aabd                	j	80005064 <handle_osdp_led+0x3e6>
			} else {
				led_ctrl.current_state = led_ctrl.perm_state;
80004ee8:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004eec:	0017c703          	lbu	a4,1(a5)
80004ef0:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004ef4:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_state);
80004ef8:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004efc:	0017c783          	lbu	a5,1(a5)
80004f00:	853e                	mv	a0,a5
80004f02:	b6eff0ef          	jal	ra,80004270 <set_led_state>
				led_ctrl.phase_ms_left = 0;
80004f06:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f0a:	0007a823          	sw	zero,16(a5)
80004f0e:	aa99                	j	80005064 <handle_osdp_led+0x3e6>
			}
		} else if (tcode == 0x02) {
80004f10:	fd944703          	lbu	a4,-39(s0)
80004f14:	4789                	li	a5,2
80004f16:	14f71763          	bne	a4,a5,80005064 <handle_osdp_led+0x3e6>
			// Установить временный режим немедленно и запустить таймер
			uint32_t on_ms  = (uint32_t)tOn100ms  * 100u;
80004f1a:	fd844703          	lbu	a4,-40(s0)
80004f1e:	06400793          	li	a5,100
80004f22:	02f707b3          	mul	a5,a4,a5
80004f26:	fcf42023          	sw	a5,-64(s0)
			uint32_t off_ms = (uint32_t)tOff100ms  * 100u;
80004f2a:	fd744703          	lbu	a4,-41(s0)
80004f2e:	06400793          	li	a5,100
80004f32:	02f707b3          	mul	a5,a4,a5
80004f36:	faf42e23          	sw	a5,-68(s0)
			led_ctrl.on_ms  = (on_ms  > 0) ? on_ms  : 0; //защита от отрицательных значений
80004f3a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f3e:	fc042703          	lw	a4,-64(s0)
80004f42:	c3d8                	sw	a4,4(a5)
			led_ctrl.off_ms = (off_ms > 0) ? off_ms : 0; 
80004f44:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f48:	fbc42703          	lw	a4,-68(s0)
80004f4c:	c798                	sw	a4,8(a5)
			led_ctrl.temp_on_color_is_on  = (tOnColor  != 0);
80004f4e:	fd644783          	lbu	a5,-42(s0)
80004f52:	00f037b3          	snez	a5,a5
80004f56:	0ff7f793          	zext.b	a5,a5
80004f5a:	873e                	mv	a4,a5
80004f5c:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f60:	00e78e23          	sb	a4,28(a5)
			led_ctrl.temp_off_color_is_on = (tOffColor != 0);
80004f64:	fd544783          	lbu	a5,-43(s0)
80004f68:	00f037b3          	snez	a5,a5
80004f6c:	0ff7f793          	zext.b	a5,a5
80004f70:	873e                	mv	a4,a5
80004f72:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f76:	00e78ea3          	sb	a4,29(a5)
			// Рассчитать количество циклов из таймера, если задан
			if (timer100ms == 0) {
80004f7a:	fd245783          	lhu	a5,-46(s0)
80004f7e:	e791                	bnez	a5,80004f8a <handle_osdp_led+0x30c>
				led_ctrl.cycles_left = 0; // бесконечно
80004f80:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f84:	00079623          	sh	zero,12(a5)
80004f88:	a0bd                	j	80004ff6 <handle_osdp_led+0x378>
			} else {
				uint32_t period = (led_ctrl.on_ms + led_ctrl.off_ms);
80004f8a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f8e:	43d8                	lw	a4,4(a5)
80004f90:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004f94:	479c                	lw	a5,8(a5)
80004f96:	97ba                	add	a5,a5,a4
80004f98:	fef42423          	sw	a5,-24(s0)
				if (period == 0) period = 100; // защита от деления на 0
80004f9c:	fe842783          	lw	a5,-24(s0)
80004fa0:	e789                	bnez	a5,80004faa <handle_osdp_led+0x32c>
80004fa2:	06400793          	li	a5,100
80004fa6:	fef42423          	sw	a5,-24(s0)
				uint32_t total_ms = (uint32_t)timer100ms * 100u;
80004faa:	fd245703          	lhu	a4,-46(s0)
80004fae:	06400793          	li	a5,100
80004fb2:	02f707b3          	mul	a5,a4,a5
80004fb6:	faf42c23          	sw	a5,-72(s0)
				uint32_t cycles = total_ms / period;
80004fba:	fb842703          	lw	a4,-72(s0)
80004fbe:	fe842783          	lw	a5,-24(s0)
80004fc2:	02f757b3          	divu	a5,a4,a5
80004fc6:	fef42223          	sw	a5,-28(s0)
				if (cycles == 0) cycles = 1;
80004fca:	fe442783          	lw	a5,-28(s0)
80004fce:	e781                	bnez	a5,80004fd6 <handle_osdp_led+0x358>
80004fd0:	4785                	li	a5,1
80004fd2:	fef42223          	sw	a5,-28(s0)
				led_ctrl.cycles_left = (uint16_t)((cycles > 0xFFFFu) ? 0xFFFFu : cycles);
80004fd6:	fe442703          	lw	a4,-28(s0)
80004fda:	67c1                	lui	a5,0x10
80004fdc:	00f77763          	bgeu	a4,a5,80004fea <handle_osdp_led+0x36c>
80004fe0:	fe442783          	lw	a5,-28(s0)
80004fe4:	07c2                	slli	a5,a5,0x10
80004fe6:	83c1                	srli	a5,a5,0x10
80004fe8:	a019                	j	80004fee <handle_osdp_led+0x370>
80004fea:	67c1                	lui	a5,0x10
80004fec:	17fd                	addi	a5,a5,-1 # ffff <STACK_SIZE+0xf7ff>
80004fee:	f1418713          	addi	a4,gp,-236 # 40000694 <led_ctrl>
80004ff2:	00f71623          	sh	a5,12(a4)
			}
			// Стартовая фаза – включение, если on_ms > 0, иначе – выключение
			if (led_ctrl.on_ms > 0) {
80004ff6:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80004ffa:	43dc                	lw	a5,4(a5)
80004ffc:	cb85                	beqz	a5,8000502c <handle_osdp_led+0x3ae>
				led_ctrl.current_state = 1;
80004ffe:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80005002:	4705                	li	a4,1
80005004:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.temp_on_color_is_on ? 1 : 0);
80005008:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
8000500c:	01c7c783          	lbu	a5,28(a5)
80005010:	00f037b3          	snez	a5,a5
80005014:	0ff7f793          	zext.b	a5,a5
80005018:	853e                	mv	a0,a5
8000501a:	a56ff0ef          	jal	ra,80004270 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.on_ms;
8000501e:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80005022:	43d8                	lw	a4,4(a5)
80005024:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80005028:	cb98                	sw	a4,16(a5)
8000502a:	a035                	j	80005056 <handle_osdp_led+0x3d8>
			} else {
				led_ctrl.current_state = 0;
8000502c:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80005030:	00078123          	sb	zero,2(a5)
				set_led_state(led_ctrl.temp_off_color_is_on ? 1 : 0);
80005034:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80005038:	01d7c783          	lbu	a5,29(a5)
8000503c:	00f037b3          	snez	a5,a5
80005040:	0ff7f793          	zext.b	a5,a5
80005044:	853e                	mv	a0,a5
80005046:	a2aff0ef          	jal	ra,80004270 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.off_ms;
8000504a:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
8000504e:	4798                	lw	a4,8(a5)
80005050:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
80005054:	cb98                	sw	a4,16(a5)
			}
			led_ctrl.temp_active = 1;
80005056:	f1418793          	addi	a5,gp,-236 # 40000694 <led_ctrl>
8000505a:	4705                	li	a4,1
8000505c:	00e78023          	sb	a4,0(a5)
80005060:	a011                	j	80005064 <handle_osdp_led+0x3e6>
		if (!(reader == 0 && lednum == 0)) continue; // у нас пока один LED: reader0, led0
80005062:	0001                	nop
	for (uint16_t rec = 0; rec < count; rec++) {     // rec - запись
80005064:	fee45783          	lhu	a5,-18(s0)
80005068:	0785                	addi	a5,a5,1
8000506a:	fef41723          	sh	a5,-18(s0)
8000506e:	fee45703          	lhu	a4,-18(s0)
80005072:	fe245783          	lhu	a5,-30(s0)
80005076:	c2f76ce3          	bltu	a4,a5,80004cae <handle_osdp_led+0x30>
8000507a:	a011                	j	8000507e <handle_osdp_led+0x400>
	if (data_len < 14) return;
8000507c:	0001                	nop
		}
	}
}
8000507e:	40f6                	lw	ra,92(sp)
80005080:	4466                	lw	s0,88(sp)
80005082:	6125                	addi	sp,sp,96
80005084:	8082                	ret

80005086 <osdp_init>:


void osdp_init(void)
{
80005086:	1101                	addi	sp,sp,-32
80005088:	ce06                	sw	ra,28(sp)
8000508a:	cc22                	sw	s0,24(sp)
8000508c:	1000                	addi	s0,sp,32
	osdp_load_addr_baud();
8000508e:	ad9fe0ef          	jal	ra,80003b66 <osdp_load_addr_baud>
	rx_state = st_wait_som;
80005092:	e801ae23          	sw	zero,-356(gp) # 4000061c <rx_state>
	rx_expected_len = 0;
80005096:	ea019023          	sh	zero,-352(gp) # 40000620 <rx_expected_len>
	rx_pos = 0;
8000509a:	ea019123          	sh	zero,-350(gp) # 40000622 <rx_pos>
	
	// Инициализация состояния выходов
	for (uint8_t i = 0; i < 4; i++) {
8000509e:	fe0407a3          	sb	zero,-17(s0)
800050a2:	a8ad                	j	8000511c <osdp_init+0x96>
		output_ctrl[i].permanent_state = 0; // По умолчанию все выходы выключены
800050a4:	fef44703          	lbu	a4,-17(s0)
800050a8:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800050ac:	87ba                	mv	a5,a4
800050ae:	0786                	slli	a5,a5,0x1
800050b0:	97ba                	add	a5,a5,a4
800050b2:	078a                	slli	a5,a5,0x2
800050b4:	97b6                	add	a5,a5,a3
800050b6:	00078023          	sb	zero,0(a5)
		output_ctrl[i].temp_active = 0;
800050ba:	fef44703          	lbu	a4,-17(s0)
800050be:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800050c2:	87ba                	mv	a5,a4
800050c4:	0786                	slli	a5,a5,0x1
800050c6:	97ba                	add	a5,a5,a4
800050c8:	078a                	slli	a5,a5,0x2
800050ca:	97b6                	add	a5,a5,a3
800050cc:	000780a3          	sb	zero,1(a5)
		output_ctrl[i].temp_state = 0;
800050d0:	fef44703          	lbu	a4,-17(s0)
800050d4:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800050d8:	87ba                	mv	a5,a4
800050da:	0786                	slli	a5,a5,0x1
800050dc:	97ba                	add	a5,a5,a4
800050de:	078a                	slli	a5,a5,0x2
800050e0:	97b6                	add	a5,a5,a3
800050e2:	00078123          	sb	zero,2(a5)
		output_ctrl[i].timer_ms_left = 0;
800050e6:	fef44703          	lbu	a4,-17(s0)
800050ea:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
800050ee:	87ba                	mv	a5,a4
800050f0:	0786                	slli	a5,a5,0x1
800050f2:	97ba                	add	a5,a5,a4
800050f4:	078a                	slli	a5,a5,0x2
800050f6:	97b6                	add	a5,a5,a3
800050f8:	0007a223          	sw	zero,4(a5)
		output_ctrl[i].allow_completion = 0;
800050fc:	fef44703          	lbu	a4,-17(s0)
80005100:	ee418693          	addi	a3,gp,-284 # 40000664 <output_ctrl>
80005104:	87ba                	mv	a5,a4
80005106:	0786                	slli	a5,a5,0x1
80005108:	97ba                	add	a5,a5,a4
8000510a:	078a                	slli	a5,a5,0x2
8000510c:	97b6                	add	a5,a5,a3
8000510e:	00078423          	sb	zero,8(a5)
	for (uint8_t i = 0; i < 4; i++) {
80005112:	fef44783          	lbu	a5,-17(s0)
80005116:	0785                	addi	a5,a5,1
80005118:	fef407a3          	sb	a5,-17(s0)
8000511c:	fef44703          	lbu	a4,-17(s0)
80005120:	478d                	li	a5,3
80005122:	f8e7f1e3          	bgeu	a5,a4,800050a4 <osdp_init+0x1e>
	}
}
80005126:	0001                	nop
80005128:	0001                	nop
8000512a:	40f2                	lw	ra,28(sp)
8000512c:	4462                	lw	s0,24(sp)
8000512e:	6105                	addi	sp,sp,32
80005130:	8082                	ret

80005132 <osdp_on_rx_byte>:

void osdp_on_rx_byte(uint8_t byte) // парсер входящих байтов
{
80005132:	715d                	addi	sp,sp,-80
80005134:	c686                	sw	ra,76(sp)
80005136:	c4a2                	sw	s0,72(sp)
80005138:	0880                	addi	s0,sp,80
8000513a:	87aa                	mv	a5,a0
8000513c:	faf40fa3          	sb	a5,-65(s0)
	switch (rx_state) {
80005140:	e9c1a783          	lw	a5,-356(gp) # 4000061c <rx_state>
80005144:	4711                	li	a4,4
80005146:	3ef76f63          	bltu	a4,a5,80005544 <osdp_on_rx_byte+0x412>
8000514a:	00279713          	slli	a4,a5,0x2
8000514e:	8000a7b7          	lui	a5,0x8000a
80005152:	81878793          	addi	a5,a5,-2024 # 80009818 <__data_source_start+0xfffffdf4>
80005156:	97ba                	add	a5,a5,a4
80005158:	439c                	lw	a5,0(a5)
8000515a:	8782                	jr	a5
	case st_wait_som:
		if (byte == OSDP_SOM) {
8000515c:	fbf44703          	lbu	a4,-65(s0)
80005160:	05300793          	li	a5,83
80005164:	3ef71363          	bne	a4,a5,8000554a <osdp_on_rx_byte+0x418>
			rx_pos = 0;
80005168:	ea019123          	sh	zero,-350(gp) # 40000622 <rx_pos>
			rx_buf[rx_pos++] = byte;
8000516c:	ea21d783          	lhu	a5,-350(gp) # 40000622 <rx_pos>
80005170:	00178713          	addi	a4,a5,1
80005174:	01071693          	slli	a3,a4,0x10
80005178:	82c1                	srli	a3,a3,0x10
8000517a:	ead19123          	sh	a3,-350(gp) # 40000622 <rx_pos>
8000517e:	873e                	mv	a4,a5
80005180:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
80005184:	97ba                	add	a5,a5,a4
80005186:	fbf44703          	lbu	a4,-65(s0)
8000518a:	00e78023          	sb	a4,0(a5)
			rx_state = st_wait_addr;
8000518e:	4705                	li	a4,1
80005190:	e8e1ae23          	sw	a4,-356(gp) # 4000061c <rx_state>
		}
		break;
80005194:	ae5d                	j	8000554a <osdp_on_rx_byte+0x418>
	case st_wait_addr:
		rx_buf[rx_pos++] = byte;
80005196:	ea21d783          	lhu	a5,-350(gp) # 40000622 <rx_pos>
8000519a:	00178713          	addi	a4,a5,1
8000519e:	01071693          	slli	a3,a4,0x10
800051a2:	82c1                	srli	a3,a3,0x10
800051a4:	ead19123          	sh	a3,-350(gp) # 40000622 <rx_pos>
800051a8:	873e                	mv	a4,a5
800051aa:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
800051ae:	97ba                	add	a5,a5,a4
800051b0:	fbf44703          	lbu	a4,-65(s0)
800051b4:	00e78023          	sb	a4,0(a5)
		rx_state = st_wait_len_l;
800051b8:	4709                	li	a4,2
800051ba:	e8e1ae23          	sw	a4,-356(gp) # 4000061c <rx_state>
		break;
800051be:	ae49                	j	80005550 <osdp_on_rx_byte+0x41e>
	case st_wait_len_l:
		rx_buf[rx_pos++] = byte;
800051c0:	ea21d783          	lhu	a5,-350(gp) # 40000622 <rx_pos>
800051c4:	00178713          	addi	a4,a5,1
800051c8:	01071693          	slli	a3,a4,0x10
800051cc:	82c1                	srli	a3,a3,0x10
800051ce:	ead19123          	sh	a3,-350(gp) # 40000622 <rx_pos>
800051d2:	873e                	mv	a4,a5
800051d4:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
800051d8:	97ba                	add	a5,a5,a4
800051da:	fbf44703          	lbu	a4,-65(s0)
800051de:	00e78023          	sb	a4,0(a5)
		rx_expected_len = byte;
800051e2:	fbf44783          	lbu	a5,-65(s0)
800051e6:	01079713          	slli	a4,a5,0x10
800051ea:	8341                	srli	a4,a4,0x10
800051ec:	eae19023          	sh	a4,-352(gp) # 40000620 <rx_expected_len>
		rx_state = st_wait_len_m;
800051f0:	470d                	li	a4,3
800051f2:	e8e1ae23          	sw	a4,-356(gp) # 4000061c <rx_state>
		break;
800051f6:	aea9                	j	80005550 <osdp_on_rx_byte+0x41e>
	case st_wait_len_m:
		rx_buf[rx_pos++] = byte;
800051f8:	ea21d783          	lhu	a5,-350(gp) # 40000622 <rx_pos>
800051fc:	00178713          	addi	a4,a5,1
80005200:	01071693          	slli	a3,a4,0x10
80005204:	82c1                	srli	a3,a3,0x10
80005206:	ead19123          	sh	a3,-350(gp) # 40000622 <rx_pos>
8000520a:	873e                	mv	a4,a5
8000520c:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
80005210:	97ba                	add	a5,a5,a4
80005212:	fbf44703          	lbu	a4,-65(s0)
80005216:	00e78023          	sb	a4,0(a5)
		rx_expected_len |= ((uint16_t)byte << 8);
8000521a:	fbf44783          	lbu	a5,-65(s0)
8000521e:	07a2                	slli	a5,a5,0x8
80005220:	01079713          	slli	a4,a5,0x10
80005224:	8741                	srai	a4,a4,0x10
80005226:	ea01d783          	lhu	a5,-352(gp) # 40000620 <rx_expected_len>
8000522a:	07c2                	slli	a5,a5,0x10
8000522c:	87c1                	srai	a5,a5,0x10
8000522e:	8fd9                	or	a5,a5,a4
80005230:	07c2                	slli	a5,a5,0x10
80005232:	87c1                	srai	a5,a5,0x10
80005234:	01079713          	slli	a4,a5,0x10
80005238:	8341                	srli	a4,a4,0x10
8000523a:	eae19023          	sh	a4,-352(gp) # 40000620 <rx_expected_len>
		if (rx_expected_len < 8 || rx_expected_len > sizeof(rx_buf)) {
8000523e:	ea01d703          	lhu	a4,-352(gp) # 40000620 <rx_expected_len>
80005242:	479d                	li	a5,7
80005244:	00e7f863          	bgeu	a5,a4,80005254 <osdp_on_rx_byte+0x122>
80005248:	ea01d703          	lhu	a4,-352(gp) # 40000620 <rx_expected_len>
8000524c:	04000793          	li	a5,64
80005250:	00e7f563          	bgeu	a5,a4,8000525a <osdp_on_rx_byte+0x128>
			// некорректная длина — сброс
			rx_state = st_wait_som;
80005254:	e801ae23          	sw	zero,-356(gp) # 4000061c <rx_state>
			break;
80005258:	ace5                	j	80005550 <osdp_on_rx_byte+0x41e>
		}
		rx_state = st_receive_bytes;
8000525a:	4711                	li	a4,4
8000525c:	e8e1ae23          	sw	a4,-356(gp) # 4000061c <rx_state>
		break;
80005260:	acc5                	j	80005550 <osdp_on_rx_byte+0x41e>
	case st_receive_bytes:
		rx_buf[rx_pos++] = byte;
80005262:	ea21d783          	lhu	a5,-350(gp) # 40000622 <rx_pos>
80005266:	00178713          	addi	a4,a5,1
8000526a:	01071693          	slli	a3,a4,0x10
8000526e:	82c1                	srli	a3,a3,0x10
80005270:	ead19123          	sh	a3,-350(gp) # 40000622 <rx_pos>
80005274:	873e                	mv	a4,a5
80005276:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
8000527a:	97ba                	add	a5,a5,a4
8000527c:	fbf44703          	lbu	a4,-65(s0)
80005280:	00e78023          	sb	a4,0(a5)
		if (rx_pos >= rx_expected_len) {
80005284:	ea21d703          	lhu	a4,-350(gp) # 40000622 <rx_pos>
80005288:	ea01d783          	lhu	a5,-352(gp) # 40000620 <rx_expected_len>
8000528c:	2cf76163          	bltu	a4,a5,8000554e <osdp_on_rx_byte+0x41c>
			// Проверка CRC
			if (osdp_crc_is_ok(rx_buf, rx_expected_len)) {
80005290:	ea01d783          	lhu	a5,-352(gp) # 40000620 <rx_expected_len>
80005294:	85be                	mv	a1,a5
80005296:	ea418513          	addi	a0,gp,-348 # 40000624 <rx_buf>
8000529a:	fd0fe0ef          	jal	ra,80003a6a <osdp_crc_is_ok>
8000529e:	87aa                	mv	a5,a0
800052a0:	22078c63          	beqz	a5,800054d8 <osdp_on_rx_byte+0x3a6>
				uint8_t addr = (uint8_t)(rx_buf[1] & 0x7F);
800052a4:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
800052a8:	0017c783          	lbu	a5,1(a5)
800052ac:	07f7f793          	andi	a5,a5,127
800052b0:	fef40623          	sb	a5,-20(s0)
				if (addr == g_addr || addr == 0x7F || addr == 0x00) {
800052b4:	e941c783          	lbu	a5,-364(gp) # 40000614 <g_addr>
800052b8:	fec44703          	lbu	a4,-20(s0)
800052bc:	00f70c63          	beq	a4,a5,800052d4 <osdp_on_rx_byte+0x1a2>
800052c0:	fec44703          	lbu	a4,-20(s0)
800052c4:	07f00793          	li	a5,127
800052c8:	00f70663          	beq	a4,a5,800052d4 <osdp_on_rx_byte+0x1a2>
800052cc:	fec44783          	lbu	a5,-20(s0)
800052d0:	26079763          	bnez	a5,8000553e <osdp_on_rx_byte+0x40c>
					uint8_t ctrl = rx_buf[4];
800052d4:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
800052d8:	0047c783          	lbu	a5,4(a5)
800052dc:	fef405a3          	sb	a5,-21(s0)
					uint8_t seq = (uint8_t)(ctrl & 0x03);
800052e0:	feb44783          	lbu	a5,-21(s0)
800052e4:	8b8d                	andi	a5,a5,3
800052e6:	fef40523          	sb	a5,-22(s0)
					uint8_t cmd = rx_buf[5];
800052ea:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
800052ee:	0057c783          	lbu	a5,5(a5)
800052f2:	fef404a3          	sb	a5,-23(s0)
					// На широковещательный (0x7F) отвечать нельзя
					char should_reply = (addr != 0x7F);
800052f6:	fec44783          	lbu	a5,-20(s0)
800052fa:	f8178793          	addi	a5,a5,-127
800052fe:	00f037b3          	snez	a5,a5
80005302:	0ff7f793          	zext.b	a5,a5
80005306:	fef40423          	sb	a5,-24(s0)
					switch (cmd) {
8000530a:	fe944783          	lbu	a5,-23(s0)
8000530e:	fa078793          	addi	a5,a5,-96
80005312:	02000713          	li	a4,32
80005316:	1af76763          	bltu	a4,a5,800054c4 <osdp_on_rx_byte+0x392>
8000531a:	00279713          	slli	a4,a5,0x2
8000531e:	8000a7b7          	lui	a5,0x8000a
80005322:	82c78793          	addi	a5,a5,-2004 # 8000982c <__data_source_start+0xfffffe08>
80005326:	97ba                	add	a5,a5,a4
80005328:	439c                	lw	a5,0(a5)
8000532a:	8782                	jr	a5
					case osdp_POLL:
						if (should_reply) osdp_build_and_send_ack(seq);
8000532c:	fe844783          	lbu	a5,-24(s0)
80005330:	1e078463          	beqz	a5,80005518 <osdp_on_rx_byte+0x3e6>
80005334:	fea44783          	lbu	a5,-22(s0)
80005338:	853e                	mv	a0,a5
8000533a:	aa7fe0ef          	jal	ra,80003de0 <osdp_build_and_send_ack>
						break;
8000533e:	aae9                	j	80005518 <osdp_on_rx_byte+0x3e6>
					case osdp_ID:
						if (should_reply) osdp_build_and_send_pdid(seq);
80005340:	fe844783          	lbu	a5,-24(s0)
80005344:	1c078c63          	beqz	a5,8000551c <osdp_on_rx_byte+0x3ea>
80005348:	fea44783          	lbu	a5,-22(s0)
8000534c:	853e                	mv	a0,a5
8000534e:	b77fe0ef          	jal	ra,80003ec4 <osdp_build_and_send_pdid>
						break;
80005352:	a2e9                	j	8000551c <osdp_on_rx_byte+0x3ea>
					case osdp_CAP:
						if (should_reply) osdp_build_and_send_pdcap(seq);
80005354:	fe844783          	lbu	a5,-24(s0)
80005358:	1c078463          	beqz	a5,80005520 <osdp_on_rx_byte+0x3ee>
8000535c:	fea44783          	lbu	a5,-22(s0)
80005360:	853e                	mv	a0,a5
80005362:	c6ffe0ef          	jal	ra,80003fd0 <osdp_build_and_send_pdcap>
						break;
80005366:	aa6d                	j	80005520 <osdp_on_rx_byte+0x3ee>
					case osdp_ISTAT:
						if (should_reply) osdp_build_and_send_istat(seq);
80005368:	fe844783          	lbu	a5,-24(s0)
8000536c:	1a078c63          	beqz	a5,80005524 <osdp_on_rx_byte+0x3f2>
80005370:	fea44783          	lbu	a5,-22(s0)
80005374:	853e                	mv	a0,a5
80005376:	f67fe0ef          	jal	ra,800042dc <osdp_build_and_send_istat>
						break;
8000537a:	a26d                	j	80005524 <osdp_on_rx_byte+0x3f2>
					case osdp_OSTAT:
						if (should_reply) osdp_build_and_send_ostat(seq);
8000537c:	fe844783          	lbu	a5,-24(s0)
80005380:	1a078463          	beqz	a5,80005528 <osdp_on_rx_byte+0x3f6>
80005384:	fea44783          	lbu	a5,-22(s0)
80005388:	853e                	mv	a0,a5
8000538a:	858ff0ef          	jal	ra,800043e2 <osdp_build_and_send_ostat>
						break;
8000538e:	aa69                	j	80005528 <osdp_on_rx_byte+0x3f6>
					case osdp_COMSET: {
						// Ожидаем 5 байт данных: [addr][baud L][baud H][baud HH][baud HHH]
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
80005390:	ea01d783          	lhu	a5,-352(gp) # 40000620 <rx_expected_len>
80005394:	17e1                	addi	a5,a5,-8
80005396:	fef41323          	sh	a5,-26(s0)
						if (data_len == 5) {
8000539a:	fe645703          	lhu	a4,-26(s0)
8000539e:	4795                	li	a5,5
800053a0:	08f71d63          	bne	a4,a5,8000543a <osdp_on_rx_byte+0x308>
							uint8_t *data = &rx_buf[6];
800053a4:	eaa18793          	addi	a5,gp,-342 # 4000062a <rx_buf+0x6>
800053a8:	fef42023          	sw	a5,-32(s0)
							uint8_t new_addr = (uint8_t)(data[0] & 0x7F);
800053ac:	fe042783          	lw	a5,-32(s0)
800053b0:	0007c783          	lbu	a5,0(a5)
800053b4:	07f7f793          	andi	a5,a5,127
800053b8:	fcf40fa3          	sb	a5,-33(s0)
							uint32_t new_baud = (uint32_t)data[1] |
800053bc:	fe042783          	lw	a5,-32(s0)
800053c0:	0785                	addi	a5,a5,1
800053c2:	0007c783          	lbu	a5,0(a5)
800053c6:	873e                	mv	a4,a5
							                    ((uint32_t)data[2] << 8) |
800053c8:	fe042783          	lw	a5,-32(s0)
800053cc:	0789                	addi	a5,a5,2
800053ce:	0007c783          	lbu	a5,0(a5)
800053d2:	07a2                	slli	a5,a5,0x8
							uint32_t new_baud = (uint32_t)data[1] |
800053d4:	8f5d                	or	a4,a4,a5
							                    ((uint32_t)data[3] << 16) |
800053d6:	fe042783          	lw	a5,-32(s0)
800053da:	078d                	addi	a5,a5,3
800053dc:	0007c783          	lbu	a5,0(a5)
800053e0:	07c2                	slli	a5,a5,0x10
							                    ((uint32_t)data[2] << 8) |
800053e2:	8f5d                	or	a4,a4,a5
							                    ((uint32_t)data[4] << 24);
800053e4:	fe042783          	lw	a5,-32(s0)
800053e8:	0791                	addi	a5,a5,4
800053ea:	0007c783          	lbu	a5,0(a5)
800053ee:	07e2                	slli	a5,a5,0x18
							uint32_t new_baud = (uint32_t)data[1] |
800053f0:	8fd9                	or	a5,a5,a4
800053f2:	fcf42c23          	sw	a5,-40(s0)
							// Отправим ответ osdp_COM с теми же параметрами
							if (should_reply) osdp_build_and_send_com(seq, new_addr, new_baud);
800053f6:	fe844783          	lbu	a5,-24(s0)
800053fa:	cb99                	beqz	a5,80005410 <osdp_on_rx_byte+0x2de>
800053fc:	fdf44703          	lbu	a4,-33(s0)
80005400:	fea44783          	lbu	a5,-22(s0)
80005404:	fd842603          	lw	a2,-40(s0)
80005408:	85ba                	mv	a1,a4
8000540a:	853e                	mv	a0,a5
8000540c:	caffe0ef          	jal	ra,800040ba <osdp_build_and_send_com>
							// Применим локально: адрес и скорость UART
							g_addr = new_addr;
80005410:	fdf44703          	lbu	a4,-33(s0)
80005414:	e8e18a23          	sb	a4,-364(gp) # 40000614 <g_addr>
							if (new_baud >= 1200 && new_baud <= 921600) {
80005418:	fd842703          	lw	a4,-40(s0)
8000541c:	4af00793          	li	a5,1199
80005420:	10e7f663          	bgeu	a5,a4,8000552c <osdp_on_rx_byte+0x3fa>
80005424:	fd842703          	lw	a4,-40(s0)
80005428:	000e17b7          	lui	a5,0xe1
8000542c:	10e7e063          	bltu	a5,a4,8000552c <osdp_on_rx_byte+0x3fa>
								set_uart_baud(new_baud);
80005430:	fd842503          	lw	a0,-40(s0)
80005434:	c9eff0ef          	jal	ra,800048d2 <set_uart_baud>
							}
						} else {
							// Неправильная длина — NAK (reason 0x02: invalid length)
							if (should_reply) osdp_build_and_send_nak(seq, 0x02);
						}
						break;
80005438:	a8d5                	j	8000552c <osdp_on_rx_byte+0x3fa>
							if (should_reply) osdp_build_and_send_nak(seq, 0x02);
8000543a:	fe844783          	lbu	a5,-24(s0)
8000543e:	0e078763          	beqz	a5,8000552c <osdp_on_rx_byte+0x3fa>
80005442:	fea44783          	lbu	a5,-22(s0)
80005446:	4589                	li	a1,2
80005448:	853e                	mv	a0,a5
8000544a:	9f9fe0ef          	jal	ra,80003e42 <osdp_build_and_send_nak>
						break;
8000544e:	a8f9                	j	8000552c <osdp_on_rx_byte+0x3fa>
					}
					case osdp_LED: {
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
80005450:	ea01d783          	lhu	a5,-352(gp) # 40000620 <rx_expected_len>
80005454:	17e1                	addi	a5,a5,-8 # e0ff8 <STACK_SIZE+0xe07f8>
80005456:	fcf41b23          	sh	a5,-42(s0)
						uint8_t *data = &rx_buf[6];
8000545a:	eaa18793          	addi	a5,gp,-342 # 4000062a <rx_buf+0x6>
8000545e:	fcf42823          	sw	a5,-48(s0)
						handle_osdp_led(data, data_len);
80005462:	fd645783          	lhu	a5,-42(s0)
80005466:	85be                	mv	a1,a5
80005468:	fd042503          	lw	a0,-48(s0)
8000546c:	3809                	jal	80004c7e <handle_osdp_led>
						if (should_reply) osdp_build_and_send_ack(seq);
8000546e:	fe844783          	lbu	a5,-24(s0)
80005472:	cfdd                	beqz	a5,80005530 <osdp_on_rx_byte+0x3fe>
80005474:	fea44783          	lbu	a5,-22(s0)
80005478:	853e                	mv	a0,a5
8000547a:	967fe0ef          	jal	ra,80003de0 <osdp_build_and_send_ack>
						break;
8000547e:	a84d                	j	80005530 <osdp_on_rx_byte+0x3fe>
					}
					case osdp_OUT: {
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
80005480:	ea01d783          	lhu	a5,-352(gp) # 40000620 <rx_expected_len>
80005484:	17e1                	addi	a5,a5,-8
80005486:	fcf41723          	sh	a5,-50(s0)
						uint8_t *data = &rx_buf[6];
8000548a:	eaa18793          	addi	a5,gp,-342 # 4000062a <rx_buf+0x6>
8000548e:	fcf42423          	sw	a5,-56(s0)
						handle_osdp_out(data, data_len);
80005492:	fce45783          	lhu	a5,-50(s0)
80005496:	85be                	mv	a1,a5
80005498:	fc842503          	lw	a0,-56(s0)
8000549c:	852ff0ef          	jal	ra,800044ee <handle_osdp_out>
						if (should_reply) osdp_build_and_send_ack(seq);
800054a0:	fe844783          	lbu	a5,-24(s0)
800054a4:	cbc1                	beqz	a5,80005534 <osdp_on_rx_byte+0x402>
800054a6:	fea44783          	lbu	a5,-22(s0)
800054aa:	853e                	mv	a0,a5
800054ac:	935fe0ef          	jal	ra,80003de0 <osdp_build_and_send_ack>
						break;
800054b0:	a051                	j	80005534 <osdp_on_rx_byte+0x402>
					}
					case osdp_MFG: {
						// Команда производителя (0x80).
						// На данном этапе просто подтверждаем любую такую команду ACK,
						// не проверяя вендора и не разбирая данные.
						if (should_reply) {
800054b2:	fe844783          	lbu	a5,-24(s0)
800054b6:	c3c9                	beqz	a5,80005538 <osdp_on_rx_byte+0x406>
							osdp_build_and_send_ack(seq);
800054b8:	fea44783          	lbu	a5,-22(s0)
800054bc:	853e                	mv	a0,a5
800054be:	923fe0ef          	jal	ra,80003de0 <osdp_build_and_send_ack>
						}
						break;
800054c2:	a89d                	j	80005538 <osdp_on_rx_byte+0x406>
					}
					default:
						// Неизвестная команда — NAK (reason 0x03: unknown command)
						if (should_reply) osdp_build_and_send_nak(seq, 0x03);
800054c4:	fe844783          	lbu	a5,-24(s0)
800054c8:	cbb5                	beqz	a5,8000553c <osdp_on_rx_byte+0x40a>
800054ca:	fea44783          	lbu	a5,-22(s0)
800054ce:	458d                	li	a1,3
800054d0:	853e                	mv	a0,a5
800054d2:	971fe0ef          	jal	ra,80003e42 <osdp_build_and_send_nak>
						break;
800054d6:	a09d                	j	8000553c <osdp_on_rx_byte+0x40a>
					}
				}
			} else {
				// Плохая CRC — NAK (reason 0x01), если это не широковещательный адрес
				uint8_t addr = (uint8_t)(rx_buf[1] & 0x7F);
800054d8:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
800054dc:	0017c783          	lbu	a5,1(a5)
800054e0:	07f7f793          	andi	a5,a5,127
800054e4:	fef407a3          	sb	a5,-17(s0)
				if (addr != 0x7F) {
800054e8:	fef44703          	lbu	a4,-17(s0)
800054ec:	07f00793          	li	a5,127
800054f0:	04f70763          	beq	a4,a5,8000553e <osdp_on_rx_byte+0x40c>
					uint8_t ctrl = rx_buf[4];
800054f4:	ea418793          	addi	a5,gp,-348 # 40000624 <rx_buf>
800054f8:	0047c783          	lbu	a5,4(a5)
800054fc:	fef40723          	sb	a5,-18(s0)
					uint8_t seq = (uint8_t)(ctrl & 0x03);
80005500:	fee44783          	lbu	a5,-18(s0)
80005504:	8b8d                	andi	a5,a5,3
80005506:	fef406a3          	sb	a5,-19(s0)
					osdp_build_and_send_nak(seq, 0x01);
8000550a:	fed44783          	lbu	a5,-19(s0)
8000550e:	4585                	li	a1,1
80005510:	853e                	mv	a0,a5
80005512:	931fe0ef          	jal	ra,80003e42 <osdp_build_and_send_nak>
80005516:	a025                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
80005518:	0001                	nop
8000551a:	a015                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
8000551c:	0001                	nop
8000551e:	a005                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
80005520:	0001                	nop
80005522:	a831                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
80005524:	0001                	nop
80005526:	a821                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
80005528:	0001                	nop
8000552a:	a811                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
8000552c:	0001                	nop
8000552e:	a801                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
80005530:	0001                	nop
80005532:	a031                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
80005534:	0001                	nop
80005536:	a021                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
80005538:	0001                	nop
8000553a:	a011                	j	8000553e <osdp_on_rx_byte+0x40c>
						break;
8000553c:	0001                	nop
				}
			}
			// Готовы к следующему пакету
			rx_state = st_wait_som;
8000553e:	e801ae23          	sw	zero,-356(gp) # 4000061c <rx_state>
		}
		break;
80005542:	a031                	j	8000554e <osdp_on_rx_byte+0x41c>
	default:
		rx_state = st_wait_som;
80005544:	e801ae23          	sw	zero,-356(gp) # 4000061c <rx_state>
		break;
80005548:	a021                	j	80005550 <osdp_on_rx_byte+0x41e>
		break;
8000554a:	0001                	nop
8000554c:	a011                	j	80005550 <osdp_on_rx_byte+0x41e>
		break;
8000554e:	0001                	nop
	}
}
80005550:	0001                	nop
80005552:	40b6                	lw	ra,76(sp)
80005554:	4426                	lw	s0,72(sp)
80005556:	6161                	addi	sp,sp,80
80005558:	8082                	ret

8000555a <RCU_ADCSARRstCmd>:
  * @brief   Cнятие сброса АЦП
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void RCU_ADCSARRstCmd(FunctionalState State)
{
8000555a:	1101                	addi	sp,sp,-32
8000555c:	ce22                	sw	s0,28(sp)
8000555e:	1000                	addi	s0,sp,32
80005560:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(RCU->ADCSARCLKCFG_bit.RSTDIS, State);
80005564:	3000e7b7          	lui	a5,0x3000e
80005568:	fec42703          	lw	a4,-20(s0)
8000556c:	8b05                	andi	a4,a4,1
8000556e:	0ff77713          	zext.b	a4,a4
80005572:	8b05                	andi	a4,a4,1
80005574:	0722                	slli	a4,a4,0x8
80005576:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
8000557a:	eff6f693          	andi	a3,a3,-257
8000557e:	8f55                	or	a4,a4,a3
80005580:	0ae7a823          	sw	a4,176(a5)
}
80005584:	0001                	nop
80005586:	4472                	lw	s0,28(sp)
80005588:	6105                	addi	sp,sp,32
8000558a:	8082                	ret

8000558c <ADCSAR_SEQ_SwStartEnCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SwStartEnCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
8000558c:	1101                	addi	sp,sp,-32
8000558e:	ce22                	sw	s0,28(sp)
80005590:	1000                	addi	s0,sp,32
80005592:	fea42623          	sw	a0,-20(s0)
80005596:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQSYNC, 1 << (uint32_t)SEQ_Num, State << (uint32_t)SEQ_Num);
8000559a:	300107b7          	lui	a5,0x30010
8000559e:	43dc                	lw	a5,4(a5)
800055a0:	fec42703          	lw	a4,-20(s0)
800055a4:	4685                	li	a3,1
800055a6:	00e69733          	sll	a4,a3,a4
800055aa:	fff74713          	not	a4,a4
800055ae:	00e7f6b3          	and	a3,a5,a4
800055b2:	fec42783          	lw	a5,-20(s0)
800055b6:	fe842703          	lw	a4,-24(s0)
800055ba:	00f71733          	sll	a4,a4,a5
800055be:	300107b7          	lui	a5,0x30010
800055c2:	8f55                	or	a4,a4,a3
800055c4:	c3d8                	sw	a4,4(a5)
}
800055c6:	0001                	nop
800055c8:	4472                	lw	s0,28(sp)
800055ca:	6105                	addi	sp,sp,32
800055cc:	8082                	ret

800055ce <ADCSAR_SEQ_StartEventConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   StartEvent  Выбор события
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_StartEventConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_StartEvent_TypeDef StartEvent)
{
800055ce:	1101                	addi	sp,sp,-32
800055d0:	ce22                	sw	s0,28(sp)
800055d2:	1000                	addi	s0,sp,32
800055d4:	fea42623          	sw	a0,-20(s0)
800055d8:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    MODIFY_REG(ADCSAR->EMUX, 0xF << ((uint32_t)SEQ_Num * 4), StartEvent << ((uint32_t)SEQ_Num * 4));
800055dc:	300107b7          	lui	a5,0x30010
800055e0:	4fdc                	lw	a5,28(a5)
800055e2:	fec42703          	lw	a4,-20(s0)
800055e6:	070a                	slli	a4,a4,0x2
800055e8:	46bd                	li	a3,15
800055ea:	00e69733          	sll	a4,a3,a4
800055ee:	fff74713          	not	a4,a4
800055f2:	00e7f6b3          	and	a3,a5,a4
800055f6:	fec42783          	lw	a5,-20(s0)
800055fa:	078a                	slli	a5,a5,0x2
800055fc:	fe842703          	lw	a4,-24(s0)
80005600:	00f71733          	sll	a4,a4,a5
80005604:	300107b7          	lui	a5,0x30010
80005608:	8f55                	or	a4,a4,a3
8000560a:	cfd8                	sw	a4,28(a5)
}
8000560c:	0001                	nop
8000560e:	4472                	lw	s0,28(sp)
80005610:	6105                	addi	sp,sp,32
80005612:	8082                	ret

80005614 <ADCSAR_SEQ_ReqMaxConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   ReqNumMax  Номер последнего запроса
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqMaxConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_ReqNum_TypeDef ReqNumMax)
{
80005614:	1101                	addi	sp,sp,-32
80005616:	ce22                	sw	s0,28(sp)
80005618:	1000                	addi	s0,sp,32
8000561a:	fea42623          	sw	a0,-20(s0)
8000561e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_REQ_NUM(ReqNumMax));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.RQMAX, ReqNumMax);
80005622:	30010637          	lui	a2,0x30010
80005626:	fe842783          	lw	a5,-24(s0)
8000562a:	8b9d                	andi	a5,a5,7
8000562c:	0ff7f693          	zext.b	a3,a5
80005630:	fec42703          	lw	a4,-20(s0)
80005634:	87ba                	mv	a5,a4
80005636:	0792                	slli	a5,a5,0x4
80005638:	8f99                	sub	a5,a5,a4
8000563a:	078a                	slli	a5,a5,0x2
8000563c:	97b2                	add	a5,a5,a2
8000563e:	0076f713          	andi	a4,a3,7
80005642:	0587d683          	lhu	a3,88(a5) # 30010058 <STACK_SIZE+0x3000f858>
80005646:	9ae1                	andi	a3,a3,-8
80005648:	8f55                	or	a4,a4,a3
8000564a:	04e79c23          	sh	a4,88(a5)
}
8000564e:	0001                	nop
80005650:	4472                	lw	s0,28(sp)
80005652:	6105                	addi	sp,sp,32
80005654:	8082                	ret

80005656 <ADCSAR_SEQ_ReqAverageConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   Average  Выбор режима усреднения
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqAverageConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_Average_TypeDef Average)
{
80005656:	1101                	addi	sp,sp,-32
80005658:	ce22                	sw	s0,28(sp)
8000565a:	1000                	addi	s0,sp,32
8000565c:	fea42623          	sw	a0,-20(s0)
80005660:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_AVERAGE(Average));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.QAVGVAL, Average);
80005664:	30010637          	lui	a2,0x30010
80005668:	fe842783          	lw	a5,-24(s0)
8000566c:	8b9d                	andi	a5,a5,7
8000566e:	0ff7f693          	zext.b	a3,a5
80005672:	fec42703          	lw	a4,-20(s0)
80005676:	87ba                	mv	a5,a4
80005678:	0792                	slli	a5,a5,0x4
8000567a:	8f99                	sub	a5,a5,a4
8000567c:	078a                	slli	a5,a5,0x2
8000567e:	97b2                	add	a5,a5,a2
80005680:	0076f713          	andi	a4,a3,7
80005684:	00971613          	slli	a2,a4,0x9
80005688:	0587d703          	lhu	a4,88(a5)
8000568c:	86ba                	mv	a3,a4
8000568e:	777d                	lui	a4,0xfffff
80005690:	1ff70713          	addi	a4,a4,511 # fffff1ff <__data_source_start+0x7fff57db>
80005694:	8f75                	and	a4,a4,a3
80005696:	86ba                	mv	a3,a4
80005698:	8732                	mv	a4,a2
8000569a:	8f55                	or	a4,a4,a3
8000569c:	04e79c23          	sh	a4,88(a5)
}
800056a0:	0001                	nop
800056a2:	4472                	lw	s0,28(sp)
800056a4:	6105                	addi	sp,sp,32
800056a6:	8082                	ret

800056a8 <ADCSAR_SEQ_ReqAverageCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqAverageCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
800056a8:	1101                	addi	sp,sp,-32
800056aa:	ce22                	sw	s0,28(sp)
800056ac:	1000                	addi	s0,sp,32
800056ae:	fea42623          	sw	a0,-20(s0)
800056b2:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.QAVGEN, State);
800056b6:	30010637          	lui	a2,0x30010
800056ba:	fe842783          	lw	a5,-24(s0)
800056be:	8b85                	andi	a5,a5,1
800056c0:	0ff7f693          	zext.b	a3,a5
800056c4:	fec42703          	lw	a4,-20(s0)
800056c8:	87ba                	mv	a5,a4
800056ca:	0792                	slli	a5,a5,0x4
800056cc:	8f99                	sub	a5,a5,a4
800056ce:	078a                	slli	a5,a5,0x2
800056d0:	97b2                	add	a5,a5,a2
800056d2:	0016f713          	andi	a4,a3,1
800056d6:	0722                	slli	a4,a4,0x8
800056d8:	0587d683          	lhu	a3,88(a5)
800056dc:	eff6f693          	andi	a3,a3,-257
800056e0:	8f55                	or	a4,a4,a3
800056e2:	04e79c23          	sh	a4,88(a5)
}
800056e6:	0001                	nop
800056e8:	4472                	lw	s0,28(sp)
800056ea:	6105                	addi	sp,sp,32
800056ec:	8082                	ret

800056ee <ADCSAR_SEQ_DMAConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   DMAFIFOLevel  Выбор уровня заполнения буфера для генерации запросов DMA
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DMAConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_DMAFIFOLevel_TypeDef DMAFIFOLevel)
{
800056ee:	1101                	addi	sp,sp,-32
800056f0:	ce22                	sw	s0,28(sp)
800056f2:	1000                	addi	s0,sp,32
800056f4:	fea42623          	sw	a0,-20(s0)
800056f8:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_DMA_FIFO_LEVEL(DMAFIFOLevel));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SDMACTL_bit.WMARK, DMAFIFOLevel);
800056fc:	30010637          	lui	a2,0x30010
80005700:	fe842783          	lw	a5,-24(s0)
80005704:	8b9d                	andi	a5,a5,7
80005706:	0ff7f693          	zext.b	a3,a5
8000570a:	fec42703          	lw	a4,-20(s0)
8000570e:	87ba                	mv	a5,a4
80005710:	0792                	slli	a5,a5,0x4
80005712:	8f99                	sub	a5,a5,a4
80005714:	078a                	slli	a5,a5,0x2
80005716:	97b2                	add	a5,a5,a2
80005718:	0076f713          	andi	a4,a3,7
8000571c:	0722                	slli	a4,a4,0x8
8000571e:	0607d683          	lhu	a3,96(a5)
80005722:	8ff6f693          	andi	a3,a3,-1793
80005726:	8f55                	or	a4,a4,a3
80005728:	06e79023          	sh	a4,96(a5)
}
8000572c:	0001                	nop
8000572e:	4472                	lw	s0,28(sp)
80005730:	6105                	addi	sp,sp,32
80005732:	8082                	ret

80005734 <ADCSAR_SEQ_DMACmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DMACmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80005734:	1101                	addi	sp,sp,-32
80005736:	ce22                	sw	s0,28(sp)
80005738:	1000                	addi	s0,sp,32
8000573a:	fea42623          	sw	a0,-20(s0)
8000573e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SDMACTL_bit.DMAEN, State);
80005742:	30010637          	lui	a2,0x30010
80005746:	fe842783          	lw	a5,-24(s0)
8000574a:	8b85                	andi	a5,a5,1
8000574c:	0ff7f693          	zext.b	a3,a5
80005750:	fec42703          	lw	a4,-20(s0)
80005754:	87ba                	mv	a5,a4
80005756:	0792                	slli	a5,a5,0x4
80005758:	8f99                	sub	a5,a5,a4
8000575a:	078a                	slli	a5,a5,0x2
8000575c:	97b2                	add	a5,a5,a2
8000575e:	0016f713          	andi	a4,a3,1
80005762:	0607d683          	lhu	a3,96(a5)
80005766:	9af9                	andi	a3,a3,-2
80005768:	8f55                	or	a4,a4,a3
8000576a:	06e79023          	sh	a4,96(a5)
}
8000576e:	0001                	nop
80005770:	4472                	lw	s0,28(sp)
80005772:	6105                	addi	sp,sp,32
80005774:	8082                	ret

80005776 <ADCSAR_SEQ_RestartConfig>:
  * @param   RestartVal  Количество. 0x00 - без перезапусков,
  *                      0x01 - 1 перезапуск, 0xFF - 255 перезапусков.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_RestartConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t RestartVal)
{
80005776:	1101                	addi	sp,sp,-32
80005778:	ce22                	sw	s0,28(sp)
8000577a:	1000                	addi	s0,sp,32
8000577c:	fea42623          	sw	a0,-20(s0)
80005780:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_RESTART_VAL(RestartVal));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.RCNT, RestartVal);
80005784:	30010637          	lui	a2,0x30010
80005788:	fe842783          	lw	a5,-24(s0)
8000578c:	0ff7f693          	zext.b	a3,a5
80005790:	fec42703          	lw	a4,-20(s0)
80005794:	87ba                	mv	a5,a4
80005796:	0792                	slli	a5,a5,0x4
80005798:	8f99                	sub	a5,a5,a4
8000579a:	078a                	slli	a5,a5,0x2
8000579c:	97b2                	add	a5,a5,a2
8000579e:	06d78223          	sb	a3,100(a5)
}
800057a2:	0001                	nop
800057a4:	4472                	lw	s0,28(sp)
800057a6:	6105                	addi	sp,sp,32
800057a8:	8082                	ret

800057aa <ADCSAR_SEQ_RestartAverageCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_RestartAverageCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
800057aa:	1101                	addi	sp,sp,-32
800057ac:	ce22                	sw	s0,28(sp)
800057ae:	1000                	addi	s0,sp,32
800057b0:	fea42623          	sw	a0,-20(s0)
800057b4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.RAVGEN, State);
800057b8:	30010637          	lui	a2,0x30010
800057bc:	fe842783          	lw	a5,-24(s0)
800057c0:	8b85                	andi	a5,a5,1
800057c2:	0ff7f693          	zext.b	a3,a5
800057c6:	fec42703          	lw	a4,-20(s0)
800057ca:	87ba                	mv	a5,a4
800057cc:	0792                	slli	a5,a5,0x4
800057ce:	8f99                	sub	a5,a5,a4
800057d0:	078a                	slli	a5,a5,0x2
800057d2:	97b2                	add	a5,a5,a2
800057d4:	0016f713          	andi	a4,a3,1
800057d8:	0722                	slli	a4,a4,0x8
800057da:	53f4                	lw	a3,100(a5)
800057dc:	eff6f693          	andi	a3,a3,-257
800057e0:	8f55                	or	a4,a4,a3
800057e2:	d3f8                	sw	a4,100(a5)
}
800057e4:	0001                	nop
800057e6:	4472                	lw	s0,28(sp)
800057e8:	6105                	addi	sp,sp,32
800057ea:	8082                	ret

800057ec <ADCSAR_SEQ_DCEnableCmd>:
  * @param   DC_Num  Выбор компаратора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DCEnableCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_DC_Num_TypeDef DC_Num, FunctionalState State)
{
800057ec:	1101                	addi	sp,sp,-32
800057ee:	ce22                	sw	s0,28(sp)
800057f0:	1000                	addi	s0,sp,32
800057f2:	fea42623          	sw	a0,-20(s0)
800057f6:	feb42423          	sw	a1,-24(s0)
800057fa:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SDC, 1 << ((uint32_t)DC_Num), State << ((uint32_t)DC_Num));
800057fe:	300106b7          	lui	a3,0x30010
80005802:	fec42703          	lw	a4,-20(s0)
80005806:	87ba                	mv	a5,a4
80005808:	0792                	slli	a5,a5,0x4
8000580a:	8f99                	sub	a5,a5,a4
8000580c:	078a                	slli	a5,a5,0x2
8000580e:	97b6                	add	a5,a5,a3
80005810:	57fc                	lw	a5,108(a5)
80005812:	fe842703          	lw	a4,-24(s0)
80005816:	4685                	li	a3,1
80005818:	00e69733          	sll	a4,a3,a4
8000581c:	fff74713          	not	a4,a4
80005820:	8f7d                	and	a4,a4,a5
80005822:	fe842783          	lw	a5,-24(s0)
80005826:	fe442683          	lw	a3,-28(s0)
8000582a:	00f697b3          	sll	a5,a3,a5
8000582e:	30010637          	lui	a2,0x30010
80005832:	00f766b3          	or	a3,a4,a5
80005836:	fec42703          	lw	a4,-20(s0)
8000583a:	87ba                	mv	a5,a4
8000583c:	0792                	slli	a5,a5,0x4
8000583e:	8f99                	sub	a5,a5,a4
80005840:	078a                	slli	a5,a5,0x2
80005842:	97b2                	add	a5,a5,a2
80005844:	d7f4                	sw	a3,108(a5)
}
80005846:	0001                	nop
80005848:	4472                	lw	s0,28(sp)
8000584a:	6105                	addi	sp,sp,32
8000584c:	8082                	ret

8000584e <ADCSAR_SEQ_SetRestartTimer>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   TimerVal  Значение. 0 - означает отсутствие задержки и немедленный перезапуск (если активен).
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SetRestartTimer(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t TimerVal)
{
8000584e:	1101                	addi	sp,sp,-32
80005850:	ce22                	sw	s0,28(sp)
80005852:	1000                	addi	s0,sp,32
80005854:	fea42623          	sw	a0,-20(s0)
80005858:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_RESTART_TIMER_VAL(TimerVal));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRTMR_bit.VAL, TimerVal);
8000585c:	30010637          	lui	a2,0x30010
80005860:	fe842703          	lw	a4,-24(s0)
80005864:	010007b7          	lui	a5,0x1000
80005868:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
8000586a:	00f776b3          	and	a3,a4,a5
8000586e:	fec42703          	lw	a4,-20(s0)
80005872:	87ba                	mv	a5,a4
80005874:	0792                	slli	a5,a5,0x4
80005876:	8f99                	sub	a5,a5,a4
80005878:	078a                	slli	a5,a5,0x2
8000587a:	97b2                	add	a5,a5,a2
8000587c:	01000737          	lui	a4,0x1000
80005880:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80005882:	8f75                	and	a4,a4,a3
80005884:	5bb0                	lw	a2,112(a5)
80005886:	ff0006b7          	lui	a3,0xff000
8000588a:	8ef1                	and	a3,a3,a2
8000588c:	8f55                	or	a4,a4,a3
8000588e:	dbb8                	sw	a4,112(a5)
}
80005890:	0001                	nop
80005892:	4472                	lw	s0,28(sp)
80005894:	6105                	addi	sp,sp,32
80005896:	8082                	ret

80005898 <ADCSAR_DC_OutputCmd>:
  * @param   DC_Num  Выбор компаратора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_OutputCmd(ADCSAR_DC_Num_TypeDef DC_Num, FunctionalState State)
{
80005898:	1101                	addi	sp,sp,-32
8000589a:	ce22                	sw	s0,28(sp)
8000589c:	1000                	addi	s0,sp,32
8000589e:	fea42623          	sw	a0,-20(s0)
800058a2:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.CTE, State);
800058a6:	30010637          	lui	a2,0x30010
800058aa:	fe842783          	lw	a5,-24(s0)
800058ae:	8b85                	andi	a5,a5,1
800058b0:	0ff7f693          	zext.b	a3,a5
800058b4:	fec42703          	lw	a4,-20(s0)
800058b8:	87ba                	mv	a5,a4
800058ba:	0786                	slli	a5,a5,0x1
800058bc:	97ba                	add	a5,a5,a4
800058be:	078a                	slli	a5,a5,0x2
800058c0:	97b2                	add	a5,a5,a2
800058c2:	0016f713          	andi	a4,a3,1
800058c6:	0732                	slli	a4,a4,0xc
800058c8:	4007a603          	lw	a2,1024(a5)
800058cc:	76fd                	lui	a3,0xfffff
800058ce:	16fd                	addi	a3,a3,-1 # ffffefff <__data_source_start+0x7fff55db>
800058d0:	8ef1                	and	a3,a3,a2
800058d2:	8f55                	or	a4,a4,a3
800058d4:	40e7a023          	sw	a4,1024(a5)
}
800058d8:	0001                	nop
800058da:	4472                	lw	s0,28(sp)
800058dc:	6105                	addi	sp,sp,32
800058de:	8082                	ret

800058e0 <ADCSAR_DC_SourceConfig>:
  * @param   DC_Num  Выбор компаратора
  * @param   Source  Выбор источника
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SourceConfig(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Source_TypeDef Source)
{
800058e0:	1101                	addi	sp,sp,-32
800058e2:	ce22                	sw	s0,28(sp)
800058e4:	1000                	addi	s0,sp,32
800058e6:	fea42623          	sw	a0,-20(s0)
800058ea:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_SOURCE(Source));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.SRC, Source);
800058ee:	30010637          	lui	a2,0x30010
800058f2:	fe842783          	lw	a5,-24(s0)
800058f6:	8b85                	andi	a5,a5,1
800058f8:	0ff7f693          	zext.b	a3,a5
800058fc:	fec42703          	lw	a4,-20(s0)
80005900:	87ba                	mv	a5,a4
80005902:	0786                	slli	a5,a5,0x1
80005904:	97ba                	add	a5,a5,a4
80005906:	078a                	slli	a5,a5,0x2
80005908:	97b2                	add	a5,a5,a2
8000590a:	0016f713          	andi	a4,a3,1
8000590e:	0762                	slli	a4,a4,0x18
80005910:	4007a603          	lw	a2,1024(a5)
80005914:	ff0006b7          	lui	a3,0xff000
80005918:	16fd                	addi	a3,a3,-1 # feffffff <__data_source_start+0x7eff65db>
8000591a:	8ef1                	and	a3,a3,a2
8000591c:	8f55                	or	a4,a4,a3
8000591e:	40e7a023          	sw	a4,1024(a5)
}
80005922:	0001                	nop
80005924:	4472                	lw	s0,28(sp)
80005926:	6105                	addi	sp,sp,32
80005928:	8082                	ret

8000592a <ADCSAR_DC_ChannelConfig>:
  * @param   DC_Num  Выбор компаратора
  * @param   Source  Выбор источника
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_ChannelConfig(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_CH_Num_TypeDef Channel_Num)
{
8000592a:	1101                	addi	sp,sp,-32
8000592c:	ce22                	sw	s0,28(sp)
8000592e:	1000                	addi	s0,sp,32
80005930:	fea42623          	sw	a0,-20(s0)
80005934:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_CH_NUM(Channel_Num));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.CHNL, Channel_Num);
80005938:	30010637          	lui	a2,0x30010
8000593c:	fe842783          	lw	a5,-24(s0)
80005940:	8b9d                	andi	a5,a5,7
80005942:	0ff7f693          	zext.b	a3,a5
80005946:	fec42703          	lw	a4,-20(s0)
8000594a:	87ba                	mv	a5,a4
8000594c:	0786                	slli	a5,a5,0x1
8000594e:	97ba                	add	a5,a5,a4
80005950:	078a                	slli	a5,a5,0x2
80005952:	97b2                	add	a5,a5,a2
80005954:	0076f713          	andi	a4,a3,7
80005958:	0742                	slli	a4,a4,0x10
8000595a:	4007a603          	lw	a2,1024(a5)
8000595e:	fff906b7          	lui	a3,0xfff90
80005962:	16fd                	addi	a3,a3,-1 # fff8ffff <__data_source_start+0x7ff865db>
80005964:	8ef1                	and	a3,a3,a2
80005966:	8f55                	or	a4,a4,a3
80005968:	40e7a023          	sw	a4,1024(a5)
}
8000596c:	0001                	nop
8000596e:	4472                	lw	s0,28(sp)
80005970:	6105                	addi	sp,sp,32
80005972:	8082                	ret

80005974 <ADCSAR_DC_Config>:
  * @param   Mode  Выбор режима
  * @param   Condition  Выбор условия
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_Config(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Mode_TypeDef Mode, ADCSAR_DC_Condition_TypeDef Condition)
{
80005974:	1101                	addi	sp,sp,-32
80005976:	ce22                	sw	s0,28(sp)
80005978:	1000                	addi	s0,sp,32
8000597a:	fea42623          	sw	a0,-20(s0)
8000597e:	feb42423          	sw	a1,-24(s0)
80005982:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_MODE(Mode));
    assert_param(IS_ADCSAR_DC_CONDITION(Condition));

    MODIFY_REG(ADCSAR->DC[DC_Num].DCTL, ADCSAR_DC_DCTL_CTC_Msk | ADCSAR_DC_DCTL_CTM_Msk,
80005986:	300106b7          	lui	a3,0x30010
8000598a:	fec42703          	lw	a4,-20(s0)
8000598e:	87ba                	mv	a5,a4
80005990:	0786                	slli	a5,a5,0x1
80005992:	97ba                	add	a5,a5,a4
80005994:	078a                	slli	a5,a5,0x2
80005996:	97b6                	add	a5,a5,a3
80005998:	4007a703          	lw	a4,1024(a5)
8000599c:	77fd                	lui	a5,0xfffff
8000599e:	0ff78793          	addi	a5,a5,255 # fffff0ff <__data_source_start+0x7fff56db>
800059a2:	8f7d                	and	a4,a4,a5
800059a4:	fe842783          	lw	a5,-24(s0)
800059a8:	00879693          	slli	a3,a5,0x8
800059ac:	fe442783          	lw	a5,-28(s0)
800059b0:	07aa                	slli	a5,a5,0xa
800059b2:	8fd5                	or	a5,a5,a3
800059b4:	30010637          	lui	a2,0x30010
800059b8:	00f766b3          	or	a3,a4,a5
800059bc:	fec42703          	lw	a4,-20(s0)
800059c0:	87ba                	mv	a5,a4
800059c2:	0786                	slli	a5,a5,0x1
800059c4:	97ba                	add	a5,a5,a4
800059c6:	078a                	slli	a5,a5,0x2
800059c8:	97b2                	add	a5,a5,a2
800059ca:	40d7a023          	sw	a3,1024(a5)
               ((Mode << ADCSAR_DC_DCTL_CTM_Pos) |
                (Condition << ADCSAR_DC_DCTL_CTC_Pos)));
}
800059ce:	0001                	nop
800059d0:	4472                	lw	s0,28(sp)
800059d2:	6105                	addi	sp,sp,32
800059d4:	8082                	ret

800059d6 <ADCSAR_DC_SetThresholdLow>:
  * @param   DC_Num  Выбор компаратора
  * @param   Val  Значение. Диапазон 0-0xFFF.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SetThresholdLow(ADCSAR_DC_Num_TypeDef DC_Num, uint32_t Val)
{
800059d6:	1101                	addi	sp,sp,-32
800059d8:	ce22                	sw	s0,28(sp)
800059da:	1000                	addi	s0,sp,32
800059dc:	fea42623          	sw	a0,-20(s0)
800059e0:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_THRESHOLD(Val));

    WRITE_REG(ADCSAR->DC[DC_Num].DCMP_bit.CMPL, Val);
800059e4:	30010637          	lui	a2,0x30010
800059e8:	fe842783          	lw	a5,-24(s0)
800059ec:	873e                	mv	a4,a5
800059ee:	6785                	lui	a5,0x1
800059f0:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
800059f2:	8ff9                	and	a5,a5,a4
800059f4:	01079693          	slli	a3,a5,0x10
800059f8:	82c1                	srli	a3,a3,0x10
800059fa:	fec42703          	lw	a4,-20(s0)
800059fe:	87ba                	mv	a5,a4
80005a00:	0786                	slli	a5,a5,0x1
80005a02:	97ba                	add	a5,a5,a4
80005a04:	078a                	slli	a5,a5,0x2
80005a06:	97b2                	add	a5,a5,a2
80005a08:	6705                	lui	a4,0x1
80005a0a:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80005a0c:	8f75                	and	a4,a4,a3
80005a0e:	4047a603          	lw	a2,1028(a5)
80005a12:	76fd                	lui	a3,0xfffff
80005a14:	8ef1                	and	a3,a3,a2
80005a16:	8f55                	or	a4,a4,a3
80005a18:	40e7a223          	sw	a4,1028(a5)
}
80005a1c:	0001                	nop
80005a1e:	4472                	lw	s0,28(sp)
80005a20:	6105                	addi	sp,sp,32
80005a22:	8082                	ret

80005a24 <ADCSAR_DC_SetThresholdHigh>:
  * @param   DC_Num  Выбор компаратора
  * @param   Val  Значение. Диапазон 0-0xFFF.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SetThresholdHigh(ADCSAR_DC_Num_TypeDef DC_Num, uint32_t Val)
{
80005a24:	1101                	addi	sp,sp,-32
80005a26:	ce22                	sw	s0,28(sp)
80005a28:	1000                	addi	s0,sp,32
80005a2a:	fea42623          	sw	a0,-20(s0)
80005a2e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_THRESHOLD(Val));

    WRITE_REG(ADCSAR->DC[DC_Num].DCMP_bit.CMPH, Val);
80005a32:	30010637          	lui	a2,0x30010
80005a36:	fe842783          	lw	a5,-24(s0)
80005a3a:	873e                	mv	a4,a5
80005a3c:	6785                	lui	a5,0x1
80005a3e:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80005a40:	8ff9                	and	a5,a5,a4
80005a42:	01079693          	slli	a3,a5,0x10
80005a46:	82c1                	srli	a3,a3,0x10
80005a48:	fec42703          	lw	a4,-20(s0)
80005a4c:	87ba                	mv	a5,a4
80005a4e:	0786                	slli	a5,a5,0x1
80005a50:	97ba                	add	a5,a5,a4
80005a52:	078a                	slli	a5,a5,0x2
80005a54:	97b2                	add	a5,a5,a2
80005a56:	6705                	lui	a4,0x1
80005a58:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80005a5a:	8f75                	and	a4,a4,a3
80005a5c:	0742                	slli	a4,a4,0x10
80005a5e:	4047a603          	lw	a2,1028(a5)
80005a62:	f00106b7          	lui	a3,0xf0010
80005a66:	16fd                	addi	a3,a3,-1 # f000ffff <__data_source_start+0x700065db>
80005a68:	8ef1                	and	a3,a3,a2
80005a6a:	8f55                	or	a4,a4,a3
80005a6c:	40e7a223          	sw	a4,1028(a5)
}
80005a70:	0001                	nop
80005a72:	4472                	lw	s0,28(sp)
80005a74:	6105                	addi	sp,sp,32
80005a76:	8082                	ret

80005a78 <ADCSAR_SEQ_ReqConfig>:
  * @param   ReqNum  Выбор запроса
  * @param   Channel_Num  Выбор канала
  * @retval  void
  */
void ADCSAR_SEQ_ReqConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_ReqNum_TypeDef ReqNum, ADCSAR_CH_Num_TypeDef Channel_Num)
{
80005a78:	7179                	addi	sp,sp,-48
80005a7a:	d622                	sw	s0,44(sp)
80005a7c:	1800                	addi	s0,sp,48
80005a7e:	fca42e23          	sw	a0,-36(s0)
80005a82:	fcb42c23          	sw	a1,-40(s0)
80005a86:	fcc42a23          	sw	a2,-44(s0)

    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_REQ_NUM(ReqNum));
    assert_param(IS_ADCSAR_CH_NUM(Channel_Num));

    req_pos = ReqNum * 4;
80005a8a:	fd842783          	lw	a5,-40(s0)
80005a8e:	078a                	slli	a5,a5,0x2
80005a90:	fef42623          	sw	a5,-20(s0)

    MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x0F << req_pos, Channel_Num << req_pos); // srqsel2
80005a94:	300106b7          	lui	a3,0x30010
80005a98:	fdc42703          	lw	a4,-36(s0)
80005a9c:	87ba                	mv	a5,a4
80005a9e:	0792                	slli	a5,a5,0x4
80005aa0:	8f99                	sub	a5,a5,a4
80005aa2:	078a                	slli	a5,a5,0x2
80005aa4:	97b6                	add	a5,a5,a3
80005aa6:	43bc                	lw	a5,64(a5)
80005aa8:	fec42703          	lw	a4,-20(s0)
80005aac:	46bd                	li	a3,15
80005aae:	00e69733          	sll	a4,a3,a4
80005ab2:	fff74713          	not	a4,a4
80005ab6:	8f7d                	and	a4,a4,a5
80005ab8:	fec42783          	lw	a5,-20(s0)
80005abc:	fd442683          	lw	a3,-44(s0)
80005ac0:	00f697b3          	sll	a5,a3,a5
80005ac4:	30010637          	lui	a2,0x30010
80005ac8:	00f766b3          	or	a3,a4,a5
80005acc:	fdc42703          	lw	a4,-36(s0)
80005ad0:	87ba                	mv	a5,a4
80005ad2:	0792                	slli	a5,a5,0x4
80005ad4:	8f99                	sub	a5,a5,a4
80005ad6:	078a                	slli	a5,a5,0x2
80005ad8:	97b2                	add	a5,a5,a2
80005ada:	c3b4                	sw	a3,64(a5)
}
80005adc:	0001                	nop
80005ade:	5432                	lw	s0,44(sp)
80005ae0:	6145                	addi	sp,sp,48
80005ae2:	8082                	ret

80005ae4 <ADCSAR_DeInit>:
/**
  * @brief   Устанавливает все регистры ADCSAR значениями по умолчанию
  * @retval  void
  */
void ADCSAR_DeInit()
{
80005ae4:	1141                	addi	sp,sp,-16
80005ae6:	c606                	sw	ra,12(sp)
80005ae8:	c422                	sw	s0,8(sp)
80005aea:	0800                	addi	s0,sp,16
    RCU_ADCSARRstCmd(DISABLE);
80005aec:	4501                	li	a0,0
80005aee:	34b5                	jal	8000555a <RCU_ADCSARRstCmd>
    RCU_ADCSARRstCmd(ENABLE);
80005af0:	4505                	li	a0,1
80005af2:	34a5                	jal	8000555a <RCU_ADCSARRstCmd>
}
80005af4:	0001                	nop
80005af6:	40b2                	lw	ra,12(sp)
80005af8:	4422                	lw	s0,8(sp)
80005afa:	0141                	addi	sp,sp,16
80005afc:	8082                	ret

80005afe <ADCSAR_SEQ_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_SEQ_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSAR_SEQ_Init(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_Init_TypeDef* InitStruct)
{
80005afe:	7179                	addi	sp,sp,-48
80005b00:	d606                	sw	ra,44(sp)
80005b02:	d422                	sw	s0,40(sp)
80005b04:	1800                	addi	s0,sp,48
80005b06:	fca42e23          	sw	a0,-36(s0)
80005b0a:	fcb42c23          	sw	a1,-40(s0)
    ADCSAR_SEQ_StartEventConfig(SEQ_Num, InitStruct->StartEvent);
80005b0e:	fd842783          	lw	a5,-40(s0)
80005b12:	439c                	lw	a5,0(a5)
80005b14:	85be                	mv	a1,a5
80005b16:	fdc42503          	lw	a0,-36(s0)
80005b1a:	3c55                	jal	800055ce <ADCSAR_SEQ_StartEventConfig>
    ADCSAR_SEQ_SwStartEnCmd(SEQ_Num, InitStruct->SWStartEn);
80005b1c:	fd842783          	lw	a5,-40(s0)
80005b20:	43dc                	lw	a5,4(a5)
80005b22:	85be                	mv	a1,a5
80005b24:	fdc42503          	lw	a0,-36(s0)
80005b28:	3495                	jal	8000558c <ADCSAR_SEQ_SwStartEnCmd>
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80005b2a:	fe042623          	sw	zero,-20(s0)
80005b2e:	a01d                	j	80005b54 <ADCSAR_SEQ_Init+0x56>
        ADCSAR_SEQ_ReqConfig(SEQ_Num, (ADCSAR_SEQ_ReqNum_TypeDef)i, InitStruct->Req[i]);
80005b30:	fd842703          	lw	a4,-40(s0)
80005b34:	fec42783          	lw	a5,-20(s0)
80005b38:	078a                	slli	a5,a5,0x2
80005b3a:	97ba                	add	a5,a5,a4
80005b3c:	479c                	lw	a5,8(a5)
80005b3e:	863e                	mv	a2,a5
80005b40:	fec42583          	lw	a1,-20(s0)
80005b44:	fdc42503          	lw	a0,-36(s0)
80005b48:	3f05                	jal	80005a78 <ADCSAR_SEQ_ReqConfig>
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80005b4a:	fec42783          	lw	a5,-20(s0)
80005b4e:	0785                	addi	a5,a5,1
80005b50:	fef42623          	sw	a5,-20(s0)
80005b54:	fec42703          	lw	a4,-20(s0)
80005b58:	479d                	li	a5,7
80005b5a:	fce7fbe3          	bgeu	a5,a4,80005b30 <ADCSAR_SEQ_Init+0x32>
    }
    ADCSAR_SEQ_ReqMaxConfig(SEQ_Num, InitStruct->ReqMax);
80005b5e:	fd842783          	lw	a5,-40(s0)
80005b62:	579c                	lw	a5,40(a5)
80005b64:	85be                	mv	a1,a5
80005b66:	fdc42503          	lw	a0,-36(s0)
80005b6a:	346d                	jal	80005614 <ADCSAR_SEQ_ReqMaxConfig>
    ADCSAR_SEQ_ReqAverageConfig(SEQ_Num, InitStruct->ReqAverage);
80005b6c:	fd842783          	lw	a5,-40(s0)
80005b70:	57dc                	lw	a5,44(a5)
80005b72:	85be                	mv	a1,a5
80005b74:	fdc42503          	lw	a0,-36(s0)
80005b78:	3cf9                	jal	80005656 <ADCSAR_SEQ_ReqAverageConfig>
    ADCSAR_SEQ_ReqAverageCmd(SEQ_Num, InitStruct->ReqAverageEn);
80005b7a:	fd842783          	lw	a5,-40(s0)
80005b7e:	5b9c                	lw	a5,48(a5)
80005b80:	85be                	mv	a1,a5
80005b82:	fdc42503          	lw	a0,-36(s0)
80005b86:	360d                	jal	800056a8 <ADCSAR_SEQ_ReqAverageCmd>
    ADCSAR_SEQ_RestartConfig(SEQ_Num, InitStruct->RestartCount);
80005b88:	fd842783          	lw	a5,-40(s0)
80005b8c:	5bdc                	lw	a5,52(a5)
80005b8e:	85be                	mv	a1,a5
80005b90:	fdc42503          	lw	a0,-36(s0)
80005b94:	36cd                	jal	80005776 <ADCSAR_SEQ_RestartConfig>
    ADCSAR_SEQ_RestartAverageCmd(SEQ_Num, InitStruct->RestartAverageEn);
80005b96:	fd842783          	lw	a5,-40(s0)
80005b9a:	5f9c                	lw	a5,56(a5)
80005b9c:	85be                	mv	a1,a5
80005b9e:	fdc42503          	lw	a0,-36(s0)
80005ba2:	3121                	jal	800057aa <ADCSAR_SEQ_RestartAverageCmd>
    ADCSAR_SEQ_SetRestartTimer(SEQ_Num, InitStruct->RestartTimer);
80005ba4:	fd842783          	lw	a5,-40(s0)
80005ba8:	5fdc                	lw	a5,60(a5)
80005baa:	85be                	mv	a1,a5
80005bac:	fdc42503          	lw	a0,-36(s0)
80005bb0:	3979                	jal	8000584e <ADCSAR_SEQ_SetRestartTimer>
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
80005bb2:	fe042423          	sw	zero,-24(s0)
80005bb6:	a025                	j	80005bde <ADCSAR_SEQ_Init+0xe0>
        ADCSAR_SEQ_DCEnableCmd(SEQ_Num, (ADCSAR_DC_Num_TypeDef)i, InitStruct->DCEn[i]);
80005bb8:	fd842703          	lw	a4,-40(s0)
80005bbc:	fe842783          	lw	a5,-24(s0)
80005bc0:	07c1                	addi	a5,a5,16
80005bc2:	078a                	slli	a5,a5,0x2
80005bc4:	97ba                	add	a5,a5,a4
80005bc6:	439c                	lw	a5,0(a5)
80005bc8:	863e                	mv	a2,a5
80005bca:	fe842583          	lw	a1,-24(s0)
80005bce:	fdc42503          	lw	a0,-36(s0)
80005bd2:	3929                	jal	800057ec <ADCSAR_SEQ_DCEnableCmd>
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
80005bd4:	fe842783          	lw	a5,-24(s0)
80005bd8:	0785                	addi	a5,a5,1
80005bda:	fef42423          	sw	a5,-24(s0)
80005bde:	fe842703          	lw	a4,-24(s0)
80005be2:	479d                	li	a5,7
80005be4:	fce7fae3          	bgeu	a5,a4,80005bb8 <ADCSAR_SEQ_Init+0xba>
    }
    ADCSAR_SEQ_DMAConfig(SEQ_Num, InitStruct->DMAFIFOLevel);
80005be8:	fd842783          	lw	a5,-40(s0)
80005bec:	53bc                	lw	a5,96(a5)
80005bee:	85be                	mv	a1,a5
80005bf0:	fdc42503          	lw	a0,-36(s0)
80005bf4:	3ced                	jal	800056ee <ADCSAR_SEQ_DMAConfig>
    ADCSAR_SEQ_DMACmd(SEQ_Num, InitStruct->DMAEn);
80005bf6:	fd842783          	lw	a5,-40(s0)
80005bfa:	53fc                	lw	a5,100(a5)
80005bfc:	85be                	mv	a1,a5
80005bfe:	fdc42503          	lw	a0,-36(s0)
80005c02:	3e0d                	jal	80005734 <ADCSAR_SEQ_DMACmd>
}
80005c04:	0001                	nop
80005c06:	50b2                	lw	ra,44(sp)
80005c08:	5422                	lw	s0,40(sp)
80005c0a:	6145                	addi	sp,sp,48
80005c0c:	8082                	ret

80005c0e <ADCSAR_SEQ_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_SEQ_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSAR_SEQ_StructInit(ADCSAR_SEQ_Init_TypeDef* InitStruct)
{
80005c0e:	7179                	addi	sp,sp,-48
80005c10:	d622                	sw	s0,44(sp)
80005c12:	1800                	addi	s0,sp,48
80005c14:	fca42e23          	sw	a0,-36(s0)
    InitStruct->StartEvent = ADCSAR_SEQ_StartEvent_SwReq;
80005c18:	fdc42783          	lw	a5,-36(s0)
80005c1c:	0007a023          	sw	zero,0(a5)
    InitStruct->SWStartEn = DISABLE;
80005c20:	fdc42783          	lw	a5,-36(s0)
80005c24:	0007a223          	sw	zero,4(a5)
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80005c28:	fe042623          	sw	zero,-20(s0)
80005c2c:	a831                	j	80005c48 <ADCSAR_SEQ_StructInit+0x3a>
        InitStruct->Req[i] = ADCSAR_CH_Num_0;
80005c2e:	fdc42703          	lw	a4,-36(s0)
80005c32:	fec42783          	lw	a5,-20(s0)
80005c36:	078a                	slli	a5,a5,0x2
80005c38:	97ba                	add	a5,a5,a4
80005c3a:	0007a423          	sw	zero,8(a5)
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80005c3e:	fec42783          	lw	a5,-20(s0)
80005c42:	0785                	addi	a5,a5,1
80005c44:	fef42623          	sw	a5,-20(s0)
80005c48:	fec42703          	lw	a4,-20(s0)
80005c4c:	479d                	li	a5,7
80005c4e:	fee7f0e3          	bgeu	a5,a4,80005c2e <ADCSAR_SEQ_StructInit+0x20>
    }
    InitStruct->ReqMax = ADCSAR_SEQ_ReqNum_0;
80005c52:	fdc42783          	lw	a5,-36(s0)
80005c56:	0207a423          	sw	zero,40(a5)
    InitStruct->ReqAverage = ADCSAR_SEQ_Average_2;
80005c5a:	fdc42783          	lw	a5,-36(s0)
80005c5e:	4705                	li	a4,1
80005c60:	d7d8                	sw	a4,44(a5)
    InitStruct->ReqAverageEn = DISABLE;
80005c62:	fdc42783          	lw	a5,-36(s0)
80005c66:	0207a823          	sw	zero,48(a5)
    InitStruct->RestartCount = 0;
80005c6a:	fdc42783          	lw	a5,-36(s0)
80005c6e:	0207aa23          	sw	zero,52(a5)
    InitStruct->RestartAverageEn = DISABLE;
80005c72:	fdc42783          	lw	a5,-36(s0)
80005c76:	0207ac23          	sw	zero,56(a5)
    InitStruct->RestartTimer = 0;
80005c7a:	fdc42783          	lw	a5,-36(s0)
80005c7e:	0207ae23          	sw	zero,60(a5)
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
80005c82:	fe042423          	sw	zero,-24(s0)
80005c86:	a839                	j	80005ca4 <ADCSAR_SEQ_StructInit+0x96>
        InitStruct->DCEn[i] = DISABLE;
80005c88:	fdc42703          	lw	a4,-36(s0)
80005c8c:	fe842783          	lw	a5,-24(s0)
80005c90:	07c1                	addi	a5,a5,16
80005c92:	078a                	slli	a5,a5,0x2
80005c94:	97ba                	add	a5,a5,a4
80005c96:	0007a023          	sw	zero,0(a5)
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
80005c9a:	fe842783          	lw	a5,-24(s0)
80005c9e:	0785                	addi	a5,a5,1
80005ca0:	fef42423          	sw	a5,-24(s0)
80005ca4:	fe842703          	lw	a4,-24(s0)
80005ca8:	479d                	li	a5,7
80005caa:	fce7ffe3          	bgeu	a5,a4,80005c88 <ADCSAR_SEQ_StructInit+0x7a>
    }
    InitStruct->DMAFIFOLevel = ADCSAR_SEQ_DMAFIFOLevel_1;
80005cae:	fdc42783          	lw	a5,-36(s0)
80005cb2:	4705                	li	a4,1
80005cb4:	d3b8                	sw	a4,96(a5)
    InitStruct->DMAEn = DISABLE;
80005cb6:	fdc42783          	lw	a5,-36(s0)
80005cba:	0607a223          	sw	zero,100(a5)
}
80005cbe:	0001                	nop
80005cc0:	5432                	lw	s0,44(sp)
80005cc2:	6145                	addi	sp,sp,48
80005cc4:	8082                	ret

80005cc6 <ADCSAR_DC_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_DC_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSAR_DC_Init(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Init_TypeDef* InitStruct)
{
80005cc6:	1101                	addi	sp,sp,-32
80005cc8:	ce06                	sw	ra,28(sp)
80005cca:	cc22                	sw	s0,24(sp)
80005ccc:	1000                	addi	s0,sp,32
80005cce:	fea42623          	sw	a0,-20(s0)
80005cd2:	feb42423          	sw	a1,-24(s0)
    ADCSAR_DC_OutputCmd(DC_Num, InitStruct->DCOutput);
80005cd6:	fe842783          	lw	a5,-24(s0)
80005cda:	439c                	lw	a5,0(a5)
80005cdc:	85be                	mv	a1,a5
80005cde:	fec42503          	lw	a0,-20(s0)
80005ce2:	3e5d                	jal	80005898 <ADCSAR_DC_OutputCmd>
    ADCSAR_DC_SetThresholdLow(DC_Num, InitStruct->ThresholdLow);
80005ce4:	fe842783          	lw	a5,-24(s0)
80005ce8:	43dc                	lw	a5,4(a5)
80005cea:	85be                	mv	a1,a5
80005cec:	fec42503          	lw	a0,-20(s0)
80005cf0:	31dd                	jal	800059d6 <ADCSAR_DC_SetThresholdLow>
    ADCSAR_DC_SetThresholdHigh(DC_Num, InitStruct->ThresholdHigh);
80005cf2:	fe842783          	lw	a5,-24(s0)
80005cf6:	479c                	lw	a5,8(a5)
80005cf8:	85be                	mv	a1,a5
80005cfa:	fec42503          	lw	a0,-20(s0)
80005cfe:	331d                	jal	80005a24 <ADCSAR_DC_SetThresholdHigh>
    ADCSAR_DC_SourceConfig(DC_Num, InitStruct->Source);
80005d00:	fe842783          	lw	a5,-24(s0)
80005d04:	47dc                	lw	a5,12(a5)
80005d06:	85be                	mv	a1,a5
80005d08:	fec42503          	lw	a0,-20(s0)
80005d0c:	3ed1                	jal	800058e0 <ADCSAR_DC_SourceConfig>
    ADCSAR_DC_ChannelConfig(DC_Num, InitStruct->Channel);
80005d0e:	fe842783          	lw	a5,-24(s0)
80005d12:	4b9c                	lw	a5,16(a5)
80005d14:	85be                	mv	a1,a5
80005d16:	fec42503          	lw	a0,-20(s0)
80005d1a:	3901                	jal	8000592a <ADCSAR_DC_ChannelConfig>
    ADCSAR_DC_Config(DC_Num, InitStruct->Mode, InitStruct->Condition);
80005d1c:	fe842783          	lw	a5,-24(s0)
80005d20:	4bd8                	lw	a4,20(a5)
80005d22:	fe842783          	lw	a5,-24(s0)
80005d26:	4f9c                	lw	a5,24(a5)
80005d28:	863e                	mv	a2,a5
80005d2a:	85ba                	mv	a1,a4
80005d2c:	fec42503          	lw	a0,-20(s0)
80005d30:	3191                	jal	80005974 <ADCSAR_DC_Config>
}
80005d32:	0001                	nop
80005d34:	40f2                	lw	ra,28(sp)
80005d36:	4462                	lw	s0,24(sp)
80005d38:	6105                	addi	sp,sp,32
80005d3a:	8082                	ret

80005d3c <ADCSAR_DC_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_DC_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSAR_DC_StructInit(ADCSAR_DC_Init_TypeDef* InitStruct)
{
80005d3c:	1101                	addi	sp,sp,-32
80005d3e:	ce22                	sw	s0,28(sp)
80005d40:	1000                	addi	s0,sp,32
80005d42:	fea42623          	sw	a0,-20(s0)
    InitStruct->DCOutput = DISABLE;
80005d46:	fec42783          	lw	a5,-20(s0)
80005d4a:	0007a023          	sw	zero,0(a5)
    InitStruct->ThresholdLow = 0;
80005d4e:	fec42783          	lw	a5,-20(s0)
80005d52:	0007a223          	sw	zero,4(a5)
    InitStruct->ThresholdHigh = 0;
80005d56:	fec42783          	lw	a5,-20(s0)
80005d5a:	0007a423          	sw	zero,8(a5)
    InitStruct->Source = ADCSAR_DC_Source_EOC;
80005d5e:	fec42783          	lw	a5,-20(s0)
80005d62:	0007a623          	sw	zero,12(a5)
    InitStruct->Channel = ADCSAR_CH_Num_0;
80005d66:	fec42783          	lw	a5,-20(s0)
80005d6a:	0007a823          	sw	zero,16(a5)
    InitStruct->Mode = ADCSAR_DC_Mode_Multiple;
80005d6e:	fec42783          	lw	a5,-20(s0)
80005d72:	0007aa23          	sw	zero,20(a5)
    InitStruct->Condition = ADCSAR_DC_Condition_Low;
80005d76:	fec42783          	lw	a5,-20(s0)
80005d7a:	0007ac23          	sw	zero,24(a5)
}
80005d7e:	0001                	nop
80005d80:	4472                	lw	s0,28(sp)
80005d82:	6105                	addi	sp,sp,32
80005d84:	8082                	ret

80005d86 <RCU_ADCSDRstCmd>:
  * @brief   Cнятие сброса АЦП сигма-дельта
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void RCU_ADCSDRstCmd(FunctionalState State)
{
80005d86:	1101                	addi	sp,sp,-32
80005d88:	ce22                	sw	s0,28(sp)
80005d8a:	1000                	addi	s0,sp,32
80005d8c:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(RCU->ADCSDCLKCFG_bit.RSTDIS, State);
80005d90:	3000e7b7          	lui	a5,0x3000e
80005d94:	fec42703          	lw	a4,-20(s0)
80005d98:	8b05                	andi	a4,a4,1
80005d9a:	0ff77713          	zext.b	a4,a4
80005d9e:	8b05                	andi	a4,a4,1
80005da0:	0722                	slli	a4,a4,0x8
80005da2:	0b47a683          	lw	a3,180(a5) # 3000e0b4 <STACK_SIZE+0x3000d8b4>
80005da6:	eff6f693          	andi	a3,a3,-257
80005daa:	8f55                	or	a4,a4,a3
80005dac:	0ae7aa23          	sw	a4,180(a5)
}
80005db0:	0001                	nop
80005db2:	4472                	lw	s0,28(sp)
80005db4:	6105                	addi	sp,sp,32
80005db6:	8082                	ret

80005db8 <ADCSD_WaitCycleCmd>:
  * @brief   Выбор количества тактов ожидания АЦП сигма-дельта
  * @param   waitClkAmount Количество тактов ожидания
  * @retval  void
  */
__STATIC_INLINE void ADCSD_WaitCycleCmd(uint32_t WaitCycle)
{
80005db8:	1101                	addi	sp,sp,-32
80005dba:	ce22                	sw	s0,28(sp)
80005dbc:	1000                	addi	s0,sp,32
80005dbe:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_WTCYC(WaitCycle));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_WTCYC_Msk, WaitCycle << ADCSD_CTRL_WTCYC_Pos);
80005dc2:	300127b7          	lui	a5,0x30012
80005dc6:	4398                	lw	a4,0(a5)
80005dc8:	fff907b7          	lui	a5,0xfff90
80005dcc:	17fd                	addi	a5,a5,-1 # fff8ffff <__data_source_start+0x7ff865db>
80005dce:	00f776b3          	and	a3,a4,a5
80005dd2:	fec42783          	lw	a5,-20(s0)
80005dd6:	01079713          	slli	a4,a5,0x10
80005dda:	300127b7          	lui	a5,0x30012
80005dde:	8f55                	or	a4,a4,a3
80005de0:	c398                	sw	a4,0(a5)
}
80005de2:	0001                	nop
80005de4:	4472                	lw	s0,28(sp)
80005de6:	6105                	addi	sp,sp,32
80005de8:	8082                	ret

80005dea <ADCSD_MainDivCmd>:
  * @brief   Выбор основного делителя частоты АЦП сигма-дельта
  * @param   mainDiv Значение основного делителя частоты
  * @retval  void
  */
__STATIC_INLINE void ADCSD_MainDivCmd(ADCSD_MainDiv_TypeDef mainDiv)
{
80005dea:	1101                	addi	sp,sp,-32
80005dec:	ce22                	sw	s0,28(sp)
80005dee:	1000                	addi	s0,sp,32
80005df0:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_MAINDIV(mainDiv));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_MDC_Msk, mainDiv << ADCSD_CTRL_MDC_Pos);
80005df4:	300127b7          	lui	a5,0x30012
80005df8:	4398                	lw	a4,0(a5)
80005dfa:	77e5                	lui	a5,0xffff9
80005dfc:	17fd                	addi	a5,a5,-1 # ffff8fff <__data_source_start+0x7ffef5db>
80005dfe:	00f776b3          	and	a3,a4,a5
80005e02:	fec42783          	lw	a5,-20(s0)
80005e06:	00c79713          	slli	a4,a5,0xc
80005e0a:	300127b7          	lui	a5,0x30012
80005e0e:	8f55                	or	a4,a4,a3
80005e10:	c398                	sw	a4,0(a5)
}
80005e12:	0001                	nop
80005e14:	4472                	lw	s0,28(sp)
80005e16:	6105                	addi	sp,sp,32
80005e18:	8082                	ret

80005e1a <ADCSD_SampleDivCmd>:
  * @brief   Выбор делителя коэффициента прореживания АЦП сигма-дельта
  * @param   sampleDiv Значение делителя коэффициента прореживания
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SampleDivCmd(ADCSD_SamleDiv_TypeDef sampleDiv)
{
80005e1a:	1101                	addi	sp,sp,-32
80005e1c:	ce22                	sw	s0,28(sp)
80005e1e:	1000                	addi	s0,sp,32
80005e20:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_SAMPLEDIV(sampleDiv));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_DR_Msk, sampleDiv << ADCSD_CTRL_DR_Pos);
80005e24:	300127b7          	lui	a5,0x30012
80005e28:	439c                	lw	a5,0(a5)
80005e2a:	cff7f693          	andi	a3,a5,-769
80005e2e:	fec42783          	lw	a5,-20(s0)
80005e32:	00879713          	slli	a4,a5,0x8
80005e36:	300127b7          	lui	a5,0x30012
80005e3a:	8f55                	or	a4,a4,a3
80005e3c:	c398                	sw	a4,0(a5)
}
80005e3e:	0001                	nop
80005e40:	4472                	lw	s0,28(sp)
80005e42:	6105                	addi	sp,sp,32
80005e44:	8082                	ret

80005e46 <ADCSD_SetMode>:
  * @param   ch_num Выбор канала АЦП
  * @param   mode Выбор режима
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SetMode(ADCSD_CH_Num_TypeDef ch_num, ADCSD_MODE_TypeDef mode)
{
80005e46:	1101                	addi	sp,sp,-32
80005e48:	ce22                	sw	s0,28(sp)
80005e4a:	1000                	addi	s0,sp,32
80005e4c:	fea42623          	sw	a0,-20(s0)
80005e50:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_ADCSD_CH_NUM(ch_num));
	assert_param(IS_ADCSD_MODE(mode));

	MODIFY_REG(ADCSD->MODE, ADCSD_MODE_CH0_Msk << ((uint32_t)ch_num << 2), mode << ((uint32_t)ch_num << 2));
80005e54:	300127b7          	lui	a5,0x30012
80005e58:	43d8                	lw	a4,4(a5)
80005e5a:	fec42783          	lw	a5,-20(s0)
80005e5e:	078a                	slli	a5,a5,0x2
80005e60:	468d                	li	a3,3
80005e62:	00f697b3          	sll	a5,a3,a5
80005e66:	fff7c793          	not	a5,a5
80005e6a:	00f776b3          	and	a3,a4,a5
80005e6e:	fec42783          	lw	a5,-20(s0)
80005e72:	078a                	slli	a5,a5,0x2
80005e74:	fe842703          	lw	a4,-24(s0)
80005e78:	00f71733          	sll	a4,a4,a5
80005e7c:	300127b7          	lui	a5,0x30012
80005e80:	8f55                	or	a4,a4,a3
80005e82:	c3d8                	sw	a4,4(a5)
}
80005e84:	0001                	nop
80005e86:	4472                	lw	s0,28(sp)
80005e88:	6105                	addi	sp,sp,32
80005e8a:	8082                	ret

80005e8c <ADCSD_SetAmplification>:
  * @param   ch_num Выбор канала АЦП сигма-дельта
  * @param 	 ampl Выбор усиления канала
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SetAmplification(ADCSD_CH_Num_TypeDef ch_num, ADCSD_AMPL_TypeDef ampl)
{
80005e8c:	1101                	addi	sp,sp,-32
80005e8e:	ce22                	sw	s0,28(sp)
80005e90:	1000                	addi	s0,sp,32
80005e92:	fea42623          	sw	a0,-20(s0)
80005e96:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_ADCSD_CH_NUM(ch_num));
	assert_param(IS_ADCSD_AMPL(ampl));

	MODIFY_REG(ADCSD->AMPL, ADCSD_AMPL_CH0_Msk << ((uint32_t)ch_num << 2), (uint32_t)ampl << ((uint32_t)ch_num << 2));
80005e9a:	300127b7          	lui	a5,0x30012
80005e9e:	4798                	lw	a4,8(a5)
80005ea0:	fec42783          	lw	a5,-20(s0)
80005ea4:	078a                	slli	a5,a5,0x2
80005ea6:	469d                	li	a3,7
80005ea8:	00f697b3          	sll	a5,a3,a5
80005eac:	fff7c793          	not	a5,a5
80005eb0:	00f776b3          	and	a3,a4,a5
80005eb4:	fec42783          	lw	a5,-20(s0)
80005eb8:	078a                	slli	a5,a5,0x2
80005eba:	fe842703          	lw	a4,-24(s0)
80005ebe:	00f71733          	sll	a4,a4,a5
80005ec2:	300127b7          	lui	a5,0x30012
80005ec6:	8f55                	or	a4,a4,a3
80005ec8:	c798                	sw	a4,8(a5)
}
80005eca:	0001                	nop
80005ecc:	4472                	lw	s0,28(sp)
80005ece:	6105                	addi	sp,sp,32
80005ed0:	8082                	ret

80005ed2 <ADCSD_DeInit>:
/**
  * @brief   Устанавливает все регистры ADCSD значениями по умолчанию
  * @retval  void
  */
void ADCSD_DeInit(void)
{
80005ed2:	1141                	addi	sp,sp,-16
80005ed4:	c606                	sw	ra,12(sp)
80005ed6:	c422                	sw	s0,8(sp)
80005ed8:	0800                	addi	s0,sp,16
    RCU_ADCSDRstCmd(DISABLE);
80005eda:	4501                	li	a0,0
80005edc:	356d                	jal	80005d86 <RCU_ADCSDRstCmd>
    RCU_ADCSDRstCmd(ENABLE);
80005ede:	4505                	li	a0,1
80005ee0:	355d                	jal	80005d86 <RCU_ADCSDRstCmd>
}
80005ee2:	0001                	nop
80005ee4:	40b2                	lw	ra,12(sp)
80005ee6:	4422                	lw	s0,8(sp)
80005ee8:	0141                	addi	sp,sp,16
80005eea:	8082                	ret

80005eec <ADCSD_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSD_Init(ADCSD_Init_TypeDef* InitStruct)
{
80005eec:	1101                	addi	sp,sp,-32
80005eee:	ce06                	sw	ra,28(sp)
80005ef0:	cc22                	sw	s0,24(sp)
80005ef2:	1000                	addi	s0,sp,32
80005ef4:	fea42623          	sw	a0,-20(s0)
	ADCSD_WaitCycleCmd(InitStruct->WaitCycle);
80005ef8:	fec42783          	lw	a5,-20(s0)
80005efc:	439c                	lw	a5,0(a5)
80005efe:	853e                	mv	a0,a5
80005f00:	3d65                	jal	80005db8 <ADCSD_WaitCycleCmd>
	ADCSD_MainDivCmd(InitStruct->MainDiv);
80005f02:	fec42783          	lw	a5,-20(s0)
80005f06:	43dc                	lw	a5,4(a5)
80005f08:	853e                	mv	a0,a5
80005f0a:	35c5                	jal	80005dea <ADCSD_MainDivCmd>
	ADCSD_SampleDivCmd(InitStruct->SampleDiv);
80005f0c:	fec42783          	lw	a5,-20(s0)
80005f10:	479c                	lw	a5,8(a5)
80005f12:	853e                	mv	a0,a5
80005f14:	3719                	jal	80005e1a <ADCSD_SampleDivCmd>
}
80005f16:	0001                	nop
80005f18:	40f2                	lw	ra,28(sp)
80005f1a:	4462                	lw	s0,24(sp)
80005f1c:	6105                	addi	sp,sp,32
80005f1e:	8082                	ret

80005f20 <ADCSD_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSD_StructInit(ADCSD_Init_TypeDef* InitStruct)
{
80005f20:	1101                	addi	sp,sp,-32
80005f22:	ce22                	sw	s0,28(sp)
80005f24:	1000                	addi	s0,sp,32
80005f26:	fea42623          	sw	a0,-20(s0)
	InitStruct->MainDiv = 0x0;
80005f2a:	fec42783          	lw	a5,-20(s0)
80005f2e:	0007a223          	sw	zero,4(a5) # 30012004 <STACK_SIZE+0x30011804>
	InitStruct->SampleDiv = 0x0;
80005f32:	fec42783          	lw	a5,-20(s0)
80005f36:	0007a423          	sw	zero,8(a5)
	InitStruct->WaitCycle = 0x0;
80005f3a:	fec42783          	lw	a5,-20(s0)
80005f3e:	0007a023          	sw	zero,0(a5)
}
80005f42:	0001                	nop
80005f44:	4472                	lw	s0,28(sp)
80005f46:	6105                	addi	sp,sp,32
80005f48:	8082                	ret

80005f4a <ADCSD_CH_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_CH_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSD_CH_Init(ADCSD_CH_Num_TypeDef ch_num, ADCSD_CH_Init_TypeDef* InitStruct)
{
80005f4a:	1101                	addi	sp,sp,-32
80005f4c:	ce06                	sw	ra,28(sp)
80005f4e:	cc22                	sw	s0,24(sp)
80005f50:	1000                	addi	s0,sp,32
80005f52:	fea42623          	sw	a0,-20(s0)
80005f56:	feb42423          	sw	a1,-24(s0)
	ADCSD_SetMode(ch_num, InitStruct->Mode);
80005f5a:	fe842783          	lw	a5,-24(s0)
80005f5e:	439c                	lw	a5,0(a5)
80005f60:	85be                	mv	a1,a5
80005f62:	fec42503          	lw	a0,-20(s0)
80005f66:	35c5                	jal	80005e46 <ADCSD_SetMode>
	ADCSD_SetAmplification(ch_num, InitStruct->Amplifier);
80005f68:	fe842783          	lw	a5,-24(s0)
80005f6c:	43dc                	lw	a5,4(a5)
80005f6e:	85be                	mv	a1,a5
80005f70:	fec42503          	lw	a0,-20(s0)
80005f74:	3f21                	jal	80005e8c <ADCSD_SetAmplification>
}
80005f76:	0001                	nop
80005f78:	40f2                	lw	ra,28(sp)
80005f7a:	4462                	lw	s0,24(sp)
80005f7c:	6105                	addi	sp,sp,32
80005f7e:	8082                	ret

80005f80 <ADCSD_CH_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_CH_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSD_CH_StructInit(ADCSD_CH_Init_TypeDef* InitStruct)
{
80005f80:	1101                	addi	sp,sp,-32
80005f82:	ce22                	sw	s0,28(sp)
80005f84:	1000                	addi	s0,sp,32
80005f86:	fea42623          	sw	a0,-20(s0)
	InitStruct->Amplifier = 0x0;
80005f8a:	fec42783          	lw	a5,-20(s0)
80005f8e:	0007a223          	sw	zero,4(a5)
	InitStruct->Mode = 0x1;
80005f92:	fec42783          	lw	a5,-20(s0)
80005f96:	4705                	li	a4,1
80005f98:	c398                	sw	a4,0(a5)
}
80005f9a:	0001                	nop
80005f9c:	4472                	lw	s0,28(sp)
80005f9e:	6105                	addi	sp,sp,32
80005fa0:	8082                	ret

80005fa2 <RCU_AHBRstCmd>:
{
80005fa2:	1101                	addi	sp,sp,-32
80005fa4:	ce22                	sw	s0,28(sp)
80005fa6:	1000                	addi	s0,sp,32
80005fa8:	fea42623          	sw	a0,-20(s0)
80005fac:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80005fb0:	3000e7b7          	lui	a5,0x3000e
80005fb4:	4b98                	lw	a4,16(a5)
80005fb6:	fec42783          	lw	a5,-20(s0)
80005fba:	fff7c793          	not	a5,a5
80005fbe:	00f776b3          	and	a3,a4,a5
80005fc2:	fe842783          	lw	a5,-24(s0)
80005fc6:	c781                	beqz	a5,80005fce <RCU_AHBRstCmd+0x2c>
80005fc8:	fec42783          	lw	a5,-20(s0)
80005fcc:	a011                	j	80005fd0 <RCU_AHBRstCmd+0x2e>
80005fce:	4781                	li	a5,0
80005fd0:	3000e737          	lui	a4,0x3000e
80005fd4:	8fd5                	or	a5,a5,a3
80005fd6:	cb1c                	sw	a5,16(a4)
}
80005fd8:	0001                	nop
80005fda:	4472                	lw	s0,28(sp)
80005fdc:	6105                	addi	sp,sp,32
80005fde:	8082                	ret

80005fe0 <CRC_ResetCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   state Бит сброса
  * @retval  void
  */
__STATIC_INLINE void CRC_ResetCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
80005fe0:	1101                	addi	sp,sp,-32
80005fe2:	ce22                	sw	s0,28(sp)
80005fe4:	1000                	addi	s0,sp,32
80005fe6:	fea42623          	sw	a0,-20(s0)
80005fea:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_RESET_Msk, state << CRC_CR_RESET_Pos);
80005fee:	fec42783          	lw	a5,-20(s0)
80005ff2:	479c                	lw	a5,8(a5)
80005ff4:	ffe7f713          	andi	a4,a5,-2
80005ff8:	fe842783          	lw	a5,-24(s0)
80005ffc:	8f5d                	or	a4,a4,a5
80005ffe:	fec42783          	lw	a5,-20(s0)
80006002:	c798                	sw	a4,8(a5)
}
80006004:	0001                	nop
80006006:	4472                	lw	s0,28(sp)
80006008:	6105                	addi	sp,sp,32
8000600a:	8082                	ret

8000600c <CRC_ModeCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   state Выбор режима
  * @retval  void
  */
__STATIC_INLINE void CRC_ModeCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
8000600c:	1101                	addi	sp,sp,-32
8000600e:	ce22                	sw	s0,28(sp)
80006010:	1000                	addi	s0,sp,32
80006012:	fea42623          	sw	a0,-20(s0)
80006016:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_MODE_Msk, state << CRC_CR_MODE_Pos);
8000601a:	fec42783          	lw	a5,-20(s0)
8000601e:	479c                	lw	a5,8(a5)
80006020:	ffd7f713          	andi	a4,a5,-3
80006024:	fe842783          	lw	a5,-24(s0)
80006028:	0786                	slli	a5,a5,0x1
8000602a:	8f5d                	or	a4,a4,a5
8000602c:	fec42783          	lw	a5,-20(s0)
80006030:	c798                	sw	a4,8(a5)
}
80006032:	0001                	nop
80006034:	4472                	lw	s0,28(sp)
80006036:	6105                	addi	sp,sp,32
80006038:	8082                	ret

8000603a <CRC_XOROutCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   state Выбор режима
  * @retval  void
  */
__STATIC_INLINE void CRC_XOROutCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
8000603a:	1101                	addi	sp,sp,-32
8000603c:	ce22                	sw	s0,28(sp)
8000603e:	1000                	addi	s0,sp,32
80006040:	fea42623          	sw	a0,-20(s0)
80006044:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_XOROUT_Msk, state << CRC_CR_XOROUT_Pos);
80006048:	fec42783          	lw	a5,-20(s0)
8000604c:	479c                	lw	a5,8(a5)
8000604e:	ffb7f713          	andi	a4,a5,-5
80006052:	fe842783          	lw	a5,-24(s0)
80006056:	078a                	slli	a5,a5,0x2
80006058:	8f5d                	or	a4,a4,a5
8000605a:	fec42783          	lw	a5,-20(s0)
8000605e:	c798                	sw	a4,8(a5)
}
80006060:	0001                	nop
80006062:	4472                	lw	s0,28(sp)
80006064:	6105                	addi	sp,sp,32
80006066:	8082                	ret

80006068 <CRC_SetPolysize>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   polysize размер порождающего полинома
  * @retval  void
  */
__STATIC_INLINE void CRC_SetPolysize(CRC_TypeDef* CRCx, CRC_POLYSIZE_TypeDef polysize)
{
80006068:	1101                	addi	sp,sp,-32
8000606a:	ce22                	sw	s0,28(sp)
8000606c:	1000                	addi	s0,sp,32
8000606e:	fea42623          	sw	a0,-20(s0)
80006072:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_CRC_POLYSIZE(polysize));

	MODIFY_REG(CRCx->CR, CRC_CR_POLYSIZE_Msk, polysize << CRC_CR_POLYSIZE_Pos);
80006076:	fec42783          	lw	a5,-20(s0)
8000607a:	479c                	lw	a5,8(a5)
8000607c:	fe77f713          	andi	a4,a5,-25
80006080:	fe842783          	lw	a5,-24(s0)
80006084:	078e                	slli	a5,a5,0x3
80006086:	8f5d                	or	a4,a4,a5
80006088:	fec42783          	lw	a5,-20(s0)
8000608c:	c798                	sw	a4,8(a5)
}
8000608e:	0001                	nop
80006090:	4472                	lw	s0,28(sp)
80006092:	6105                	addi	sp,sp,32
80006094:	8082                	ret

80006096 <CRC_SetRevIn>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   revin Обращение входных данных
  * @retval  void
  */
__STATIC_INLINE void CRC_SetRevIn(CRC_TypeDef* CRCx, CRC_REV_IN_TypeDef revin)
{
80006096:	1101                	addi	sp,sp,-32
80006098:	ce22                	sw	s0,28(sp)
8000609a:	1000                	addi	s0,sp,32
8000609c:	fea42623          	sw	a0,-20(s0)
800060a0:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_CRC_REV_IN(revin));

	MODIFY_REG(CRCx->CR, CRC_CR_REV_IN_Msk, revin << CRC_CR_REV_IN_Pos);
800060a4:	fec42783          	lw	a5,-20(s0)
800060a8:	479c                	lw	a5,8(a5)
800060aa:	f9f7f713          	andi	a4,a5,-97
800060ae:	fe842783          	lw	a5,-24(s0)
800060b2:	0796                	slli	a5,a5,0x5
800060b4:	8f5d                	or	a4,a4,a5
800060b6:	fec42783          	lw	a5,-20(s0)
800060ba:	c798                	sw	a4,8(a5)
}
800060bc:	0001                	nop
800060be:	4472                	lw	s0,28(sp)
800060c0:	6105                	addi	sp,sp,32
800060c2:	8082                	ret

800060c4 <CRC_RevOutCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param	 state бит обращения выходных данных
  * @retval  void
  */
__STATIC_INLINE void CRC_RevOutCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
800060c4:	1101                	addi	sp,sp,-32
800060c6:	ce22                	sw	s0,28(sp)
800060c8:	1000                	addi	s0,sp,32
800060ca:	fea42623          	sw	a0,-20(s0)
800060ce:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_REV_OUT_Msk, state << CRC_CR_REV_OUT_Pos);
800060d2:	fec42783          	lw	a5,-20(s0)
800060d6:	479c                	lw	a5,8(a5)
800060d8:	f7f7f713          	andi	a4,a5,-129
800060dc:	fe842783          	lw	a5,-24(s0)
800060e0:	079e                	slli	a5,a5,0x7
800060e2:	8f5d                	or	a4,a4,a5
800060e4:	fec42783          	lw	a5,-20(s0)
800060e8:	c798                	sw	a4,8(a5)
}
800060ea:	0001                	nop
800060ec:	4472                	lw	s0,28(sp)
800060ee:	6105                	addi	sp,sp,32
800060f0:	8082                	ret

800060f2 <CRC_SetInit>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   val Начальное значение блока
  * @retval  void
  */
__STATIC_INLINE void CRC_SetInit(CRC_TypeDef* CRCx, uint32_t val)
{
800060f2:	1101                	addi	sp,sp,-32
800060f4:	ce22                	sw	s0,28(sp)
800060f6:	1000                	addi	s0,sp,32
800060f8:	fea42623          	sw	a0,-20(s0)
800060fc:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	WRITE_REG(CRCx->INIT, val);
80006100:	fec42783          	lw	a5,-20(s0)
80006104:	fe842703          	lw	a4,-24(s0)
80006108:	c7d8                	sw	a4,12(a5)
}
8000610a:	0001                	nop
8000610c:	4472                	lw	s0,28(sp)
8000610e:	6105                	addi	sp,sp,32
80006110:	8082                	ret

80006112 <CRC_SetPol>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   val Значение коэффициентов порождающего полинома
  * @retval  void
  */
__STATIC_INLINE void CRC_SetPol(CRC_TypeDef* CRCx, uint32_t val)
{
80006112:	1101                	addi	sp,sp,-32
80006114:	ce22                	sw	s0,28(sp)
80006116:	1000                	addi	s0,sp,32
80006118:	fea42623          	sw	a0,-20(s0)
8000611c:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	WRITE_REG(CRCx->POL, val);
80006120:	fec42783          	lw	a5,-20(s0)
80006124:	fe842703          	lw	a4,-24(s0)
80006128:	cb98                	sw	a4,16(a5)
}
8000612a:	0001                	nop
8000612c:	4472                	lw	s0,28(sp)
8000612e:	6105                	addi	sp,sp,32
80006130:	8082                	ret

80006132 <CRC_DeInit>:
/**
  * @brief   Устанавливает все регистры CRC значениями по умолчанию
  * @retval  void
  */
void CRC_DeInit(CRC_TypeDef* CRCx)
{
80006132:	7179                	addi	sp,sp,-48
80006134:	d606                	sw	ra,44(sp)
80006136:	d422                	sw	s0,40(sp)
80006138:	1800                	addi	s0,sp,48
8000613a:	fca42e23          	sw	a0,-36(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	CRC_ResetCmd(CRCx, ENABLE);
8000613e:	4585                	li	a1,1
80006140:	fdc42503          	lw	a0,-36(s0)
80006144:	3d71                	jal	80005fe0 <CRC_ResetCmd>
	CRC_ResetCmd(CRCx, DISABLE);
80006146:	4581                	li	a1,0
80006148:	fdc42503          	lw	a0,-36(s0)
8000614c:	3d51                	jal	80005fe0 <CRC_ResetCmd>
	uint32_t CRC_num = (CRCx == CRC0) ? RCU_AHBRst_CRC0 : RCU_AHBRst_CRC1;
8000614e:	fdc42703          	lw	a4,-36(s0)
80006152:	200307b7          	lui	a5,0x20030
80006156:	00f71463          	bne	a4,a5,8000615e <CRC_DeInit+0x2c>
8000615a:	6785                	lui	a5,0x1
8000615c:	a011                	j	80006160 <CRC_DeInit+0x2e>
8000615e:	6789                	lui	a5,0x2
80006160:	fef42623          	sw	a5,-20(s0)
    RCU_AHBRstCmd(CRC_num, DISABLE);
80006164:	4581                	li	a1,0
80006166:	fec42503          	lw	a0,-20(s0)
8000616a:	3d25                	jal	80005fa2 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(CRC_num, ENABLE);
8000616c:	4585                	li	a1,1
8000616e:	fec42503          	lw	a0,-20(s0)
80006172:	3d05                	jal	80005fa2 <RCU_AHBRstCmd>
}
80006174:	0001                	nop
80006176:	50b2                	lw	ra,44(sp)
80006178:	5422                	lw	s0,40(sp)
8000617a:	6145                	addi	sp,sp,48
8000617c:	8082                	ret

8000617e <CRC_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref CRC_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void CRC_Init(CRC_TypeDef* CRCx, CRC_Init_TypeDef* InitStruct)
{
8000617e:	1101                	addi	sp,sp,-32
80006180:	ce06                	sw	ra,28(sp)
80006182:	cc22                	sw	s0,24(sp)
80006184:	1000                	addi	s0,sp,32
80006186:	fea42623          	sw	a0,-20(s0)
8000618a:	feb42423          	sw	a1,-24(s0)
	CRC_SetInit(CRCx, InitStruct->Init);
8000618e:	fe842783          	lw	a5,-24(s0)
80006192:	439c                	lw	a5,0(a5)
80006194:	85be                	mv	a1,a5
80006196:	fec42503          	lw	a0,-20(s0)
8000619a:	3fa1                	jal	800060f2 <CRC_SetInit>
	CRC_SetRevIn(CRCx, InitStruct->RevIn);
8000619c:	fe842783          	lw	a5,-24(s0)
800061a0:	43dc                	lw	a5,4(a5)
800061a2:	85be                	mv	a1,a5
800061a4:	fec42503          	lw	a0,-20(s0)
800061a8:	35fd                	jal	80006096 <CRC_SetRevIn>
	CRC_RevOutCmd(CRCx, InitStruct->RevOut);
800061aa:	fe842783          	lw	a5,-24(s0)
800061ae:	479c                	lw	a5,8(a5)
800061b0:	85be                	mv	a1,a5
800061b2:	fec42503          	lw	a0,-20(s0)
800061b6:	3739                	jal	800060c4 <CRC_RevOutCmd>
	CRC_ModeCmd(CRCx, InitStruct->Mode);
800061b8:	fe842783          	lw	a5,-24(s0)
800061bc:	47dc                	lw	a5,12(a5)
800061be:	85be                	mv	a1,a5
800061c0:	fec42503          	lw	a0,-20(s0)
800061c4:	35a1                	jal	8000600c <CRC_ModeCmd>
	CRC_XOROutCmd(CRCx, InitStruct->XorOut);
800061c6:	fe842783          	lw	a5,-24(s0)
800061ca:	4b9c                	lw	a5,16(a5)
800061cc:	85be                	mv	a1,a5
800061ce:	fec42503          	lw	a0,-20(s0)
800061d2:	35a5                	jal	8000603a <CRC_XOROutCmd>
	CRC_SetPolysize(CRCx, InitStruct->Polysize);
800061d4:	fe842783          	lw	a5,-24(s0)
800061d8:	4bdc                	lw	a5,20(a5)
800061da:	85be                	mv	a1,a5
800061dc:	fec42503          	lw	a0,-20(s0)
800061e0:	3561                	jal	80006068 <CRC_SetPolysize>
	CRC_SetPol(CRCx, InitStruct->Pol);
800061e2:	fe842783          	lw	a5,-24(s0)
800061e6:	4f9c                	lw	a5,24(a5)
800061e8:	85be                	mv	a1,a5
800061ea:	fec42503          	lw	a0,-20(s0)
800061ee:	3715                	jal	80006112 <CRC_SetPol>
}
800061f0:	0001                	nop
800061f2:	40f2                	lw	ra,28(sp)
800061f4:	4462                	lw	s0,24(sp)
800061f6:	6105                	addi	sp,sp,32
800061f8:	8082                	ret

800061fa <CRC_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref CRC_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void CRC_StructInit(CRC_Init_TypeDef* InitStruct)
{
800061fa:	1101                	addi	sp,sp,-32
800061fc:	ce22                	sw	s0,28(sp)
800061fe:	1000                	addi	s0,sp,32
80006200:	fea42623          	sw	a0,-20(s0)
	InitStruct->Init = 0x0;
80006204:	fec42783          	lw	a5,-20(s0)
80006208:	0007a023          	sw	zero,0(a5) # 2000 <STACK_SIZE+0x1800>
	InitStruct->RevIn = 0x0;
8000620c:	fec42783          	lw	a5,-20(s0)
80006210:	0007a223          	sw	zero,4(a5)
	InitStruct->RevOut = 0x0;
80006214:	fec42783          	lw	a5,-20(s0)
80006218:	0007a423          	sw	zero,8(a5)
	InitStruct->Mode = 0x0;
8000621c:	fec42783          	lw	a5,-20(s0)
80006220:	0007a623          	sw	zero,12(a5)
	InitStruct->XorOut = 0x0;
80006224:	fec42783          	lw	a5,-20(s0)
80006228:	0007a823          	sw	zero,16(a5)
	InitStruct->Polysize = 0x0;
8000622c:	fec42783          	lw	a5,-20(s0)
80006230:	0007aa23          	sw	zero,20(a5)
	InitStruct->Pol = 0x4C11DB7;	// CRC-32 (Ethernet)
80006234:	fec42783          	lw	a5,-20(s0)
80006238:	04c12737          	lui	a4,0x4c12
8000623c:	db770713          	addi	a4,a4,-585 # 4c11db7 <STACK_SIZE+0x4c115b7>
80006240:	cf98                	sw	a4,24(a5)
}
80006242:	0001                	nop
80006244:	4472                	lw	s0,28(sp)
80006246:	6105                	addi	sp,sp,32
80006248:	8082                	ret

8000624a <RCU_AHBRstCmd>:
{
8000624a:	1101                	addi	sp,sp,-32
8000624c:	ce22                	sw	s0,28(sp)
8000624e:	1000                	addi	s0,sp,32
80006250:	fea42623          	sw	a0,-20(s0)
80006254:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80006258:	3000e7b7          	lui	a5,0x3000e
8000625c:	4b98                	lw	a4,16(a5)
8000625e:	fec42783          	lw	a5,-20(s0)
80006262:	fff7c793          	not	a5,a5
80006266:	00f776b3          	and	a3,a4,a5
8000626a:	fe842783          	lw	a5,-24(s0)
8000626e:	c781                	beqz	a5,80006276 <RCU_AHBRstCmd+0x2c>
80006270:	fec42783          	lw	a5,-20(s0)
80006274:	a011                	j	80006278 <RCU_AHBRstCmd+0x2e>
80006276:	4781                	li	a5,0
80006278:	3000e737          	lui	a4,0x3000e
8000627c:	8fd5                	or	a5,a5,a3
8000627e:	cb1c                	sw	a5,16(a4)
}
80006280:	0001                	nop
80006282:	4472                	lw	s0,28(sp)
80006284:	6105                	addi	sp,sp,32
80006286:	8082                	ret

80006288 <CRYPTO_UpdateKeyCmd>:
  * 		 или регистров KEY_0...KEY_3 для алгоритма AES-128
  * @pararm  state флаг обновления ключа
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_UpdateKeyCmd(FunctionalState state)
{
80006288:	1101                	addi	sp,sp,-32
8000628a:	ce22                	sw	s0,28(sp)
8000628c:	1000                	addi	s0,sp,32
8000628e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_UPDATE_KEY_Msk, state << CRYPTO_CONTROL_UPDATE_KEY_Pos);
80006292:	200207b7          	lui	a5,0x20020
80006296:	43fc                	lw	a5,68(a5)
80006298:	ffe7f693          	andi	a3,a5,-2
8000629c:	200207b7          	lui	a5,0x20020
800062a0:	fec42703          	lw	a4,-20(s0)
800062a4:	8f55                	or	a4,a4,a3
800062a6:	c3f8                	sw	a4,68(a5)
}
800062a8:	0001                	nop
800062aa:	4472                	lw	s0,28(sp)
800062ac:	6105                	addi	sp,sp,32
800062ae:	8082                	ret

800062b0 <CRYPTO_DirectionConfig>:
  * @brief   Выбор направления криптографической операции
  * @param   dir Направление криптографической операции 0 - кодирование, 1 - декодирование
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DirectionConfig(CRYPTO_Dir_TypeDef dir)
{
800062b0:	1101                	addi	sp,sp,-32
800062b2:	ce22                	sw	s0,28(sp)
800062b4:	1000                	addi	s0,sp,32
800062b6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_DIR(dir));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_DIRECTION_Msk, dir << CRYPTO_CONTROL_DIRECTION_Pos);
800062ba:	200207b7          	lui	a5,0x20020
800062be:	43fc                	lw	a5,68(a5)
800062c0:	ffb7f693          	andi	a3,a5,-5
800062c4:	fec42783          	lw	a5,-20(s0)
800062c8:	00279713          	slli	a4,a5,0x2
800062cc:	200207b7          	lui	a5,0x20020
800062d0:	8f55                	or	a4,a4,a3
800062d2:	c3f8                	sw	a4,68(a5)
}
800062d4:	0001                	nop
800062d6:	4472                	lw	s0,28(sp)
800062d8:	6105                	addi	sp,sp,32
800062da:	8082                	ret

800062dc <CRYPTO_AlgoConfig>:
  * @brief   Выбор криптографической алгоритма операции
  * @param   algo алгоритм криптографической операции
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_AlgoConfig(CRYPTO_Algo_TypeDef algo)
{
800062dc:	1101                	addi	sp,sp,-32
800062de:	ce22                	sw	s0,28(sp)
800062e0:	1000                	addi	s0,sp,32
800062e2:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_ALGO(algo));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_ALGORITHM_Msk, algo << CRYPTO_CONTROL_ALGORITHM_Pos);
800062e6:	200207b7          	lui	a5,0x20020
800062ea:	43fc                	lw	a5,68(a5)
800062ec:	fe77f693          	andi	a3,a5,-25
800062f0:	fec42783          	lw	a5,-20(s0)
800062f4:	00379713          	slli	a4,a5,0x3
800062f8:	200207b7          	lui	a5,0x20020
800062fc:	8f55                	or	a4,a4,a3
800062fe:	c3f8                	sw	a4,68(a5)
}
80006300:	0001                	nop
80006302:	4472                	lw	s0,28(sp)
80006304:	6105                	addi	sp,sp,32
80006306:	8082                	ret

80006308 <CRYPTO_ModeConfig>:
  * @brief   Выбор режима выполнения криптографической операции
  * @param   mode режим выполнения криптографической операции
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_ModeConfig(CRYPTO_Mode_TypeDef mode)
{
80006308:	1101                	addi	sp,sp,-32
8000630a:	ce22                	sw	s0,28(sp)
8000630c:	1000                	addi	s0,sp,32
8000630e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_MODE(mode));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_MODE_Msk, mode << CRYPTO_CONTROL_MODE_Pos);
80006312:	200207b7          	lui	a5,0x20020
80006316:	43fc                	lw	a5,68(a5)
80006318:	f9f7f693          	andi	a3,a5,-97
8000631c:	fec42783          	lw	a5,-20(s0)
80006320:	00579713          	slli	a4,a5,0x5
80006324:	200207b7          	lui	a5,0x20020
80006328:	8f55                	or	a4,a4,a3
8000632a:	c3f8                	sw	a4,68(a5)
}
8000632c:	0001                	nop
8000632e:	4472                	lw	s0,28(sp)
80006330:	6105                	addi	sp,sp,32
80006332:	8082                	ret

80006334 <CRYPTO_InitVectorAutoUpdateCmd>:
  * @brief   Разрешение автоматического обновления регистров IV_* при завершении криптографической операции
  * @param   state флаг разрешения
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_InitVectorAutoUpdateCmd(FunctionalState state)
{
80006334:	1101                	addi	sp,sp,-32
80006336:	ce22                	sw	s0,28(sp)
80006338:	1000                	addi	s0,sp,32
8000633a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_SELF_UPDATE_Msk, state << CRYPTO_CONTROL_SELF_UPDATE_Pos);
8000633e:	200207b7          	lui	a5,0x20020
80006342:	43fc                	lw	a5,68(a5)
80006344:	eff7f693          	andi	a3,a5,-257
80006348:	fec42783          	lw	a5,-20(s0)
8000634c:	00879713          	slli	a4,a5,0x8
80006350:	200207b7          	lui	a5,0x20020
80006354:	8f55                	or	a4,a4,a3
80006356:	c3f8                	sw	a4,68(a5)
}
80006358:	0001                	nop
8000635a:	4472                	lw	s0,28(sp)
8000635c:	6105                	addi	sp,sp,32
8000635e:	8082                	ret

80006360 <CRYPTO_SetKeyInReg>:
  * @param   idx индекс в массиве раундовых ключей
  * @param   val значение элемента раундового ключа
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_SetKeyInReg(uint32_t idx, uint32_t val)
{
80006360:	1101                	addi	sp,sp,-32
80006362:	ce22                	sw	s0,28(sp)
80006364:	1000                	addi	s0,sp,32
80006366:	fea42623          	sw	a0,-20(s0)
8000636a:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRYPTO_KEY(idx));

	WRITE_REG(CRYPTO->KEY[idx], val);
8000636e:	20020737          	lui	a4,0x20020
80006372:	fec42783          	lw	a5,-20(s0)
80006376:	07a1                	addi	a5,a5,8 # 20020008 <STACK_SIZE+0x2001f808>
80006378:	078a                	slli	a5,a5,0x2
8000637a:	97ba                	add	a5,a5,a4
8000637c:	fe842703          	lw	a4,-24(s0)
80006380:	c398                	sw	a4,0(a5)
}
80006382:	0001                	nop
80006384:	4472                	lw	s0,28(sp)
80006386:	6105                	addi	sp,sp,32
80006388:	8082                	ret

8000638a <CRYPTO_DMA_SetBaseDescriptor>:
  * @brief   Устанаваливает базовый дескриптор для DMA
  * @param   address адрес базового дескриптора, являющийся структурой типа @ref CRYPTO_DMA_DesciptorAddress_TypeDef
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_SetBaseDescriptor(uint32_t address)
{
8000638a:	1101                	addi	sp,sp,-32
8000638c:	ce22                	sw	s0,28(sp)
8000638e:	1000                	addi	s0,sp,32
80006390:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(CRYPTO->BASE_DESCRIPTOR, address);
80006394:	200207b7          	lui	a5,0x20020
80006398:	fec42703          	lw	a4,-20(s0)
8000639c:	c7b8                	sw	a4,72(a5)
}
8000639e:	0001                	nop
800063a0:	4472                	lw	s0,28(sp)
800063a2:	6105                	addi	sp,sp,32
800063a4:	8082                	ret

800063a6 <CRYPTO_DMA_StartCmd>:
/**
  * @brief   Запускает последовательность операций в режиме DMA
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_StartCmd()
{
800063a6:	1141                	addi	sp,sp,-16
800063a8:	c622                	sw	s0,12(sp)
800063aa:	0800                	addi	s0,sp,16
	SET_BIT(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_START_Msk);
800063ac:	200207b7          	lui	a5,0x20020
800063b0:	47f8                	lw	a4,76(a5)
800063b2:	200207b7          	lui	a5,0x20020
800063b6:	00176713          	ori	a4,a4,1
800063ba:	c7f8                	sw	a4,76(a5)
}
800063bc:	0001                	nop
800063be:	4432                	lw	s0,12(sp)
800063c0:	0141                	addi	sp,sp,16
800063c2:	8082                	ret

800063c4 <CRYPTO_DMA_ByteSwapCmd>:
  * @brief   Инвертирование порядка байт припосылке на шину AHB
  * @param   state флаг инвертирования
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_ByteSwapCmd(FunctionalState state)
{
800063c4:	1101                	addi	sp,sp,-32
800063c6:	ce22                	sw	s0,28(sp)
800063c8:	1000                	addi	s0,sp,32
800063ca:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_BYTES_SWAP_Msk, state << CRYPTO_DMA_CONTROL_BYTES_SWAP_Pos);
800063ce:	200207b7          	lui	a5,0x20020
800063d2:	47fc                	lw	a5,76(a5)
800063d4:	ffd7f693          	andi	a3,a5,-3
800063d8:	fec42783          	lw	a5,-20(s0)
800063dc:	00179713          	slli	a4,a5,0x1
800063e0:	200207b7          	lui	a5,0x20020
800063e4:	8f55                	or	a4,a4,a3
800063e6:	c7f8                	sw	a4,76(a5)
}
800063e8:	0001                	nop
800063ea:	4472                	lw	s0,28(sp)
800063ec:	6105                	addi	sp,sp,32
800063ee:	8082                	ret

800063f0 <CRYPTO_DMA_WordSwapCmd>:
  * @brief   Инвертирование порядка слов припосылке на шину AHB
  * @param   state флаг инвертирования
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_WordSwapCmd(FunctionalState state)
{
800063f0:	1101                	addi	sp,sp,-32
800063f2:	ce22                	sw	s0,28(sp)
800063f4:	1000                	addi	s0,sp,32
800063f6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_WORDS_SWAP_Msk, state << CRYPTO_DMA_CONTROL_WORDS_SWAP_Pos);
800063fa:	200207b7          	lui	a5,0x20020
800063fe:	47fc                	lw	a5,76(a5)
80006400:	ffb7f693          	andi	a3,a5,-5
80006404:	fec42783          	lw	a5,-20(s0)
80006408:	00279713          	slli	a4,a5,0x2
8000640c:	200207b7          	lui	a5,0x20020
80006410:	8f55                	or	a4,a4,a3
80006412:	c7f8                	sw	a4,76(a5)
}
80006414:	0001                	nop
80006416:	4472                	lw	s0,28(sp)
80006418:	6105                	addi	sp,sp,32
8000641a:	8082                	ret

8000641c <CRYPTO_DeInit>:
/**
  * @brief   Устанавливает все регистры CRYPTO значениями по умолчанию
  * @retval  void
  */
void CRYPTO_DeInit()
{
8000641c:	1141                	addi	sp,sp,-16
8000641e:	c606                	sw	ra,12(sp)
80006420:	c422                	sw	s0,8(sp)
80006422:	0800                	addi	s0,sp,16
	RCU_AHBRstCmd(RCU_AHBRst_CRYPTO, DISABLE);
80006424:	4581                	li	a1,0
80006426:	4511                	li	a0,4
80006428:	350d                	jal	8000624a <RCU_AHBRstCmd>
	RCU_AHBRstCmd(RCU_AHBRst_CRYPTO, ENABLE);
8000642a:	4585                	li	a1,1
8000642c:	4511                	li	a0,4
8000642e:	3d31                	jal	8000624a <RCU_AHBRstCmd>
}
80006430:	0001                	nop
80006432:	40b2                	lw	ra,12(sp)
80006434:	4422                	lw	s0,8(sp)
80006436:	0141                	addi	sp,sp,16
80006438:	8082                	ret

8000643a <CRYPTO_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref CRYPTO_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void CRYPTO_Init(CRYPTO_Init_TypeDef* InitStruct)
{
8000643a:	1101                	addi	sp,sp,-32
8000643c:	ce06                	sw	ra,28(sp)
8000643e:	cc22                	sw	s0,24(sp)
80006440:	1000                	addi	s0,sp,32
80006442:	fea42623          	sw	a0,-20(s0)
	CRYPTO_DirectionConfig(InitStruct->Direction);
80006446:	fec42783          	lw	a5,-20(s0)
8000644a:	439c                	lw	a5,0(a5)
8000644c:	853e                	mv	a0,a5
8000644e:	358d                	jal	800062b0 <CRYPTO_DirectionConfig>
	CRYPTO_AlgoConfig(InitStruct->Algorithm);
80006450:	fec42783          	lw	a5,-20(s0)
80006454:	43dc                	lw	a5,4(a5)
80006456:	853e                	mv	a0,a5
80006458:	3551                	jal	800062dc <CRYPTO_AlgoConfig>
	CRYPTO_ModeConfig(InitStruct->Mode);
8000645a:	fec42783          	lw	a5,-20(s0)
8000645e:	479c                	lw	a5,8(a5)
80006460:	853e                	mv	a0,a5
80006462:	355d                	jal	80006308 <CRYPTO_ModeConfig>
	CRYPTO_InitVectorAutoUpdateCmd(InitStruct->InitVectorAutoUpdate);
80006464:	fec42783          	lw	a5,-20(s0)
80006468:	47dc                	lw	a5,12(a5)
8000646a:	853e                	mv	a0,a5
8000646c:	35e1                	jal	80006334 <CRYPTO_InitVectorAutoUpdateCmd>
	CRYPTO_UpdateKeyCmd(InitStruct->UpdateKey);
8000646e:	fec42783          	lw	a5,-20(s0)
80006472:	4b9c                	lw	a5,16(a5)
80006474:	853e                	mv	a0,a5
80006476:	3d09                	jal	80006288 <CRYPTO_UpdateKeyCmd>
}
80006478:	0001                	nop
8000647a:	40f2                	lw	ra,28(sp)
8000647c:	4462                	lw	s0,24(sp)
8000647e:	6105                	addi	sp,sp,32
80006480:	8082                	ret

80006482 <CRYPTO_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref CRYPTO_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void CRYPTO_StructInit(CRYPTO_Init_TypeDef* InitStruct)
{
80006482:	1101                	addi	sp,sp,-32
80006484:	ce22                	sw	s0,28(sp)
80006486:	1000                	addi	s0,sp,32
80006488:	fea42623          	sw	a0,-20(s0)
	InitStruct->Direction = CRYPTO_Dir_Encrypt;
8000648c:	fec42783          	lw	a5,-20(s0)
80006490:	0007a023          	sw	zero,0(a5) # 20020000 <STACK_SIZE+0x2001f800>
	InitStruct->Algorithm = CRYPTO_Algo_AES_256;
80006494:	fec42783          	lw	a5,-20(s0)
80006498:	4705                	li	a4,1
8000649a:	c3d8                	sw	a4,4(a5)
	InitStruct->Mode = CRYPTO_Mode_GCM;
8000649c:	fec42783          	lw	a5,-20(s0)
800064a0:	470d                	li	a4,3
800064a2:	c798                	sw	a4,8(a5)
	InitStruct->InitVectorAutoUpdate = ENABLE;
800064a4:	fec42783          	lw	a5,-20(s0)
800064a8:	4705                	li	a4,1
800064aa:	c7d8                	sw	a4,12(a5)
	InitStruct->UpdateKey = ENABLE;
800064ac:	fec42783          	lw	a5,-20(s0)
800064b0:	4705                	li	a4,1
800064b2:	cb98                	sw	a4,16(a5)
	InitStruct->GCMPhase = CRYPTO_GCM_PHASE_INIT;
800064b4:	fec42783          	lw	a5,-20(s0)
800064b8:	0007aa23          	sw	zero,20(a5)
}
800064bc:	0001                	nop
800064be:	4472                	lw	s0,28(sp)
800064c0:	6105                	addi	sp,sp,32
800064c2:	8082                	ret

800064c4 <CRYPTO_DMAStructInit>:
  * @param   CryptoStruct Указатель на стуктуру типа @ref CRYPTO_Init_TypeDef,
  * 					  которая содержит параметры шифрования
  * @retval  void
  */
void CRYPTO_DMAStructInit(CRYPTO_DMAInit_TypeDef* DMAStruct, CRYPTO_Init_TypeDef* CryptoStruct)
{
800064c4:	1101                	addi	sp,sp,-32
800064c6:	ce22                	sw	s0,28(sp)
800064c8:	1000                	addi	s0,sp,32
800064ca:	fea42623          	sw	a0,-20(s0)
800064ce:	feb42423          	sw	a1,-24(s0)
	DMAStruct->ByteSwap = DISABLE;
800064d2:	fec42783          	lw	a5,-20(s0)
800064d6:	0007a023          	sw	zero,0(a5)
	DMAStruct->WordSwap = DISABLE;
800064da:	fec42783          	lw	a5,-20(s0)
800064de:	0007a223          	sw	zero,4(a5)

	DMAStruct->CryptoSettings = CryptoStruct;
800064e2:	fec42783          	lw	a5,-20(s0)
800064e6:	fe842703          	lw	a4,-24(s0)
800064ea:	cbd8                	sw	a4,20(a5)
	DMAStruct->LastDescriptor = ENABLE;
800064ec:	fec42783          	lw	a5,-20(s0)
800064f0:	4705                	li	a4,1
800064f2:	c798                	sw	a4,8(a5)
	DMAStruct->ITEnable = DISABLE;
800064f4:	fec42783          	lw	a5,-20(s0)
800064f8:	0007a623          	sw	zero,12(a5)
	DMAStruct->BlocksCount = 0;
800064fc:	fec42783          	lw	a5,-20(s0)
80006500:	0007a823          	sw	zero,16(a5)

	DMAStruct->SourceAddress = 0;
80006504:	fec42783          	lw	a5,-20(s0)
80006508:	0007ae23          	sw	zero,28(a5)
	DMAStruct->DestinationAddress = 0;
8000650c:	fec42783          	lw	a5,-20(s0)
80006510:	0207a023          	sw	zero,32(a5)
	DMAStruct->DescriptorPtr->NEXT_DESCR = 0;
80006514:	fec42783          	lw	a5,-20(s0)
80006518:	53dc                	lw	a5,36(a5)
8000651a:	0007a623          	sw	zero,12(a5)
	DMAStruct->DescriptorPtr = 0;
8000651e:	fec42783          	lw	a5,-20(s0)
80006522:	0207a223          	sw	zero,36(a5)
}
80006526:	0001                	nop
80006528:	4472                	lw	s0,28(sp)
8000652a:	6105                	addi	sp,sp,32
8000652c:	8082                	ret

8000652e <CRYPTO_InitDMADescriptor>:
  * @param   DMAStruct  Указатель на структуру типа @ref CRYPTO_DMAInit_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
uint32_t CRYPTO_InitDMADescriptor(CRYPTO_DMAInit_TypeDef* DMAStruct)
{
8000652e:	1101                	addi	sp,sp,-32
80006530:	ce06                	sw	ra,28(sp)
80006532:	cc22                	sw	s0,24(sp)
80006534:	1000                	addi	s0,sp,32
80006536:	fea42623          	sw	a0,-20(s0)
	/* CRYPTO DMA operation control word */
	DMAStruct->DescriptorPtr->CONTROL_bit.UPDATE_KEY = DMAStruct->CryptoSettings->UpdateKey;
8000653a:	fec42783          	lw	a5,-20(s0)
8000653e:	4bdc                	lw	a5,20(a5)
80006540:	4b98                	lw	a4,16(a5)
80006542:	fec42783          	lw	a5,-20(s0)
80006546:	53dc                	lw	a5,36(a5)
80006548:	8b05                	andi	a4,a4,1
8000654a:	0ff77713          	zext.b	a4,a4
8000654e:	8b05                	andi	a4,a4,1
80006550:	4394                	lw	a3,0(a5)
80006552:	9af9                	andi	a3,a3,-2
80006554:	8f55                	or	a4,a4,a3
80006556:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.LAST_DESCRIPTOR = DMAStruct->LastDescriptor;
80006558:	fec42783          	lw	a5,-20(s0)
8000655c:	4798                	lw	a4,8(a5)
8000655e:	fec42783          	lw	a5,-20(s0)
80006562:	53dc                	lw	a5,36(a5)
80006564:	8b05                	andi	a4,a4,1
80006566:	0ff77713          	zext.b	a4,a4
8000656a:	8b05                	andi	a4,a4,1
8000656c:	0706                	slli	a4,a4,0x1
8000656e:	4394                	lw	a3,0(a5)
80006570:	9af5                	andi	a3,a3,-3
80006572:	8f55                	or	a4,a4,a3
80006574:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.DIRECTION = DMAStruct->CryptoSettings->Direction;
80006576:	fec42783          	lw	a5,-20(s0)
8000657a:	4bdc                	lw	a5,20(a5)
8000657c:	4398                	lw	a4,0(a5)
8000657e:	fec42783          	lw	a5,-20(s0)
80006582:	53dc                	lw	a5,36(a5)
80006584:	8b05                	andi	a4,a4,1
80006586:	0ff77713          	zext.b	a4,a4
8000658a:	8b05                	andi	a4,a4,1
8000658c:	070a                	slli	a4,a4,0x2
8000658e:	4394                	lw	a3,0(a5)
80006590:	9aed                	andi	a3,a3,-5
80006592:	8f55                	or	a4,a4,a3
80006594:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.ALGORITHM = DMAStruct->CryptoSettings->Algorithm;
80006596:	fec42783          	lw	a5,-20(s0)
8000659a:	4bdc                	lw	a5,20(a5)
8000659c:	43d8                	lw	a4,4(a5)
8000659e:	fec42783          	lw	a5,-20(s0)
800065a2:	53dc                	lw	a5,36(a5)
800065a4:	8b0d                	andi	a4,a4,3
800065a6:	0ff77713          	zext.b	a4,a4
800065aa:	8b0d                	andi	a4,a4,3
800065ac:	070e                	slli	a4,a4,0x3
800065ae:	4394                	lw	a3,0(a5)
800065b0:	9a9d                	andi	a3,a3,-25
800065b2:	8f55                	or	a4,a4,a3
800065b4:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.MODE = DMAStruct->CryptoSettings->Mode;
800065b6:	fec42783          	lw	a5,-20(s0)
800065ba:	4bdc                	lw	a5,20(a5)
800065bc:	4798                	lw	a4,8(a5)
800065be:	fec42783          	lw	a5,-20(s0)
800065c2:	53dc                	lw	a5,36(a5)
800065c4:	8b0d                	andi	a4,a4,3
800065c6:	0ff77713          	zext.b	a4,a4
800065ca:	8b0d                	andi	a4,a4,3
800065cc:	0716                	slli	a4,a4,0x5
800065ce:	4394                	lw	a3,0(a5)
800065d0:	f9f6f693          	andi	a3,a3,-97
800065d4:	8f55                	or	a4,a4,a3
800065d6:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.GCM_PHASE = DMAStruct->CryptoSettings->GCMPhase;
800065d8:	fec42783          	lw	a5,-20(s0)
800065dc:	4bdc                	lw	a5,20(a5)
800065de:	4bd8                	lw	a4,20(a5)
800065e0:	fec42783          	lw	a5,-20(s0)
800065e4:	53dc                	lw	a5,36(a5)
800065e6:	8b0d                	andi	a4,a4,3
800065e8:	0ff77713          	zext.b	a4,a4
800065ec:	8b0d                	andi	a4,a4,3
800065ee:	0736                	slli	a4,a4,0xd
800065f0:	4390                	lw	a2,0(a5)
800065f2:	76e9                	lui	a3,0xffffa
800065f4:	16fd                	addi	a3,a3,-1 # ffff9fff <__data_source_start+0x7fff05db>
800065f6:	8ef1                	and	a3,a3,a2
800065f8:	8f55                	or	a4,a4,a3
800065fa:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.INTERRUPT_ENABLE = DMAStruct->ITEnable;
800065fc:	fec42783          	lw	a5,-20(s0)
80006600:	47d8                	lw	a4,12(a5)
80006602:	fec42783          	lw	a5,-20(s0)
80006606:	53dc                	lw	a5,36(a5)
80006608:	8b05                	andi	a4,a4,1
8000660a:	0ff77713          	zext.b	a4,a4
8000660e:	8b05                	andi	a4,a4,1
80006610:	073e                	slli	a4,a4,0xf
80006612:	4390                	lw	a2,0(a5)
80006614:	76e1                	lui	a3,0xffff8
80006616:	16fd                	addi	a3,a3,-1 # ffff7fff <__data_source_start+0x7ffee5db>
80006618:	8ef1                	and	a3,a3,a2
8000661a:	8f55                	or	a4,a4,a3
8000661c:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.BLOCKS_COUNT = DMAStruct->BlocksCount;
8000661e:	fec42783          	lw	a5,-20(s0)
80006622:	4b98                	lw	a4,16(a5)
80006624:	fec42783          	lw	a5,-20(s0)
80006628:	53dc                	lw	a5,36(a5)
8000662a:	86ba                	mv	a3,a4
8000662c:	6705                	lui	a4,0x1
8000662e:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80006630:	8f75                	and	a4,a4,a3
80006632:	01071693          	slli	a3,a4,0x10
80006636:	82c1                	srli	a3,a3,0x10
80006638:	6705                	lui	a4,0x1
8000663a:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
8000663c:	8f75                	and	a4,a4,a3
8000663e:	0742                	slli	a4,a4,0x10
80006640:	4390                	lw	a2,0(a5)
80006642:	f00106b7          	lui	a3,0xf0010
80006646:	16fd                	addi	a3,a3,-1 # f000ffff <__data_source_start+0x700065db>
80006648:	8ef1                	and	a3,a3,a2
8000664a:	8f55                	or	a4,a4,a3
8000664c:	c398                	sw	a4,0(a5)

	DMAStruct->DescriptorPtr->SRC_ADDR = (uint32_t) DMAStruct->SourceAddress;
8000664e:	fec42783          	lw	a5,-20(s0)
80006652:	4fd8                	lw	a4,28(a5)
80006654:	fec42783          	lw	a5,-20(s0)
80006658:	53dc                	lw	a5,36(a5)
8000665a:	c3d8                	sw	a4,4(a5)
	DMAStruct->DescriptorPtr->DST_ADDR = (uint32_t)DMAStruct->DestinationAddress;
8000665c:	fec42783          	lw	a5,-20(s0)
80006660:	5398                	lw	a4,32(a5)
80006662:	fec42783          	lw	a5,-20(s0)
80006666:	53dc                	lw	a5,36(a5)
80006668:	c798                	sw	a4,8(a5)
	DMAStruct->DescriptorPtr->NEXT_DESCR = (uint32_t) DMAStruct->LastDescriptor ? 0 : CRYPTO_InitDMADescriptor((CRYPTO_DMAInit_TypeDef*) DMAStruct->NextDescriptor);
8000666a:	fec42783          	lw	a5,-20(s0)
8000666e:	479c                	lw	a5,8(a5)
80006670:	eb81                	bnez	a5,80006680 <CRYPTO_InitDMADescriptor+0x152>
80006672:	fec42783          	lw	a5,-20(s0)
80006676:	4f9c                	lw	a5,24(a5)
80006678:	853e                	mv	a0,a5
8000667a:	3d55                	jal	8000652e <CRYPTO_InitDMADescriptor>
8000667c:	872a                	mv	a4,a0
8000667e:	a011                	j	80006682 <CRYPTO_InitDMADescriptor+0x154>
80006680:	4701                	li	a4,0
80006682:	fec42783          	lw	a5,-20(s0)
80006686:	53dc                	lw	a5,36(a5)
80006688:	c7d8                	sw	a4,12(a5)
//		DMAStruct->DescriptorPtr->NEXT_DESCR = (uint32_t) &headerDescriptor;
//		headerDescriptor.NEXT_DESCR = (uint32_t) &payloadDescriptor;
//		payloadDescriptor.NEXT_DESCR = (uint32_t) &lastBlockDescriptor;
//	}

	return (uint32_t) DMAStruct->DescriptorPtr;
8000668a:	fec42783          	lw	a5,-20(s0)
8000668e:	53dc                	lw	a5,36(a5)
}
80006690:	853e                	mv	a0,a5
80006692:	40f2                	lw	ra,28(sp)
80006694:	4462                	lw	s0,24(sp)
80006696:	6105                	addi	sp,sp,32
80006698:	8082                	ret

8000669a <CRPYTO_ProcessData>:
  * @param   DMAStruct  Указатель на структуру типа @ref CRYPTO_DMAInit_TypeDef,
  *                      которая будет исполнена как дескриптор DMA
  * @retval  void
  */
void CRPYTO_ProcessData(CRYPTO_DMAInit_TypeDef* DMAStruct)
{
8000669a:	1101                	addi	sp,sp,-32
8000669c:	ce06                	sw	ra,28(sp)
8000669e:	cc22                	sw	s0,24(sp)
800066a0:	1000                	addi	s0,sp,32
800066a2:	fea42623          	sw	a0,-20(s0)
	CRYPTO_DMA_ByteSwapCmd(DMAStruct->ByteSwap);
800066a6:	fec42783          	lw	a5,-20(s0)
800066aa:	439c                	lw	a5,0(a5)
800066ac:	853e                	mv	a0,a5
800066ae:	3b19                	jal	800063c4 <CRYPTO_DMA_ByteSwapCmd>
	CRYPTO_DMA_WordSwapCmd(DMAStruct->WordSwap);
800066b0:	fec42783          	lw	a5,-20(s0)
800066b4:	43dc                	lw	a5,4(a5)
800066b6:	853e                	mv	a0,a5
800066b8:	3b25                	jal	800063f0 <CRYPTO_DMA_WordSwapCmd>
	CRYPTO_DMA_SetBaseDescriptor(CRYPTO_InitDMADescriptor(DMAStruct));
800066ba:	fec42503          	lw	a0,-20(s0)
800066be:	3d85                	jal	8000652e <CRYPTO_InitDMADescriptor>
800066c0:	87aa                	mv	a5,a0
800066c2:	853e                	mv	a0,a5
800066c4:	31d9                	jal	8000638a <CRYPTO_DMA_SetBaseDescriptor>
	CRYPTO_DMA_StartCmd();
800066c6:	31c5                	jal	800063a6 <CRYPTO_DMA_StartCmd>
}
800066c8:	0001                	nop
800066ca:	40f2                	lw	ra,28(sp)
800066cc:	4462                	lw	s0,24(sp)
800066ce:	6105                	addi	sp,sp,32
800066d0:	8082                	ret

800066d2 <CRYPTO_SetKey>:
  * @brief   Устанавливает значение ключа, максимум 256 бит, для AES-128 128 бит
  * @param   key массив слов, который формирует ключ шифрования
  * @retval  void
  */
void CRYPTO_SetKey(uint32_t* key, uint32_t len)
{
800066d2:	7179                	addi	sp,sp,-48
800066d4:	d606                	sw	ra,44(sp)
800066d6:	d422                	sw	s0,40(sp)
800066d8:	1800                	addi	s0,sp,48
800066da:	fca42e23          	sw	a0,-36(s0)
800066de:	fcb42c23          	sw	a1,-40(s0)
	uint32_t idx = 0;
800066e2:	fe042623          	sw	zero,-20(s0)
	while(idx < len)
800066e6:	a00d                	j	80006708 <CRYPTO_SetKey+0x36>
	{
		CRYPTO_SetKeyInReg(idx++, *key++);
800066e8:	fec42703          	lw	a4,-20(s0)
800066ec:	00170793          	addi	a5,a4,1
800066f0:	fef42623          	sw	a5,-20(s0)
800066f4:	fdc42783          	lw	a5,-36(s0)
800066f8:	00478693          	addi	a3,a5,4
800066fc:	fcd42e23          	sw	a3,-36(s0)
80006700:	439c                	lw	a5,0(a5)
80006702:	85be                	mv	a1,a5
80006704:	853a                	mv	a0,a4
80006706:	39a9                	jal	80006360 <CRYPTO_SetKeyInReg>
	while(idx < len)
80006708:	fec42703          	lw	a4,-20(s0)
8000670c:	fd842783          	lw	a5,-40(s0)
80006710:	fcf76ce3          	bltu	a4,a5,800066e8 <CRYPTO_SetKey+0x16>
	}
}
80006714:	0001                	nop
80006716:	0001                	nop
80006718:	50b2                	lw	ra,44(sp)
8000671a:	5422                	lw	s0,40(sp)
8000671c:	6145                	addi	sp,sp,48
8000671e:	8082                	ret

80006720 <DMA_ProtectConfig>:
  * @brief   Управление защитой шины при обращении контроллера DMA к управляющим данным
  * @param   CtrlProtect  Структура, содержащая конфигурацию защиты
  * @retval  void
  */
__STATIC_INLINE void DMA_ProtectConfig(DMA_Protect_TypeDef* CtrlProtect)
{
80006720:	1101                	addi	sp,sp,-32
80006722:	ce22                	sw	s0,28(sp)
80006724:	1000                	addi	s0,sp,32
80006726:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Bufferable));
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Cacheable));
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Priveleged));

    MODIFY_REG(DMA->CFG, DMA_CFG_CHPROT_Msk, ((CtrlProtect->Priveleged << (DMA_CFG_CHPROT_Pos + 0)) |
8000672a:	3000c7b7          	lui	a5,0x3000c
8000672e:	43dc                	lw	a5,4(a5)
80006730:	ff87f693          	andi	a3,a5,-8
80006734:	fec42783          	lw	a5,-20(s0)
80006738:	4398                	lw	a4,0(a5)
8000673a:	fec42783          	lw	a5,-20(s0)
8000673e:	43dc                	lw	a5,4(a5)
80006740:	0786                	slli	a5,a5,0x1
80006742:	8f5d                	or	a4,a4,a5
80006744:	fec42783          	lw	a5,-20(s0)
80006748:	479c                	lw	a5,8(a5)
8000674a:	078a                	slli	a5,a5,0x2
8000674c:	8f5d                	or	a4,a4,a5
8000674e:	3000c7b7          	lui	a5,0x3000c
80006752:	8f55                	or	a4,a4,a3
80006754:	c3d8                	sw	a4,4(a5)
                                              (CtrlProtect->Bufferable << (DMA_CFG_CHPROT_Pos + 1)) |
                                              (CtrlProtect->Cacheable << (DMA_CFG_CHPROT_Pos + 2))));
}
80006756:	0001                	nop
80006758:	4472                	lw	s0,28(sp)
8000675a:	6105                	addi	sp,sp,32
8000675c:	8082                	ret

8000675e <DMA_UseBurstCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_UseBurstCmd(uint32_t Channel, FunctionalState State)
{
8000675e:	1101                	addi	sp,sp,-32
80006760:	ce22                	sw	s0,28(sp)
80006762:	1000                	addi	s0,sp,32
80006764:	fea42623          	sw	a0,-20(s0)
80006768:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000676c:	fe842703          	lw	a4,-24(s0)
80006770:	4785                	li	a5,1
80006772:	00f71863          	bne	a4,a5,80006782 <DMA_UseBurstCmd+0x24>
        WRITE_REG(DMA->USEBURSTSET, Channel);
80006776:	3000c7b7          	lui	a5,0x3000c
8000677a:	fec42703          	lw	a4,-20(s0)
8000677e:	cf98                	sw	a4,24(a5)
    else
        WRITE_REG(DMA->USEBURSTCLR, Channel);
}
80006780:	a031                	j	8000678c <DMA_UseBurstCmd+0x2e>
        WRITE_REG(DMA->USEBURSTCLR, Channel);
80006782:	3000c7b7          	lui	a5,0x3000c
80006786:	fec42703          	lw	a4,-20(s0)
8000678a:	cfd8                	sw	a4,28(a5)
}
8000678c:	0001                	nop
8000678e:	4472                	lw	s0,28(sp)
80006790:	6105                	addi	sp,sp,32
80006792:	8082                	ret

80006794 <DMA_ReqMaskCmd>:
  *                      Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param      State  Выбор состояния
  * @retval     void
  */
__STATIC_INLINE void DMA_ReqMaskCmd(uint32_t Channel, FunctionalState State)
{
80006794:	1101                	addi	sp,sp,-32
80006796:	ce22                	sw	s0,28(sp)
80006798:	1000                	addi	s0,sp,32
8000679a:	fea42623          	sw	a0,-20(s0)
8000679e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800067a2:	fe842703          	lw	a4,-24(s0)
800067a6:	4785                	li	a5,1
800067a8:	00f71863          	bne	a4,a5,800067b8 <DMA_ReqMaskCmd+0x24>
        WRITE_REG(DMA->REQMASKSET, Channel);
800067ac:	3000c7b7          	lui	a5,0x3000c
800067b0:	fec42703          	lw	a4,-20(s0)
800067b4:	d398                	sw	a4,32(a5)
    else
        WRITE_REG(DMA->REQMASKCLR, Channel);
}
800067b6:	a031                	j	800067c2 <DMA_ReqMaskCmd+0x2e>
        WRITE_REG(DMA->REQMASKCLR, Channel);
800067b8:	3000c7b7          	lui	a5,0x3000c
800067bc:	fec42703          	lw	a4,-20(s0)
800067c0:	d3d8                	sw	a4,36(a5)
}
800067c2:	0001                	nop
800067c4:	4472                	lw	s0,28(sp)
800067c6:	6105                	addi	sp,sp,32
800067c8:	8082                	ret

800067ca <DMA_ChannelEnableCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_ChannelEnableCmd(uint32_t Channel, FunctionalState State)
{
800067ca:	1101                	addi	sp,sp,-32
800067cc:	ce22                	sw	s0,28(sp)
800067ce:	1000                	addi	s0,sp,32
800067d0:	fea42623          	sw	a0,-20(s0)
800067d4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800067d8:	fe842703          	lw	a4,-24(s0)
800067dc:	4785                	li	a5,1
800067de:	00f71863          	bne	a4,a5,800067ee <DMA_ChannelEnableCmd+0x24>
        WRITE_REG(DMA->ENSET, Channel);
800067e2:	3000c7b7          	lui	a5,0x3000c
800067e6:	fec42703          	lw	a4,-20(s0)
800067ea:	d798                	sw	a4,40(a5)
    else
        WRITE_REG(DMA->ENCLR, Channel);
}
800067ec:	a031                	j	800067f8 <DMA_ChannelEnableCmd+0x2e>
        WRITE_REG(DMA->ENCLR, Channel);
800067ee:	3000c7b7          	lui	a5,0x3000c
800067f2:	fec42703          	lw	a4,-20(s0)
800067f6:	d7d8                	sw	a4,44(a5)
}
800067f8:	0001                	nop
800067fa:	4472                	lw	s0,28(sp)
800067fc:	6105                	addi	sp,sp,32
800067fe:	8082                	ret

80006800 <DMA_AltCtrlCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_AltCtrlCmd(uint32_t Channel, FunctionalState State)
{
80006800:	1101                	addi	sp,sp,-32
80006802:	ce22                	sw	s0,28(sp)
80006804:	1000                	addi	s0,sp,32
80006806:	fea42623          	sw	a0,-20(s0)
8000680a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000680e:	fe842703          	lw	a4,-24(s0)
80006812:	4785                	li	a5,1
80006814:	00f71863          	bne	a4,a5,80006824 <DMA_AltCtrlCmd+0x24>
        WRITE_REG(DMA->PRIALTSET, Channel);
80006818:	3000c7b7          	lui	a5,0x3000c
8000681c:	fec42703          	lw	a4,-20(s0)
80006820:	db98                	sw	a4,48(a5)
    else
        WRITE_REG(DMA->PRIALTCLR, Channel);
}
80006822:	a031                	j	8000682e <DMA_AltCtrlCmd+0x2e>
        WRITE_REG(DMA->PRIALTCLR, Channel);
80006824:	3000c7b7          	lui	a5,0x3000c
80006828:	fec42703          	lw	a4,-20(s0)
8000682c:	dbd8                	sw	a4,52(a5)
}
8000682e:	0001                	nop
80006830:	4472                	lw	s0,28(sp)
80006832:	6105                	addi	sp,sp,32
80006834:	8082                	ret

80006836 <DMA_HighPriorityCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_HighPriorityCmd(uint32_t Channel, FunctionalState State)
{
80006836:	1101                	addi	sp,sp,-32
80006838:	ce22                	sw	s0,28(sp)
8000683a:	1000                	addi	s0,sp,32
8000683c:	fea42623          	sw	a0,-20(s0)
80006840:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80006844:	fe842703          	lw	a4,-24(s0)
80006848:	4785                	li	a5,1
8000684a:	00f71863          	bne	a4,a5,8000685a <DMA_HighPriorityCmd+0x24>
        WRITE_REG(DMA->PRIORITYSET, Channel);
8000684e:	3000c7b7          	lui	a5,0x3000c
80006852:	fec42703          	lw	a4,-20(s0)
80006856:	df98                	sw	a4,56(a5)
    else
        WRITE_REG(DMA->PRIORITYCLR, Channel);
}
80006858:	a031                	j	80006864 <DMA_HighPriorityCmd+0x2e>
        WRITE_REG(DMA->PRIORITYCLR, Channel);
8000685a:	3000c7b7          	lui	a5,0x3000c
8000685e:	fec42703          	lw	a4,-20(s0)
80006862:	dfd8                	sw	a4,60(a5)
}
80006864:	0001                	nop
80006866:	4472                	lw	s0,28(sp)
80006868:	6105                	addi	sp,sp,32
8000686a:	8082                	ret

8000686c <DMA_ChannelDeInit>:
  * @param   ChannelStruct  Указатель на структуру типа @ref DMA_Channel_TypeDef,
  *                         которая содержит конфигурационную информацию канала
  * @retval  void
  */
void DMA_ChannelDeInit(DMA_Channel_TypeDef* ChannelStruct)
{
8000686c:	1101                	addi	sp,sp,-32
8000686e:	ce22                	sw	s0,28(sp)
80006870:	1000                	addi	s0,sp,32
80006872:	fea42623          	sw	a0,-20(s0)
    ChannelStruct->SRC_DATA_END_PTR = 0;
80006876:	fec42783          	lw	a5,-20(s0)
8000687a:	0007a023          	sw	zero,0(a5) # 3000c000 <STACK_SIZE+0x3000b800>
    ChannelStruct->DST_DATA_END_PTR = 0;
8000687e:	fec42783          	lw	a5,-20(s0)
80006882:	0007a223          	sw	zero,4(a5)
    ChannelStruct->CHANNEL_CFG = 0;
80006886:	fec42783          	lw	a5,-20(s0)
8000688a:	0007a423          	sw	zero,8(a5)
}
8000688e:	0001                	nop
80006890:	4472                	lw	s0,28(sp)
80006892:	6105                	addi	sp,sp,32
80006894:	8082                	ret

80006896 <DMA_ChannelInit>:
  * @param   ChannelInitStruct  Указатель на структуру типа @ref DMA_ChannelInit_TypeDef,
  *                             которая содержит конфигурационную информацию канала
  * @retval  void
  */
void DMA_ChannelInit(DMA_Channel_TypeDef* ChannelStruct, DMA_ChannelInit_TypeDef* ChannelInitStruct)
{
80006896:	1101                	addi	sp,sp,-32
80006898:	ce22                	sw	s0,28(sp)
8000689a:	1000                	addi	s0,sp,32
8000689c:	fea42623          	sw	a0,-20(s0)
800068a0:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Bufferable));
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Cacheable));
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Priveleged));

    /* источник */
    ChannelStruct->SRC_DATA_END_PTR = (uint32_t)ChannelInitStruct->SrcDataEndPtr;
800068a4:	fe842783          	lw	a5,-24(s0)
800068a8:	439c                	lw	a5,0(a5)
800068aa:	873e                	mv	a4,a5
800068ac:	fec42783          	lw	a5,-20(s0)
800068b0:	c398                	sw	a4,0(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_SIZE = ChannelInitStruct->SrcDataSize;
800068b2:	fe842783          	lw	a5,-24(s0)
800068b6:	5b9c                	lw	a5,48(a5)
800068b8:	8b8d                	andi	a5,a5,3
800068ba:	0ff7f713          	zext.b	a4,a5
800068be:	fec42783          	lw	a5,-20(s0)
800068c2:	8b0d                	andi	a4,a4,3
800068c4:	0746                	slli	a4,a4,0x11
800068c6:	4790                	lw	a2,8(a5)
800068c8:	fffa06b7          	lui	a3,0xfffa0
800068cc:	16fd                	addi	a3,a3,-1 # fff9ffff <__data_source_start+0x7ff965db>
800068ce:	8ef1                	and	a3,a3,a2
800068d0:	8f55                	or	a4,a4,a3
800068d2:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_INC = ChannelInitStruct->SrcDataInc;
800068d4:	fe842783          	lw	a5,-24(s0)
800068d8:	5f9c                	lw	a5,56(a5)
800068da:	8b8d                	andi	a5,a5,3
800068dc:	0ff7f713          	zext.b	a4,a5
800068e0:	fec42783          	lw	a5,-20(s0)
800068e4:	8b0d                	andi	a4,a4,3
800068e6:	073e                	slli	a4,a4,0xf
800068e8:	4790                	lw	a2,8(a5)
800068ea:	76a1                	lui	a3,0xfffe8
800068ec:	16fd                	addi	a3,a3,-1 # fffe7fff <__data_source_start+0x7ffde5db>
800068ee:	8ef1                	and	a3,a3,a2
800068f0:	8f55                	or	a4,a4,a3
800068f2:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_BUFF = ChannelInitStruct->SrcProtect.Bufferable;
800068f4:	fe842783          	lw	a5,-24(s0)
800068f8:	4fdc                	lw	a5,28(a5)
800068fa:	8b85                	andi	a5,a5,1
800068fc:	0ff7f713          	zext.b	a4,a5
80006900:	fec42783          	lw	a5,-20(s0)
80006904:	8b05                	andi	a4,a4,1
80006906:	076e                	slli	a4,a4,0x1b
80006908:	4790                	lw	a2,8(a5)
8000690a:	f80006b7          	lui	a3,0xf8000
8000690e:	16fd                	addi	a3,a3,-1 # f7ffffff <__data_source_start+0x77ff65db>
80006910:	8ef1                	and	a3,a3,a2
80006912:	8f55                	or	a4,a4,a3
80006914:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_PRIV = ChannelInitStruct->SrcProtect.Priveleged;
80006916:	fe842783          	lw	a5,-24(s0)
8000691a:	4f9c                	lw	a5,24(a5)
8000691c:	8b85                	andi	a5,a5,1
8000691e:	0ff7f713          	zext.b	a4,a5
80006922:	fec42783          	lw	a5,-20(s0)
80006926:	8b05                	andi	a4,a4,1
80006928:	076a                	slli	a4,a4,0x1a
8000692a:	4790                	lw	a2,8(a5)
8000692c:	fc0006b7          	lui	a3,0xfc000
80006930:	16fd                	addi	a3,a3,-1 # fbffffff <__data_source_start+0x7bff65db>
80006932:	8ef1                	and	a3,a3,a2
80006934:	8f55                	or	a4,a4,a3
80006936:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_CACHE = ChannelInitStruct->SrcProtect.Cacheable;
80006938:	fe842783          	lw	a5,-24(s0)
8000693c:	539c                	lw	a5,32(a5)
8000693e:	8b85                	andi	a5,a5,1
80006940:	0ff7f713          	zext.b	a4,a5
80006944:	fec42783          	lw	a5,-20(s0)
80006948:	8b05                	andi	a4,a4,1
8000694a:	0772                	slli	a4,a4,0x1c
8000694c:	4790                	lw	a2,8(a5)
8000694e:	f00006b7          	lui	a3,0xf0000
80006952:	16fd                	addi	a3,a3,-1 # efffffff <__data_source_start+0x6fff65db>
80006954:	8ef1                	and	a3,a3,a2
80006956:	8f55                	or	a4,a4,a3
80006958:	c798                	sw	a4,8(a5)
    /* приемник */
    ChannelStruct->DST_DATA_END_PTR = (uint32_t)ChannelInitStruct->DstDataEndPtr;
8000695a:	fe842783          	lw	a5,-24(s0)
8000695e:	43dc                	lw	a5,4(a5)
80006960:	873e                	mv	a4,a5
80006962:	fec42783          	lw	a5,-20(s0)
80006966:	c3d8                	sw	a4,4(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_SIZE = ChannelInitStruct->DstDataSize;
80006968:	fe842783          	lw	a5,-24(s0)
8000696c:	5bdc                	lw	a5,52(a5)
8000696e:	8b8d                	andi	a5,a5,3
80006970:	0ff7f713          	zext.b	a4,a5
80006974:	fec42783          	lw	a5,-20(s0)
80006978:	8b0d                	andi	a4,a4,3
8000697a:	0756                	slli	a4,a4,0x15
8000697c:	4790                	lw	a2,8(a5)
8000697e:	ffa006b7          	lui	a3,0xffa00
80006982:	16fd                	addi	a3,a3,-1 # ff9fffff <__data_source_start+0x7f9f65db>
80006984:	8ef1                	and	a3,a3,a2
80006986:	8f55                	or	a4,a4,a3
80006988:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_INC = ChannelInitStruct->DstDataInc;
8000698a:	fe842783          	lw	a5,-24(s0)
8000698e:	5fdc                	lw	a5,60(a5)
80006990:	8b8d                	andi	a5,a5,3
80006992:	0ff7f713          	zext.b	a4,a5
80006996:	fec42783          	lw	a5,-20(s0)
8000699a:	8b0d                	andi	a4,a4,3
8000699c:	074e                	slli	a4,a4,0x13
8000699e:	4790                	lw	a2,8(a5)
800069a0:	ffe806b7          	lui	a3,0xffe80
800069a4:	16fd                	addi	a3,a3,-1 # ffe7ffff <__data_source_start+0x7fe765db>
800069a6:	8ef1                	and	a3,a3,a2
800069a8:	8f55                	or	a4,a4,a3
800069aa:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_BUFF = ChannelInitStruct->DstProtect.Bufferable;
800069ac:	fe842783          	lw	a5,-24(s0)
800069b0:	579c                	lw	a5,40(a5)
800069b2:	8b85                	andi	a5,a5,1
800069b4:	0ff7f713          	zext.b	a4,a5
800069b8:	fec42783          	lw	a5,-20(s0)
800069bc:	8b05                	andi	a4,a4,1
800069be:	0762                	slli	a4,a4,0x18
800069c0:	4790                	lw	a2,8(a5)
800069c2:	ff0006b7          	lui	a3,0xff000
800069c6:	16fd                	addi	a3,a3,-1 # feffffff <__data_source_start+0x7eff65db>
800069c8:	8ef1                	and	a3,a3,a2
800069ca:	8f55                	or	a4,a4,a3
800069cc:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_PRIV = ChannelInitStruct->DstProtect.Priveleged;
800069ce:	fe842783          	lw	a5,-24(s0)
800069d2:	53dc                	lw	a5,36(a5)
800069d4:	8b85                	andi	a5,a5,1
800069d6:	0ff7f713          	zext.b	a4,a5
800069da:	fec42783          	lw	a5,-20(s0)
800069de:	8b05                	andi	a4,a4,1
800069e0:	075e                	slli	a4,a4,0x17
800069e2:	4790                	lw	a2,8(a5)
800069e4:	ff8006b7          	lui	a3,0xff800
800069e8:	16fd                	addi	a3,a3,-1 # ff7fffff <__data_source_start+0x7f7f65db>
800069ea:	8ef1                	and	a3,a3,a2
800069ec:	8f55                	or	a4,a4,a3
800069ee:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_CACHE = ChannelInitStruct->DstProtect.Cacheable;
800069f0:	fe842783          	lw	a5,-24(s0)
800069f4:	57dc                	lw	a5,44(a5)
800069f6:	8b85                	andi	a5,a5,1
800069f8:	0ff7f713          	zext.b	a4,a5
800069fc:	fec42783          	lw	a5,-20(s0)
80006a00:	8b05                	andi	a4,a4,1
80006a02:	0766                	slli	a4,a4,0x19
80006a04:	4790                	lw	a2,8(a5)
80006a06:	fe0006b7          	lui	a3,0xfe000
80006a0a:	16fd                	addi	a3,a3,-1 # fdffffff <__data_source_start+0x7dff65db>
80006a0c:	8ef1                	and	a3,a3,a2
80006a0e:	8f55                	or	a4,a4,a3
80006a10:	c798                	sw	a4,8(a5)
    /* общее */
    ChannelStruct->CHANNEL_CFG_bit.NEXT_USEBURST = ChannelInitStruct->NextUseburst;
80006a12:	fe842783          	lw	a5,-24(s0)
80006a16:	47dc                	lw	a5,12(a5)
80006a18:	8b85                	andi	a5,a5,1
80006a1a:	0ff7f713          	zext.b	a4,a5
80006a1e:	fec42783          	lw	a5,-20(s0)
80006a22:	8b05                	andi	a4,a4,1
80006a24:	4794                	lw	a3,8(a5)
80006a26:	9af9                	andi	a3,a3,-2
80006a28:	8f55                	or	a4,a4,a3
80006a2a:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.R_POWER = ChannelInitStruct->ArbitrationRate;
80006a2c:	fe842783          	lw	a5,-24(s0)
80006a30:	4bdc                	lw	a5,20(a5)
80006a32:	8bbd                	andi	a5,a5,15
80006a34:	0ff7f713          	zext.b	a4,a5
80006a38:	fec42783          	lw	a5,-20(s0)
80006a3c:	8b3d                	andi	a4,a4,15
80006a3e:	0706                	slli	a4,a4,0x1
80006a40:	4794                	lw	a3,8(a5)
80006a42:	9a85                	andi	a3,a3,-31
80006a44:	8f55                	or	a4,a4,a3
80006a46:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.N_MINUS_1 = ChannelInitStruct->TransfersTotal - 1;
80006a48:	fe842783          	lw	a5,-24(s0)
80006a4c:	4b9c                	lw	a5,16(a5)
80006a4e:	07c2                	slli	a5,a5,0x10
80006a50:	83c1                	srli	a5,a5,0x10
80006a52:	17fd                	addi	a5,a5,-1
80006a54:	07c2                	slli	a5,a5,0x10
80006a56:	83c1                	srli	a5,a5,0x10
80006a58:	3ff7f793          	andi	a5,a5,1023
80006a5c:	01079713          	slli	a4,a5,0x10
80006a60:	8341                	srli	a4,a4,0x10
80006a62:	fec42783          	lw	a5,-20(s0)
80006a66:	3ff77713          	andi	a4,a4,1023
80006a6a:	0716                	slli	a4,a4,0x5
80006a6c:	4790                	lw	a2,8(a5)
80006a6e:	76e1                	lui	a3,0xffff8
80006a70:	06fd                	addi	a3,a3,31 # ffff801f <__data_source_start+0x7ffee5fb>
80006a72:	8ef1                	and	a3,a3,a2
80006a74:	8f55                	or	a4,a4,a3
80006a76:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.CYCLE_CTRL = ChannelInitStruct->Mode;
80006a78:	fe842783          	lw	a5,-24(s0)
80006a7c:	479c                	lw	a5,8(a5)
80006a7e:	8b9d                	andi	a5,a5,7
80006a80:	0ff7f713          	zext.b	a4,a5
80006a84:	fec42783          	lw	a5,-20(s0)
80006a88:	0776                	slli	a4,a4,0x1d
80006a8a:	4790                	lw	a2,8(a5)
80006a8c:	200006b7          	lui	a3,0x20000
80006a90:	16fd                	addi	a3,a3,-1 # 1fffffff <STACK_SIZE+0x1ffff7ff>
80006a92:	8ef1                	and	a3,a3,a2
80006a94:	8f55                	or	a4,a4,a3
80006a96:	c798                	sw	a4,8(a5)
}
80006a98:	0001                	nop
80006a9a:	4472                	lw	s0,28(sp)
80006a9c:	6105                	addi	sp,sp,32
80006a9e:	8082                	ret

80006aa0 <DMA_ChannelStructInit>:
  * @param   ChannelInitStruct  Указатель на структуру типа @ref DMA_ChannelInit_TypeDef,
  *                             которую необходимо проинициализировать
  * @retval  void
  */
void DMA_ChannelStructInit(DMA_ChannelInit_TypeDef* ChannelInitStruct)
{
80006aa0:	1101                	addi	sp,sp,-32
80006aa2:	ce22                	sw	s0,28(sp)
80006aa4:	1000                	addi	s0,sp,32
80006aa6:	fea42623          	sw	a0,-20(s0)
    /* источник */
    ChannelInitStruct->SrcDataEndPtr = (uint32_t*)0x00000000;
80006aaa:	fec42783          	lw	a5,-20(s0)
80006aae:	0007a023          	sw	zero,0(a5)
    ChannelInitStruct->SrcDataSize = DMA_DataSize_8;
80006ab2:	fec42783          	lw	a5,-20(s0)
80006ab6:	0207a823          	sw	zero,48(a5)
    ChannelInitStruct->SrcDataInc = DMA_DataInc_Disable;
80006aba:	fec42783          	lw	a5,-20(s0)
80006abe:	470d                	li	a4,3
80006ac0:	df98                	sw	a4,56(a5)
    ChannelInitStruct->SrcProtect.Bufferable = DISABLE;
80006ac2:	fec42783          	lw	a5,-20(s0)
80006ac6:	0007ae23          	sw	zero,28(a5)
    ChannelInitStruct->SrcProtect.Priveleged = DISABLE;
80006aca:	fec42783          	lw	a5,-20(s0)
80006ace:	0007ac23          	sw	zero,24(a5)
    ChannelInitStruct->SrcProtect.Cacheable = DISABLE;
80006ad2:	fec42783          	lw	a5,-20(s0)
80006ad6:	0207a023          	sw	zero,32(a5)
    /* приемник */
    ChannelInitStruct->DstDataEndPtr = (uint32_t*)0x00000000;
80006ada:	fec42783          	lw	a5,-20(s0)
80006ade:	0007a223          	sw	zero,4(a5)
    ChannelInitStruct->DstDataSize = DMA_DataSize_8;
80006ae2:	fec42783          	lw	a5,-20(s0)
80006ae6:	0207aa23          	sw	zero,52(a5)
    ChannelInitStruct->DstDataInc = DMA_DataInc_Disable;
80006aea:	fec42783          	lw	a5,-20(s0)
80006aee:	470d                	li	a4,3
80006af0:	dfd8                	sw	a4,60(a5)
    ChannelInitStruct->DstProtect.Bufferable = DISABLE;
80006af2:	fec42783          	lw	a5,-20(s0)
80006af6:	0207a423          	sw	zero,40(a5)
    ChannelInitStruct->DstProtect.Priveleged = DISABLE;
80006afa:	fec42783          	lw	a5,-20(s0)
80006afe:	0207a223          	sw	zero,36(a5)
    ChannelInitStruct->DstProtect.Cacheable = DISABLE;
80006b02:	fec42783          	lw	a5,-20(s0)
80006b06:	0207a623          	sw	zero,44(a5)
    /* общее */
    ChannelInitStruct->NextUseburst = DISABLE;
80006b0a:	fec42783          	lw	a5,-20(s0)
80006b0e:	0007a623          	sw	zero,12(a5)
    ChannelInitStruct->ArbitrationRate = DMA_ArbitrationRate_1;
80006b12:	fec42783          	lw	a5,-20(s0)
80006b16:	0007aa23          	sw	zero,20(a5)
    ChannelInitStruct->TransfersTotal = 1;
80006b1a:	fec42783          	lw	a5,-20(s0)
80006b1e:	4705                	li	a4,1
80006b20:	cb98                	sw	a4,16(a5)
    ChannelInitStruct->Mode = DMA_Mode_Disable;
80006b22:	fec42783          	lw	a5,-20(s0)
80006b26:	0007a423          	sw	zero,8(a5)
}
80006b2a:	0001                	nop
80006b2c:	4472                	lw	s0,28(sp)
80006b2e:	6105                	addi	sp,sp,32
80006b30:	8082                	ret

80006b32 <DMA_DeInit>:
/**
  * @brief   Деинициализация контроллера DMA
  * @retval  void
  */
void DMA_DeInit()
{
80006b32:	1141                	addi	sp,sp,-16
80006b34:	c622                	sw	s0,12(sp)
80006b36:	0800                	addi	s0,sp,16
    CLEAR_REG(DMA->CFG);
80006b38:	3000c7b7          	lui	a5,0x3000c
80006b3c:	0007a223          	sw	zero,4(a5) # 3000c004 <STACK_SIZE+0x3000b804>
    CLEAR_REG(DMA->BASEPTR);
80006b40:	3000c7b7          	lui	a5,0x3000c
80006b44:	0007a423          	sw	zero,8(a5) # 3000c008 <STACK_SIZE+0x3000b808>
    WRITE_REG(DMA->ENCLR, DMA_Channel_All);
80006b48:	3000c7b7          	lui	a5,0x3000c
80006b4c:	01000737          	lui	a4,0x1000
80006b50:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006b52:	d7d8                	sw	a4,44(a5)
    WRITE_REG(DMA->PRIORITYCLR, DMA_Channel_All);
80006b54:	3000c7b7          	lui	a5,0x3000c
80006b58:	01000737          	lui	a4,0x1000
80006b5c:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006b5e:	dfd8                	sw	a4,60(a5)
    WRITE_REG(DMA->PRIALTCLR, DMA_Channel_All);
80006b60:	3000c7b7          	lui	a5,0x3000c
80006b64:	01000737          	lui	a4,0x1000
80006b68:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006b6a:	dbd8                	sw	a4,52(a5)
    WRITE_REG(DMA->REQMASKCLR, DMA_Channel_All);
80006b6c:	3000c7b7          	lui	a5,0x3000c
80006b70:	01000737          	lui	a4,0x1000
80006b74:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006b76:	d3d8                	sw	a4,36(a5)
    WRITE_REG(DMA->USEBURSTCLR, DMA_Channel_All);
80006b78:	3000c7b7          	lui	a5,0x3000c
80006b7c:	01000737          	lui	a4,0x1000
80006b80:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006b82:	cfd8                	sw	a4,28(a5)
}
80006b84:	0001                	nop
80006b86:	4432                	lw	s0,12(sp)
80006b88:	0141                	addi	sp,sp,16
80006b8a:	8082                	ret

80006b8c <DMA_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref DMA_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void DMA_Init(DMA_Init_TypeDef* InitStruct)
{
80006b8c:	1101                	addi	sp,sp,-32
80006b8e:	ce06                	sw	ra,28(sp)
80006b90:	cc22                	sw	s0,24(sp)
80006b92:	1000                	addi	s0,sp,32
80006b94:	fea42623          	sw	a0,-20(s0)
    DMA_ProtectConfig(&(InitStruct->CtrlProtect));
80006b98:	fec42783          	lw	a5,-20(s0)
80006b9c:	0791                	addi	a5,a5,4 # 3000c004 <STACK_SIZE+0x3000b804>
80006b9e:	853e                	mv	a0,a5
80006ba0:	3641                	jal	80006720 <DMA_ProtectConfig>
    DMA_UseBurstCmd(InitStruct->Channel, InitStruct->UseBurst);
80006ba2:	fec42783          	lw	a5,-20(s0)
80006ba6:	4398                	lw	a4,0(a5)
80006ba8:	fec42783          	lw	a5,-20(s0)
80006bac:	4b9c                	lw	a5,16(a5)
80006bae:	85be                	mv	a1,a5
80006bb0:	853a                	mv	a0,a4
80006bb2:	3675                	jal	8000675e <DMA_UseBurstCmd>
    DMA_AltCtrlCmd(InitStruct->Channel, InitStruct->AltCtrl);
80006bb4:	fec42783          	lw	a5,-20(s0)
80006bb8:	4398                	lw	a4,0(a5)
80006bba:	fec42783          	lw	a5,-20(s0)
80006bbe:	4f9c                	lw	a5,24(a5)
80006bc0:	85be                	mv	a1,a5
80006bc2:	853a                	mv	a0,a4
80006bc4:	3935                	jal	80006800 <DMA_AltCtrlCmd>
    DMA_HighPriorityCmd(InitStruct->Channel, InitStruct->HighPriority);
80006bc6:	fec42783          	lw	a5,-20(s0)
80006bca:	4398                	lw	a4,0(a5)
80006bcc:	fec42783          	lw	a5,-20(s0)
80006bd0:	4fdc                	lw	a5,28(a5)
80006bd2:	85be                	mv	a1,a5
80006bd4:	853a                	mv	a0,a4
80006bd6:	3185                	jal	80006836 <DMA_HighPriorityCmd>
    DMA_ReqMaskCmd(InitStruct->Channel, InitStruct->ReqMask);
80006bd8:	fec42783          	lw	a5,-20(s0)
80006bdc:	4398                	lw	a4,0(a5)
80006bde:	fec42783          	lw	a5,-20(s0)
80006be2:	4bdc                	lw	a5,20(a5)
80006be4:	85be                	mv	a1,a5
80006be6:	853a                	mv	a0,a4
80006be8:	3675                	jal	80006794 <DMA_ReqMaskCmd>
    DMA_ChannelEnableCmd(InitStruct->Channel, InitStruct->ChannelEnable);
80006bea:	fec42783          	lw	a5,-20(s0)
80006bee:	4398                	lw	a4,0(a5)
80006bf0:	fec42783          	lw	a5,-20(s0)
80006bf4:	539c                	lw	a5,32(a5)
80006bf6:	85be                	mv	a1,a5
80006bf8:	853a                	mv	a0,a4
80006bfa:	3ec1                	jal	800067ca <DMA_ChannelEnableCmd>
}
80006bfc:	0001                	nop
80006bfe:	40f2                	lw	ra,28(sp)
80006c00:	4462                	lw	s0,24(sp)
80006c02:	6105                	addi	sp,sp,32
80006c04:	8082                	ret

80006c06 <DMA_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref DMA_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void DMA_StructInit(DMA_Init_TypeDef* InitStruct)
{
80006c06:	1101                	addi	sp,sp,-32
80006c08:	ce22                	sw	s0,28(sp)
80006c0a:	1000                	addi	s0,sp,32
80006c0c:	fea42623          	sw	a0,-20(s0)
    InitStruct->Channel = DMA_Channel_All;
80006c10:	fec42783          	lw	a5,-20(s0)
80006c14:	01000737          	lui	a4,0x1000
80006c18:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006c1a:	c398                	sw	a4,0(a5)
    InitStruct->ChannelEnable = DISABLE;
80006c1c:	fec42783          	lw	a5,-20(s0)
80006c20:	0207a023          	sw	zero,32(a5)
    InitStruct->HighPriority = DISABLE;
80006c24:	fec42783          	lw	a5,-20(s0)
80006c28:	0007ae23          	sw	zero,28(a5)
    InitStruct->AltCtrl = DISABLE;
80006c2c:	fec42783          	lw	a5,-20(s0)
80006c30:	0007ac23          	sw	zero,24(a5)
    InitStruct->ReqMask = DISABLE;
80006c34:	fec42783          	lw	a5,-20(s0)
80006c38:	0007aa23          	sw	zero,20(a5)
    InitStruct->UseBurst = DISABLE;
80006c3c:	fec42783          	lw	a5,-20(s0)
80006c40:	0007a823          	sw	zero,16(a5)
    InitStruct->CtrlProtect.Bufferable = DISABLE;
80006c44:	fec42783          	lw	a5,-20(s0)
80006c48:	0007a423          	sw	zero,8(a5)
    InitStruct->CtrlProtect.Cacheable = DISABLE;
80006c4c:	fec42783          	lw	a5,-20(s0)
80006c50:	0007a623          	sw	zero,12(a5)
    InitStruct->CtrlProtect.Priveleged = DISABLE;
80006c54:	fec42783          	lw	a5,-20(s0)
80006c58:	0007a223          	sw	zero,4(a5)
}
80006c5c:	0001                	nop
80006c5e:	4472                	lw	s0,28(sp)
80006c60:	6105                	addi	sp,sp,32
80006c62:	8082                	ret

80006c64 <__NOP>:
/* Простейшая реализация NOP для использования в PLIB (например, plib015_flash.c).
 * В старых версиях CMSIS была функция __NOP(), здесь оформляем её как inline.
 */
#ifndef __NOP
__STATIC_INLINE void __NOP(void)
{
80006c64:	1141                	addi	sp,sp,-16
80006c66:	c622                	sw	s0,12(sp)
80006c68:	0800                	addi	s0,sp,16
    __asm volatile ("nop");
80006c6a:	0001                	nop
}
80006c6c:	0001                	nop
80006c6e:	4432                	lw	s0,12(sp)
80006c70:	0141                	addi	sp,sp,16
80006c72:	8082                	ret

80006c74 <FLASH_SetAddr>:
  * @brief   Установка значения адреса
  * @param   AddrVal  Значение адреса
  * @retval  void
  */
__STATIC_INLINE void FLASH_SetAddr(uint32_t AddrVal)
{
80006c74:	1101                	addi	sp,sp,-32
80006c76:	ce22                	sw	s0,28(sp)
80006c78:	1000                	addi	s0,sp,32
80006c7a:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(FLASH->ADDR, AddrVal);
80006c7e:	3000d7b7          	lui	a5,0x3000d
80006c82:	fec42703          	lw	a4,-20(s0)
80006c86:	c398                	sw	a4,0(a5)
}
80006c88:	0001                	nop
80006c8a:	4472                	lw	s0,28(sp)
80006c8c:	6105                	addi	sp,sp,32
80006c8e:	8082                	ret

80006c90 <FLASH_SetData>:
  * @param   DataNum  Номер слова данных
  * @param   DataVal  Значение слова данных
  * @retval  void
  */
__STATIC_INLINE void FLASH_SetData(uint32_t DataNum, uint32_t DataVal)
{
80006c90:	1101                	addi	sp,sp,-32
80006c92:	ce22                	sw	s0,28(sp)
80006c94:	1000                	addi	s0,sp,32
80006c96:	fea42623          	sw	a0,-20(s0)
80006c9a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_FLASH_DATA_NUM(DataNum));

    WRITE_REG(FLASH->DATA[DataNum].DATA, DataVal);
80006c9e:	3000d737          	lui	a4,0x3000d
80006ca2:	fec42783          	lw	a5,-20(s0)
80006ca6:	078a                	slli	a5,a5,0x2
80006ca8:	97ba                	add	a5,a5,a4
80006caa:	fe842703          	lw	a4,-24(s0)
80006cae:	c3d8                	sw	a4,4(a5)
}
80006cb0:	0001                	nop
80006cb2:	4472                	lw	s0,28(sp)
80006cb4:	6105                	addi	sp,sp,32
80006cb6:	8082                	ret

80006cb8 <FLASH_GetData>:
  * @brief   Получение выбранного слова данных
  * @param   DataNum  Номер слова данных
  * @retval  Val  Значение слова данных
  */
__STATIC_INLINE uint32_t FLASH_GetData(uint32_t DataNum)
{
80006cb8:	1101                	addi	sp,sp,-32
80006cba:	ce22                	sw	s0,28(sp)
80006cbc:	1000                	addi	s0,sp,32
80006cbe:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FLASH_DATA_NUM(DataNum));

    return READ_REG(FLASH->DATA[DataNum].DATA);
80006cc2:	3000d737          	lui	a4,0x3000d
80006cc6:	fec42783          	lw	a5,-20(s0)
80006cca:	078a                	slli	a5,a5,0x2
80006ccc:	97ba                	add	a5,a5,a4
80006cce:	43dc                	lw	a5,4(a5)
}
80006cd0:	853e                	mv	a0,a5
80006cd2:	4472                	lw	s0,28(sp)
80006cd4:	6105                	addi	sp,sp,32
80006cd6:	8082                	ret

80006cd8 <FLASH_SetCmd>:
  * @param   Cmd  Команда
  * @param   Region  Область
  * @retval  void
  */
__STATIC_INLINE void FLASH_SetCmd(FLASH_Cmd_TypeDef Cmd, FLASH_Region_TypeDef Region)
{
80006cd8:	1101                	addi	sp,sp,-32
80006cda:	ce22                	sw	s0,28(sp)
80006cdc:	1000                	addi	s0,sp,32
80006cde:	fea42623          	sw	a0,-20(s0)
80006ce2:	feb42423          	sw	a1,-24(s0)
    WRITE_REG(FLASH->CMD, ((uint32_t)FLASH_CMD_KEY_Access << FLASH_CMD_KEY_Pos) | (uint32_t)Region | (uint32_t)Cmd);
80006ce6:	fe842703          	lw	a4,-24(s0)
80006cea:	fec42783          	lw	a5,-20(s0)
80006cee:	00f766b3          	or	a3,a4,a5
80006cf2:	3000d7b7          	lui	a5,0x3000d
80006cf6:	c0de0737          	lui	a4,0xc0de0
80006cfa:	8f55                	or	a4,a4,a3
80006cfc:	c3f8                	sw	a4,68(a5)
}
80006cfe:	0001                	nop
80006d00:	4472                	lw	s0,28(sp)
80006d02:	6105                	addi	sp,sp,32
80006d04:	8082                	ret

80006d06 <FLASH_BusyStatus>:
/**
  * @brief   Получение статуса занятости контроллера флеш-памяти
  * @retval  Status
  */
__STATIC_INLINE FlagStatus FLASH_BusyStatus(void)
{
80006d06:	1141                	addi	sp,sp,-16
80006d08:	c622                	sw	s0,12(sp)
80006d0a:	0800                	addi	s0,sp,16
    return (FlagStatus)READ_BIT(FLASH->STAT, FLASH_STAT_BUSY_Msk);
80006d0c:	3000d7b7          	lui	a5,0x3000d
80006d10:	47bc                	lw	a5,72(a5)
80006d12:	8b85                	andi	a5,a5,1
}
80006d14:	853e                	mv	a0,a5
80006d16:	4432                	lw	s0,12(sp)
80006d18:	0141                	addi	sp,sp,16
80006d1a:	8082                	ret

80006d1c <FLASH_ReadData>:
  * @param   DataArr  Указатель на массив, в который будут переданы 2 32-битных слова данных
  * @param   Region  Выбор области
  * @retval  void
  */
void FLASH_ReadData(uint32_t AddrVal, uint32_t* DataArr, FLASH_Region_TypeDef Region)
{
80006d1c:	7179                	addi	sp,sp,-48
80006d1e:	d606                	sw	ra,44(sp)
80006d20:	d422                	sw	s0,40(sp)
80006d22:	d226                	sw	s1,36(sp)
80006d24:	1800                	addi	s0,sp,48
80006d26:	fca42e23          	sw	a0,-36(s0)
80006d2a:	fcb42c23          	sw	a1,-40(s0)
80006d2e:	fcc42a23          	sw	a2,-44(s0)
    if (Region == FLASH_Region_Main)
        assert_param(IS_FLASH_MAIN_ADDR(AddrVal));
    else /* (Region == FLASH_Region_NVR) */
        assert_param(IS_FLASH_NVR_ADDR(AddrVal));

    FLASH_SetAddr(AddrVal);
80006d32:	fdc42503          	lw	a0,-36(s0)
80006d36:	3f3d                	jal	80006c74 <FLASH_SetAddr>
    FLASH_SetCmd(FLASH_Cmd_Read, Region);
80006d38:	fd442583          	lw	a1,-44(s0)
80006d3c:	4505                	li	a0,1
80006d3e:	3f69                	jal	80006cd8 <FLASH_SetCmd>
    __NOP5();
80006d40:	3715                	jal	80006c64 <__NOP>
80006d42:	370d                	jal	80006c64 <__NOP>
80006d44:	3705                	jal	80006c64 <__NOP>
80006d46:	3f39                	jal	80006c64 <__NOP>
80006d48:	3f31                	jal	80006c64 <__NOP>
    while (FLASH_BusyStatus()) {
80006d4a:	0001                	nop
80006d4c:	3f6d                	jal	80006d06 <FLASH_BusyStatus>
80006d4e:	87aa                	mv	a5,a0
80006d50:	fff5                	bnez	a5,80006d4c <FLASH_ReadData+0x30>
    };
    for (uint32_t i = 0; i < MEM_FLASH_BUS_WIDTH_WORDS; i++) {
80006d52:	fe042623          	sw	zero,-20(s0)
80006d56:	a015                	j	80006d7a <FLASH_ReadData+0x5e>
        DataArr[i] = FLASH_GetData(i);
80006d58:	fec42783          	lw	a5,-20(s0)
80006d5c:	078a                	slli	a5,a5,0x2
80006d5e:	fd842703          	lw	a4,-40(s0)
80006d62:	00f704b3          	add	s1,a4,a5
80006d66:	fec42503          	lw	a0,-20(s0)
80006d6a:	37b9                	jal	80006cb8 <FLASH_GetData>
80006d6c:	87aa                	mv	a5,a0
80006d6e:	c09c                	sw	a5,0(s1)
    for (uint32_t i = 0; i < MEM_FLASH_BUS_WIDTH_WORDS; i++) {
80006d70:	fec42783          	lw	a5,-20(s0)
80006d74:	0785                	addi	a5,a5,1 # 3000d001 <STACK_SIZE+0x3000c801>
80006d76:	fef42623          	sw	a5,-20(s0)
80006d7a:	fec42703          	lw	a4,-20(s0)
80006d7e:	47bd                	li	a5,15
80006d80:	fce7fce3          	bgeu	a5,a4,80006d58 <FLASH_ReadData+0x3c>
    }
}
80006d84:	0001                	nop
80006d86:	0001                	nop
80006d88:	50b2                	lw	ra,44(sp)
80006d8a:	5422                	lw	s0,40(sp)
80006d8c:	5492                	lw	s1,36(sp)
80006d8e:	6145                	addi	sp,sp,48
80006d90:	8082                	ret

80006d92 <FLASH_WriteData>:
  * @param   DataArr  Указатель на массив, из которого будут взяты 2 32-битных слова данных
  * @param   Region  Выбор области
  * @retval  void
  */
void FLASH_WriteData(uint32_t AddrVal, uint32_t* DataArr, FLASH_Region_TypeDef Region)
{
80006d92:	7179                	addi	sp,sp,-48
80006d94:	d606                	sw	ra,44(sp)
80006d96:	d422                	sw	s0,40(sp)
80006d98:	1800                	addi	s0,sp,48
80006d9a:	fca42e23          	sw	a0,-36(s0)
80006d9e:	fcb42c23          	sw	a1,-40(s0)
80006da2:	fcc42a23          	sw	a2,-44(s0)
    if (Region == FLASH_Region_Main)
        assert_param(IS_FLASH_MAIN_ADDR(AddrVal));
    else /* (Region == FLASH_Region_NVR) */
        assert_param(IS_FLASH_NVR_ADDR(AddrVal));

    FLASH_SetAddr(AddrVal);
80006da6:	fdc42503          	lw	a0,-36(s0)
80006daa:	35e9                	jal	80006c74 <FLASH_SetAddr>
    for (uint32_t i = 0; i < MEM_FLASH_BUS_WIDTH_WORDS; i++) {
80006dac:	fe042623          	sw	zero,-20(s0)
80006db0:	a00d                	j	80006dd2 <FLASH_WriteData+0x40>
        FLASH_SetData(i, DataArr[i]);
80006db2:	fec42783          	lw	a5,-20(s0)
80006db6:	078a                	slli	a5,a5,0x2
80006db8:	fd842703          	lw	a4,-40(s0)
80006dbc:	97ba                	add	a5,a5,a4
80006dbe:	439c                	lw	a5,0(a5)
80006dc0:	85be                	mv	a1,a5
80006dc2:	fec42503          	lw	a0,-20(s0)
80006dc6:	35e9                	jal	80006c90 <FLASH_SetData>
    for (uint32_t i = 0; i < MEM_FLASH_BUS_WIDTH_WORDS; i++) {
80006dc8:	fec42783          	lw	a5,-20(s0)
80006dcc:	0785                	addi	a5,a5,1
80006dce:	fef42623          	sw	a5,-20(s0)
80006dd2:	fec42703          	lw	a4,-20(s0)
80006dd6:	47bd                	li	a5,15
80006dd8:	fce7fde3          	bgeu	a5,a4,80006db2 <FLASH_WriteData+0x20>
    }
    FLASH_SetCmd(FLASH_Cmd_Write, Region);
80006ddc:	fd442583          	lw	a1,-44(s0)
80006de0:	4509                	li	a0,2
80006de2:	3ddd                	jal	80006cd8 <FLASH_SetCmd>
    __NOP5();
80006de4:	3541                	jal	80006c64 <__NOP>
80006de6:	3dbd                	jal	80006c64 <__NOP>
80006de8:	3db5                	jal	80006c64 <__NOP>
80006dea:	3dad                	jal	80006c64 <__NOP>
80006dec:	3da5                	jal	80006c64 <__NOP>
    while (FLASH_BusyStatus()) {
80006dee:	0001                	nop
80006df0:	3f19                	jal	80006d06 <FLASH_BusyStatus>
80006df2:	87aa                	mv	a5,a0
80006df4:	fff5                	bnez	a5,80006df0 <FLASH_WriteData+0x5e>
    };
}
80006df6:	0001                	nop
80006df8:	0001                	nop
80006dfa:	50b2                	lw	ra,44(sp)
80006dfc:	5422                	lw	s0,40(sp)
80006dfe:	6145                	addi	sp,sp,48
80006e00:	8082                	ret

80006e02 <FLASH_ErasePage>:
  * @param   AddrVal  Начальный адрес страницы
  * @param   Region  Выбор области
  * @retval  void
  */
void FLASH_ErasePage(uint32_t AddrVal, FLASH_Region_TypeDef Region)
{
80006e02:	1101                	addi	sp,sp,-32
80006e04:	ce06                	sw	ra,28(sp)
80006e06:	cc22                	sw	s0,24(sp)
80006e08:	1000                	addi	s0,sp,32
80006e0a:	fea42623          	sw	a0,-20(s0)
80006e0e:	feb42423          	sw	a1,-24(s0)
    if (Region == FLASH_Region_Main)
        assert_param(IS_FLASH_MAIN_ADDR(AddrVal));
    else /* (Region == FLASH_Region_NVR) */
        assert_param(IS_FLASH_NVR_ADDR(AddrVal));

    FLASH_SetAddr(AddrVal);
80006e12:	fec42503          	lw	a0,-20(s0)
80006e16:	3db9                	jal	80006c74 <FLASH_SetAddr>
    FLASH_SetCmd(FLASH_Cmd_ErasePage, Region);
80006e18:	fe842583          	lw	a1,-24(s0)
80006e1c:	4511                	li	a0,4
80006e1e:	3d6d                	jal	80006cd8 <FLASH_SetCmd>
    __NOP5();
80006e20:	3591                	jal	80006c64 <__NOP>
80006e22:	3589                	jal	80006c64 <__NOP>
80006e24:	3581                	jal	80006c64 <__NOP>
80006e26:	3d3d                	jal	80006c64 <__NOP>
80006e28:	3d35                	jal	80006c64 <__NOP>
    while (FLASH_BusyStatus()) {
80006e2a:	0001                	nop
80006e2c:	3de9                	jal	80006d06 <FLASH_BusyStatus>
80006e2e:	87aa                	mv	a5,a0
80006e30:	fff5                	bnez	a5,80006e2c <FLASH_ErasePage+0x2a>
    };
}
80006e32:	0001                	nop
80006e34:	0001                	nop
80006e36:	40f2                	lw	ra,28(sp)
80006e38:	4462                	lw	s0,24(sp)
80006e3a:	6105                	addi	sp,sp,32
80006e3c:	8082                	ret

80006e3e <FLASH_EraseFull>:
  * @brief   Стирание области флеш полностью
  * @param   Region  Выбор области
  * @retval  void
  */
void FLASH_EraseFull(FLASH_Region_TypeDef Region)
{
80006e3e:	1101                	addi	sp,sp,-32
80006e40:	ce06                	sw	ra,28(sp)
80006e42:	cc22                	sw	s0,24(sp)
80006e44:	1000                	addi	s0,sp,32
80006e46:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FLASH_REGION(Region));

    FLASH_SetCmd(FLASH_Cmd_EraseFull, Region);
80006e4a:	fec42583          	lw	a1,-20(s0)
80006e4e:	4531                	li	a0,12
80006e50:	3561                	jal	80006cd8 <FLASH_SetCmd>
    __NOP5();
80006e52:	3d09                	jal	80006c64 <__NOP>
80006e54:	3d01                	jal	80006c64 <__NOP>
80006e56:	3539                	jal	80006c64 <__NOP>
80006e58:	3531                	jal	80006c64 <__NOP>
80006e5a:	3529                	jal	80006c64 <__NOP>
    while (FLASH_BusyStatus()) {
80006e5c:	0001                	nop
80006e5e:	3565                	jal	80006d06 <FLASH_BusyStatus>
80006e60:	87aa                	mv	a5,a0
80006e62:	fff5                	bnez	a5,80006e5e <FLASH_EraseFull+0x20>
    };
}
80006e64:	0001                	nop
80006e66:	0001                	nop
80006e68:	40f2                	lw	ra,28(sp)
80006e6a:	4462                	lw	s0,24(sp)
80006e6c:	6105                	addi	sp,sp,32
80006e6e:	8082                	ret

80006e70 <RCU_AHBRstCmd>:
{
80006e70:	1101                	addi	sp,sp,-32
80006e72:	ce22                	sw	s0,28(sp)
80006e74:	1000                	addi	s0,sp,32
80006e76:	fea42623          	sw	a0,-20(s0)
80006e7a:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80006e7e:	3000e7b7          	lui	a5,0x3000e
80006e82:	4b98                	lw	a4,16(a5)
80006e84:	fec42783          	lw	a5,-20(s0)
80006e88:	fff7c793          	not	a5,a5
80006e8c:	00f776b3          	and	a3,a4,a5
80006e90:	fe842783          	lw	a5,-24(s0)
80006e94:	c781                	beqz	a5,80006e9c <RCU_AHBRstCmd+0x2c>
80006e96:	fec42783          	lw	a5,-20(s0)
80006e9a:	a011                	j	80006e9e <RCU_AHBRstCmd+0x2e>
80006e9c:	4781                	li	a5,0
80006e9e:	3000e737          	lui	a4,0x3000e
80006ea2:	8fd5                	or	a5,a5,a3
80006ea4:	cb1c                	sw	a5,16(a4)
}
80006ea6:	0001                	nop
80006ea8:	4472                	lw	s0,28(sp)
80006eaa:	6105                	addi	sp,sp,32
80006eac:	8082                	ret

80006eae <GPIO_OutCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_OutCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80006eae:	1101                	addi	sp,sp,-32
80006eb0:	ce22                	sw	s0,28(sp)
80006eb2:	1000                	addi	s0,sp,32
80006eb4:	fea42623          	sw	a0,-20(s0)
80006eb8:	feb42423          	sw	a1,-24(s0)
80006ebc:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80006ec0:	fe442703          	lw	a4,-28(s0)
80006ec4:	4785                	li	a5,1
80006ec6:	00f71863          	bne	a4,a5,80006ed6 <GPIO_OutCmd+0x28>
        WRITE_REG(GPIOx->OUTENSET, Pin);
80006eca:	fec42783          	lw	a5,-20(s0)
80006ece:	fe842703          	lw	a4,-24(s0)
80006ed2:	d7d8                	sw	a4,44(a5)
    else
        WRITE_REG(GPIOx->OUTENCLR, Pin);
}
80006ed4:	a031                	j	80006ee0 <GPIO_OutCmd+0x32>
        WRITE_REG(GPIOx->OUTENCLR, Pin);
80006ed6:	fec42783          	lw	a5,-20(s0)
80006eda:	fe842703          	lw	a4,-24(s0)
80006ede:	db98                	sw	a4,48(a5)
}
80006ee0:	0001                	nop
80006ee2:	4472                	lw	s0,28(sp)
80006ee4:	6105                	addi	sp,sp,32
80006ee6:	8082                	ret

80006ee8 <GPIO_AltFuncCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_AltFuncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80006ee8:	1101                	addi	sp,sp,-32
80006eea:	ce22                	sw	s0,28(sp)
80006eec:	1000                	addi	s0,sp,32
80006eee:	fea42623          	sw	a0,-20(s0)
80006ef2:	feb42423          	sw	a1,-24(s0)
80006ef6:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80006efa:	fe442703          	lw	a4,-28(s0)
80006efe:	4785                	li	a5,1
80006f00:	00f71863          	bne	a4,a5,80006f10 <GPIO_AltFuncCmd+0x28>
        WRITE_REG(GPIOx->ALTFUNCSET, Pin);
80006f04:	fec42783          	lw	a5,-20(s0)
80006f08:	fe842703          	lw	a4,-24(s0)
80006f0c:	dbd8                	sw	a4,52(a5)
    else
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
}
80006f0e:	a031                	j	80006f1a <GPIO_AltFuncCmd+0x32>
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
80006f10:	fec42783          	lw	a5,-20(s0)
80006f14:	fe842703          	lw	a4,-24(s0)
80006f18:	df98                	sw	a4,56(a5)
}
80006f1a:	0001                	nop
80006f1c:	4472                	lw	s0,28(sp)
80006f1e:	6105                	addi	sp,sp,32
80006f20:	8082                	ret

80006f22 <modeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   Val  Конфигурация пинов (2-битное значение)
  * @retval  void
  */
static void modeConfig(volatile uint32_t* Reg, uint32_t Pin, uint32_t Val)
{
80006f22:	7179                	addi	sp,sp,-48
80006f24:	d622                	sw	s0,44(sp)
80006f26:	1800                	addi	s0,sp,48
80006f28:	fca42e23          	sw	a0,-36(s0)
80006f2c:	fcb42c23          	sw	a1,-40(s0)
80006f30:	fcc42a23          	sw	a2,-44(s0)
    uint32_t reg_temp = *Reg;
80006f34:	fdc42783          	lw	a5,-36(s0)
80006f38:	439c                	lw	a5,0(a5)
80006f3a:	fef42623          	sw	a5,-20(s0)

    for (uint32_t i = 0; i < 16; i++) {
80006f3e:	fe042423          	sw	zero,-24(s0)
80006f42:	a889                	j	80006f94 <modeConfig+0x72>
        if (Pin & (1 << i)) {
80006f44:	fe842783          	lw	a5,-24(s0)
80006f48:	4705                	li	a4,1
80006f4a:	00f717b3          	sll	a5,a4,a5
80006f4e:	873e                	mv	a4,a5
80006f50:	fd842783          	lw	a5,-40(s0)
80006f54:	8ff9                	and	a5,a5,a4
80006f56:	cb95                	beqz	a5,80006f8a <modeConfig+0x68>
            reg_temp &= ~(0x3UL << i * 0x2UL);
80006f58:	fe842783          	lw	a5,-24(s0)
80006f5c:	0786                	slli	a5,a5,0x1
80006f5e:	470d                	li	a4,3
80006f60:	00f717b3          	sll	a5,a4,a5
80006f64:	fff7c793          	not	a5,a5
80006f68:	fec42703          	lw	a4,-20(s0)
80006f6c:	8ff9                	and	a5,a5,a4
80006f6e:	fef42623          	sw	a5,-20(s0)
            reg_temp |= Val << i * 0x2UL;
80006f72:	fe842783          	lw	a5,-24(s0)
80006f76:	0786                	slli	a5,a5,0x1
80006f78:	fd442703          	lw	a4,-44(s0)
80006f7c:	00f717b3          	sll	a5,a4,a5
80006f80:	fec42703          	lw	a4,-20(s0)
80006f84:	8fd9                	or	a5,a5,a4
80006f86:	fef42623          	sw	a5,-20(s0)
    for (uint32_t i = 0; i < 16; i++) {
80006f8a:	fe842783          	lw	a5,-24(s0)
80006f8e:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80006f90:	fef42423          	sw	a5,-24(s0)
80006f94:	fe842703          	lw	a4,-24(s0)
80006f98:	47bd                	li	a5,15
80006f9a:	fae7f5e3          	bgeu	a5,a4,80006f44 <modeConfig+0x22>
        }
    }

    WRITE_REG(*Reg, reg_temp);
80006f9e:	fdc42783          	lw	a5,-36(s0)
80006fa2:	fec42703          	lw	a4,-20(s0)
80006fa6:	c398                	sw	a4,0(a5)
}
80006fa8:	0001                	nop
80006faa:	5432                	lw	s0,44(sp)
80006fac:	6145                	addi	sp,sp,48
80006fae:	8082                	ret

80006fb0 <GPIO_OutModeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   OutMode  Режим работы
  * @retval  void
  */
void GPIO_OutModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_OutMode_TypeDef OutMode)
{
80006fb0:	1101                	addi	sp,sp,-32
80006fb2:	ce06                	sw	ra,28(sp)
80006fb4:	cc22                	sw	s0,24(sp)
80006fb6:	1000                	addi	s0,sp,32
80006fb8:	fea42623          	sw	a0,-20(s0)
80006fbc:	feb42423          	sw	a1,-24(s0)
80006fc0:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_OUT_MODE(OutMode));

    modeConfig(&(GPIOx->OUTMODE), Pin, (uint32_t)OutMode);
80006fc4:	fec42783          	lw	a5,-20(s0)
80006fc8:	02478793          	addi	a5,a5,36
80006fcc:	fe442603          	lw	a2,-28(s0)
80006fd0:	fe842583          	lw	a1,-24(s0)
80006fd4:	853e                	mv	a0,a5
80006fd6:	37b1                	jal	80006f22 <modeConfig>
}
80006fd8:	0001                	nop
80006fda:	40f2                	lw	ra,28(sp)
80006fdc:	4462                	lw	s0,24(sp)
80006fde:	6105                	addi	sp,sp,32
80006fe0:	8082                	ret

80006fe2 <GPIO_PullModeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   PullMode  Режим работы
  * @retval  void
  */
void GPIO_PullModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_PullMode_TypeDef PullMode)
{
80006fe2:	1101                	addi	sp,sp,-32
80006fe4:	ce22                	sw	s0,28(sp)
80006fe6:	1000                	addi	s0,sp,32
80006fe8:	fea42623          	sw	a0,-20(s0)
80006fec:	feb42423          	sw	a1,-24(s0)
80006ff0:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_PULL_MODE(PullMode));

    MODIFY_REG(GPIOx->PULLMODE, Pin, (uint32_t)PullMode);
80006ff4:	fec42783          	lw	a5,-20(s0)
80006ff8:	5398                	lw	a4,32(a5)
80006ffa:	fe842783          	lw	a5,-24(s0)
80006ffe:	fff7c793          	not	a5,a5
80007002:	8f7d                	and	a4,a4,a5
80007004:	fe442783          	lw	a5,-28(s0)
80007008:	8f5d                	or	a4,a4,a5
8000700a:	fec42783          	lw	a5,-20(s0)
8000700e:	d398                	sw	a4,32(a5)
}
80007010:	0001                	nop
80007012:	4472                	lw	s0,28(sp)
80007014:	6105                	addi	sp,sp,32
80007016:	8082                	ret

80007018 <GPIO_AltFuncNumConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   AltFuncNum  Номер функции
  * @retval  void
  */
void GPIO_AltFuncNumConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_AltFuncNum_TypeDef AltFuncNum)
{
80007018:	7179                	addi	sp,sp,-48
8000701a:	d622                	sw	s0,44(sp)
8000701c:	1800                	addi	s0,sp,48
8000701e:	fca42e23          	sw	a0,-36(s0)
80007022:	fcb42c23          	sw	a1,-40(s0)
80007026:	fcc42a23          	sw	a2,-44(s0)
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_ALT_FUNC_NUM(AltFuncNum));

    uint32_t temp;

    temp = GPIOx->ALTFUNCNUM;
8000702a:	fdc42783          	lw	a5,-36(s0)
8000702e:	5fdc                	lw	a5,60(a5)
80007030:	fef42623          	sw	a5,-20(s0)

    for (uint32_t i = 0; i < 16; i++) {
80007034:	fe042423          	sw	zero,-24(s0)
80007038:	a889                	j	8000708a <GPIO_AltFuncNumConfig+0x72>
    	if (Pin & (1 << i))
8000703a:	fe842783          	lw	a5,-24(s0)
8000703e:	4705                	li	a4,1
80007040:	00f717b3          	sll	a5,a4,a5
80007044:	873e                	mv	a4,a5
80007046:	fd842783          	lw	a5,-40(s0)
8000704a:	8ff9                	and	a5,a5,a4
8000704c:	cb95                	beqz	a5,80007080 <GPIO_AltFuncNumConfig+0x68>
    	{
    		temp &= ~(0x3UL << i * 0x2UL);
8000704e:	fe842783          	lw	a5,-24(s0)
80007052:	0786                	slli	a5,a5,0x1
80007054:	470d                	li	a4,3
80007056:	00f717b3          	sll	a5,a4,a5
8000705a:	fff7c793          	not	a5,a5
8000705e:	fec42703          	lw	a4,-20(s0)
80007062:	8ff9                	and	a5,a5,a4
80007064:	fef42623          	sw	a5,-20(s0)
    		temp |= (uint32_t)AltFuncNum << i * 0x2UL;
80007068:	fe842783          	lw	a5,-24(s0)
8000706c:	0786                	slli	a5,a5,0x1
8000706e:	fd442703          	lw	a4,-44(s0)
80007072:	00f717b3          	sll	a5,a4,a5
80007076:	fec42703          	lw	a4,-20(s0)
8000707a:	8fd9                	or	a5,a5,a4
8000707c:	fef42623          	sw	a5,-20(s0)
    for (uint32_t i = 0; i < 16; i++) {
80007080:	fe842783          	lw	a5,-24(s0)
80007084:	0785                	addi	a5,a5,1
80007086:	fef42423          	sw	a5,-24(s0)
8000708a:	fe842703          	lw	a4,-24(s0)
8000708e:	47bd                	li	a5,15
80007090:	fae7f5e3          	bgeu	a5,a4,8000703a <GPIO_AltFuncNumConfig+0x22>
//                temp1 |= (uint32_t)AltFuncNum << (i - 8) * 0x4UL;
//            }
//        }
    }

    GPIOx->ALTFUNCNUM = temp;
80007094:	fdc42783          	lw	a5,-36(s0)
80007098:	fec42703          	lw	a4,-20(s0)
8000709c:	dfd8                	sw	a4,60(a5)
}
8000709e:	0001                	nop
800070a0:	5432                	lw	s0,44(sp)
800070a2:	6145                	addi	sp,sp,48
800070a4:	8082                	ret

800070a6 <GPIO_DeInit>:
  * @brief   Устанавливает все регистры выбранного GPIOx значениями по умолчанию
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @retval  void
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
800070a6:	7179                	addi	sp,sp,-48
800070a8:	d606                	sw	ra,44(sp)
800070aa:	d422                	sw	s0,40(sp)
800070ac:	1800                	addi	s0,sp,48
800070ae:	fca42e23          	sw	a0,-36(s0)
    uint32_t GPIO_rst;

    assert_param(IS_GPIO_PERIPH(GPIOx));

    if (GPIOx == GPIOA)
800070b2:	fdc42703          	lw	a4,-36(s0)
800070b6:	280007b7          	lui	a5,0x28000
800070ba:	00f71763          	bne	a4,a5,800070c8 <GPIO_DeInit+0x22>
        GPIO_rst = RCU_AHBRst_GPIOA;
800070be:	10000793          	li	a5,256
800070c2:	fef42623          	sw	a5,-20(s0)
800070c6:	a035                	j	800070f2 <GPIO_DeInit+0x4c>
    else if (GPIOx == GPIOB)
800070c8:	fdc42703          	lw	a4,-36(s0)
800070cc:	280017b7          	lui	a5,0x28001
800070d0:	00f71763          	bne	a4,a5,800070de <GPIO_DeInit+0x38>
        GPIO_rst = RCU_AHBRst_GPIOB;
800070d4:	20000793          	li	a5,512
800070d8:	fef42623          	sw	a5,-20(s0)
800070dc:	a819                	j	800070f2 <GPIO_DeInit+0x4c>
    else  if (GPIOx == GPIOC)
800070de:	fdc42703          	lw	a4,-36(s0)
800070e2:	280027b7          	lui	a5,0x28002
800070e6:	00f71663          	bne	a4,a5,800070f2 <GPIO_DeInit+0x4c>
        GPIO_rst = RCU_AHBRst_GPIOC;
800070ea:	40000793          	li	a5,1024
800070ee:	fef42623          	sw	a5,-20(s0)

    RCU_AHBRstCmd(GPIO_rst, DISABLE);
800070f2:	4581                	li	a1,0
800070f4:	fec42503          	lw	a0,-20(s0)
800070f8:	3ba5                	jal	80006e70 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(GPIO_rst, ENABLE);
800070fa:	4585                	li	a1,1
800070fc:	fec42503          	lw	a0,-20(s0)
80007100:	3b85                	jal	80006e70 <RCU_AHBRstCmd>
}
80007102:	0001                	nop
80007104:	50b2                	lw	ra,44(sp)
80007106:	5422                	lw	s0,40(sp)
80007108:	6145                	addi	sp,sp,48
8000710a:	8082                	ret

8000710c <GPIO_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref GPIO_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_Init_TypeDef* InitStruct)
{
8000710c:	1101                	addi	sp,sp,-32
8000710e:	ce06                	sw	ra,28(sp)
80007110:	cc22                	sw	s0,24(sp)
80007112:	1000                	addi	s0,sp,32
80007114:	fea42623          	sw	a0,-20(s0)
80007118:	feb42423          	sw	a1,-24(s0)
    GPIO_OutCmd(GPIOx, InitStruct->Pin, InitStruct->Out);
8000711c:	fe842783          	lw	a5,-24(s0)
80007120:	4398                	lw	a4,0(a5)
80007122:	fe842783          	lw	a5,-24(s0)
80007126:	43dc                	lw	a5,4(a5)
80007128:	863e                	mv	a2,a5
8000712a:	85ba                	mv	a1,a4
8000712c:	fec42503          	lw	a0,-20(s0)
80007130:	3bbd                	jal	80006eae <GPIO_OutCmd>
    GPIO_AltFuncNumConfig(GPIOx, InitStruct->Pin, InitStruct->AltFuncNum);
80007132:	fe842783          	lw	a5,-24(s0)
80007136:	4398                	lw	a4,0(a5)
80007138:	fe842783          	lw	a5,-24(s0)
8000713c:	47dc                	lw	a5,12(a5)
8000713e:	863e                	mv	a2,a5
80007140:	85ba                	mv	a1,a4
80007142:	fec42503          	lw	a0,-20(s0)
80007146:	3dc9                	jal	80007018 <GPIO_AltFuncNumConfig>
    GPIO_AltFuncCmd(GPIOx, InitStruct->Pin, InitStruct->AltFunc);
80007148:	fe842783          	lw	a5,-24(s0)
8000714c:	4398                	lw	a4,0(a5)
8000714e:	fe842783          	lw	a5,-24(s0)
80007152:	479c                	lw	a5,8(a5)
80007154:	863e                	mv	a2,a5
80007156:	85ba                	mv	a1,a4
80007158:	fec42503          	lw	a0,-20(s0)
8000715c:	3371                	jal	80006ee8 <GPIO_AltFuncCmd>
    GPIO_OutModeConfig(GPIOx, InitStruct->Pin, InitStruct->OutMode);
8000715e:	fe842783          	lw	a5,-24(s0)
80007162:	4398                	lw	a4,0(a5)
80007164:	fe842783          	lw	a5,-24(s0)
80007168:	4b9c                	lw	a5,16(a5)
8000716a:	863e                	mv	a2,a5
8000716c:	85ba                	mv	a1,a4
8000716e:	fec42503          	lw	a0,-20(s0)
80007172:	3d3d                	jal	80006fb0 <GPIO_OutModeConfig>
    GPIO_PullModeConfig(GPIOx, InitStruct->Pin, InitStruct->PullMode);
80007174:	fe842783          	lw	a5,-24(s0)
80007178:	4398                	lw	a4,0(a5)
8000717a:	fe842783          	lw	a5,-24(s0)
8000717e:	4bdc                	lw	a5,20(a5)
80007180:	863e                	mv	a2,a5
80007182:	85ba                	mv	a1,a4
80007184:	fec42503          	lw	a0,-20(s0)
80007188:	3da9                	jal	80006fe2 <GPIO_PullModeConfig>
}
8000718a:	0001                	nop
8000718c:	40f2                	lw	ra,28(sp)
8000718e:	4462                	lw	s0,24(sp)
80007190:	6105                	addi	sp,sp,32
80007192:	8082                	ret

80007194 <GPIO_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref GPIO_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void GPIO_StructInit(GPIO_Init_TypeDef* InitStruct)
{
80007194:	1101                	addi	sp,sp,-32
80007196:	ce22                	sw	s0,28(sp)
80007198:	1000                	addi	s0,sp,32
8000719a:	fea42623          	sw	a0,-20(s0)
    InitStruct->Pin = GPIO_Pin_All;
8000719e:	fec42783          	lw	a5,-20(s0)
800071a2:	6741                	lui	a4,0x10
800071a4:	177d                	addi	a4,a4,-1 # ffff <STACK_SIZE+0xf7ff>
800071a6:	c398                	sw	a4,0(a5)
    InitStruct->Out = DISABLE;
800071a8:	fec42783          	lw	a5,-20(s0)
800071ac:	0007a223          	sw	zero,4(a5) # 28002004 <STACK_SIZE+0x28001804>
    InitStruct->AltFuncNum = GPIO_AltFuncNum_None;
800071b0:	fec42783          	lw	a5,-20(s0)
800071b4:	0007a623          	sw	zero,12(a5)
    InitStruct->AltFunc = DISABLE;
800071b8:	fec42783          	lw	a5,-20(s0)
800071bc:	0007a423          	sw	zero,8(a5)
    InitStruct->OutMode = GPIO_OutMode_PP;
800071c0:	fec42783          	lw	a5,-20(s0)
800071c4:	0007a823          	sw	zero,16(a5)
    InitStruct->PullMode = GPIO_PullMode_Disable;
800071c8:	fec42783          	lw	a5,-20(s0)
800071cc:	0007aa23          	sw	zero,20(a5)
}
800071d0:	0001                	nop
800071d2:	4472                	lw	s0,28(sp)
800071d4:	6105                	addi	sp,sp,32
800071d6:	8082                	ret

800071d8 <RCU_AHBClkCmd>:
{
800071d8:	1101                	addi	sp,sp,-32
800071da:	ce22                	sw	s0,28(sp)
800071dc:	1000                	addi	s0,sp,32
800071de:	fea42623          	sw	a0,-20(s0)
800071e2:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->CGCFGAHB, AHBClk, State ? AHBClk : 0);
800071e6:	3000e7b7          	lui	a5,0x3000e
800071ea:	4398                	lw	a4,0(a5)
800071ec:	fec42783          	lw	a5,-20(s0)
800071f0:	fff7c793          	not	a5,a5
800071f4:	00f776b3          	and	a3,a4,a5
800071f8:	fe842783          	lw	a5,-24(s0)
800071fc:	c781                	beqz	a5,80007204 <RCU_AHBClkCmd+0x2c>
800071fe:	fec42783          	lw	a5,-20(s0)
80007202:	a011                	j	80007206 <RCU_AHBClkCmd+0x2e>
80007204:	4781                	li	a5,0
80007206:	3000e737          	lui	a4,0x3000e
8000720a:	8fd5                	or	a5,a5,a3
8000720c:	c31c                	sw	a5,0(a4)
}
8000720e:	0001                	nop
80007210:	4472                	lw	s0,28(sp)
80007212:	6105                	addi	sp,sp,32
80007214:	8082                	ret

80007216 <RCU_AHBRstCmd>:
{
80007216:	1101                	addi	sp,sp,-32
80007218:	ce22                	sw	s0,28(sp)
8000721a:	1000                	addi	s0,sp,32
8000721c:	fea42623          	sw	a0,-20(s0)
80007220:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80007224:	3000e7b7          	lui	a5,0x3000e
80007228:	4b98                	lw	a4,16(a5)
8000722a:	fec42783          	lw	a5,-20(s0)
8000722e:	fff7c793          	not	a5,a5
80007232:	00f776b3          	and	a3,a4,a5
80007236:	fe842783          	lw	a5,-24(s0)
8000723a:	c781                	beqz	a5,80007242 <RCU_AHBRstCmd+0x2c>
8000723c:	fec42783          	lw	a5,-20(s0)
80007240:	a011                	j	80007244 <RCU_AHBRstCmd+0x2e>
80007242:	4781                	li	a5,0
80007244:	3000e737          	lui	a4,0x3000e
80007248:	8fd5                	or	a5,a5,a3
8000724a:	cb1c                	sw	a5,16(a4)
}
8000724c:	0001                	nop
8000724e:	4472                	lw	s0,28(sp)
80007250:	6105                	addi	sp,sp,32
80007252:	8082                	ret

80007254 <HASH_InitCmd>:
  * @brief   Инициализация хеш-процессора
  * @param   state Состояние инициализации
  * @retval  void
  */
__STATIC_INLINE void HASH_InitCmd(FunctionalState state)
{
80007254:	1101                	addi	sp,sp,-32
80007256:	ce22                	sw	s0,28(sp)
80007258:	1000                	addi	s0,sp,32
8000725a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_INIT_Msk, state << HASH_CR_INIT_Pos);
8000725e:	200327b7          	lui	a5,0x20032
80007262:	439c                	lw	a5,0(a5)
80007264:	ffe7f693          	andi	a3,a5,-2
80007268:	200327b7          	lui	a5,0x20032
8000726c:	fec42703          	lw	a4,-20(s0)
80007270:	8f55                	or	a4,a4,a3
80007272:	c398                	sw	a4,0(a5)
}
80007274:	0001                	nop
80007276:	4472                	lw	s0,28(sp)
80007278:	6105                	addi	sp,sp,32
8000727a:	8082                	ret

8000727c <HASH_ModeCmd>:
  * @brief   Выбор режима алгоритма
  * @param   state Режим алгоритма
  * @retval  void
  */
__STATIC_INLINE void HASH_ModeCmd(HASH_MODE_TypeDef mode)
{
8000727c:	1101                	addi	sp,sp,-32
8000727e:	ce22                	sw	s0,28(sp)
80007280:	1000                	addi	s0,sp,32
80007282:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_MODE(mode));

	MODIFY_REG(HASH->CR, HASH_CR_MODE_Msk, mode << HASH_CR_MODE_Pos);
80007286:	200327b7          	lui	a5,0x20032
8000728a:	439c                	lw	a5,0(a5)
8000728c:	ffd7f693          	andi	a3,a5,-3
80007290:	fec42783          	lw	a5,-20(s0)
80007294:	00179713          	slli	a4,a5,0x1
80007298:	200327b7          	lui	a5,0x20032
8000729c:	8f55                	or	a4,a4,a3
8000729e:	c398                	sw	a4,0(a5)
}
800072a0:	0001                	nop
800072a2:	4472                	lw	s0,28(sp)
800072a4:	6105                	addi	sp,sp,32
800072a6:	8082                	ret

800072a8 <HASH_KeyLengthCmd>:
  * @brief   Выбор длинного ключа
  * @param   length Длина ключа
  * @retval  void
  */
__STATIC_INLINE void HASH_KeyLengthCmd(HASH_LKEY_TypeDef length)
{
800072a8:	1101                	addi	sp,sp,-32
800072aa:	ce22                	sw	s0,28(sp)
800072ac:	1000                	addi	s0,sp,32
800072ae:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_LKEY(length));

	MODIFY_REG(HASH->CR, HASH_CR_LKEY_Msk, length << HASH_CR_LKEY_Pos);
800072b2:	200327b7          	lui	a5,0x20032
800072b6:	439c                	lw	a5,0(a5)
800072b8:	ffb7f693          	andi	a3,a5,-5
800072bc:	fec42783          	lw	a5,-20(s0)
800072c0:	00279713          	slli	a4,a5,0x2
800072c4:	200327b7          	lui	a5,0x20032
800072c8:	8f55                	or	a4,a4,a3
800072ca:	c398                	sw	a4,0(a5)
}
800072cc:	0001                	nop
800072ce:	4472                	lw	s0,28(sp)
800072d0:	6105                	addi	sp,sp,32
800072d2:	8082                	ret

800072d4 <HASH_SameKeyCmd>:
  * @brief   Использование одинаковыч внешних и внутренних ключей
  * @param   state Разрешение использования одинакового ключа
  * @retval  void
  */
__STATIC_INLINE void HASH_SameKeyCmd(FunctionalState state)
{
800072d4:	1101                	addi	sp,sp,-32
800072d6:	ce22                	sw	s0,28(sp)
800072d8:	1000                	addi	s0,sp,32
800072da:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_SAMK_Msk, state << HASH_CR_SAMK_Pos);
800072de:	200327b7          	lui	a5,0x20032
800072e2:	439c                	lw	a5,0(a5)
800072e4:	ff77f693          	andi	a3,a5,-9
800072e8:	fec42783          	lw	a5,-20(s0)
800072ec:	00379713          	slli	a4,a5,0x3
800072f0:	200327b7          	lui	a5,0x20032
800072f4:	8f55                	or	a4,a4,a3
800072f6:	c398                	sw	a4,0(a5)
}
800072f8:	0001                	nop
800072fa:	4472                	lw	s0,28(sp)
800072fc:	6105                	addi	sp,sp,32
800072fe:	8082                	ret

80007300 <HASH_DataTypeConfig>:
  * @brief   Выбор формата данных
  * @param   dt формат данных
  * @retval  void
  */
__STATIC_INLINE void HASH_DataTypeConfig(HASH_DATATYPE_TypeDef dt)
{
80007300:	1101                	addi	sp,sp,-32
80007302:	ce22                	sw	s0,28(sp)
80007304:	1000                	addi	s0,sp,32
80007306:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_DATATYPE(dt));

	MODIFY_REG(HASH->CR, HASH_CR_DATATYPE_Msk, dt << HASH_CR_DATATYPE_Pos);
8000730a:	200327b7          	lui	a5,0x20032
8000730e:	439c                	lw	a5,0(a5)
80007310:	fcf7f693          	andi	a3,a5,-49
80007314:	fec42783          	lw	a5,-20(s0)
80007318:	00479713          	slli	a4,a5,0x4
8000731c:	200327b7          	lui	a5,0x20032
80007320:	8f55                	or	a4,a4,a3
80007322:	c398                	sw	a4,0(a5)
}
80007324:	0001                	nop
80007326:	4472                	lw	s0,28(sp)
80007328:	6105                	addi	sp,sp,32
8000732a:	8082                	ret

8000732c <HASH_DMACmd>:
  * @brief   Включение механизма DMA
  * @param   state Состояние передач DMA
  * @retval  void
  */
__STATIC_INLINE void HASH_DMACmd(FunctionalState state)
{
8000732c:	1101                	addi	sp,sp,-32
8000732e:	ce22                	sw	s0,28(sp)
80007330:	1000                	addi	s0,sp,32
80007332:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_DMAE_Msk, state << HASH_CR_DMAE_Pos);
80007336:	200327b7          	lui	a5,0x20032
8000733a:	439c                	lw	a5,0(a5)
8000733c:	fbf7f693          	andi	a3,a5,-65
80007340:	fec42783          	lw	a5,-20(s0)
80007344:	00679713          	slli	a4,a5,0x6
80007348:	200327b7          	lui	a5,0x20032
8000734c:	8f55                	or	a4,a4,a3
8000734e:	c398                	sw	a4,0(a5)
}
80007350:	0001                	nop
80007352:	4472                	lw	s0,28(sp)
80007354:	6105                	addi	sp,sp,32
80007356:	8082                	ret

80007358 <HASH_SetMultyDMATransmit>:
  * @brief   Включение механизма MDMAT
  * @param   state Состояние передачи MDMAT
  * @retval  void
  */
__STATIC_INLINE void HASH_SetMultyDMATransmit(FunctionalState state)
{
80007358:	1101                	addi	sp,sp,-32
8000735a:	ce22                	sw	s0,28(sp)
8000735c:	1000                	addi	s0,sp,32
8000735e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_MDMAT_Msk, state << HASH_CR_MDMAT_Pos);
80007362:	200327b7          	lui	a5,0x20032
80007366:	439c                	lw	a5,0(a5)
80007368:	f7f7f693          	andi	a3,a5,-129
8000736c:	fec42783          	lw	a5,-20(s0)
80007370:	00779713          	slli	a4,a5,0x7
80007374:	200327b7          	lui	a5,0x20032
80007378:	8f55                	or	a4,a4,a3
8000737a:	c398                	sw	a4,0(a5)
}
8000737c:	0001                	nop
8000737e:	4472                	lw	s0,28(sp)
80007380:	6105                	addi	sp,sp,32
80007382:	8082                	ret

80007384 <HASH_SetAlgo>:
  * @brief   Выбор алгоритма хэш-функции
  * @param   algo алгоритм хем-функции
  * @retval  void
  */
__STATIC_INLINE void HASH_SetAlgo(HASH_ALGO_TypeDef algo)
{
80007384:	1101                	addi	sp,sp,-32
80007386:	ce22                	sw	s0,28(sp)
80007388:	1000                	addi	s0,sp,32
8000738a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_ALGO(algo));

	MODIFY_REG(HASH->CR, HASH_CR_ALGO_Msk, algo << HASH_CR_ALGO_Pos);
8000738e:	200327b7          	lui	a5,0x20032
80007392:	4398                	lw	a4,0(a5)
80007394:	77d1                	lui	a5,0xffff4
80007396:	17fd                	addi	a5,a5,-1 # ffff3fff <__data_source_start+0x7ffea5db>
80007398:	00f776b3          	and	a3,a4,a5
8000739c:	fec42783          	lw	a5,-20(s0)
800073a0:	00e79713          	slli	a4,a5,0xe
800073a4:	200327b7          	lui	a5,0x20032
800073a8:	8f55                	or	a4,a4,a3
800073aa:	c398                	sw	a4,0(a5)
}
800073ac:	0001                	nop
800073ae:	4472                	lw	s0,28(sp)
800073b0:	6105                	addi	sp,sp,32
800073b2:	8082                	ret

800073b4 <HASH_GetAlgo>:
/**
  * @brief   Получение выбранного алгоритма хэш-функции
  * @retval  algo алгоритм хем-функции
  */
__STATIC_INLINE HASH_ALGO_TypeDef HASH_GetAlgo()
{
800073b4:	1141                	addi	sp,sp,-16
800073b6:	c622                	sw	s0,12(sp)
800073b8:	0800                	addi	s0,sp,16
	return (HASH_ALGO_TypeDef) ((READ_REG(HASH->CR) & HASH_CR_ALGO_Msk) >> HASH_CR_ALGO_Pos);
800073ba:	200327b7          	lui	a5,0x20032
800073be:	439c                	lw	a5,0(a5)
800073c0:	83b9                	srli	a5,a5,0xe
800073c2:	8b8d                	andi	a5,a5,3
}
800073c4:	853e                	mv	a0,a5
800073c6:	4432                	lw	s0,12(sp)
800073c8:	0141                	addi	sp,sp,16
800073ca:	8082                	ret

800073cc <HASH_SetData>:
  * @brief   Добавление данных для формирования хеш-суммы
  * @param   data Данные для добавления
  * @retval  void
  */
__STATIC_INLINE void HASH_SetData(uint32_t data)
{
800073cc:	1101                	addi	sp,sp,-32
800073ce:	ce22                	sw	s0,28(sp)
800073d0:	1000                	addi	s0,sp,32
800073d2:	fea42623          	sw	a0,-20(s0)
	WRITE_REG(HASH->DATAIN_bit.VAL, data);
800073d6:	200327b7          	lui	a5,0x20032
800073da:	fec42703          	lw	a4,-20(s0)
800073de:	c3d8                	sw	a4,4(a5)
}
800073e0:	0001                	nop
800073e2:	4472                	lw	s0,28(sp)
800073e4:	6105                	addi	sp,sp,32
800073e6:	8082                	ret

800073e8 <HASH_GetHash>:
/**
  * @brief   Получение последних записанных в регистр данных
  * @retval  data Последние добавленные данные
  */
__STATIC_INLINE uint32_t HASH_GetHash(uint32_t idx)
{
800073e8:	1101                	addi	sp,sp,-32
800073ea:	ce22                	sw	s0,28(sp)
800073ec:	1000                	addi	s0,sp,32
800073ee:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_HR(idx));

	return (uint32_t) READ_REG(HASH->HR[idx].HR);
800073f2:	20032737          	lui	a4,0x20032
800073f6:	fec42783          	lw	a5,-20(s0)
800073fa:	07c1                	addi	a5,a5,16 # 20032010 <STACK_SIZE+0x20031810>
800073fc:	078a                	slli	a5,a5,0x2
800073fe:	97ba                	add	a5,a5,a4
80007400:	439c                	lw	a5,0(a5)
}
80007402:	853e                	mv	a0,a5
80007404:	4472                	lw	s0,28(sp)
80007406:	6105                	addi	sp,sp,32
80007408:	8082                	ret

8000740a <HASH_GetHashLen>:
  * @brief   Устанваливает буфер значениями хеш-суммы
  * @param   buffer ссылка на начало буфера, размер которого должен соответсвовать размерности алгоритма шифрования см. Руководство пользователя Приложение А10 Регистр HR
  * @retval  length длина хеша
  */
uint32_t HASH_GetHashLen(HASH_ALGO_TypeDef algo)
{
8000740a:	1101                	addi	sp,sp,-32
8000740c:	ce06                	sw	ra,28(sp)
8000740e:	cc22                	sw	s0,24(sp)
80007410:	1000                	addi	s0,sp,32
80007412:	fea42623          	sw	a0,-20(s0)
	switch(HASH_GetAlgo()) {
80007416:	3f79                	jal	800073b4 <HASH_GetAlgo>
80007418:	87aa                	mv	a5,a0
8000741a:	470d                	li	a4,3
8000741c:	02e78663          	beq	a5,a4,80007448 <HASH_GetHashLen+0x3e>
80007420:	470d                	li	a4,3
80007422:	02f76563          	bltu	a4,a5,8000744c <HASH_GetHashLen+0x42>
80007426:	4709                	li	a4,2
80007428:	00e78e63          	beq	a5,a4,80007444 <HASH_GetHashLen+0x3a>
8000742c:	4709                	li	a4,2
8000742e:	00f76f63          	bltu	a4,a5,8000744c <HASH_GetHashLen+0x42>
80007432:	c789                	beqz	a5,8000743c <HASH_GetHashLen+0x32>
80007434:	4705                	li	a4,1
80007436:	00e78563          	beq	a5,a4,80007440 <HASH_GetHashLen+0x36>
8000743a:	a809                	j	8000744c <HASH_GetHashLen+0x42>
		case HASH_ALGO_SHA1:
			return 5;
8000743c:	4795                	li	a5,5
8000743e:	a801                	j	8000744e <HASH_GetHashLen+0x44>
		case HASH_ALGO_MD5:
			return 4;
80007440:	4791                	li	a5,4
80007442:	a031                	j	8000744e <HASH_GetHashLen+0x44>
		case HASH_ALGO_SHA224:
			return 7;
80007444:	479d                	li	a5,7
80007446:	a021                	j	8000744e <HASH_GetHashLen+0x44>
		case HASH_ALGO_SHA256:
			return 8;
80007448:	47a1                	li	a5,8
8000744a:	a011                	j	8000744e <HASH_GetHashLen+0x44>
		default:
			return 0;
8000744c:	4781                	li	a5,0
	}
}
8000744e:	853e                	mv	a0,a5
80007450:	40f2                	lw	ra,28(sp)
80007452:	4462                	lw	s0,24(sp)
80007454:	6105                	addi	sp,sp,32
80007456:	8082                	ret

80007458 <HASH_GetHashBuffer>:

uint32_t HASH_GetHashBuffer(uint32_t* buffer)
{
80007458:	7179                	addi	sp,sp,-48
8000745a:	d606                	sw	ra,44(sp)
8000745c:	d422                	sw	s0,40(sp)
8000745e:	d226                	sw	s1,36(sp)
80007460:	1800                	addi	s0,sp,48
80007462:	fca42e23          	sw	a0,-36(s0)
	uint32_t idx = 0, len = 0;
80007466:	fe042623          	sw	zero,-20(s0)
8000746a:	fe042423          	sw	zero,-24(s0)
	idx = len = HASH_GetHashLen(HASH_GetAlgo());
8000746e:	3799                	jal	800073b4 <HASH_GetAlgo>
80007470:	87aa                	mv	a5,a0
80007472:	853e                	mv	a0,a5
80007474:	3f59                	jal	8000740a <HASH_GetHashLen>
80007476:	fea42423          	sw	a0,-24(s0)
8000747a:	fe842783          	lw	a5,-24(s0)
8000747e:	fef42623          	sw	a5,-20(s0)

	while(idx) {
80007482:	a015                	j	800074a6 <HASH_GetHashBuffer+0x4e>
    idx--;
80007484:	fec42783          	lw	a5,-20(s0)
80007488:	17fd                	addi	a5,a5,-1
8000748a:	fef42623          	sw	a5,-20(s0)
		buffer[idx] = HASH_GetHash(idx);
8000748e:	fec42783          	lw	a5,-20(s0)
80007492:	078a                	slli	a5,a5,0x2
80007494:	fdc42703          	lw	a4,-36(s0)
80007498:	00f704b3          	add	s1,a4,a5
8000749c:	fec42503          	lw	a0,-20(s0)
800074a0:	37a1                	jal	800073e8 <HASH_GetHash>
800074a2:	87aa                	mv	a5,a0
800074a4:	c09c                	sw	a5,0(s1)
	while(idx) {
800074a6:	fec42783          	lw	a5,-20(s0)
800074aa:	ffe9                	bnez	a5,80007484 <HASH_GetHashBuffer+0x2c>
	}

	return len;
800074ac:	fe842783          	lw	a5,-24(s0)
}
800074b0:	853e                	mv	a0,a5
800074b2:	50b2                	lw	ra,44(sp)
800074b4:	5422                	lw	s0,40(sp)
800074b6:	5492                	lw	s1,36(sp)
800074b8:	6145                	addi	sp,sp,48
800074ba:	8082                	ret

800074bc <HASH_SetHashBuffer>:

void HASH_SetHashBuffer(uint32_t* buffer, uint32_t len)
{
800074bc:	7179                	addi	sp,sp,-48
800074be:	d606                	sw	ra,44(sp)
800074c0:	d422                	sw	s0,40(sp)
800074c2:	1800                	addi	s0,sp,48
800074c4:	fca42e23          	sw	a0,-36(s0)
800074c8:	fcb42c23          	sw	a1,-40(s0)
	for (uint32_t i = 0 ; i < len; i++)
800074cc:	fe042623          	sw	zero,-20(s0)
800074d0:	a839                	j	800074ee <HASH_SetHashBuffer+0x32>
	{
		HASH_SetData(buffer[i]);
800074d2:	fec42783          	lw	a5,-20(s0)
800074d6:	078a                	slli	a5,a5,0x2
800074d8:	fdc42703          	lw	a4,-36(s0)
800074dc:	97ba                	add	a5,a5,a4
800074de:	439c                	lw	a5,0(a5)
800074e0:	853e                	mv	a0,a5
800074e2:	35ed                	jal	800073cc <HASH_SetData>
	for (uint32_t i = 0 ; i < len; i++)
800074e4:	fec42783          	lw	a5,-20(s0)
800074e8:	0785                	addi	a5,a5,1
800074ea:	fef42623          	sw	a5,-20(s0)
800074ee:	fec42703          	lw	a4,-20(s0)
800074f2:	fd842783          	lw	a5,-40(s0)
800074f6:	fcf76ee3          	bltu	a4,a5,800074d2 <HASH_SetHashBuffer+0x16>
	}
}
800074fa:	0001                	nop
800074fc:	0001                	nop
800074fe:	50b2                	lw	ra,44(sp)
80007500:	5422                	lw	s0,40(sp)
80007502:	6145                	addi	sp,sp,48
80007504:	8082                	ret

80007506 <HASH_DeInit>:
/**
  * @brief   Устанавливает все регистры HASH значениями по умолчанию
  * @retval  void
  */
void HASH_DeInit()
{
80007506:	1141                	addi	sp,sp,-16
80007508:	c606                	sw	ra,12(sp)
8000750a:	c422                	sw	s0,8(sp)
8000750c:	0800                	addi	s0,sp,16
	HASH_InitCmd(DISABLE);
8000750e:	4501                	li	a0,0
80007510:	3391                	jal	80007254 <HASH_InitCmd>

    RCU_AHBRstCmd(RCU_AHBRst_HASH, DISABLE);
80007512:	4581                	li	a1,0
80007514:	4521                	li	a0,8
80007516:	3301                	jal	80007216 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(RCU_AHBRst_HASH, ENABLE);
80007518:	4585                	li	a1,1
8000751a:	4521                	li	a0,8
8000751c:	39ed                	jal	80007216 <RCU_AHBRstCmd>
}
8000751e:	0001                	nop
80007520:	40b2                	lw	ra,12(sp)
80007522:	4422                	lw	s0,8(sp)
80007524:	0141                	addi	sp,sp,16
80007526:	8082                	ret

80007528 <HASH_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref HASH_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void HASH_Init(HASH_Init_TypeDef* InitStruct)
{
80007528:	1101                	addi	sp,sp,-32
8000752a:	ce06                	sw	ra,28(sp)
8000752c:	cc22                	sw	s0,24(sp)
8000752e:	1000                	addi	s0,sp,32
80007530:	fea42623          	sw	a0,-20(s0)
	RCU_AHBClkCmd(RCU_AHBClk_HASH, ENABLE);
80007534:	4585                	li	a1,1
80007536:	4521                	li	a0,8
80007538:	3145                	jal	800071d8 <RCU_AHBClkCmd>
    RCU_AHBRstCmd(RCU_AHBRst_HASH, ENABLE);
8000753a:	4585                	li	a1,1
8000753c:	4521                	li	a0,8
8000753e:	39e1                	jal	80007216 <RCU_AHBRstCmd>

	HASH_DMACmd(InitStruct->DMATransmition);
80007540:	fec42783          	lw	a5,-20(s0)
80007544:	4b9c                	lw	a5,16(a5)
80007546:	853e                	mv	a0,a5
80007548:	33d5                	jal	8000732c <HASH_DMACmd>
	HASH_KeyLengthCmd(InitStruct->LongKey);
8000754a:	fec42783          	lw	a5,-20(s0)
8000754e:	43dc                	lw	a5,4(a5)
80007550:	853e                	mv	a0,a5
80007552:	3b99                	jal	800072a8 <HASH_KeyLengthCmd>
	HASH_SetMultyDMATransmit(InitStruct->MultyDMATransmition);
80007554:	fec42783          	lw	a5,-20(s0)
80007558:	4bdc                	lw	a5,20(a5)
8000755a:	853e                	mv	a0,a5
8000755c:	3bf5                	jal	80007358 <HASH_SetMultyDMATransmit>
	HASH_SetAlgo(InitStruct->Algo);
8000755e:	fec42783          	lw	a5,-20(s0)
80007562:	4f9c                	lw	a5,24(a5)
80007564:	853e                	mv	a0,a5
80007566:	3d39                	jal	80007384 <HASH_SetAlgo>
	HASH_DataTypeConfig(InitStruct->DataType);
80007568:	fec42783          	lw	a5,-20(s0)
8000756c:	47dc                	lw	a5,12(a5)
8000756e:	853e                	mv	a0,a5
80007570:	3b41                	jal	80007300 <HASH_DataTypeConfig>
	HASH_ModeCmd(InitStruct->Mode);
80007572:	fec42783          	lw	a5,-20(s0)
80007576:	439c                	lw	a5,0(a5)
80007578:	853e                	mv	a0,a5
8000757a:	3309                	jal	8000727c <HASH_ModeCmd>
	HASH_SameKeyCmd(InitStruct->SameKey);
8000757c:	fec42783          	lw	a5,-20(s0)
80007580:	479c                	lw	a5,8(a5)
80007582:	853e                	mv	a0,a5
80007584:	3b81                	jal	800072d4 <HASH_SameKeyCmd>

	HASH_InitCmd(ENABLE);
80007586:	4505                	li	a0,1
80007588:	31f1                	jal	80007254 <HASH_InitCmd>
}
8000758a:	0001                	nop
8000758c:	40f2                	lw	ra,28(sp)
8000758e:	4462                	lw	s0,24(sp)
80007590:	6105                	addi	sp,sp,32
80007592:	8082                	ret

80007594 <HASH_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref HASH_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void HASH_StructInit(HASH_Init_TypeDef* InitStruct)
{
80007594:	1101                	addi	sp,sp,-32
80007596:	ce22                	sw	s0,28(sp)
80007598:	1000                	addi	s0,sp,32
8000759a:	fea42623          	sw	a0,-20(s0)
	InitStruct->DMATransmition = 0x0;
8000759e:	fec42783          	lw	a5,-20(s0)
800075a2:	0007a823          	sw	zero,16(a5)
	InitStruct->LongKey = HASH_LKEY_ShortKey;
800075a6:	fec42783          	lw	a5,-20(s0)
800075aa:	0007a223          	sw	zero,4(a5)
	InitStruct->MultyDMATransmition = 0x0;
800075ae:	fec42783          	lw	a5,-20(s0)
800075b2:	0007aa23          	sw	zero,20(a5)
	InitStruct->Algo = HASH_ALGO_SHA1;
800075b6:	fec42783          	lw	a5,-20(s0)
800075ba:	0007ac23          	sw	zero,24(a5)
	InitStruct->DataType = HASH_DATATYPE_Word;
800075be:	fec42783          	lw	a5,-20(s0)
800075c2:	0007a623          	sw	zero,12(a5)
	InitStruct->Mode = HASH_MODE_Hash;
800075c6:	fec42783          	lw	a5,-20(s0)
800075ca:	0007a023          	sw	zero,0(a5)
	InitStruct->SameKey = 0x0;
800075ce:	fec42783          	lw	a5,-20(s0)
800075d2:	0007a423          	sw	zero,8(a5)
}
800075d6:	0001                	nop
800075d8:	4472                	lw	s0,28(sp)
800075da:	6105                	addi	sp,sp,32
800075dc:	8082                	ret

800075de <I2C_FSDivLowConfig>:
  *             смещение 4 и, в итоге, в регистре окажется значение 6.
  * @param      DivVal  Значение (биты [6:0])
  * @retval     void
  */
__STATIC_INLINE void I2C_FSDivLowConfig(uint32_t DivVal)
{
800075de:	1101                	addi	sp,sp,-32
800075e0:	ce22                	sw	s0,28(sp)
800075e2:	1000                	addi	s0,sp,32
800075e4:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_FS_DIV_LOW_VAL(DivVal));

    WRITE_REG(I2C->CTL1_bit.SCLFRQ, DivVal);
800075e8:	300057b7          	lui	a5,0x30005
800075ec:	fec42703          	lw	a4,-20(s0)
800075f0:	07f77713          	andi	a4,a4,127
800075f4:	0ff77713          	zext.b	a4,a4
800075f8:	0706                	slli	a4,a4,0x1
800075fa:	0147c683          	lbu	a3,20(a5) # 30005014 <STACK_SIZE+0x30004814>
800075fe:	8a85                	andi	a3,a3,1
80007600:	8f55                	or	a4,a4,a3
80007602:	00e78a23          	sb	a4,20(a5)
}
80007606:	0001                	nop
80007608:	4472                	lw	s0,28(sp)
8000760a:	6105                	addi	sp,sp,32
8000760c:	8082                	ret

8000760e <I2C_FSDivHighConfig>:
  * @brief   Установка старшей части делителя частоты в режиме FS мастера
  * @param   DivVal  Значение (биты [7:0])
  * @retval  void
  */
__STATIC_INLINE void I2C_FSDivHighConfig(uint32_t DivVal)
{
8000760e:	1101                	addi	sp,sp,-32
80007610:	ce22                	sw	s0,28(sp)
80007612:	1000                	addi	s0,sp,32
80007614:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_FS_DIV_HIGH_VAL(DivVal));

    WRITE_REG(I2C->CTL3_bit.SCLFRQ, DivVal);
80007618:	300057b7          	lui	a5,0x30005
8000761c:	fec42703          	lw	a4,-20(s0)
80007620:	0ff77713          	zext.b	a4,a4
80007624:	02e78023          	sb	a4,32(a5) # 30005020 <STACK_SIZE+0x30004820>
}
80007628:	0001                	nop
8000762a:	4472                	lw	s0,28(sp)
8000762c:	6105                	addi	sp,sp,32
8000762e:	8082                	ret

80007630 <I2C_HSDivLowConfig>:
  *             смещение 2 и, в итоге, в регистре окажется значение 3.
  * @param      DivVal  Значение (биты [3:0])
  * @retval     void
  */
__STATIC_INLINE void I2C_HSDivLowConfig(uint32_t DivVal)
{
80007630:	1101                	addi	sp,sp,-32
80007632:	ce22                	sw	s0,28(sp)
80007634:	1000                	addi	s0,sp,32
80007636:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_HS_DIV_LOW_VAL(DivVal));

    WRITE_REG(I2C->CTL2_bit.HSDIV, DivVal);
8000763a:	300057b7          	lui	a5,0x30005
8000763e:	fec42703          	lw	a4,-20(s0)
80007642:	8b3d                	andi	a4,a4,15
80007644:	0ff77713          	zext.b	a4,a4
80007648:	0712                	slli	a4,a4,0x4
8000764a:	01c7c683          	lbu	a3,28(a5) # 3000501c <STACK_SIZE+0x3000481c>
8000764e:	8abd                	andi	a3,a3,15
80007650:	8f55                	or	a4,a4,a3
80007652:	00e78e23          	sb	a4,28(a5)
}
80007656:	0001                	nop
80007658:	4472                	lw	s0,28(sp)
8000765a:	6105                	addi	sp,sp,32
8000765c:	8082                	ret

8000765e <I2C_HSDivHighConfig>:
  * @brief   Установка старшей части делителя частоты в режиме HS мастера
  * @param   DivVal  Значение (биты [7:0])
  * @retval  void
  */
__STATIC_INLINE void I2C_HSDivHighConfig(uint32_t DivVal)
{
8000765e:	1101                	addi	sp,sp,-32
80007660:	ce22                	sw	s0,28(sp)
80007662:	1000                	addi	s0,sp,32
80007664:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_HS_DIV_HIGH_VAL(DivVal));

    WRITE_REG(I2C->CTL4_bit.HSDIV, DivVal);
80007668:	300057b7          	lui	a5,0x30005
8000766c:	fec42703          	lw	a4,-20(s0)
80007670:	0ff77713          	zext.b	a4,a4
80007674:	02e78223          	sb	a4,36(a5) # 30005024 <STACK_SIZE+0x30004824>
}
80007678:	0001                	nop
8000767a:	4472                	lw	s0,28(sp)
8000767c:	6105                	addi	sp,sp,32
8000767e:	8082                	ret

80007680 <I2C_FSFreqConfig>:
  * @param   FSFreq  Желаемое значение частоты в ГЦ
  * @param   I2CFreq  Значение частоты  тактового сигнала I2C в ГЦ
  * @retval  void
  */
void I2C_FSFreqConfig(uint32_t FSFreq, uint32_t I2CFreq)
{
80007680:	7179                	addi	sp,sp,-48
80007682:	d606                	sw	ra,44(sp)
80007684:	d422                	sw	s0,40(sp)
80007686:	1800                	addi	s0,sp,48
80007688:	fca42e23          	sw	a0,-36(s0)
8000768c:	fcb42c23          	sw	a1,-40(s0)
    uint32_t freq_calc = I2CFreq / (4 * FSFreq);
80007690:	fdc42783          	lw	a5,-36(s0)
80007694:	078a                	slli	a5,a5,0x2
80007696:	fd842703          	lw	a4,-40(s0)
8000769a:	02f757b3          	divu	a5,a4,a5
8000769e:	fef42623          	sw	a5,-20(s0)

    I2C_FSDivLowConfig(freq_calc & 0x7F);
800076a2:	fec42783          	lw	a5,-20(s0)
800076a6:	07f7f793          	andi	a5,a5,127
800076aa:	853e                	mv	a0,a5
800076ac:	3f0d                	jal	800075de <I2C_FSDivLowConfig>
    I2C_FSDivHighConfig(freq_calc >> 7);
800076ae:	fec42783          	lw	a5,-20(s0)
800076b2:	839d                	srli	a5,a5,0x7
800076b4:	853e                	mv	a0,a5
800076b6:	3fa1                	jal	8000760e <I2C_FSDivHighConfig>
}
800076b8:	0001                	nop
800076ba:	50b2                	lw	ra,44(sp)
800076bc:	5422                	lw	s0,40(sp)
800076be:	6145                	addi	sp,sp,48
800076c0:	8082                	ret

800076c2 <I2C_HSFreqConfig>:
  * @param   HSFreq  Желаемое значение частоты в ГЦ
  * @param   I2CFreq  Значение частоты  тактового сигнала I2C в ГЦ
  * @retval  void
  */
void I2C_HSFreqConfig(uint32_t HSFreq, uint32_t I2CFreq)
{
800076c2:	7179                	addi	sp,sp,-48
800076c4:	d606                	sw	ra,44(sp)
800076c6:	d422                	sw	s0,40(sp)
800076c8:	1800                	addi	s0,sp,48
800076ca:	fca42e23          	sw	a0,-36(s0)
800076ce:	fcb42c23          	sw	a1,-40(s0)
    uint32_t freq_calc = I2CFreq / (3 * HSFreq);
800076d2:	fdc42703          	lw	a4,-36(s0)
800076d6:	87ba                	mv	a5,a4
800076d8:	0786                	slli	a5,a5,0x1
800076da:	97ba                	add	a5,a5,a4
800076dc:	fd842703          	lw	a4,-40(s0)
800076e0:	02f757b3          	divu	a5,a4,a5
800076e4:	fef42623          	sw	a5,-20(s0)

    I2C_HSDivLowConfig(freq_calc & 0x0F);
800076e8:	fec42783          	lw	a5,-20(s0)
800076ec:	8bbd                	andi	a5,a5,15
800076ee:	853e                	mv	a0,a5
800076f0:	3781                	jal	80007630 <I2C_HSDivLowConfig>
    I2C_HSDivHighConfig(freq_calc >> 4);
800076f2:	fec42783          	lw	a5,-20(s0)
800076f6:	8391                	srli	a5,a5,0x4
800076f8:	853e                	mv	a0,a5
800076fa:	3795                	jal	8000765e <I2C_HSDivHighConfig>
}
800076fc:	0001                	nop
800076fe:	50b2                	lw	ra,44(sp)
80007700:	5422                	lw	s0,40(sp)
80007702:	6145                	addi	sp,sp,48
80007704:	8082                	ret

80007706 <RCU_AHBRstCmd>:
{
80007706:	1101                	addi	sp,sp,-32
80007708:	ce22                	sw	s0,28(sp)
8000770a:	1000                	addi	s0,sp,32
8000770c:	fea42623          	sw	a0,-20(s0)
80007710:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80007714:	3000e7b7          	lui	a5,0x3000e
80007718:	4b98                	lw	a4,16(a5)
8000771a:	fec42783          	lw	a5,-20(s0)
8000771e:	fff7c793          	not	a5,a5
80007722:	00f776b3          	and	a3,a4,a5
80007726:	fe842783          	lw	a5,-24(s0)
8000772a:	c781                	beqz	a5,80007732 <RCU_AHBRstCmd+0x2c>
8000772c:	fec42783          	lw	a5,-20(s0)
80007730:	a011                	j	80007734 <RCU_AHBRstCmd+0x2e>
80007732:	4781                	li	a5,0
80007734:	3000e737          	lui	a4,0x3000e
80007738:	8fd5                	or	a5,a5,a3
8000773a:	cb1c                	sw	a5,16(a4)
}
8000773c:	0001                	nop
8000773e:	4472                	lw	s0,28(sp)
80007740:	6105                	addi	sp,sp,32
80007742:	8082                	ret

80007744 <QSPI_ModeConfig>:
  * @brief   Выбор режима работы
  * @param   mode Режим работы
  * @retval  void
  */
__STATIC_INLINE void QSPI_ModeConfig(QSPI_Mode_TypeDef mode)
{
80007744:	1101                	addi	sp,sp,-32
80007746:	ce22                	sw	s0,28(sp)
80007748:	1000                	addi	s0,sp,32
8000774a:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_QSPI_MODE(mode));

    WRITE_REG(QSPI->DCR_bit.FMOD, mode);
8000774e:	200407b7          	lui	a5,0x20040
80007752:	fec42703          	lw	a4,-20(s0)
80007756:	8b1d                	andi	a4,a4,7
80007758:	0ff77713          	zext.b	a4,a4
8000775c:	8b1d                	andi	a4,a4,7
8000775e:	0742                	slli	a4,a4,0x10
80007760:	43d0                	lw	a2,4(a5)
80007762:	fff906b7          	lui	a3,0xfff90
80007766:	16fd                	addi	a3,a3,-1 # fff8ffff <__data_source_start+0x7ff865db>
80007768:	8ef1                	and	a3,a3,a2
8000776a:	8f55                	or	a4,a4,a3
8000776c:	c3d8                	sw	a4,4(a5)
}
8000776e:	0001                	nop
80007770:	4472                	lw	s0,28(sp)
80007772:	6105                	addi	sp,sp,32
80007774:	8082                	ret

80007776 <QSPI_SCKDivConfig>:
  * @param   div	 Основной делитель.
  *                  Параметр принимает любое значение из диапазона 0-255.
  * @retval  void
  */
__STATIC_INLINE void QSPI_SCKDivConfig(uint32_t div)
{
80007776:	1101                	addi	sp,sp,-32
80007778:	ce22                	sw	s0,28(sp)
8000777a:	1000                	addi	s0,sp,32
8000777c:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_QSPI_CDIV(div));

    WRITE_REG(QSPI->DCR_bit.CDIV, div);
80007780:	200407b7          	lui	a5,0x20040
80007784:	fec42703          	lw	a4,-20(s0)
80007788:	0ff77713          	zext.b	a4,a4
8000778c:	00e782a3          	sb	a4,5(a5) # 20040005 <STACK_SIZE+0x2003f805>
}
80007790:	0001                	nop
80007792:	4472                	lw	s0,28(sp)
80007794:	6105                	addi	sp,sp,32
80007796:	8082                	ret

80007798 <QSPI_SetWordLength>:
  * @brief   Установка размера слова данных
  * @param   length длина слова, значение от 1 до 32
  * @retval  void
  */
__STATIC_INLINE void QSPI_SetWordLength(uint32_t length)
{
80007798:	1101                	addi	sp,sp,-32
8000779a:	ce22                	sw	s0,28(sp)
8000779c:	1000                	addi	s0,sp,32
8000779e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_WORD(length));

	WRITE_REG(QSPI->TCR_bit.LEN, length);
800077a2:	200407b7          	lui	a5,0x20040
800077a6:	fec42703          	lw	a4,-20(s0)
800077aa:	03f77713          	andi	a4,a4,63
800077ae:	0ff77713          	zext.b	a4,a4
800077b2:	03f77713          	andi	a4,a4,63
800077b6:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
800077ba:	fc06f693          	andi	a3,a3,-64
800077be:	8f55                	or	a4,a4,a3
800077c0:	00e79623          	sh	a4,12(a5)
}
800077c4:	0001                	nop
800077c6:	4472                	lw	s0,28(sp)
800077c8:	6105                	addi	sp,sp,32
800077ca:	8082                	ret

800077cc <QSPI_SPIDataRateConfig>:
  * @brief   Установка скорости передачи данных
  * @param   dataRate скорость передачи данных типа @ref QSPI_DR_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_SPIDataRateConfig(QSPI_SPI_DataRate_TypeDef dataRate)
{
800077cc:	1101                	addi	sp,sp,-32
800077ce:	ce22                	sw	s0,28(sp)
800077d0:	1000                	addi	s0,sp,32
800077d2:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_SPI_DR(dataRate));

	WRITE_REG(QSPI->TCR_bit.DDR, dataRate);
800077d6:	200407b7          	lui	a5,0x20040
800077da:	fec42703          	lw	a4,-20(s0)
800077de:	8b05                	andi	a4,a4,1
800077e0:	0ff77713          	zext.b	a4,a4
800077e4:	8b05                	andi	a4,a4,1
800077e6:	071e                	slli	a4,a4,0x7
800077e8:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
800077ec:	f7f6f693          	andi	a3,a3,-129
800077f0:	8f55                	or	a4,a4,a3
800077f2:	00e79623          	sh	a4,12(a5)
}
800077f6:	0001                	nop
800077f8:	4472                	lw	s0,28(sp)
800077fa:	6105                	addi	sp,sp,32
800077fc:	8082                	ret

800077fe <QSPI_TxCmd>:
  * @brief   Разрешение передачи
  * @param   state Флаг разрешения
  * @retval  void
  */
__STATIC_INLINE void QSPI_TxCmd(FunctionalState state)
{
800077fe:	1101                	addi	sp,sp,-32
80007800:	ce22                	sw	s0,28(sp)
80007802:	1000                	addi	s0,sp,32
80007804:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	WRITE_REG(QSPI->TCR_bit.TXE, state);
80007808:	200407b7          	lui	a5,0x20040
8000780c:	fec42703          	lw	a4,-20(s0)
80007810:	8b05                	andi	a4,a4,1
80007812:	0ff77713          	zext.b	a4,a4
80007816:	8b05                	andi	a4,a4,1
80007818:	0722                	slli	a4,a4,0x8
8000781a:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
8000781e:	eff6f693          	andi	a3,a3,-257
80007822:	8f55                	or	a4,a4,a3
80007824:	00e79623          	sh	a4,12(a5)
}
80007828:	0001                	nop
8000782a:	4472                	lw	s0,28(sp)
8000782c:	6105                	addi	sp,sp,32
8000782e:	8082                	ret

80007830 <QSPI_RxCmd>:
  * @brief   Разрешение приема
  * @param   state Флаг разрешения
  * @retval  void
  */
__STATIC_INLINE void QSPI_RxCmd(FunctionalState state)
{
80007830:	1101                	addi	sp,sp,-32
80007832:	ce22                	sw	s0,28(sp)
80007834:	1000                	addi	s0,sp,32
80007836:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	WRITE_REG(QSPI->TCR_bit.RXE, state);
8000783a:	200407b7          	lui	a5,0x20040
8000783e:	fec42703          	lw	a4,-20(s0)
80007842:	8b05                	andi	a4,a4,1
80007844:	0ff77713          	zext.b	a4,a4
80007848:	8b05                	andi	a4,a4,1
8000784a:	0726                	slli	a4,a4,0x9
8000784c:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80007850:	dff6f693          	andi	a3,a3,-513
80007854:	8f55                	or	a4,a4,a3
80007856:	00e79623          	sh	a4,12(a5)
}
8000785a:	0001                	nop
8000785c:	4472                	lw	s0,28(sp)
8000785e:	6105                	addi	sp,sp,32
80007860:	8082                	ret

80007862 <QSPI_SPITransactionModeConfig>:
  * @brief   Выбор количества линий данных
  * @param   mode Количество линий типа @ref QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_SPITransactionModeConfig(QSPI_SPI_IOMode_TypeDef mode)
{
80007862:	1101                	addi	sp,sp,-32
80007864:	ce22                	sw	s0,28(sp)
80007866:	1000                	addi	s0,sp,32
80007868:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_SPI_IOMODE(mode));

	WRITE_REG(QSPI->TCR_bit.IOM, mode);
8000786c:	200407b7          	lui	a5,0x20040
80007870:	fec42703          	lw	a4,-20(s0)
80007874:	8b0d                	andi	a4,a4,3
80007876:	0ff77713          	zext.b	a4,a4
8000787a:	8b0d                	andi	a4,a4,3
8000787c:	00a71613          	slli	a2,a4,0xa
80007880:	00c7d703          	lhu	a4,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80007884:	86ba                	mv	a3,a4
80007886:	777d                	lui	a4,0xfffff
80007888:	3ff70713          	addi	a4,a4,1023 # fffff3ff <__data_source_start+0x7fff59db>
8000788c:	8f75                	and	a4,a4,a3
8000788e:	86ba                	mv	a3,a4
80007890:	8732                	mv	a4,a2
80007892:	8f55                	or	a4,a4,a3
80007894:	00e79623          	sh	a4,12(a5)
}
80007898:	0001                	nop
8000789a:	4472                	lw	s0,28(sp)
8000789c:	6105                	addi	sp,sp,32
8000789e:	8082                	ret

800078a0 <QSPI_InstructionConfig>:
  * @brief   Установка кода инструкции для внешнего устройства
  * @param   instruction Код инструкции, отправляемый во внешнее устройство по QuadSPI
  * @retval  void
  */
__STATIC_INLINE void QSPI_InstructionConfig(uint8_t instruction)
{
800078a0:	1101                	addi	sp,sp,-32
800078a2:	ce22                	sw	s0,28(sp)
800078a4:	1000                	addi	s0,sp,32
800078a6:	87aa                	mv	a5,a0
800078a8:	fef407a3          	sb	a5,-17(s0)
	WRITE_REG(QSPI->QCC_bit.INST, instruction);
800078ac:	200407b7          	lui	a5,0x20040
800078b0:	fef44703          	lbu	a4,-17(s0)
800078b4:	00e78c23          	sb	a4,24(a5) # 20040018 <STACK_SIZE+0x2003f818>
}
800078b8:	0001                	nop
800078ba:	4472                	lw	s0,28(sp)
800078bc:	6105                	addi	sp,sp,32
800078be:	8082                	ret

800078c0 <QSPI_InstructionModeConfig>:
  * @brief   Установка режима фазы инструкции для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_InstructionModeConfig(QSPI_IOMode_TypeDef mode)
{
800078c0:	1101                	addi	sp,sp,-32
800078c2:	ce22                	sw	s0,28(sp)
800078c4:	1000                	addi	s0,sp,32
800078c6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.IMOD, mode);
800078ca:	200407b7          	lui	a5,0x20040
800078ce:	fec42703          	lw	a4,-20(s0)
800078d2:	8b0d                	andi	a4,a4,3
800078d4:	0ff77713          	zext.b	a4,a4
800078d8:	8b0d                	andi	a4,a4,3
800078da:	0722                	slli	a4,a4,0x8
800078dc:	4f94                	lw	a3,24(a5)
800078de:	cff6f693          	andi	a3,a3,-769
800078e2:	8f55                	or	a4,a4,a3
800078e4:	cf98                	sw	a4,24(a5)
}
800078e6:	0001                	nop
800078e8:	4472                	lw	s0,28(sp)
800078ea:	6105                	addi	sp,sp,32
800078ec:	8082                	ret

800078ee <QSPI_AddressModeConfig>:
  * @brief   Установка режима фазы адреса для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AddressModeConfig(QSPI_IOMode_TypeDef mode)
{
800078ee:	1101                	addi	sp,sp,-32
800078f0:	ce22                	sw	s0,28(sp)
800078f2:	1000                	addi	s0,sp,32
800078f4:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.ADMOD, mode);
800078f8:	200407b7          	lui	a5,0x20040
800078fc:	fec42703          	lw	a4,-20(s0)
80007900:	8b0d                	andi	a4,a4,3
80007902:	0ff77713          	zext.b	a4,a4
80007906:	8b0d                	andi	a4,a4,3
80007908:	072a                	slli	a4,a4,0xa
8000790a:	4f90                	lw	a2,24(a5)
8000790c:	76fd                	lui	a3,0xfffff
8000790e:	3ff68693          	addi	a3,a3,1023 # fffff3ff <__data_source_start+0x7fff59db>
80007912:	8ef1                	and	a3,a3,a2
80007914:	8f55                	or	a4,a4,a3
80007916:	cf98                	sw	a4,24(a5)
}
80007918:	0001                	nop
8000791a:	4472                	lw	s0,28(sp)
8000791c:	6105                	addi	sp,sp,32
8000791e:	8082                	ret

80007920 <QSPI_AddressSizeConfig>:
  * @brief   Установка размера адреса для QuadSPI
  * @param   size размер типа @ref QSPI_QSPI_DataSize_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AddressSizeConfig(QSPI_DataSize_TypeDef size)
{
80007920:	1101                	addi	sp,sp,-32
80007922:	ce22                	sw	s0,28(sp)
80007924:	1000                	addi	s0,sp,32
80007926:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATASIZE(size));

	WRITE_REG(QSPI->QCC_bit.ADSIZ, size);
8000792a:	200407b7          	lui	a5,0x20040
8000792e:	fec42703          	lw	a4,-20(s0)
80007932:	8b0d                	andi	a4,a4,3
80007934:	0ff77713          	zext.b	a4,a4
80007938:	8b0d                	andi	a4,a4,3
8000793a:	0732                	slli	a4,a4,0xc
8000793c:	4f90                	lw	a2,24(a5)
8000793e:	76f5                	lui	a3,0xffffd
80007940:	16fd                	addi	a3,a3,-1 # ffffcfff <__data_source_start+0x7fff35db>
80007942:	8ef1                	and	a3,a3,a2
80007944:	8f55                	or	a4,a4,a3
80007946:	cf98                	sw	a4,24(a5)
}
80007948:	0001                	nop
8000794a:	4472                	lw	s0,28(sp)
8000794c:	6105                	addi	sp,sp,32
8000794e:	8082                	ret

80007950 <QSPI_AdditionalModeConfig>:
  * @brief   Установка режима фазы дополнительных данных для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AdditionalModeConfig(QSPI_IOMode_TypeDef mode)
{
80007950:	1101                	addi	sp,sp,-32
80007952:	ce22                	sw	s0,28(sp)
80007954:	1000                	addi	s0,sp,32
80007956:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.ABMOD, mode);
8000795a:	200407b7          	lui	a5,0x20040
8000795e:	fec42703          	lw	a4,-20(s0)
80007962:	8b0d                	andi	a4,a4,3
80007964:	0ff77713          	zext.b	a4,a4
80007968:	8b0d                	andi	a4,a4,3
8000796a:	073a                	slli	a4,a4,0xe
8000796c:	4f90                	lw	a2,24(a5)
8000796e:	76d1                	lui	a3,0xffff4
80007970:	16fd                	addi	a3,a3,-1 # ffff3fff <__data_source_start+0x7ffea5db>
80007972:	8ef1                	and	a3,a3,a2
80007974:	8f55                	or	a4,a4,a3
80007976:	cf98                	sw	a4,24(a5)
}
80007978:	0001                	nop
8000797a:	4472                	lw	s0,28(sp)
8000797c:	6105                	addi	sp,sp,32
8000797e:	8082                	ret

80007980 <QSPI_AdditionalSizeConfig>:
  * @brief   Установка размера дополнительных данных для QuadSPI
  * @param   size размер типа @ref QSPI_QSPI_DataSize_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AdditionalSizeConfig(QSPI_DataSize_TypeDef size)
{
80007980:	1101                	addi	sp,sp,-32
80007982:	ce22                	sw	s0,28(sp)
80007984:	1000                	addi	s0,sp,32
80007986:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATASIZE(size));

	WRITE_REG(QSPI->QCC_bit.ABSIZ, size);
8000798a:	200407b7          	lui	a5,0x20040
8000798e:	fec42703          	lw	a4,-20(s0)
80007992:	8b0d                	andi	a4,a4,3
80007994:	0ff77713          	zext.b	a4,a4
80007998:	8b0d                	andi	a4,a4,3
8000799a:	0742                	slli	a4,a4,0x10
8000799c:	4f90                	lw	a2,24(a5)
8000799e:	fffd06b7          	lui	a3,0xfffd0
800079a2:	16fd                	addi	a3,a3,-1 # fffcffff <__data_source_start+0x7ffc65db>
800079a4:	8ef1                	and	a3,a3,a2
800079a6:	8f55                	or	a4,a4,a3
800079a8:	cf98                	sw	a4,24(a5)
}
800079aa:	0001                	nop
800079ac:	4472                	lw	s0,28(sp)
800079ae:	6105                	addi	sp,sp,32
800079b0:	8082                	ret

800079b2 <QSPI_WaitCyclesConfig>:
  * @brief   Установка количества циклов ожидания для QuadSPI
  * @param   waitCycles количество циклов ожидания принимает значения от 0 до 31
  * @retval  void
  */
__STATIC_INLINE void QSPI_WaitCyclesConfig(uint32_t waitCycles)
{
800079b2:	1101                	addi	sp,sp,-32
800079b4:	ce22                	sw	s0,28(sp)
800079b6:	1000                	addi	s0,sp,32
800079b8:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DCYCS(waitCycles));

	WRITE_REG(QSPI->QCC_bit.DCYCS, waitCycles);
800079bc:	200407b7          	lui	a5,0x20040
800079c0:	fec42703          	lw	a4,-20(s0)
800079c4:	8b7d                	andi	a4,a4,31
800079c6:	0ff77713          	zext.b	a4,a4
800079ca:	8b7d                	andi	a4,a4,31
800079cc:	074a                	slli	a4,a4,0x12
800079ce:	4f90                	lw	a2,24(a5)
800079d0:	ff8406b7          	lui	a3,0xff840
800079d4:	16fd                	addi	a3,a3,-1 # ff83ffff <__data_source_start+0x7f8365db>
800079d6:	8ef1                	and	a3,a3,a2
800079d8:	8f55                	or	a4,a4,a3
800079da:	cf98                	sw	a4,24(a5)
}
800079dc:	0001                	nop
800079de:	4472                	lw	s0,28(sp)
800079e0:	6105                	addi	sp,sp,32
800079e2:	8082                	ret

800079e4 <QSPI_DataModeConfig>:
  * @brief   Установка режима фазы данных для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataModeConfig(QSPI_IOMode_TypeDef mode)
{
800079e4:	1101                	addi	sp,sp,-32
800079e6:	ce22                	sw	s0,28(sp)
800079e8:	1000                	addi	s0,sp,32
800079ea:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.DMOD, mode);
800079ee:	200407b7          	lui	a5,0x20040
800079f2:	fec42703          	lw	a4,-20(s0)
800079f6:	8b0d                	andi	a4,a4,3
800079f8:	0ff77713          	zext.b	a4,a4
800079fc:	8b0d                	andi	a4,a4,3
800079fe:	0762                	slli	a4,a4,0x18
80007a00:	4f90                	lw	a2,24(a5)
80007a02:	fd0006b7          	lui	a3,0xfd000
80007a06:	16fd                	addi	a3,a3,-1 # fcffffff <__data_source_start+0x7cff65db>
80007a08:	8ef1                	and	a3,a3,a2
80007a0a:	8f55                	or	a4,a4,a3
80007a0c:	cf98                	sw	a4,24(a5)
}
80007a0e:	0001                	nop
80007a10:	4472                	lw	s0,28(sp)
80007a12:	6105                	addi	sp,sp,32
80007a14:	8082                	ret

80007a16 <QSPI_DataDirectionConfig>:
  * @brief   Установка направления передачи данных для QuadSPI
  * @param   dir напавление передачи данных типа @ref QSPI_QSPI_Direction_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataDirectionConfig(QSPI_Direction_TypeDef dir)
{
80007a16:	1101                	addi	sp,sp,-32
80007a18:	ce22                	sw	s0,28(sp)
80007a1a:	1000                	addi	s0,sp,32
80007a1c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DIR(dir));

	WRITE_REG(QSPI->QCC_bit.DIOD, dir);
80007a20:	200407b7          	lui	a5,0x20040
80007a24:	fec42703          	lw	a4,-20(s0)
80007a28:	8b0d                	andi	a4,a4,3
80007a2a:	0ff77713          	zext.b	a4,a4
80007a2e:	8b0d                	andi	a4,a4,3
80007a30:	076a                	slli	a4,a4,0x1a
80007a32:	4f90                	lw	a2,24(a5)
80007a34:	f40006b7          	lui	a3,0xf4000
80007a38:	16fd                	addi	a3,a3,-1 # f3ffffff <__data_source_start+0x73ff65db>
80007a3a:	8ef1                	and	a3,a3,a2
80007a3c:	8f55                	or	a4,a4,a3
80007a3e:	cf98                	sw	a4,24(a5)
}
80007a40:	0001                	nop
80007a42:	4472                	lw	s0,28(sp)
80007a44:	6105                	addi	sp,sp,32
80007a46:	8082                	ret

80007a48 <QSPI_DataRateConfig>:
  * @brief   Установка скорости передачи данных
  * @param   dataRate скорость передачи данных типа @ref QSPI_QSPI_DataRate_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataRateConfig(QSPI_DataRate_TypeDef dataRate)
{
80007a48:	1101                	addi	sp,sp,-32
80007a4a:	ce22                	sw	s0,28(sp)
80007a4c:	1000                	addi	s0,sp,32
80007a4e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATARATE(dataRate));

	WRITE_REG(QSPI->QCC_bit.DDRM, dataRate);
80007a52:	200407b7          	lui	a5,0x20040
80007a56:	fec42703          	lw	a4,-20(s0)
80007a5a:	8b05                	andi	a4,a4,1
80007a5c:	0ff77713          	zext.b	a4,a4
80007a60:	077e                	slli	a4,a4,0x1f
80007a62:	4f90                	lw	a2,24(a5)
80007a64:	800006b7          	lui	a3,0x80000
80007a68:	fff6c693          	not	a3,a3
80007a6c:	8ef1                	and	a3,a3,a2
80007a6e:	8f55                	or	a4,a4,a3
80007a70:	cf98                	sw	a4,24(a5)
}
80007a72:	0001                	nop
80007a74:	4472                	lw	s0,28(sp)
80007a76:	6105                	addi	sp,sp,32
80007a78:	8082                	ret

80007a7a <QSPI_DeInit>:
/**
  * @brief   Устанавливает все регистры QSPI значениями по умолчанию
  * @retval  void
  */
void QSPI_DeInit()
{
80007a7a:	1141                	addi	sp,sp,-16
80007a7c:	c606                	sw	ra,12(sp)
80007a7e:	c422                	sw	s0,8(sp)
80007a80:	0800                	addi	s0,sp,16
	RCU_AHBRstCmd(RCU_AHBClk_QSPI, DISABLE);
80007a82:	4581                	li	a1,0
80007a84:	4541                	li	a0,16
80007a86:	3141                	jal	80007706 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(RCU_AHBClk_QSPI, ENABLE);
80007a88:	4585                	li	a1,1
80007a8a:	4541                	li	a0,16
80007a8c:	39ad                	jal	80007706 <RCU_AHBRstCmd>
}
80007a8e:	0001                	nop
80007a90:	40b2                	lw	ra,12(sp)
80007a92:	4422                	lw	s0,8(sp)
80007a94:	0141                	addi	sp,sp,16
80007a96:	8082                	ret

80007a98 <QSPI_SPI_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_SPI_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void QSPI_SPI_Init(QSPI_SPI_Init_TypeDef* InitStruct)
{
80007a98:	1101                	addi	sp,sp,-32
80007a9a:	ce06                	sw	ra,28(sp)
80007a9c:	cc22                	sw	s0,24(sp)
80007a9e:	1000                	addi	s0,sp,32
80007aa0:	fea42623          	sw	a0,-20(s0)
	QSPI_ModeConfig(QSPI_Mode_SPI);
80007aa4:	4501                	li	a0,0
80007aa6:	3979                	jal	80007744 <QSPI_ModeConfig>
	QSPI_SPITransactionModeConfig(InitStruct->IOMode);
80007aa8:	fec42783          	lw	a5,-20(s0)
80007aac:	439c                	lw	a5,0(a5)
80007aae:	853e                	mv	a0,a5
80007ab0:	3b4d                	jal	80007862 <QSPI_SPITransactionModeConfig>
	QSPI_SPIDataRateConfig(InitStruct->dataRate);
80007ab2:	fec42783          	lw	a5,-20(s0)
80007ab6:	43dc                	lw	a5,4(a5)
80007ab8:	853e                	mv	a0,a5
80007aba:	3b09                	jal	800077cc <QSPI_SPIDataRateConfig>
	QSPI_SetWordLength(InitStruct->dataWidth);
80007abc:	fec42783          	lw	a5,-20(s0)
80007ac0:	479c                	lw	a5,8(a5)
80007ac2:	853e                	mv	a0,a5
80007ac4:	39d1                	jal	80007798 <QSPI_SetWordLength>
	QSPI_TxCmd(InitStruct->TxEnable);
80007ac6:	fec42783          	lw	a5,-20(s0)
80007aca:	47dc                	lw	a5,12(a5)
80007acc:	853e                	mv	a0,a5
80007ace:	3b05                	jal	800077fe <QSPI_TxCmd>
	QSPI_RxCmd(InitStruct->RxEnable);
80007ad0:	fec42783          	lw	a5,-20(s0)
80007ad4:	4b9c                	lw	a5,16(a5)
80007ad6:	853e                	mv	a0,a5
80007ad8:	3ba1                	jal	80007830 <QSPI_RxCmd>
	QSPI_SCKDivConfig(InitStruct->SCKDiv);
80007ada:	fec42783          	lw	a5,-20(s0)
80007ade:	4bdc                	lw	a5,20(a5)
80007ae0:	853e                	mv	a0,a5
80007ae2:	3951                	jal	80007776 <QSPI_SCKDivConfig>
}
80007ae4:	0001                	nop
80007ae6:	40f2                	lw	ra,28(sp)
80007ae8:	4462                	lw	s0,24(sp)
80007aea:	6105                	addi	sp,sp,32
80007aec:	8082                	ret

80007aee <QSPI_SPI_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_SPI_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void QSPI_SPI_StructInit(QSPI_SPI_Init_TypeDef* InitStruct)
{
80007aee:	1101                	addi	sp,sp,-32
80007af0:	ce22                	sw	s0,28(sp)
80007af2:	1000                	addi	s0,sp,32
80007af4:	fea42623          	sw	a0,-20(s0)
    InitStruct->IOMode = QSPI_SPI_IOMode_Single;
80007af8:	fec42783          	lw	a5,-20(s0)
80007afc:	0007a023          	sw	zero,0(a5) # 20040000 <STACK_SIZE+0x2003f800>
    InitStruct->dataRate = QSPI_SPI_DataRate_Single;
80007b00:	fec42783          	lw	a5,-20(s0)
80007b04:	0007a223          	sw	zero,4(a5)
    InitStruct->dataWidth = 0x1;
80007b08:	fec42783          	lw	a5,-20(s0)
80007b0c:	4705                	li	a4,1
80007b0e:	c798                	sw	a4,8(a5)
    InitStruct->TxEnable = DISABLE;
80007b10:	fec42783          	lw	a5,-20(s0)
80007b14:	0007a623          	sw	zero,12(a5)
    InitStruct->RxEnable = DISABLE;
80007b18:	fec42783          	lw	a5,-20(s0)
80007b1c:	0007a823          	sw	zero,16(a5)
    InitStruct->SCKDiv = 0x0;
80007b20:	fec42783          	lw	a5,-20(s0)
80007b24:	0007aa23          	sw	zero,20(a5)
}
80007b28:	0001                	nop
80007b2a:	4472                	lw	s0,28(sp)
80007b2c:	6105                	addi	sp,sp,32
80007b2e:	8082                	ret

80007b30 <QSPI_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void QSPI_Init(QSPI_Init_TypeDef* InitStruct)
{
80007b30:	1101                	addi	sp,sp,-32
80007b32:	ce06                	sw	ra,28(sp)
80007b34:	cc22                	sw	s0,24(sp)
80007b36:	1000                	addi	s0,sp,32
80007b38:	fea42623          	sw	a0,-20(s0)
    QSPI_ModeConfig(QSPI_Mode_QSPI);
80007b3c:	4509                	li	a0,2
80007b3e:	3119                	jal	80007744 <QSPI_ModeConfig>

	QSPI_InstructionConfig(InitStruct->instruction);
80007b40:	fec42783          	lw	a5,-20(s0)
80007b44:	0007c783          	lbu	a5,0(a5)
80007b48:	853e                	mv	a0,a5
80007b4a:	3b99                	jal	800078a0 <QSPI_InstructionConfig>
	QSPI_InstructionModeConfig(InitStruct->instructionMode);
80007b4c:	fec42783          	lw	a5,-20(s0)
80007b50:	43dc                	lw	a5,4(a5)
80007b52:	853e                	mv	a0,a5
80007b54:	33b5                	jal	800078c0 <QSPI_InstructionModeConfig>
	QSPI_AddressModeConfig(InitStruct->addressMode);
80007b56:	fec42783          	lw	a5,-20(s0)
80007b5a:	479c                	lw	a5,8(a5)
80007b5c:	853e                	mv	a0,a5
80007b5e:	3b41                	jal	800078ee <QSPI_AddressModeConfig>
	QSPI_AddressSizeConfig(InitStruct->addressSize);
80007b60:	fec42783          	lw	a5,-20(s0)
80007b64:	47dc                	lw	a5,12(a5)
80007b66:	853e                	mv	a0,a5
80007b68:	3b65                	jal	80007920 <QSPI_AddressSizeConfig>
	QSPI_AdditionalModeConfig(InitStruct->additionalMode);
80007b6a:	fec42783          	lw	a5,-20(s0)
80007b6e:	4b9c                	lw	a5,16(a5)
80007b70:	853e                	mv	a0,a5
80007b72:	3bf9                	jal	80007950 <QSPI_AdditionalModeConfig>
	QSPI_AdditionalSizeConfig(InitStruct->additionalSize);
80007b74:	fec42783          	lw	a5,-20(s0)
80007b78:	4bdc                	lw	a5,20(a5)
80007b7a:	853e                	mv	a0,a5
80007b7c:	3511                	jal	80007980 <QSPI_AdditionalSizeConfig>
	QSPI_WaitCyclesConfig(InitStruct->waitCycles);
80007b7e:	fec42783          	lw	a5,-20(s0)
80007b82:	4f9c                	lw	a5,24(a5)
80007b84:	853e                	mv	a0,a5
80007b86:	3535                	jal	800079b2 <QSPI_WaitCyclesConfig>
	QSPI_DataModeConfig(InitStruct->dataMode);
80007b88:	fec42783          	lw	a5,-20(s0)
80007b8c:	4fdc                	lw	a5,28(a5)
80007b8e:	853e                	mv	a0,a5
80007b90:	3d91                	jal	800079e4 <QSPI_DataModeConfig>
	QSPI_DataDirectionConfig(InitStruct->dataDirection);
80007b92:	fec42783          	lw	a5,-20(s0)
80007b96:	539c                	lw	a5,32(a5)
80007b98:	853e                	mv	a0,a5
80007b9a:	3db5                	jal	80007a16 <QSPI_DataDirectionConfig>
	QSPI_DataRateConfig(InitStruct->dataRate);
80007b9c:	fec42783          	lw	a5,-20(s0)
80007ba0:	53dc                	lw	a5,36(a5)
80007ba2:	853e                	mv	a0,a5
80007ba4:	3555                	jal	80007a48 <QSPI_DataRateConfig>
	QSPI_SCKDivConfig(InitStruct->SCKDiv);
80007ba6:	fec42783          	lw	a5,-20(s0)
80007baa:	579c                	lw	a5,40(a5)
80007bac:	853e                	mv	a0,a5
80007bae:	36e1                	jal	80007776 <QSPI_SCKDivConfig>
}
80007bb0:	0001                	nop
80007bb2:	40f2                	lw	ra,28(sp)
80007bb4:	4462                	lw	s0,24(sp)
80007bb6:	6105                	addi	sp,sp,32
80007bb8:	8082                	ret

80007bba <QSPI_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void QSPI_StructInit(QSPI_Init_TypeDef* InitStruct)
{
80007bba:	1101                	addi	sp,sp,-32
80007bbc:	ce22                	sw	s0,28(sp)
80007bbe:	1000                	addi	s0,sp,32
80007bc0:	fea42623          	sw	a0,-20(s0)
	InitStruct->instruction = 0x0;
80007bc4:	fec42783          	lw	a5,-20(s0)
80007bc8:	00078023          	sb	zero,0(a5)
	InitStruct->instructionMode = QSPI_Lines_No;
80007bcc:	fec42783          	lw	a5,-20(s0)
80007bd0:	0007a223          	sw	zero,4(a5)
	InitStruct->addressMode = QSPI_Lines_No;
80007bd4:	fec42783          	lw	a5,-20(s0)
80007bd8:	0007a423          	sw	zero,8(a5)
	InitStruct->addressSize = QSPI_DataSize_8;
80007bdc:	fec42783          	lw	a5,-20(s0)
80007be0:	0007a623          	sw	zero,12(a5)
	InitStruct->additionalMode = QSPI_Lines_No;
80007be4:	fec42783          	lw	a5,-20(s0)
80007be8:	0007a823          	sw	zero,16(a5)
	InitStruct->additionalSize = QSPI_DataSize_8;
80007bec:	fec42783          	lw	a5,-20(s0)
80007bf0:	0007aa23          	sw	zero,20(a5)
	InitStruct->waitCycles = 0x0;
80007bf4:	fec42783          	lw	a5,-20(s0)
80007bf8:	0007ac23          	sw	zero,24(a5)
	InitStruct->dataMode = QSPI_Lines_No;
80007bfc:	fec42783          	lw	a5,-20(s0)
80007c00:	0007ae23          	sw	zero,28(a5)
	InitStruct->dataDirection = QSPI_Direction_Write;
80007c04:	fec42783          	lw	a5,-20(s0)
80007c08:	0207a023          	sw	zero,32(a5)
	InitStruct->dataRate = QSPI_DataRate_Single;
80007c0c:	fec42783          	lw	a5,-20(s0)
80007c10:	0207a223          	sw	zero,36(a5)
	InitStruct->SCKDiv = 0x0;
80007c14:	fec42783          	lw	a5,-20(s0)
80007c18:	0207a423          	sw	zero,40(a5)
}
80007c1c:	0001                	nop
80007c1e:	4472                	lw	s0,28(sp)
80007c20:	6105                	addi	sp,sp,32
80007c22:	8082                	ret

80007c24 <RCU_SysClkConfig>:
{
80007c24:	1101                	addi	sp,sp,-32
80007c26:	ce22                	sw	s0,28(sp)
80007c28:	1000                	addi	s0,sp,32
80007c2a:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(RCU->SYSCLKCFG_bit.SRC, SysClk);
80007c2e:	3000e7b7          	lui	a5,0x3000e
80007c32:	fec42703          	lw	a4,-20(s0)
80007c36:	8b0d                	andi	a4,a4,3
80007c38:	0ff77713          	zext.b	a4,a4
80007c3c:	8b0d                	andi	a4,a4,3
80007c3e:	5b94                	lw	a3,48(a5)
80007c40:	9af1                	andi	a3,a3,-4
80007c42:	8f55                	or	a4,a4,a3
80007c44:	db98                	sw	a4,48(a5)
}
80007c46:	0001                	nop
80007c48:	4472                	lw	s0,28(sp)
80007c4a:	6105                	addi	sp,sp,32
80007c4c:	8082                	ret

80007c4e <RCU_SysClkStatus>:
{
80007c4e:	1141                	addi	sp,sp,-16
80007c50:	c622                	sw	s0,12(sp)
80007c52:	0800                	addi	s0,sp,16
    return (RCU_SysClk_TypeDef)READ_REG(RCU->CLKSTAT_bit.SRC);
80007c54:	3000e7b7          	lui	a5,0x3000e
80007c58:	5fdc                	lw	a5,60(a5)
80007c5a:	8b8d                	andi	a5,a5,3
80007c5c:	0ff7f793          	zext.b	a5,a5
}
80007c60:	853e                	mv	a0,a5
80007c62:	4432                	lw	s0,12(sp)
80007c64:	0141                	addi	sp,sp,16
80007c66:	8082                	ret

80007c68 <RCU_SYSPLL0_OutCmd>:
{
80007c68:	1101                	addi	sp,sp,-32
80007c6a:	ce22                	sw	s0,28(sp)
80007c6c:	1000                	addi	s0,sp,32
80007c6e:	fea42623          	sw	a0,-20(s0)
    if(State)  SET_BIT(RCU->PLLSYSCFG0, (1 << RCU_PLLSYSCFG0_FOUTEN_Pos));
80007c72:	fec42783          	lw	a5,-20(s0)
80007c76:	cb91                	beqz	a5,80007c8a <RCU_SYSPLL0_OutCmd+0x22>
80007c78:	3000e7b7          	lui	a5,0x3000e
80007c7c:	4bb8                	lw	a4,80(a5)
80007c7e:	3000e7b7          	lui	a5,0x3000e
80007c82:	02076713          	ori	a4,a4,32
80007c86:	cbb8                	sw	a4,80(a5)
}
80007c88:	a809                	j	80007c9a <RCU_SYSPLL0_OutCmd+0x32>
      else   CLEAR_BIT(RCU->PLLSYSCFG0, (1 << RCU_PLLSYSCFG0_FOUTEN_Pos));
80007c8a:	3000e7b7          	lui	a5,0x3000e
80007c8e:	4bb8                	lw	a4,80(a5)
80007c90:	3000e7b7          	lui	a5,0x3000e
80007c94:	fdf77713          	andi	a4,a4,-33
80007c98:	cbb8                	sw	a4,80(a5)
}
80007c9a:	0001                	nop
80007c9c:	4472                	lw	s0,28(sp)
80007c9e:	6105                	addi	sp,sp,32
80007ca0:	8082                	ret

80007ca2 <RCU_SYSPLL_Cmd>:
{
80007ca2:	1101                	addi	sp,sp,-32
80007ca4:	ce22                	sw	s0,28(sp)
80007ca6:	1000                	addi	s0,sp,32
80007ca8:	fea42623          	sw	a0,-20(s0)
    if(State)  MODIFY_REG(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_PLLEN_Msk,0x01);
80007cac:	fec42783          	lw	a5,-20(s0)
80007cb0:	cb91                	beqz	a5,80007cc4 <RCU_SYSPLL_Cmd+0x22>
80007cb2:	3000e7b7          	lui	a5,0x3000e
80007cb6:	4bb8                	lw	a4,80(a5)
80007cb8:	3000e7b7          	lui	a5,0x3000e
80007cbc:	00176713          	ori	a4,a4,1
80007cc0:	cbb8                	sw	a4,80(a5)
}
80007cc2:	a801                	j	80007cd2 <RCU_SYSPLL_Cmd+0x30>
      else   MODIFY_REG(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_PLLEN_Msk,0x00);
80007cc4:	3000e7b7          	lui	a5,0x3000e
80007cc8:	4bb8                	lw	a4,80(a5)
80007cca:	3000e7b7          	lui	a5,0x3000e
80007cce:	9b79                	andi	a4,a4,-2
80007cd0:	cbb8                	sw	a4,80(a5)
}
80007cd2:	0001                	nop
80007cd4:	4472                	lw	s0,28(sp)
80007cd6:	6105                	addi	sp,sp,32
80007cd8:	8082                	ret

80007cda <RCU_SYSPLL_LockStatus>:
{
80007cda:	1141                	addi	sp,sp,-16
80007cdc:	c622                	sw	s0,12(sp)
80007cde:	0800                	addi	s0,sp,16
    return (FlagStatus)READ_BIT(RCU->PLLSYSSTAT, RCU_PLLSYSSTAT_LOCK_Msk);
80007ce0:	3000e7b7          	lui	a5,0x3000e
80007ce4:	53bc                	lw	a5,96(a5)
80007ce6:	8b85                	andi	a5,a5,1
}
80007ce8:	853e                	mv	a0,a5
80007cea:	4432                	lw	s0,12(sp)
80007cec:	0141                	addi	sp,sp,16
80007cee:	8082                	ret

80007cf0 <RCU_USBPLL_OutCmd>:
{
80007cf0:	1101                	addi	sp,sp,-32
80007cf2:	ce22                	sw	s0,28(sp)
80007cf4:	1000                	addi	s0,sp,32
80007cf6:	fea42623          	sw	a0,-20(s0)
    if(State)  MODIFY_REG(USB->PLLUSBCFG0, USB_PLLUSBCFG0_FOUTEN_Msk,0x01);
80007cfa:	fec42783          	lw	a5,-20(s0)
80007cfe:	c395                	beqz	a5,80007d22 <RCU_USBPLL_OutCmd+0x32>
80007d00:	20010737          	lui	a4,0x20010
80007d04:	6785                	lui	a5,0x1
80007d06:	97ba                	add	a5,a5,a4
80007d08:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
80007d0c:	f9e7f793          	andi	a5,a5,-98
80007d10:	200106b7          	lui	a3,0x20010
80007d14:	0017e713          	ori	a4,a5,1
80007d18:	6785                	lui	a5,0x1
80007d1a:	97b6                	add	a5,a5,a3
80007d1c:	80e7a023          	sw	a4,-2048(a5) # 800 <STACK_SIZE>
}
80007d20:	a839                	j	80007d3e <RCU_USBPLL_OutCmd+0x4e>
      else   MODIFY_REG(USB->PLLUSBCFG0, USB_PLLUSBCFG0_FOUTEN_Msk,0x0);
80007d22:	20010737          	lui	a4,0x20010
80007d26:	6785                	lui	a5,0x1
80007d28:	97ba                	add	a5,a5,a4
80007d2a:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
80007d2e:	200106b7          	lui	a3,0x20010
80007d32:	f9f7f713          	andi	a4,a5,-97
80007d36:	6785                	lui	a5,0x1
80007d38:	97b6                	add	a5,a5,a3
80007d3a:	80e7a023          	sw	a4,-2048(a5) # 800 <STACK_SIZE>
}
80007d3e:	0001                	nop
80007d40:	4472                	lw	s0,28(sp)
80007d42:	6105                	addi	sp,sp,32
80007d44:	8082                	ret

80007d46 <getSysClkFreq>:
  * @brief   Получение значения частоты генерации выбранного источника
  * @param   Clk  Выбор тактового сигнала
  * @retval  Val  Значение Гц
  */
static uint32_t getSysClkFreq(RCU_SysClk_TypeDef Clk)
{
80007d46:	7179                	addi	sp,sp,-48
80007d48:	d606                	sw	ra,44(sp)
80007d4a:	d422                	sw	s0,40(sp)
80007d4c:	1800                	addi	s0,sp,48
80007d4e:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80007d52:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80007d56:	fdc42703          	lw	a4,-36(s0)
80007d5a:	478d                	li	a5,3
80007d5c:	04f70663          	beq	a4,a5,80007da8 <getSysClkFreq+0x62>
80007d60:	fdc42703          	lw	a4,-36(s0)
80007d64:	478d                	li	a5,3
80007d66:	04e7e563          	bltu	a5,a4,80007db0 <getSysClkFreq+0x6a>
80007d6a:	fdc42703          	lw	a4,-36(s0)
80007d6e:	4789                	li	a5,2
80007d70:	02f70863          	beq	a4,a5,80007da0 <getSysClkFreq+0x5a>
80007d74:	fdc42703          	lw	a4,-36(s0)
80007d78:	4789                	li	a5,2
80007d7a:	02e7eb63          	bltu	a5,a4,80007db0 <getSysClkFreq+0x6a>
80007d7e:	fdc42783          	lw	a5,-36(s0)
80007d82:	c799                	beqz	a5,80007d90 <getSysClkFreq+0x4a>
80007d84:	fdc42703          	lw	a4,-36(s0)
80007d88:	4785                	li	a5,1
80007d8a:	00f70763          	beq	a4,a5,80007d98 <getSysClkFreq+0x52>
80007d8e:	a00d                	j	80007db0 <getSysClkFreq+0x6a>
    case RCU_SysClk_HsiClk:
        clk_freq = RCU_GetHsiClkFreq();
80007d90:	2209                	jal	80007e92 <RCU_GetHsiClkFreq>
80007d92:	fea42623          	sw	a0,-20(s0)
        break;
80007d96:	a829                	j	80007db0 <getSysClkFreq+0x6a>
    case RCU_SysClk_HseClk:
        clk_freq = RCU_GetHseClkFreq();
80007d98:	221d                	jal	80007ebe <RCU_GetHseClkFreq>
80007d9a:	fea42623          	sw	a0,-20(s0)
        break;
80007d9e:	a809                	j	80007db0 <getSysClkFreq+0x6a>
    case RCU_SysClk_SysPLL0Clk:
        clk_freq = RCU_GetSysPLL0ClkFreq();
80007da0:	22a1                	jal	80007ee8 <RCU_GetSysPLL0ClkFreq>
80007da2:	fea42623          	sw	a0,-20(s0)
        break;
80007da6:	a029                	j	80007db0 <getSysClkFreq+0x6a>
    case RCU_SysClk_LsiClk:
        clk_freq = RCU_GetLsiClkFreq();
80007da8:	2235                	jal	80007ed4 <RCU_GetLsiClkFreq>
80007daa:	fea42623          	sw	a0,-20(s0)
        break;
80007dae:	0001                	nop
    }

    return clk_freq;
80007db0:	fec42783          	lw	a5,-20(s0)
}
80007db4:	853e                	mv	a0,a5
80007db6:	50b2                	lw	ra,44(sp)
80007db8:	5422                	lw	s0,40(sp)
80007dba:	6145                	addi	sp,sp,48
80007dbc:	8082                	ret

80007dbe <getPeriphClkFreq>:
  * @brief   Получение значения частоты генерации выбранного источника
  * @param   Clk  Выбор тактового сигнала
  * @retval  Val  Значение Гц
  */
static uint32_t getPeriphClkFreq(RCU_PeriphClk_TypeDef Clk)
{
80007dbe:	7179                	addi	sp,sp,-48
80007dc0:	d606                	sw	ra,44(sp)
80007dc2:	d422                	sw	s0,40(sp)
80007dc4:	1800                	addi	s0,sp,48
80007dc6:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80007dca:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80007dce:	fdc42703          	lw	a4,-36(s0)
80007dd2:	478d                	li	a5,3
80007dd4:	04f70663          	beq	a4,a5,80007e20 <getPeriphClkFreq+0x62>
80007dd8:	fdc42703          	lw	a4,-36(s0)
80007ddc:	478d                	li	a5,3
80007dde:	04e7e563          	bltu	a5,a4,80007e28 <getPeriphClkFreq+0x6a>
80007de2:	fdc42703          	lw	a4,-36(s0)
80007de6:	4789                	li	a5,2
80007de8:	02f70863          	beq	a4,a5,80007e18 <getPeriphClkFreq+0x5a>
80007dec:	fdc42703          	lw	a4,-36(s0)
80007df0:	4789                	li	a5,2
80007df2:	02e7eb63          	bltu	a5,a4,80007e28 <getPeriphClkFreq+0x6a>
80007df6:	fdc42783          	lw	a5,-36(s0)
80007dfa:	c799                	beqz	a5,80007e08 <getPeriphClkFreq+0x4a>
80007dfc:	fdc42703          	lw	a4,-36(s0)
80007e00:	4785                	li	a5,1
80007e02:	00f70763          	beq	a4,a5,80007e10 <getPeriphClkFreq+0x52>
80007e06:	a00d                	j	80007e28 <getPeriphClkFreq+0x6a>
    case RCU_PeriphClk_HsiClk:
        clk_freq = RCU_GetHsiClkFreq();
80007e08:	2069                	jal	80007e92 <RCU_GetHsiClkFreq>
80007e0a:	fea42623          	sw	a0,-20(s0)
        break;
80007e0e:	a829                	j	80007e28 <getPeriphClkFreq+0x6a>
    case RCU_PeriphClk_HseClk:
        clk_freq = RCU_GetHseClkFreq();
80007e10:	207d                	jal	80007ebe <RCU_GetHseClkFreq>
80007e12:	fea42623          	sw	a0,-20(s0)
        break;
80007e16:	a809                	j	80007e28 <getPeriphClkFreq+0x6a>
    case RCU_PeriphClk_SysPLL0Clk:
        clk_freq = RCU_GetSysPLL0ClkFreq();
80007e18:	28c1                	jal	80007ee8 <RCU_GetSysPLL0ClkFreq>
80007e1a:	fea42623          	sw	a0,-20(s0)
        break;
80007e1e:	a029                	j	80007e28 <getPeriphClkFreq+0x6a>
    case RCU_PeriphClk_SysPLL1Clk:
        clk_freq = RCU_GetSysPLL1ClkFreq();
80007e20:	2a5d                	jal	80007fd6 <RCU_GetSysPLL1ClkFreq>
80007e22:	fea42623          	sw	a0,-20(s0)
        break;
80007e26:	0001                	nop
    }

    return clk_freq;
80007e28:	fec42783          	lw	a5,-20(s0)
}
80007e2c:	853e                	mv	a0,a5
80007e2e:	50b2                	lw	ra,44(sp)
80007e30:	5422                	lw	s0,40(sp)
80007e32:	6145                	addi	sp,sp,48
80007e34:	8082                	ret

80007e36 <getIwdtClkFreq>:
  * @brief   Получение значения частоты генерации выбранного источника
  * @param   Clk  Выбор тактового сигнала
  * @retval  Val  Значение Гц
  */
static uint32_t getIwdtClkFreq(RCU_IWDTClk_TypeDef Clk)
{
80007e36:	7179                	addi	sp,sp,-48
80007e38:	d606                	sw	ra,44(sp)
80007e3a:	d422                	sw	s0,40(sp)
80007e3c:	1800                	addi	s0,sp,48
80007e3e:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80007e42:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80007e46:	fdc42703          	lw	a4,-36(s0)
80007e4a:	4789                	li	a5,2
80007e4c:	02f70863          	beq	a4,a5,80007e7c <getIwdtClkFreq+0x46>
80007e50:	fdc42703          	lw	a4,-36(s0)
80007e54:	4789                	li	a5,2
80007e56:	02e7e763          	bltu	a5,a4,80007e84 <getIwdtClkFreq+0x4e>
80007e5a:	fdc42783          	lw	a5,-36(s0)
80007e5e:	c799                	beqz	a5,80007e6c <getIwdtClkFreq+0x36>
80007e60:	fdc42703          	lw	a4,-36(s0)
80007e64:	4785                	li	a5,1
80007e66:	00f70763          	beq	a4,a5,80007e74 <getIwdtClkFreq+0x3e>
80007e6a:	a829                	j	80007e84 <getIwdtClkFreq+0x4e>
    case RCU_IWDTClk_HsiClk:
        clk_freq = RCU_GetHsiClkFreq();
80007e6c:	201d                	jal	80007e92 <RCU_GetHsiClkFreq>
80007e6e:	fea42623          	sw	a0,-20(s0)
        break;
80007e72:	a809                	j	80007e84 <getIwdtClkFreq+0x4e>
    case RCU_IWDTClk_HseClk:
        clk_freq = RCU_GetHseClkFreq();
80007e74:	20a9                	jal	80007ebe <RCU_GetHseClkFreq>
80007e76:	fea42623          	sw	a0,-20(s0)
        break;
80007e7a:	a029                	j	80007e84 <getIwdtClkFreq+0x4e>
    case RCU_IWDTClk_LsiClk:
        clk_freq = RCU_GetLsiClkFreq();
80007e7c:	28a1                	jal	80007ed4 <RCU_GetLsiClkFreq>
80007e7e:	fea42623          	sw	a0,-20(s0)
        break;
80007e82:	0001                	nop
    }

    return clk_freq;
80007e84:	fec42783          	lw	a5,-20(s0)
}
80007e88:	853e                	mv	a0,a5
80007e8a:	50b2                	lw	ra,44(sp)
80007e8c:	5422                	lw	s0,40(sp)
80007e8e:	6145                	addi	sp,sp,48
80007e90:	8082                	ret

80007e92 <RCU_GetHsiClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала HSICLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetHsiClkFreq()
{
80007e92:	1101                	addi	sp,sp,-32
80007e94:	ce22                	sw	s0,28(sp)
80007e96:	1000                	addi	s0,sp,32
    //Константы согласно таблицы 4.2 Руководства пользователя
    static const uint32_t hsi_clk[16] = {618000, 650000,686000,725000,766000,816000,873000,938000, 1012000, 1101000, 1208000, 1339000, 1510000, 1722000, 2009000, 2417000};
    uint32_t hsi_trim;

    hsi_trim = READ_REG(PMURTC->HSI_TRIM);
80007e98:	380117b7          	lui	a5,0x38011
80007e9c:	0c87a783          	lw	a5,200(a5) # 380110c8 <STACK_SIZE+0x380108c8>
80007ea0:	fef42623          	sw	a5,-20(s0)
    return hsi_clk[hsi_trim];
80007ea4:	8000a7b7          	lui	a5,0x8000a
80007ea8:	8c078713          	addi	a4,a5,-1856 # 800098c0 <__data_source_start+0xfffffe9c>
80007eac:	fec42783          	lw	a5,-20(s0)
80007eb0:	078a                	slli	a5,a5,0x2
80007eb2:	97ba                	add	a5,a5,a4
80007eb4:	439c                	lw	a5,0(a5)
}
80007eb6:	853e                	mv	a0,a5
80007eb8:	4472                	lw	s0,28(sp)
80007eba:	6105                	addi	sp,sp,32
80007ebc:	8082                	ret

80007ebe <RCU_GetHseClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала HSECLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetHseClkFreq()
{
80007ebe:	1141                	addi	sp,sp,-16
80007ec0:	c622                	sw	s0,12(sp)
80007ec2:	0800                	addi	s0,sp,16
    return HSECLK_VAL;
80007ec4:	00f427b7          	lui	a5,0xf42
80007ec8:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
}
80007ecc:	853e                	mv	a0,a5
80007ece:	4432                	lw	s0,12(sp)
80007ed0:	0141                	addi	sp,sp,16
80007ed2:	8082                	ret

80007ed4 <RCU_GetLsiClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала LSICLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetLsiClkFreq()
{
80007ed4:	1141                	addi	sp,sp,-16
80007ed6:	c622                	sw	s0,12(sp)
80007ed8:	0800                	addi	s0,sp,16
    return (uint32_t)LSICLK_VAL;
80007eda:	67a1                	lui	a5,0x8
80007edc:	d0078793          	addi	a5,a5,-768 # 7d00 <STACK_SIZE+0x7500>
}
80007ee0:	853e                	mv	a0,a5
80007ee2:	4432                	lw	s0,12(sp)
80007ee4:	0141                	addi	sp,sp,16
80007ee6:	8082                	ret

80007ee8 <RCU_GetSysPLL0ClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала SYSPLL0CLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetSysPLL0ClkFreq()
{
80007ee8:	7179                	addi	sp,sp,-48
80007eea:	d622                	sw	s0,44(sp)
80007eec:	1800                	addi	s0,sp,48
    uint32_t pll_div0a, pll_div0b, pll_fbdiv, pll_refdiv, pll_refclk, pll_clkFreq;
    float pll_fracdiv;
    pll_div0a = READ_REG(RCU->PLLSYSCFG0_bit.PD0A)+1;
80007eee:	3000e7b7          	lui	a5,0x3000e
80007ef2:	4bbc                	lw	a5,80(a5)
80007ef4:	83b5                	srli	a5,a5,0xd
80007ef6:	8b9d                	andi	a5,a5,7
80007ef8:	0ff7f793          	zext.b	a5,a5
80007efc:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80007efe:	fef42423          	sw	a5,-24(s0)
    pll_div0b = READ_REG(RCU->PLLSYSCFG0_bit.PD0B)+1;
80007f02:	3000e7b7          	lui	a5,0x3000e
80007f06:	4bbc                	lw	a5,80(a5)
80007f08:	83c1                	srli	a5,a5,0x10
80007f0a:	03f7f793          	andi	a5,a5,63
80007f0e:	0ff7f793          	zext.b	a5,a5
80007f12:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80007f14:	fef42223          	sw	a5,-28(s0)
    pll_fbdiv = READ_REG(RCU->PLLSYSCFG2_bit.FBDIV);
80007f18:	3000e7b7          	lui	a5,0x3000e
80007f1c:	4fbc                	lw	a5,88(a5)
80007f1e:	873e                	mv	a4,a5
80007f20:	6785                	lui	a5,0x1
80007f22:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80007f24:	8ff9                	and	a5,a5,a4
80007f26:	07c2                	slli	a5,a5,0x10
80007f28:	83c1                	srli	a5,a5,0x10
80007f2a:	fef42023          	sw	a5,-32(s0)
    pll_refdiv = READ_REG(RCU->PLLSYSCFG0_bit.REFDIV);
80007f2e:	3000e7b7          	lui	a5,0x3000e
80007f32:	4bbc                	lw	a5,80(a5)
80007f34:	839d                	srli	a5,a5,0x7
80007f36:	03f7f793          	andi	a5,a5,63
80007f3a:	0ff7f793          	zext.b	a5,a5
80007f3e:	fcf42e23          	sw	a5,-36(s0)
    pll_refclk = HSECLK_VAL;
80007f42:	00f427b7          	lui	a5,0xf42
80007f46:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80007f4a:	fcf42c23          	sw	a5,-40(s0)
    if (RCU->PLLSYSCFG0_bit.DSMEN) pll_fracdiv = (float)(RCU->PLLSYSCFG1_bit.FRAC / (1 << 24));
80007f4e:	3000e7b7          	lui	a5,0x3000e
80007f52:	4bbc                	lw	a5,80(a5)
80007f54:	8391                	srli	a5,a5,0x4
80007f56:	8b85                	andi	a5,a5,1
80007f58:	0ff7f793          	zext.b	a5,a5
80007f5c:	c78d                	beqz	a5,80007f86 <RCU_GetSysPLL0ClkFreq+0x9e>
80007f5e:	3000e7b7          	lui	a5,0x3000e
80007f62:	4bf8                	lw	a4,84(a5)
80007f64:	010007b7          	lui	a5,0x1000
80007f68:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
80007f6a:	8ff9                	and	a5,a5,a4
80007f6c:	41f7d693          	srai	a3,a5,0x1f
80007f70:	01000737          	lui	a4,0x1000
80007f74:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80007f76:	8f75                	and	a4,a4,a3
80007f78:	97ba                	add	a5,a5,a4
80007f7a:	87e1                	srai	a5,a5,0x18
80007f7c:	d007f7d3          	fcvt.s.w	fa5,a5
80007f80:	fef42627          	fsw	fa5,-20(s0)
80007f84:	a019                	j	80007f8a <RCU_GetSysPLL0ClkFreq+0xa2>
       else pll_fracdiv = 0;
80007f86:	fe042623          	sw	zero,-20(s0)

    pll_clkFreq = (uint32_t)((pll_refclk * (pll_fbdiv + pll_fracdiv)) / (pll_refdiv * pll_div0a * pll_div0b));
80007f8a:	fd842783          	lw	a5,-40(s0)
80007f8e:	d017f753          	fcvt.s.wu	fa4,a5
80007f92:	fe042783          	lw	a5,-32(s0)
80007f96:	d017f6d3          	fcvt.s.wu	fa3,a5
80007f9a:	fec42787          	flw	fa5,-20(s0)
80007f9e:	00f6f7d3          	fadd.s	fa5,fa3,fa5
80007fa2:	10f77753          	fmul.s	fa4,fa4,fa5
80007fa6:	fdc42703          	lw	a4,-36(s0)
80007faa:	fe842783          	lw	a5,-24(s0)
80007fae:	02f70733          	mul	a4,a4,a5
80007fb2:	fe442783          	lw	a5,-28(s0)
80007fb6:	02f707b3          	mul	a5,a4,a5
80007fba:	d017f7d3          	fcvt.s.wu	fa5,a5
80007fbe:	18f777d3          	fdiv.s	fa5,fa4,fa5
80007fc2:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80007fc6:	fcf42a23          	sw	a5,-44(s0)
    return (uint32_t)(pll_clkFreq);
80007fca:	fd442783          	lw	a5,-44(s0)
}
80007fce:	853e                	mv	a0,a5
80007fd0:	5432                	lw	s0,44(sp)
80007fd2:	6145                	addi	sp,sp,48
80007fd4:	8082                	ret

80007fd6 <RCU_GetSysPLL1ClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала SYSPLL1CLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetSysPLL1ClkFreq()
{
80007fd6:	7179                	addi	sp,sp,-48
80007fd8:	d622                	sw	s0,44(sp)
80007fda:	1800                	addi	s0,sp,48
    uint32_t pll_div1a, pll_div1b, pll_fbdiv, pll_refdiv, pll_refclk;
    float pll_fracdiv;
    pll_div1a = READ_REG(RCU->PLLSYSCFG0_bit.PD1A)+1;
80007fdc:	3000e7b7          	lui	a5,0x3000e
80007fe0:	4bbc                	lw	a5,80(a5)
80007fe2:	83d9                	srli	a5,a5,0x16
80007fe4:	8b9d                	andi	a5,a5,7
80007fe6:	0ff7f793          	zext.b	a5,a5
80007fea:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80007fec:	fef42423          	sw	a5,-24(s0)
    pll_div1b = READ_REG(RCU->PLLSYSCFG0_bit.PD1B)+1;
80007ff0:	3000e7b7          	lui	a5,0x3000e
80007ff4:	4bbc                	lw	a5,80(a5)
80007ff6:	83e5                	srli	a5,a5,0x19
80007ff8:	03f7f793          	andi	a5,a5,63
80007ffc:	0ff7f793          	zext.b	a5,a5
80008000:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80008002:	fef42223          	sw	a5,-28(s0)
    pll_fbdiv = READ_REG(RCU->PLLSYSCFG2_bit.FBDIV);
80008006:	3000e7b7          	lui	a5,0x3000e
8000800a:	4fbc                	lw	a5,88(a5)
8000800c:	873e                	mv	a4,a5
8000800e:	6785                	lui	a5,0x1
80008010:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80008012:	8ff9                	and	a5,a5,a4
80008014:	07c2                	slli	a5,a5,0x10
80008016:	83c1                	srli	a5,a5,0x10
80008018:	fef42023          	sw	a5,-32(s0)
    pll_refdiv = READ_REG(RCU->PLLSYSCFG0_bit.REFDIV);
8000801c:	3000e7b7          	lui	a5,0x3000e
80008020:	4bbc                	lw	a5,80(a5)
80008022:	839d                	srli	a5,a5,0x7
80008024:	03f7f793          	andi	a5,a5,63
80008028:	0ff7f793          	zext.b	a5,a5
8000802c:	fcf42e23          	sw	a5,-36(s0)
    pll_refclk = HSECLK_VAL;
80008030:	00f427b7          	lui	a5,0xf42
80008034:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80008038:	fcf42c23          	sw	a5,-40(s0)
    if (RCU->PLLSYSCFG0_bit.DSMEN) pll_fracdiv = (float)(RCU->PLLSYSCFG1_bit.FRAC / (1 << 24));
8000803c:	3000e7b7          	lui	a5,0x3000e
80008040:	4bbc                	lw	a5,80(a5)
80008042:	8391                	srli	a5,a5,0x4
80008044:	8b85                	andi	a5,a5,1
80008046:	0ff7f793          	zext.b	a5,a5
8000804a:	c78d                	beqz	a5,80008074 <RCU_GetSysPLL1ClkFreq+0x9e>
8000804c:	3000e7b7          	lui	a5,0x3000e
80008050:	4bf8                	lw	a4,84(a5)
80008052:	010007b7          	lui	a5,0x1000
80008056:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
80008058:	8ff9                	and	a5,a5,a4
8000805a:	41f7d693          	srai	a3,a5,0x1f
8000805e:	01000737          	lui	a4,0x1000
80008062:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80008064:	8f75                	and	a4,a4,a3
80008066:	97ba                	add	a5,a5,a4
80008068:	87e1                	srai	a5,a5,0x18
8000806a:	d007f7d3          	fcvt.s.w	fa5,a5
8000806e:	fef42627          	fsw	fa5,-20(s0)
80008072:	a019                	j	80008078 <RCU_GetSysPLL1ClkFreq+0xa2>
       else pll_fracdiv = 0;    
80008074:	fe042623          	sw	zero,-20(s0)

    return (uint32_t)((pll_refclk * (pll_fbdiv + pll_fracdiv)) / (pll_refdiv * pll_div1a * pll_div1b));
80008078:	fd842783          	lw	a5,-40(s0)
8000807c:	d017f753          	fcvt.s.wu	fa4,a5
80008080:	fe042783          	lw	a5,-32(s0)
80008084:	d017f6d3          	fcvt.s.wu	fa3,a5
80008088:	fec42787          	flw	fa5,-20(s0)
8000808c:	00f6f7d3          	fadd.s	fa5,fa3,fa5
80008090:	10f77753          	fmul.s	fa4,fa4,fa5
80008094:	fdc42703          	lw	a4,-36(s0)
80008098:	fe842783          	lw	a5,-24(s0)
8000809c:	02f70733          	mul	a4,a4,a5
800080a0:	fe442783          	lw	a5,-28(s0)
800080a4:	02f707b3          	mul	a5,a4,a5
800080a8:	d017f7d3          	fcvt.s.wu	fa5,a5
800080ac:	18f777d3          	fdiv.s	fa5,fa4,fa5
800080b0:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
}
800080b4:	853e                	mv	a0,a5
800080b6:	5432                	lw	s0,44(sp)
800080b8:	6145                	addi	sp,sp,48
800080ba:	8082                	ret

800080bc <RCU_GetUsbPLLClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала USBPLLCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetUsbPLLClkFreq()
{
800080bc:	7179                	addi	sp,sp,-48
800080be:	d622                	sw	s0,44(sp)
800080c0:	1800                	addi	s0,sp,48
    uint32_t pll_div0a, pll_div0b, pll_fracdiv, pll_fbdiv, pll_refdiv, pll_refclk;

    pll_div0a = READ_REG(USB->PLLUSBCFG0_bit.PD0A)+1;
800080c2:	20010737          	lui	a4,0x20010
800080c6:	6785                	lui	a5,0x1
800080c8:	97ba                	add	a5,a5,a4
800080ca:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
800080ce:	83b5                	srli	a5,a5,0xd
800080d0:	8b9d                	andi	a5,a5,7
800080d2:	0ff7f793          	zext.b	a5,a5
800080d6:	0785                	addi	a5,a5,1
800080d8:	fef42623          	sw	a5,-20(s0)
    pll_div0b = READ_REG(USB->PLLUSBCFG0_bit.PD0B)+1;
800080dc:	20010737          	lui	a4,0x20010
800080e0:	6785                	lui	a5,0x1
800080e2:	97ba                	add	a5,a5,a4
800080e4:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
800080e8:	83c1                	srli	a5,a5,0x10
800080ea:	03f7f793          	andi	a5,a5,63
800080ee:	0ff7f793          	zext.b	a5,a5
800080f2:	0785                	addi	a5,a5,1
800080f4:	fef42423          	sw	a5,-24(s0)
    pll_fracdiv = READ_REG(USB->PLLUSBCFG1_bit.FRAC);
800080f8:	20010737          	lui	a4,0x20010
800080fc:	6785                	lui	a5,0x1
800080fe:	97ba                	add	a5,a5,a4
80008100:	8047a703          	lw	a4,-2044(a5) # 804 <STACK_SIZE+0x4>
80008104:	010007b7          	lui	a5,0x1000
80008108:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
8000810a:	8ff9                	and	a5,a5,a4
8000810c:	fef42223          	sw	a5,-28(s0)
    pll_fbdiv = READ_REG(USB->PLLUSBCFG2_bit.FBDIV);
80008110:	20010737          	lui	a4,0x20010
80008114:	6785                	lui	a5,0x1
80008116:	97ba                	add	a5,a5,a4
80008118:	8087a783          	lw	a5,-2040(a5) # 808 <STACK_SIZE+0x8>
8000811c:	873e                	mv	a4,a5
8000811e:	6785                	lui	a5,0x1
80008120:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80008122:	8ff9                	and	a5,a5,a4
80008124:	07c2                	slli	a5,a5,0x10
80008126:	83c1                	srli	a5,a5,0x10
80008128:	fef42023          	sw	a5,-32(s0)
    pll_refdiv = READ_REG(USB->PLLUSBCFG0_bit.REFDIV);
8000812c:	20010737          	lui	a4,0x20010
80008130:	6785                	lui	a5,0x1
80008132:	97ba                	add	a5,a5,a4
80008134:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
80008138:	839d                	srli	a5,a5,0x7
8000813a:	03f7f793          	andi	a5,a5,63
8000813e:	0ff7f793          	zext.b	a5,a5
80008142:	fcf42e23          	sw	a5,-36(s0)
    pll_refclk = HSECLK_VAL;
80008146:	00f427b7          	lui	a5,0xf42
8000814a:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
8000814e:	fcf42c23          	sw	a5,-40(s0)

    return (uint32_t)((pll_refclk * pll_fbdiv) / (pll_refdiv * pll_div0a * pll_div0b));
80008152:	fd842703          	lw	a4,-40(s0)
80008156:	fe042783          	lw	a5,-32(s0)
8000815a:	02f70733          	mul	a4,a4,a5
8000815e:	fdc42683          	lw	a3,-36(s0)
80008162:	fec42783          	lw	a5,-20(s0)
80008166:	02f686b3          	mul	a3,a3,a5
8000816a:	fe842783          	lw	a5,-24(s0)
8000816e:	02f687b3          	mul	a5,a3,a5
80008172:	02f757b3          	divu	a5,a4,a5
}
80008176:	853e                	mv	a0,a5
80008178:	5432                	lw	s0,44(sp)
8000817a:	6145                	addi	sp,sp,48
8000817c:	8082                	ret

8000817e <RCU_GetSysClkFreq>:
/**
  * @brief   Получение значения частоты SYSCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetSysClkFreq()
{
8000817e:	1101                	addi	sp,sp,-32
80008180:	ce06                	sw	ra,28(sp)
80008182:	cc22                	sw	s0,24(sp)
80008184:	1000                	addi	s0,sp,32
    RCU_SysClk_TypeDef sys_clk;

    sys_clk = RCU_SysClkStatus();
80008186:	34e1                	jal	80007c4e <RCU_SysClkStatus>
80008188:	fea42623          	sw	a0,-20(s0)

    return getSysClkFreq(sys_clk);
8000818c:	fec42503          	lw	a0,-20(s0)
80008190:	3e5d                	jal	80007d46 <getSysClkFreq>
80008192:	87aa                	mv	a5,a0
}
80008194:	853e                	mv	a0,a5
80008196:	40f2                	lw	ra,28(sp)
80008198:	4462                	lw	s0,24(sp)
8000819a:	6105                	addi	sp,sp,32
8000819c:	8082                	ret

8000819e <RCU_GetUARTClkFreq>:
  * @brief   Получение значения частоты UARTCLK
  * @param   UARTx_Num  Порядковый номер блока UART
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetUARTClkFreq(UART_Num_TypeDef UARTx_Num)
{
8000819e:	7179                	addi	sp,sp,-48
800081a0:	d606                	sw	ra,44(sp)
800081a2:	d422                	sw	s0,40(sp)
800081a4:	1800                	addi	s0,sp,48
800081a6:	fca42e23          	sw	a0,-36(s0)
    RCU_PeriphClk_TypeDef uart_clk;
    uint32_t div_val;

    uart_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.CLKSEL);
800081aa:	3000e737          	lui	a4,0x3000e
800081ae:	fdc42783          	lw	a5,-36(s0)
800081b2:	07f1                	addi	a5,a5,28
800081b4:	078a                	slli	a5,a5,0x2
800081b6:	97ba                	add	a5,a5,a4
800081b8:	439c                	lw	a5,0(a5)
800081ba:	83c1                	srli	a5,a5,0x10
800081bc:	8b8d                	andi	a5,a5,3
800081be:	0ff7f793          	zext.b	a5,a5
800081c2:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.DIVEN))
800081c6:	3000e737          	lui	a4,0x3000e
800081ca:	fdc42783          	lw	a5,-36(s0)
800081ce:	07f1                	addi	a5,a5,28
800081d0:	078a                	slli	a5,a5,0x2
800081d2:	97ba                	add	a5,a5,a4
800081d4:	439c                	lw	a5,0(a5)
800081d6:	83d1                	srli	a5,a5,0x14
800081d8:	8b85                	andi	a5,a5,1
800081da:	0ff7f793          	zext.b	a5,a5
800081de:	c39d                	beqz	a5,80008204 <RCU_GetUARTClkFreq+0x66>
        div_val = 2 * (READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.DIVN) + 1);
800081e0:	3000e737          	lui	a4,0x3000e
800081e4:	fdc42783          	lw	a5,-36(s0)
800081e8:	07f1                	addi	a5,a5,28
800081ea:	078a                	slli	a5,a5,0x2
800081ec:	97ba                	add	a5,a5,a4
800081ee:	439c                	lw	a5,0(a5)
800081f0:	83e1                	srli	a5,a5,0x18
800081f2:	03f7f793          	andi	a5,a5,63
800081f6:	0ff7f793          	zext.b	a5,a5
800081fa:	0785                	addi	a5,a5,1
800081fc:	0786                	slli	a5,a5,0x1
800081fe:	fef42623          	sw	a5,-20(s0)
80008202:	a021                	j	8000820a <RCU_GetUARTClkFreq+0x6c>
    else
        div_val = 1;
80008204:	4785                	li	a5,1
80008206:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(uart_clk) / div_val;
8000820a:	fe842503          	lw	a0,-24(s0)
8000820e:	3e45                	jal	80007dbe <getPeriphClkFreq>
80008210:	872a                	mv	a4,a0
80008212:	fec42783          	lw	a5,-20(s0)
80008216:	02f757b3          	divu	a5,a4,a5
}
8000821a:	853e                	mv	a0,a5
8000821c:	50b2                	lw	ra,44(sp)
8000821e:	5422                	lw	s0,40(sp)
80008220:	6145                	addi	sp,sp,48
80008222:	8082                	ret

80008224 <RCU_GetSPIClkFreq>:
  * @brief   Получение значения частоты SPICLK
  * @param   SPIx_Num  Порядковый номер блока SPI
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetSPIClkFreq(SPI_Num_TypeDef SPIx_Num)
{
80008224:	7179                	addi	sp,sp,-48
80008226:	d606                	sw	ra,44(sp)
80008228:	d422                	sw	s0,40(sp)
8000822a:	1800                	addi	s0,sp,48
8000822c:	fca42e23          	sw	a0,-36(s0)
    RCU_PeriphClk_TypeDef spi_clk;
    uint32_t div_val;

    spi_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.CLKSEL);
80008230:	3000e737          	lui	a4,0x3000e
80008234:	fdc42783          	lw	a5,-36(s0)
80008238:	02478793          	addi	a5,a5,36
8000823c:	078a                	slli	a5,a5,0x2
8000823e:	97ba                	add	a5,a5,a4
80008240:	43dc                	lw	a5,4(a5)
80008242:	83c1                	srli	a5,a5,0x10
80008244:	8b8d                	andi	a5,a5,3
80008246:	0ff7f793          	zext.b	a5,a5
8000824a:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.DIVEN))
8000824e:	3000e737          	lui	a4,0x3000e
80008252:	fdc42783          	lw	a5,-36(s0)
80008256:	02478793          	addi	a5,a5,36
8000825a:	078a                	slli	a5,a5,0x2
8000825c:	97ba                	add	a5,a5,a4
8000825e:	43dc                	lw	a5,4(a5)
80008260:	83d1                	srli	a5,a5,0x14
80008262:	8b85                	andi	a5,a5,1
80008264:	0ff7f793          	zext.b	a5,a5
80008268:	c785                	beqz	a5,80008290 <RCU_GetSPIClkFreq+0x6c>
        div_val = 2 * (READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.DIVN) + 1);
8000826a:	3000e737          	lui	a4,0x3000e
8000826e:	fdc42783          	lw	a5,-36(s0)
80008272:	02478793          	addi	a5,a5,36
80008276:	078a                	slli	a5,a5,0x2
80008278:	97ba                	add	a5,a5,a4
8000827a:	43dc                	lw	a5,4(a5)
8000827c:	83e1                	srli	a5,a5,0x18
8000827e:	03f7f793          	andi	a5,a5,63
80008282:	0ff7f793          	zext.b	a5,a5
80008286:	0785                	addi	a5,a5,1
80008288:	0786                	slli	a5,a5,0x1
8000828a:	fef42623          	sw	a5,-20(s0)
8000828e:	a021                	j	80008296 <RCU_GetSPIClkFreq+0x72>
    else
        div_val = 1;
80008290:	4785                	li	a5,1
80008292:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(spi_clk) / div_val;
80008296:	fe842503          	lw	a0,-24(s0)
8000829a:	3615                	jal	80007dbe <getPeriphClkFreq>
8000829c:	872a                	mv	a4,a0
8000829e:	fec42783          	lw	a5,-20(s0)
800082a2:	02f757b3          	divu	a5,a4,a5
}
800082a6:	853e                	mv	a0,a5
800082a8:	50b2                	lw	ra,44(sp)
800082aa:	5422                	lw	s0,40(sp)
800082ac:	6145                	addi	sp,sp,48
800082ae:	8082                	ret

800082b0 <RCU_GetADCSARClkFreq>:
/**
  * @brief   Получение значения частоты ADCSARCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetADCSARClkFreq()
{
800082b0:	1101                	addi	sp,sp,-32
800082b2:	ce06                	sw	ra,28(sp)
800082b4:	cc22                	sw	s0,24(sp)
800082b6:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef adc_clk;
    uint32_t div_val;

    adc_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->ADCSARCLKCFG_bit.CLKSEL);
800082b8:	3000e7b7          	lui	a5,0x3000e
800082bc:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
800082c0:	83c1                	srli	a5,a5,0x10
800082c2:	8b8d                	andi	a5,a5,3
800082c4:	0ff7f793          	zext.b	a5,a5
800082c8:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->ADCSARCLKCFG_bit.DIVEN))
800082cc:	3000e7b7          	lui	a5,0x3000e
800082d0:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
800082d4:	83d1                	srli	a5,a5,0x14
800082d6:	8b85                	andi	a5,a5,1
800082d8:	0ff7f793          	zext.b	a5,a5
800082dc:	cf99                	beqz	a5,800082fa <RCU_GetADCSARClkFreq+0x4a>
        div_val = 2 * (READ_REG(RCU->ADCSARCLKCFG_bit.DIVN) + 1);
800082de:	3000e7b7          	lui	a5,0x3000e
800082e2:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
800082e6:	83e1                	srli	a5,a5,0x18
800082e8:	03f7f793          	andi	a5,a5,63
800082ec:	0ff7f793          	zext.b	a5,a5
800082f0:	0785                	addi	a5,a5,1
800082f2:	0786                	slli	a5,a5,0x1
800082f4:	fef42623          	sw	a5,-20(s0)
800082f8:	a021                	j	80008300 <RCU_GetADCSARClkFreq+0x50>
    else
        div_val = 1;
800082fa:	4785                	li	a5,1
800082fc:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(adc_clk) / div_val;
80008300:	fe842503          	lw	a0,-24(s0)
80008304:	3c6d                	jal	80007dbe <getPeriphClkFreq>
80008306:	872a                	mv	a4,a0
80008308:	fec42783          	lw	a5,-20(s0)
8000830c:	02f757b3          	divu	a5,a4,a5
}
80008310:	853e                	mv	a0,a5
80008312:	40f2                	lw	ra,28(sp)
80008314:	4462                	lw	s0,24(sp)
80008316:	6105                	addi	sp,sp,32
80008318:	8082                	ret

8000831a <RCU_GetADCSDClkFreq>:
/**
  * @brief   Получение значения частоты ADCSDCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetADCSDClkFreq()
{
8000831a:	1101                	addi	sp,sp,-32
8000831c:	ce06                	sw	ra,28(sp)
8000831e:	cc22                	sw	s0,24(sp)
80008320:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef adc_clk;
    uint32_t div_val;

    adc_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->ADCSDCLKCFG_bit.CLKSEL);
80008322:	3000e7b7          	lui	a5,0x3000e
80008326:	0b47a783          	lw	a5,180(a5) # 3000e0b4 <STACK_SIZE+0x3000d8b4>
8000832a:	83c1                	srli	a5,a5,0x10
8000832c:	8b8d                	andi	a5,a5,3
8000832e:	0ff7f793          	zext.b	a5,a5
80008332:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->ADCSDCLKCFG_bit.DIVEN))
80008336:	3000e7b7          	lui	a5,0x3000e
8000833a:	0b47a783          	lw	a5,180(a5) # 3000e0b4 <STACK_SIZE+0x3000d8b4>
8000833e:	83d1                	srli	a5,a5,0x14
80008340:	8b85                	andi	a5,a5,1
80008342:	0ff7f793          	zext.b	a5,a5
80008346:	cf99                	beqz	a5,80008364 <RCU_GetADCSDClkFreq+0x4a>
        div_val = 2 * (READ_REG(RCU->ADCSDCLKCFG_bit.DIVN) + 1);
80008348:	3000e7b7          	lui	a5,0x3000e
8000834c:	0b47a783          	lw	a5,180(a5) # 3000e0b4 <STACK_SIZE+0x3000d8b4>
80008350:	83e1                	srli	a5,a5,0x18
80008352:	03f7f793          	andi	a5,a5,63
80008356:	0ff7f793          	zext.b	a5,a5
8000835a:	0785                	addi	a5,a5,1
8000835c:	0786                	slli	a5,a5,0x1
8000835e:	fef42623          	sw	a5,-20(s0)
80008362:	a021                	j	8000836a <RCU_GetADCSDClkFreq+0x50>
    else
        div_val = 1;
80008364:	4785                	li	a5,1
80008366:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(adc_clk) / div_val;
8000836a:	fe842503          	lw	a0,-24(s0)
8000836e:	3c81                	jal	80007dbe <getPeriphClkFreq>
80008370:	872a                	mv	a4,a0
80008372:	fec42783          	lw	a5,-20(s0)
80008376:	02f757b3          	divu	a5,a4,a5
}
8000837a:	853e                	mv	a0,a5
8000837c:	40f2                	lw	ra,28(sp)
8000837e:	4462                	lw	s0,24(sp)
80008380:	6105                	addi	sp,sp,32
80008382:	8082                	ret

80008384 <RCU_GetWDTClkFreq>:
/**
  * @brief   Получение значения частоты WDTCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetWDTClkFreq()
{
80008384:	1101                	addi	sp,sp,-32
80008386:	ce06                	sw	ra,28(sp)
80008388:	cc22                	sw	s0,24(sp)
8000838a:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef wdt_clk;
    uint32_t div_val;

    wdt_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->WDOGCLKCFG_bit.CLKSEL);
8000838c:	3000e7b7          	lui	a5,0x3000e
80008390:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
80008394:	83c1                	srli	a5,a5,0x10
80008396:	8b8d                	andi	a5,a5,3
80008398:	0ff7f793          	zext.b	a5,a5
8000839c:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->WDOGCLKCFG_bit.DIVEN))
800083a0:	3000e7b7          	lui	a5,0x3000e
800083a4:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
800083a8:	83d1                	srli	a5,a5,0x14
800083aa:	8b85                	andi	a5,a5,1
800083ac:	0ff7f793          	zext.b	a5,a5
800083b0:	cf99                	beqz	a5,800083ce <RCU_GetWDTClkFreq+0x4a>
        div_val = 2 * (READ_REG(RCU->WDOGCLKCFG_bit.DIVN) + 1);
800083b2:	3000e7b7          	lui	a5,0x3000e
800083b6:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
800083ba:	83e1                	srli	a5,a5,0x18
800083bc:	03f7f793          	andi	a5,a5,63
800083c0:	0ff7f793          	zext.b	a5,a5
800083c4:	0785                	addi	a5,a5,1
800083c6:	0786                	slli	a5,a5,0x1
800083c8:	fef42623          	sw	a5,-20(s0)
800083cc:	a021                	j	800083d4 <RCU_GetWDTClkFreq+0x50>
    else
        div_val = 1;
800083ce:	4785                	li	a5,1
800083d0:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(wdt_clk) / div_val;
800083d4:	fe842503          	lw	a0,-24(s0)
800083d8:	32dd                	jal	80007dbe <getPeriphClkFreq>
800083da:	872a                	mv	a4,a0
800083dc:	fec42783          	lw	a5,-20(s0)
800083e0:	02f757b3          	divu	a5,a4,a5
}
800083e4:	853e                	mv	a0,a5
800083e6:	40f2                	lw	ra,28(sp)
800083e8:	4462                	lw	s0,24(sp)
800083ea:	6105                	addi	sp,sp,32
800083ec:	8082                	ret

800083ee <RCU_GetIWDTClkFreq>:
/**
  * @brief   Получение значения частоты IWDTCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetIWDTClkFreq()
{
800083ee:	1101                	addi	sp,sp,-32
800083f0:	ce06                	sw	ra,28(sp)
800083f2:	cc22                	sw	s0,24(sp)
800083f4:	1000                	addi	s0,sp,32
    RCU_IWDTClk_TypeDef iwdt_clk;

    iwdt_clk = (RCU_IWDTClk_TypeDef)READ_REG(PMURTC->IWDG_CFG_bit.CLKSRC);
800083f6:	380117b7          	lui	a5,0x38011
800083fa:	0ac7a783          	lw	a5,172(a5) # 380110ac <STACK_SIZE+0x380108ac>
800083fe:	8b8d                	andi	a5,a5,3
80008400:	0ff7f793          	zext.b	a5,a5
80008404:	fef42623          	sw	a5,-20(s0)

    return getIwdtClkFreq(iwdt_clk);
80008408:	fec42503          	lw	a0,-20(s0)
8000840c:	342d                	jal	80007e36 <getIwdtClkFreq>
8000840e:	87aa                	mv	a5,a0
}
80008410:	853e                	mv	a0,a5
80008412:	40f2                	lw	ra,28(sp)
80008414:	4462                	lw	s0,24(sp)
80008416:	6105                	addi	sp,sp,32
80008418:	8082                	ret

8000841a <RCU_GetClkOutFreq>:
/**
  * @brief   Получение значения частоты CLKOUT
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetClkOutFreq()
{
8000841a:	1101                	addi	sp,sp,-32
8000841c:	ce06                	sw	ra,28(sp)
8000841e:	cc22                	sw	s0,24(sp)
80008420:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef clkout;
    uint32_t div_val;

    clkout = (RCU_SysClk_TypeDef)READ_REG(RCU->CLKOUTCFG_bit.CLKSEL);
80008422:	3000e7b7          	lui	a5,0x3000e
80008426:	0bc7a783          	lw	a5,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
8000842a:	8391                	srli	a5,a5,0x4
8000842c:	8b8d                	andi	a5,a5,3
8000842e:	0ff7f793          	zext.b	a5,a5
80008432:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->CLKOUTCFG_bit.DIVEN))
80008436:	3000e7b7          	lui	a5,0x3000e
8000843a:	0bc7a783          	lw	a5,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
8000843e:	83b1                	srli	a5,a5,0xc
80008440:	8b85                	andi	a5,a5,1
80008442:	0ff7f793          	zext.b	a5,a5
80008446:	cf81                	beqz	a5,8000845e <RCU_GetClkOutFreq+0x44>
        div_val = 2 * (READ_REG(RCU->CLKOUTCFG_bit.DIVN) + 1);
80008448:	3000e7b7          	lui	a5,0x3000e
8000844c:	0be7d783          	lhu	a5,190(a5) # 3000e0be <STACK_SIZE+0x3000d8be>
80008450:	07c2                	slli	a5,a5,0x10
80008452:	83c1                	srli	a5,a5,0x10
80008454:	0785                	addi	a5,a5,1
80008456:	0786                	slli	a5,a5,0x1
80008458:	fef42623          	sw	a5,-20(s0)
8000845c:	a021                	j	80008464 <RCU_GetClkOutFreq+0x4a>
    else
        div_val = 1;
8000845e:	4785                	li	a5,1
80008460:	fef42623          	sw	a5,-20(s0)

    return getSysClkFreq(clkout) / div_val;
80008464:	fe842503          	lw	a0,-24(s0)
80008468:	38f9                	jal	80007d46 <getSysClkFreq>
8000846a:	872a                	mv	a4,a0
8000846c:	fec42783          	lw	a5,-20(s0)
80008470:	02f757b3          	divu	a5,a4,a5
}
80008474:	853e                	mv	a0,a5
80008476:	40f2                	lw	ra,28(sp)
80008478:	4462                	lw	s0,24(sp)
8000847a:	6105                	addi	sp,sp,32
8000847c:	8082                	ret

8000847e <RCU_SYSPLL0_Init>:
  * @param      InitStruct  Указатель на структуру типа @ref RCU_PLL_Init_TypeDef,
  *                         которая содержит конфигурационную информацию
  * @retval     Status
  */
OperationStatus RCU_SYSPLL0_Init(RCU_PLL_Init_TypeDef* InitStruct)
{
8000847e:	7179                	addi	sp,sp,-48
80008480:	d606                	sw	ra,44(sp)
80008482:	d422                	sw	s0,40(sp)
80008484:	1800                	addi	s0,sp,48
80008486:	fca42e23          	sw	a0,-36(s0)
    uint32_t timeout = RCU_PLLCLK_LOCK_TIMEOUT;
8000848a:	6789                	lui	a5,0x2
8000848c:	71078793          	addi	a5,a5,1808 # 2710 <STACK_SIZE+0x1f10>
80008490:	fef42623          	sw	a5,-20(s0)
    OperationStatus status = OK;
80008494:	fe042423          	sw	zero,-24(s0)
    assert_param(IS_RCU_PLL_DIV0A(InitStruct->Div0A));
    assert_param(IS_RCU_PLL_DIV0B(InitStruct->Div0B));
    assert_param(IS_RCU_PLL_DIV1A(InitStruct->Div1A));
    assert_param(IS_RCU_PLL_DIV1B(InitStruct->Div1B));

    CLEAR_BIT(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_BYP_Msk | RCU_PLLSYSCFG0_PLLEN_Msk);
80008498:	3000e7b7          	lui	a5,0x3000e
8000849c:	4bb8                	lw	a4,80(a5)
8000849e:	3000e7b7          	lui	a5,0x3000e
800084a2:	9b61                	andi	a4,a4,-8
800084a4:	cbb8                	sw	a4,80(a5)
    MODIFY_REG(RCU->PLLSYSCFG0, (RCU_PLLSYSCFG0_REFDIV_Msk | RCU_PLLSYSCFG0_PD0A_Msk | RCU_PLLSYSCFG0_PD0B_Msk),
800084a6:	3000e7b7          	lui	a5,0x3000e
800084aa:	4bb8                	lw	a4,80(a5)
800084ac:	ffc007b7          	lui	a5,0xffc00
800084b0:	07f78793          	addi	a5,a5,127 # ffc0007f <__data_source_start+0x7fbf665b>
800084b4:	00f776b3          	and	a3,a4,a5
800084b8:	fdc42783          	lw	a5,-36(s0)
800084bc:	43dc                	lw	a5,4(a5)
800084be:	00779713          	slli	a4,a5,0x7
800084c2:	fdc42783          	lw	a5,-36(s0)
800084c6:	4b9c                	lw	a5,16(a5)
800084c8:	07b6                	slli	a5,a5,0xd
800084ca:	8f5d                	or	a4,a4,a5
800084cc:	fdc42783          	lw	a5,-36(s0)
800084d0:	4bdc                	lw	a5,20(a5)
800084d2:	07c2                	slli	a5,a5,0x10
800084d4:	8f5d                	or	a4,a4,a5
800084d6:	3000e7b7          	lui	a5,0x3000e
800084da:	8f55                	or	a4,a4,a3
800084dc:	cbb8                	sw	a4,80(a5)
               (InitStruct->RefDiv << RCU_PLLSYSCFG0_REFDIV_Pos |
                InitStruct->Div0A << RCU_PLLSYSCFG0_PD0A_Pos |
                InitStruct->Div0B << RCU_PLLSYSCFG0_PD0B_Pos));
    MODIFY_REG(RCU->PLLSYSCFG2, (RCU_PLLSYSCFG2_FBDIV_Msk),
800084de:	3000e7b7          	lui	a5,0x3000e
800084e2:	4fb8                	lw	a4,88(a5)
800084e4:	77fd                	lui	a5,0xfffff
800084e6:	00f776b3          	and	a3,a4,a5
800084ea:	fdc42783          	lw	a5,-36(s0)
800084ee:	4798                	lw	a4,8(a5)
800084f0:	3000e7b7          	lui	a5,0x3000e
800084f4:	8f55                	or	a4,a4,a3
800084f6:	cfb8                	sw	a4,88(a5)
               (InitStruct->FbDiv << RCU_PLLSYSCFG2_FBDIV_Pos));

    RCU_SYSPLL0_OutCmd(ENABLE);
800084f8:	4505                	li	a0,1
800084fa:	f6eff0ef          	jal	ra,80007c68 <RCU_SYSPLL0_OutCmd>
    while (timeout) {
800084fe:	a811                	j	80008512 <RCU_SYSPLL0_Init+0x94>
        if (RCU_SYSPLL_LockStatus()) {
80008500:	fdaff0ef          	jal	ra,80007cda <RCU_SYSPLL_LockStatus>
80008504:	87aa                	mv	a5,a0
80008506:	eb91                	bnez	a5,8000851a <RCU_SYSPLL0_Init+0x9c>
            break;
        } else {
            timeout--;
80008508:	fec42783          	lw	a5,-20(s0)
8000850c:	17fd                	addi	a5,a5,-1 # 3000dfff <STACK_SIZE+0x3000d7ff>
8000850e:	fef42623          	sw	a5,-20(s0)
    while (timeout) {
80008512:	fec42783          	lw	a5,-20(s0)
80008516:	f7ed                	bnez	a5,80008500 <RCU_SYSPLL0_Init+0x82>
80008518:	a011                	j	8000851c <RCU_SYSPLL0_Init+0x9e>
            break;
8000851a:	0001                	nop
        }
    }
    if (!timeout) {
8000851c:	fec42783          	lw	a5,-20(s0)
80008520:	e781                	bnez	a5,80008528 <RCU_SYSPLL0_Init+0xaa>
        status = ERROR;
80008522:	4785                	li	a5,1
80008524:	fef42423          	sw	a5,-24(s0)
    }

    return status;
80008528:	fe842783          	lw	a5,-24(s0)
}
8000852c:	853e                	mv	a0,a5
8000852e:	50b2                	lw	ra,44(sp)
80008530:	5422                	lw	s0,40(sp)
80008532:	6145                	addi	sp,sp,48
80008534:	8082                	ret

80008536 <RCU_USBPLL_Init>:
  * @param      InitStruct  Указатель на структуру типа @ref RCU_PLL_Init_TypeDef,
  *                         которая содержит конфигурационную информацию
  * @retval     Status
  */
OperationStatus RCU_USBPLL_Init(RCU_PLL_Init_TypeDef* InitStruct)
{
80008536:	7179                	addi	sp,sp,-48
80008538:	d606                	sw	ra,44(sp)
8000853a:	d422                	sw	s0,40(sp)
8000853c:	1800                	addi	s0,sp,48
8000853e:	fca42e23          	sw	a0,-36(s0)
    uint32_t timeout = RCU_PLLCLK_LOCK_TIMEOUT;
80008542:	6789                	lui	a5,0x2
80008544:	71078793          	addi	a5,a5,1808 # 2710 <STACK_SIZE+0x1f10>
80008548:	fef42623          	sw	a5,-20(s0)
    OperationStatus status = OK;
8000854c:	fe042423          	sw	zero,-24(s0)
    assert_param(IS_RCU_PLL_DIV0A(InitStruct->Div0A));
    assert_param(IS_RCU_PLL_DIV0B(InitStruct->Div0B));
    assert_param(IS_RCU_PLL_DIV1A(InitStruct->Div1A));
    assert_param(IS_RCU_PLL_DIV1B(InitStruct->Div1B));

    CLEAR_BIT(USB->PLLUSBCFG0, USB_PLLUSBCFG0_BYP_Msk | USB_PLLUSBCFG0_PLLEN_Msk);
80008550:	20010737          	lui	a4,0x20010
80008554:	6785                	lui	a5,0x1
80008556:	97ba                	add	a5,a5,a4
80008558:	8007a783          	lw	a5,-2048(a5) # 800 <STACK_SIZE>
8000855c:	200106b7          	lui	a3,0x20010
80008560:	ff87f713          	andi	a4,a5,-8
80008564:	6785                	lui	a5,0x1
80008566:	97b6                	add	a5,a5,a3
80008568:	80e7a023          	sw	a4,-2048(a5) # 800 <STACK_SIZE>
    MODIFY_REG(USB->PLLUSBCFG0, (USB_PLLUSBCFG0_REFDIV_Msk | USB_PLLUSBCFG0_PD0A_Msk | USB_PLLUSBCFG0_PD0B_Msk),
8000856c:	20010737          	lui	a4,0x20010
80008570:	6785                	lui	a5,0x1
80008572:	97ba                	add	a5,a5,a4
80008574:	8007a703          	lw	a4,-2048(a5) # 800 <STACK_SIZE>
80008578:	ffc007b7          	lui	a5,0xffc00
8000857c:	07f78793          	addi	a5,a5,127 # ffc0007f <__data_source_start+0x7fbf665b>
80008580:	8f7d                	and	a4,a4,a5
80008582:	fdc42783          	lw	a5,-36(s0)
80008586:	43dc                	lw	a5,4(a5)
80008588:	00779693          	slli	a3,a5,0x7
8000858c:	fdc42783          	lw	a5,-36(s0)
80008590:	4b9c                	lw	a5,16(a5)
80008592:	07b6                	slli	a5,a5,0xd
80008594:	8edd                	or	a3,a3,a5
80008596:	fdc42783          	lw	a5,-36(s0)
8000859a:	4bdc                	lw	a5,20(a5)
8000859c:	07c2                	slli	a5,a5,0x10
8000859e:	8fd5                	or	a5,a5,a3
800085a0:	200106b7          	lui	a3,0x20010
800085a4:	8f5d                	or	a4,a4,a5
800085a6:	6785                	lui	a5,0x1
800085a8:	97b6                	add	a5,a5,a3
800085aa:	80e7a023          	sw	a4,-2048(a5) # 800 <STACK_SIZE>
               (InitStruct->RefDiv << USB_PLLUSBCFG0_REFDIV_Pos |
                InitStruct->Div0A << USB_PLLUSBCFG0_PD0A_Pos |
                InitStruct->Div0B << USB_PLLUSBCFG0_PD0B_Pos));
    MODIFY_REG(USB->PLLUSBCFG2, (USB_PLLUSBCFG2_FBDIV_Msk),
800085ae:	20010737          	lui	a4,0x20010
800085b2:	6785                	lui	a5,0x1
800085b4:	97ba                	add	a5,a5,a4
800085b6:	8087a703          	lw	a4,-2040(a5) # 808 <STACK_SIZE+0x8>
800085ba:	77fd                	lui	a5,0xfffff
800085bc:	8f7d                	and	a4,a4,a5
800085be:	fdc42783          	lw	a5,-36(s0)
800085c2:	479c                	lw	a5,8(a5)
800085c4:	200106b7          	lui	a3,0x20010
800085c8:	8f5d                	or	a4,a4,a5
800085ca:	6785                	lui	a5,0x1
800085cc:	97b6                	add	a5,a5,a3
800085ce:	80e7a423          	sw	a4,-2040(a5) # 808 <STACK_SIZE+0x8>
               (InitStruct->FbDiv << USB_PLLUSBCFG2_FBDIV_Pos));

    RCU_SYSPLL0_OutCmd(ENABLE);
800085d2:	4505                	li	a0,1
800085d4:	e94ff0ef          	jal	ra,80007c68 <RCU_SYSPLL0_OutCmd>
    while (timeout) {
800085d8:	a811                	j	800085ec <RCU_USBPLL_Init+0xb6>
        if (RCU_SYSPLL_LockStatus()) {
800085da:	f00ff0ef          	jal	ra,80007cda <RCU_SYSPLL_LockStatus>
800085de:	87aa                	mv	a5,a0
800085e0:	eb91                	bnez	a5,800085f4 <RCU_USBPLL_Init+0xbe>
            break;
        } else {
            timeout--;
800085e2:	fec42783          	lw	a5,-20(s0)
800085e6:	17fd                	addi	a5,a5,-1
800085e8:	fef42623          	sw	a5,-20(s0)
    while (timeout) {
800085ec:	fec42783          	lw	a5,-20(s0)
800085f0:	f7ed                	bnez	a5,800085da <RCU_USBPLL_Init+0xa4>
800085f2:	a011                	j	800085f6 <RCU_USBPLL_Init+0xc0>
            break;
800085f4:	0001                	nop
        }
    }
    if (!timeout) {
800085f6:	fec42783          	lw	a5,-20(s0)
800085fa:	e781                	bnez	a5,80008602 <RCU_USBPLL_Init+0xcc>
        status = ERROR;
800085fc:	4785                	li	a5,1
800085fe:	fef42423          	sw	a5,-24(s0)
    }

    return status;
80008602:	fe842783          	lw	a5,-24(s0)
}
80008606:	853e                	mv	a0,a5
80008608:	50b2                	lw	ra,44(sp)
8000860a:	5422                	lw	s0,40(sp)
8000860c:	6145                	addi	sp,sp,48
8000860e:	8082                	ret

80008610 <RCU_PLL_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref RCU_PLL_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void RCU_PLL_StructInit(RCU_PLL_Init_TypeDef* InitStruct)
{
80008610:	1101                	addi	sp,sp,-32
80008612:	ce22                	sw	s0,28(sp)
80008614:	1000                	addi	s0,sp,32
80008616:	fea42623          	sw	a0,-20(s0)
    InitStruct->FbDiv = 16;
8000861a:	fec42783          	lw	a5,-20(s0)
8000861e:	4741                	li	a4,16
80008620:	c798                	sw	a4,8(a5)
    InitStruct->RefDiv = 1;
80008622:	fec42783          	lw	a5,-20(s0)
80008626:	4705                	li	a4,1
80008628:	c3d8                	sw	a4,4(a5)
    InitStruct->Div0A = 1;
8000862a:	fec42783          	lw	a5,-20(s0)
8000862e:	4705                	li	a4,1
80008630:	cb98                	sw	a4,16(a5)
    InitStruct->Div0B = 1;
80008632:	fec42783          	lw	a5,-20(s0)
80008636:	4705                	li	a4,1
80008638:	cbd8                	sw	a4,20(a5)
    InitStruct->Div1A = 1;
8000863a:	fec42783          	lw	a5,-20(s0)
8000863e:	4705                	li	a4,1
80008640:	cf98                	sw	a4,24(a5)
    InitStruct->Div1B = 1;
80008642:	fec42783          	lw	a5,-20(s0)
80008646:	4705                	li	a4,1
80008648:	cfd8                	sw	a4,28(a5)
}
8000864a:	0001                	nop
8000864c:	4472                	lw	s0,28(sp)
8000864e:	6105                	addi	sp,sp,32
80008650:	8082                	ret

80008652 <RCU_SYSPLL_DeInit>:
/**
  * @brief   Устанавливает все регистры SYSPLL значениями по умолчанию
  * @retval  void
  */
void RCU_SYSPLL_DeInit()
{
80008652:	1141                	addi	sp,sp,-16
80008654:	c606                	sw	ra,12(sp)
80008656:	c422                	sw	s0,8(sp)
80008658:	0800                	addi	s0,sp,16
    RCU_SYSPLL_Cmd(DISABLE);
8000865a:	4501                	li	a0,0
8000865c:	e46ff0ef          	jal	ra,80007ca2 <RCU_SYSPLL_Cmd>
    WRITE_REG(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_RST_VAL);
80008660:	3000e7b7          	lui	a5,0x3000e
80008664:	0407a823          	sw	zero,80(a5) # 3000e050 <STACK_SIZE+0x3000d850>
}
80008668:	0001                	nop
8000866a:	40b2                	lw	ra,12(sp)
8000866c:	4422                	lw	s0,8(sp)
8000866e:	0141                	addi	sp,sp,16
80008670:	8082                	ret

80008672 <RCU_USBPLL_DeInit>:
/**
  * @brief   Устанавливает все регистры USBPLL значениями по умолчанию
  * @retval  void
  */
void RCU_USBPLL_DeInit()
{
80008672:	1141                	addi	sp,sp,-16
80008674:	c606                	sw	ra,12(sp)
80008676:	c422                	sw	s0,8(sp)
80008678:	0800                	addi	s0,sp,16
    RCU_USBPLL_OutCmd(DISABLE);
8000867a:	4501                	li	a0,0
8000867c:	e74ff0ef          	jal	ra,80007cf0 <RCU_USBPLL_OutCmd>
    WRITE_REG(USB->PLLUSBCFG0, RCU_PLLSYSCFG0_RST_VAL);
80008680:	20010737          	lui	a4,0x20010
80008684:	6785                	lui	a5,0x1
80008686:	97ba                	add	a5,a5,a4
80008688:	8007a023          	sw	zero,-2048(a5) # 800 <STACK_SIZE>
}
8000868c:	0001                	nop
8000868e:	40b2                	lw	ra,12(sp)
80008690:	4422                	lw	s0,8(sp)
80008692:	0141                	addi	sp,sp,16
80008694:	8082                	ret

80008696 <RCU_SysClkChangeCmd>:
  * @brief   Переключение источника для системного тактового сигнала
  * @param   SysClk  Выбор источника
  * @retval  void
  */
OperationStatus RCU_SysClkChangeCmd(RCU_SysClk_TypeDef SysClk)
{
80008696:	7179                	addi	sp,sp,-48
80008698:	d606                	sw	ra,44(sp)
8000869a:	d422                	sw	s0,40(sp)
8000869c:	1800                	addi	s0,sp,48
8000869e:	fca42e23          	sw	a0,-36(s0)
    uint32_t timeout = RCU_SYSCLK_CHANGE_TIMEOUT;
800086a2:	6789                	lui	a5,0x2
800086a4:	71078793          	addi	a5,a5,1808 # 2710 <STACK_SIZE+0x1f10>
800086a8:	fef42623          	sw	a5,-20(s0)
    OperationStatus status = OK;
800086ac:	fe042423          	sw	zero,-24(s0)

    assert_param(IS_RCU_SYS_CLK(SysClk));

    RCU_SysClkConfig(SysClk);
800086b0:	fdc42503          	lw	a0,-36(s0)
800086b4:	d70ff0ef          	jal	ra,80007c24 <RCU_SysClkConfig>

    while (timeout) {
800086b8:	a829                	j	800086d2 <RCU_SysClkChangeCmd+0x3c>
        if ((RCU_SysClkStatus() != SysClk)) {
800086ba:	d94ff0ef          	jal	ra,80007c4e <RCU_SysClkStatus>
800086be:	872a                	mv	a4,a0
800086c0:	fdc42783          	lw	a5,-36(s0)
800086c4:	00e78b63          	beq	a5,a4,800086da <RCU_SysClkChangeCmd+0x44>
            timeout--;
800086c8:	fec42783          	lw	a5,-20(s0)
800086cc:	17fd                	addi	a5,a5,-1
800086ce:	fef42623          	sw	a5,-20(s0)
    while (timeout) {
800086d2:	fec42783          	lw	a5,-20(s0)
800086d6:	f3f5                	bnez	a5,800086ba <RCU_SysClkChangeCmd+0x24>
800086d8:	a011                	j	800086dc <RCU_SysClkChangeCmd+0x46>
        } else {
            break;
800086da:	0001                	nop
        }
    }

    if (!timeout) {
800086dc:	fec42783          	lw	a5,-20(s0)
800086e0:	e781                	bnez	a5,800086e8 <RCU_SysClkChangeCmd+0x52>
        status = ERROR;
800086e2:	4785                	li	a5,1
800086e4:	fef42423          	sw	a5,-24(s0)
    }

    return status;
800086e8:	fe842783          	lw	a5,-24(s0)
}
800086ec:	853e                	mv	a0,a5
800086ee:	50b2                	lw	ra,44(sp)
800086f0:	5422                	lw	s0,40(sp)
800086f2:	6145                	addi	sp,sp,48
800086f4:	8082                	ret

800086f6 <RCU_SPIRstCmd>:
{
800086f6:	1101                	addi	sp,sp,-32
800086f8:	ce22                	sw	s0,28(sp)
800086fa:	1000                	addi	s0,sp,32
800086fc:	fea42623          	sw	a0,-20(s0)
80008700:	feb42423          	sw	a1,-24(s0)
    WRITE_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.RSTDIS, State);
80008704:	3000e6b7          	lui	a3,0x3000e
80008708:	fe842783          	lw	a5,-24(s0)
8000870c:	8b85                	andi	a5,a5,1
8000870e:	0ff7f713          	zext.b	a4,a5
80008712:	fec42783          	lw	a5,-20(s0)
80008716:	02478793          	addi	a5,a5,36
8000871a:	078a                	slli	a5,a5,0x2
8000871c:	97b6                	add	a5,a5,a3
8000871e:	8b05                	andi	a4,a4,1
80008720:	0722                	slli	a4,a4,0x8
80008722:	43d4                	lw	a3,4(a5)
80008724:	eff6f693          	andi	a3,a3,-257
80008728:	8f55                	or	a4,a4,a3
8000872a:	c3d8                	sw	a4,4(a5)
}
8000872c:	0001                	nop
8000872e:	4472                	lw	s0,28(sp)
80008730:	6105                	addi	sp,sp,32
80008732:	8082                	ret

80008734 <SPI_DataWidthConfig>:
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @param   DataWidth  Значение разрядности слова
  * @retval  void
  */
__STATIC_INLINE void SPI_DataWidthConfig(SPI_TypeDef* SPIx, SPI_DataWidth_TypeDef DataWidth)
{
80008734:	1101                	addi	sp,sp,-32
80008736:	ce22                	sw	s0,28(sp)
80008738:	1000                	addi	s0,sp,32
8000873a:	fea42623          	sw	a0,-20(s0)
8000873e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_DATA_WIDTH(DataWidth));

    WRITE_REG(SPIx->CR0_bit.DSS, DataWidth);
80008742:	fe842783          	lw	a5,-24(s0)
80008746:	8bbd                	andi	a5,a5,15
80008748:	0ff7f713          	zext.b	a4,a5
8000874c:	fec42783          	lw	a5,-20(s0)
80008750:	8b3d                	andi	a4,a4,15
80008752:	0007d683          	lhu	a3,0(a5)
80008756:	9ac1                	andi	a3,a3,-16
80008758:	8f55                	or	a4,a4,a3
8000875a:	00e79023          	sh	a4,0(a5)
}
8000875e:	0001                	nop
80008760:	4472                	lw	s0,28(sp)
80008762:	6105                	addi	sp,sp,32
80008764:	8082                	ret

80008766 <SPI_ModeConfig>:
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @param   Mode  Выбор режима
  * @retval  void
  */
__STATIC_INLINE void SPI_ModeConfig(SPI_TypeDef* SPIx, SPI_Mode_TypeDef Mode)
{
80008766:	1101                	addi	sp,sp,-32
80008768:	ce22                	sw	s0,28(sp)
8000876a:	1000                	addi	s0,sp,32
8000876c:	fea42623          	sw	a0,-20(s0)
80008770:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_MODE(Mode));

    WRITE_REG(SPIx->CR1_bit.MS, Mode);
80008774:	fe842783          	lw	a5,-24(s0)
80008778:	8b85                	andi	a5,a5,1
8000877a:	0ff7f713          	zext.b	a4,a5
8000877e:	fec42783          	lw	a5,-20(s0)
80008782:	8b05                	andi	a4,a4,1
80008784:	070a                	slli	a4,a4,0x2
80008786:	0047d683          	lhu	a3,4(a5)
8000878a:	9aed                	andi	a3,a3,-5
8000878c:	8f55                	or	a4,a4,a3
8000878e:	00e79223          	sh	a4,4(a5)
}
80008792:	0001                	nop
80008794:	4472                	lw	s0,28(sp)
80008796:	6105                	addi	sp,sp,32
80008798:	8082                	ret

8000879a <SPI_FrameFormatConfig>:
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @param   FrameFormat  Выбор формата
  * @retval  void
  */
__STATIC_INLINE void SPI_FrameFormatConfig(SPI_TypeDef* SPIx, SPI_FrameFormat_TypeDef FrameFormat)
{
8000879a:	1101                	addi	sp,sp,-32
8000879c:	ce22                	sw	s0,28(sp)
8000879e:	1000                	addi	s0,sp,32
800087a0:	fea42623          	sw	a0,-20(s0)
800087a4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_FRAME_FORMAT(FrameFormat));

    WRITE_REG(SPIx->CR0_bit.FRF, FrameFormat);
800087a8:	fe842783          	lw	a5,-24(s0)
800087ac:	8b8d                	andi	a5,a5,3
800087ae:	0ff7f713          	zext.b	a4,a5
800087b2:	fec42783          	lw	a5,-20(s0)
800087b6:	8b0d                	andi	a4,a4,3
800087b8:	0712                	slli	a4,a4,0x4
800087ba:	0007d683          	lhu	a3,0(a5)
800087be:	fcf6f693          	andi	a3,a3,-49
800087c2:	8f55                	or	a4,a4,a3
800087c4:	00e79023          	sh	a4,0(a5)
}
800087c8:	0001                	nop
800087ca:	4472                	lw	s0,28(sp)
800087cc:	6105                	addi	sp,sp,32
800087ce:	8082                	ret

800087d0 <SPI_SCKDivConfig>:
                          Параметр может принимать любые четные значения из диапазона: 2-254.

  * @retval  void
  */
__STATIC_INLINE void SPI_SCKDivConfig(SPI_TypeDef* SPIx, uint32_t SCKDiv, uint32_t SCKDivExtra)
{
800087d0:	1101                	addi	sp,sp,-32
800087d2:	ce22                	sw	s0,28(sp)
800087d4:	1000                	addi	s0,sp,32
800087d6:	fea42623          	sw	a0,-20(s0)
800087da:	feb42423          	sw	a1,-24(s0)
800087de:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_SCK_DIV(SCKDiv));
    assert_param(IS_SPI_SCK_DIV_EXTRA(SCKDivExtra));

    WRITE_REG(SPIx->CR0_bit.SCR, SCKDiv);
800087e2:	fe842783          	lw	a5,-24(s0)
800087e6:	0ff7f713          	zext.b	a4,a5
800087ea:	fec42783          	lw	a5,-20(s0)
800087ee:	00e780a3          	sb	a4,1(a5)
    WRITE_REG(SPIx->CPSR, SCKDivExtra);
800087f2:	fec42783          	lw	a5,-20(s0)
800087f6:	fe442703          	lw	a4,-28(s0)
800087fa:	cb98                	sw	a4,16(a5)
}
800087fc:	0001                	nop
800087fe:	4472                	lw	s0,28(sp)
80008800:	6105                	addi	sp,sp,32
80008802:	8082                	ret

80008804 <SPI_DeInit>:
  * @brief   Устанавливает все регистры SPI значениями по умолчанию
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @retval  void
  */
void SPI_DeInit(SPI_TypeDef* SPIx)
{
80008804:	7179                	addi	sp,sp,-48
80008806:	d606                	sw	ra,44(sp)
80008808:	d422                	sw	s0,40(sp)
8000880a:	1800                	addi	s0,sp,48
8000880c:	fca42e23          	sw	a0,-36(s0)
    SPI_Num_TypeDef SPIx_Num;
    assert_param(IS_SPI_PERIPH(SPIx));

    if (SPIx == SPI0) {
80008810:	fdc42703          	lw	a4,-36(s0)
80008814:	200507b7          	lui	a5,0x20050
80008818:	00f71563          	bne	a4,a5,80008822 <SPI_DeInit+0x1e>
        SPIx_Num = SPI0_Num;
8000881c:	fe042623          	sw	zero,-20(s0)
80008820:	a811                	j	80008834 <SPI_DeInit+0x30>
    } else if (SPIx == SPI1) {
80008822:	fdc42703          	lw	a4,-36(s0)
80008826:	200607b7          	lui	a5,0x20060
8000882a:	00f71563          	bne	a4,a5,80008834 <SPI_DeInit+0x30>
        SPIx_Num = SPI1_Num;
8000882e:	4785                	li	a5,1
80008830:	fef42623          	sw	a5,-20(s0)
    }

    RCU_SPIRstCmd(SPIx_Num, DISABLE);
80008834:	4581                	li	a1,0
80008836:	fec42503          	lw	a0,-20(s0)
8000883a:	3d75                	jal	800086f6 <RCU_SPIRstCmd>
    RCU_SPIRstCmd(SPIx_Num, ENABLE);
8000883c:	4585                	li	a1,1
8000883e:	fec42503          	lw	a0,-20(s0)
80008842:	3d55                	jal	800086f6 <RCU_SPIRstCmd>
}
80008844:	0001                	nop
80008846:	50b2                	lw	ra,44(sp)
80008848:	5422                	lw	s0,40(sp)
8000884a:	6145                	addi	sp,sp,48
8000884c:	8082                	ret

8000884e <SPI_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref SPI_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_Init_TypeDef* InitStruct)
{
8000884e:	1101                	addi	sp,sp,-32
80008850:	ce06                	sw	ra,28(sp)
80008852:	cc22                	sw	s0,24(sp)
80008854:	1000                	addi	s0,sp,32
80008856:	fea42623          	sw	a0,-20(s0)
8000885a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));

    SPI_SCKDivConfig(SPIx, InitStruct->SCKDiv, InitStruct->SCKDivExtra);
8000885e:	fe842783          	lw	a5,-24(s0)
80008862:	47d8                	lw	a4,12(a5)
80008864:	fe842783          	lw	a5,-24(s0)
80008868:	4b9c                	lw	a5,16(a5)
8000886a:	863e                	mv	a2,a5
8000886c:	85ba                	mv	a1,a4
8000886e:	fec42503          	lw	a0,-20(s0)
80008872:	3fb9                	jal	800087d0 <SPI_SCKDivConfig>
    SPI_DataWidthConfig(SPIx, InitStruct->DataWidth);
80008874:	fe842783          	lw	a5,-24(s0)
80008878:	479c                	lw	a5,8(a5)
8000887a:	85be                	mv	a1,a5
8000887c:	fec42503          	lw	a0,-20(s0)
80008880:	3d55                	jal	80008734 <SPI_DataWidthConfig>
    SPI_FrameFormatConfig(SPIx, InitStruct->FrameFormat);
80008882:	fe842783          	lw	a5,-24(s0)
80008886:	43dc                	lw	a5,4(a5)
80008888:	85be                	mv	a1,a5
8000888a:	fec42503          	lw	a0,-20(s0)
8000888e:	3731                	jal	8000879a <SPI_FrameFormatConfig>
    SPI_ModeConfig(SPIx, InitStruct->Mode);
80008890:	fe842783          	lw	a5,-24(s0)
80008894:	439c                	lw	a5,0(a5)
80008896:	85be                	mv	a1,a5
80008898:	fec42503          	lw	a0,-20(s0)
8000889c:	35e9                	jal	80008766 <SPI_ModeConfig>
}
8000889e:	0001                	nop
800088a0:	40f2                	lw	ra,28(sp)
800088a2:	4462                	lw	s0,24(sp)
800088a4:	6105                	addi	sp,sp,32
800088a6:	8082                	ret

800088a8 <SPI_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref SPI_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void SPI_StructInit(SPI_Init_TypeDef* InitStruct)
{
800088a8:	1101                	addi	sp,sp,-32
800088aa:	ce22                	sw	s0,28(sp)
800088ac:	1000                	addi	s0,sp,32
800088ae:	fea42623          	sw	a0,-20(s0)
    InitStruct->SCKDiv = 0;
800088b2:	fec42783          	lw	a5,-20(s0)
800088b6:	0007a623          	sw	zero,12(a5) # 2006000c <STACK_SIZE+0x2005f80c>
    InitStruct->SCKDivExtra = 2;
800088ba:	fec42783          	lw	a5,-20(s0)
800088be:	4709                	li	a4,2
800088c0:	cb98                	sw	a4,16(a5)
    InitStruct->DataWidth = SPI_DataWidth_8;
800088c2:	fec42783          	lw	a5,-20(s0)
800088c6:	471d                	li	a4,7
800088c8:	c798                	sw	a4,8(a5)
    InitStruct->FrameFormat = SPI_FrameFormat_SPI;
800088ca:	fec42783          	lw	a5,-20(s0)
800088ce:	0007a223          	sw	zero,4(a5)
    InitStruct->Mode = SPI_Mode_Master;
800088d2:	fec42783          	lw	a5,-20(s0)
800088d6:	0007a023          	sw	zero,0(a5)
}
800088da:	0001                	nop
800088dc:	4472                	lw	s0,28(sp)
800088de:	6105                	addi	sp,sp,32
800088e0:	8082                	ret

800088e2 <RCU_APBClkCmd>:
{
800088e2:	1101                	addi	sp,sp,-32
800088e4:	ce22                	sw	s0,28(sp)
800088e6:	1000                	addi	s0,sp,32
800088e8:	fea42623          	sw	a0,-20(s0)
800088ec:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->CGCFGAPB, APBClk, State ? APBClk : 0);
800088f0:	3000e7b7          	lui	a5,0x3000e
800088f4:	4798                	lw	a4,8(a5)
800088f6:	fec42783          	lw	a5,-20(s0)
800088fa:	fff7c793          	not	a5,a5
800088fe:	00f776b3          	and	a3,a4,a5
80008902:	fe842783          	lw	a5,-24(s0)
80008906:	c781                	beqz	a5,8000890e <RCU_APBClkCmd+0x2c>
80008908:	fec42783          	lw	a5,-20(s0)
8000890c:	a011                	j	80008910 <RCU_APBClkCmd+0x2e>
8000890e:	4781                	li	a5,0
80008910:	3000e737          	lui	a4,0x3000e
80008914:	8fd5                	or	a5,a5,a3
80008916:	c71c                	sw	a5,8(a4)
}
80008918:	0001                	nop
8000891a:	4472                	lw	s0,28(sp)
8000891c:	6105                	addi	sp,sp,32
8000891e:	8082                	ret

80008920 <RCU_APBRstCmd>:
{
80008920:	1101                	addi	sp,sp,-32
80008922:	ce22                	sw	s0,28(sp)
80008924:	1000                	addi	s0,sp,32
80008926:	fea42623          	sw	a0,-20(s0)
8000892a:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAPB, APBRst, State ? APBRst : 0);
8000892e:	3000e7b7          	lui	a5,0x3000e
80008932:	4f98                	lw	a4,24(a5)
80008934:	fec42783          	lw	a5,-20(s0)
80008938:	fff7c793          	not	a5,a5
8000893c:	00f776b3          	and	a3,a4,a5
80008940:	fe842783          	lw	a5,-24(s0)
80008944:	c781                	beqz	a5,8000894c <RCU_APBRstCmd+0x2c>
80008946:	fec42783          	lw	a5,-20(s0)
8000894a:	a011                	j	8000894e <RCU_APBRstCmd+0x2e>
8000894c:	4781                	li	a5,0
8000894e:	3000e737          	lui	a4,0x3000e
80008952:	8fd5                	or	a5,a5,a3
80008954:	cf1c                	sw	a5,24(a4)
}
80008956:	0001                	nop
80008958:	4472                	lw	s0,28(sp)
8000895a:	6105                	addi	sp,sp,32
8000895c:	8082                	ret

8000895e <TRNG_StartCmd>:
  * @brief   Запуск ИГСЧ
  * @param   state Состояние запуска ИГСЧ
  * @retval  void
  */
__STATIC_INLINE void TRNG_StartCmd(FunctionalState state)
{
8000895e:	1101                	addi	sp,sp,-32
80008960:	ce22                	sw	s0,28(sp)
80008962:	1000                	addi	s0,sp,32
80008964:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_START_Msk, state << TRNG_CR_START_Pos);
80008968:	300047b7          	lui	a5,0x30004
8000896c:	439c                	lw	a5,0(a5)
8000896e:	ffe7f693          	andi	a3,a5,-2
80008972:	300047b7          	lui	a5,0x30004
80008976:	fec42703          	lw	a4,-20(s0)
8000897a:	8f55                	or	a4,a4,a3
8000897c:	c398                	sw	a4,0(a5)
}
8000897e:	0001                	nop
80008980:	4472                	lw	s0,28(sp)
80008982:	6105                	addi	sp,sp,32
80008984:	8082                	ret

80008986 <TRNG_PseudorandomGeneratorCmd>:
  * @brief   Выбор между ИГСЧ и псевдослучайным генератором
  * @param   state Выбор режима 0 - ИГСЧ асинхронный независимый генератор, 1 - псевдослучайный генератор
  * @retval  void
  */
__STATIC_INLINE void TRNG_PseudorandomGeneratorCmd(FunctionalState state)
{
80008986:	1101                	addi	sp,sp,-32
80008988:	ce22                	sw	s0,28(sp)
8000898a:	1000                	addi	s0,sp,32
8000898c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_LFSR_Msk, state << TRNG_CR_LFSR_Pos);
80008990:	300047b7          	lui	a5,0x30004
80008994:	439c                	lw	a5,0(a5)
80008996:	ffd7f693          	andi	a3,a5,-3
8000899a:	fec42783          	lw	a5,-20(s0)
8000899e:	00179713          	slli	a4,a5,0x1
800089a2:	300047b7          	lui	a5,0x30004
800089a6:	8f55                	or	a4,a4,a3
800089a8:	c398                	sw	a4,0(a5)
}
800089aa:	0001                	nop
800089ac:	4472                	lw	s0,28(sp)
800089ae:	6105                	addi	sp,sp,32
800089b0:	8082                	ret

800089b2 <TRNG_BypassHandlerCmd>:
  * @brief   Пропуск функции обработки
  * @param   state Флаг использования функции обработки 0 - использование функции обработки, 1 - пропуск функции обработки
  * @retval  void
  */
__STATIC_INLINE void TRNG_BypassHandlerCmd(FunctionalState state)
{
800089b2:	1101                	addi	sp,sp,-32
800089b4:	ce22                	sw	s0,28(sp)
800089b6:	1000                	addi	s0,sp,32
800089b8:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_CONDBYPASS_Msk, state << TRNG_CR_CONDBYPASS_Pos);
800089bc:	300047b7          	lui	a5,0x30004
800089c0:	439c                	lw	a5,0(a5)
800089c2:	ff77f693          	andi	a3,a5,-9
800089c6:	fec42783          	lw	a5,-20(s0)
800089ca:	00379713          	slli	a4,a5,0x3
800089ce:	300047b7          	lui	a5,0x30004
800089d2:	8f55                	or	a4,a4,a3
800089d4:	c398                	sw	a4,0(a5)
}
800089d6:	0001                	nop
800089d8:	4472                	lw	s0,28(sp)
800089da:	6105                	addi	sp,sp,32
800089dc:	8082                	ret

800089de <TRNG_SwResetCmd>:
  * 		 Этот бит не очищается автоматически!
  * @param   state Флаг включения сброса
  * @retval  void
  */
__STATIC_INLINE void TRNG_SwResetCmd(FunctionalState state)
{
800089de:	1101                	addi	sp,sp,-32
800089e0:	ce22                	sw	s0,28(sp)
800089e2:	1000                	addi	s0,sp,32
800089e4:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_SOFTRST_Msk, state << TRNG_CR_SOFTRST_Pos);
800089e8:	300047b7          	lui	a5,0x30004
800089ec:	439c                	lw	a5,0(a5)
800089ee:	eff7f693          	andi	a3,a5,-257
800089f2:	fec42783          	lw	a5,-20(s0)
800089f6:	00879713          	slli	a4,a5,0x8
800089fa:	300047b7          	lui	a5,0x30004
800089fe:	8f55                	or	a4,a4,a3
80008a00:	c398                	sw	a4,0(a5)
}
80008a02:	0001                	nop
80008a04:	4472                	lw	s0,28(sp)
80008a06:	6105                	addi	sp,sp,32
80008a08:	8082                	ret

80008a0a <TRNG_ForceGeneratorCmd>:
  * @brief   Принудительный запуск генераторов, когда FIFO заполнен
  * @param   state Флаг принудительного запуска генераторов
  * @retval  void
  */
__STATIC_INLINE void TRNG_ForceGeneratorCmd(FunctionalState state)
{
80008a0a:	1101                	addi	sp,sp,-32
80008a0c:	ce22                	sw	s0,28(sp)
80008a0e:	1000                	addi	s0,sp,32
80008a10:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_FORCEROS_Msk, state << TRNG_CR_FORCEROS_Pos);
80008a14:	300047b7          	lui	a5,0x30004
80008a18:	4398                	lw	a4,0(a5)
80008a1a:	77fd                	lui	a5,0xfffff
80008a1c:	7ff78793          	addi	a5,a5,2047 # fffff7ff <__data_source_start+0x7fff5ddb>
80008a20:	00f776b3          	and	a3,a4,a5
80008a24:	fec42783          	lw	a5,-20(s0)
80008a28:	00b79713          	slli	a4,a5,0xb
80008a2c:	300047b7          	lui	a5,0x30004
80008a30:	8f55                	or	a4,a4,a3
80008a32:	c398                	sw	a4,0(a5)
}
80008a34:	0001                	nop
80008a36:	4472                	lw	s0,28(sp)
80008a38:	6105                	addi	sp,sp,32
80008a3a:	8082                	ret

80008a3c <TRNG_SetBlockAmountForHandler>:
  * @param   countBlock Количество блоков для функции обработки
  * 		 Нулевое значение не допускается
  * @retval  void
  */
__STATIC_INLINE void TRNG_SetBlockAmountForHandler(uint32_t countBlock)
{
80008a3c:	1101                	addi	sp,sp,-32
80008a3e:	ce22                	sw	s0,28(sp)
80008a40:	1000                	addi	s0,sp,32
80008a42:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TRNG_COUNTBLOCK(countBlock));

	MODIFY_REG(TRNG->CR, TRNG_CR_COUNTBLOCK_Msk, countBlock << TRNG_CR_COUNTBLOCK_Pos);
80008a46:	300047b7          	lui	a5,0x30004
80008a4a:	4398                	lw	a4,0(a5)
80008a4c:	fff107b7          	lui	a5,0xfff10
80008a50:	17fd                	addi	a5,a5,-1 # fff0ffff <__data_source_start+0x7ff065db>
80008a52:	00f776b3          	and	a3,a4,a5
80008a56:	fec42783          	lw	a5,-20(s0)
80008a5a:	01079713          	slli	a4,a5,0x10
80008a5e:	300047b7          	lui	a5,0x30004
80008a62:	8f55                	or	a4,a4,a3
80008a64:	c398                	sw	a4,0(a5)
}
80008a66:	0001                	nop
80008a68:	4472                	lw	s0,28(sp)
80008a6a:	6105                	addi	sp,sp,32
80008a6c:	8082                	ret

80008a6e <TRNG_FIFOfillOnStartCmd>:
  * @brief   Разрешение записи выборок в FIFO во время запуска
  * @param   state Флаг разрешения записи
  * @retval  void
  */
__STATIC_INLINE void TRNG_FIFOfillOnStartCmd(FunctionalState state)
{
80008a6e:	1101                	addi	sp,sp,-32
80008a70:	ce22                	sw	s0,28(sp)
80008a72:	1000                	addi	s0,sp,32
80008a74:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_FIFOFILLST_Msk, state << TRNG_CR_FIFOFILLST_Pos);
80008a78:	300047b7          	lui	a5,0x30004
80008a7c:	4398                	lw	a4,0(a5)
80008a7e:	fff007b7          	lui	a5,0xfff00
80008a82:	17fd                	addi	a5,a5,-1 # ffefffff <__data_source_start+0x7fef65db>
80008a84:	00f776b3          	and	a3,a4,a5
80008a88:	fec42783          	lw	a5,-20(s0)
80008a8c:	01479713          	slli	a4,a5,0x14
80008a90:	300047b7          	lui	a5,0x30004
80008a94:	8f55                	or	a4,a4,a3
80008a96:	c398                	sw	a4,0(a5)
}
80008a98:	0001                	nop
80008a9a:	4472                	lw	s0,28(sp)
80008a9c:	6105                	addi	sp,sp,32
80008a9e:	8082                	ret

80008aa0 <TRNG_BlendMethodConfig>:
  * @brief   Выбор метода смешивания
  * @param   method метод смешнивания
  * @retval  void
  */
__STATIC_INLINE void TRNG_BlendMethodConfig(TRNG_BLENDMETHOD_TypeDef method)
{
80008aa0:	1101                	addi	sp,sp,-32
80008aa2:	ce22                	sw	s0,28(sp)
80008aa4:	1000                	addi	s0,sp,32
80008aa6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TRNG_BLENDMETHOD(method));

	MODIFY_REG(TRNG->CR, TRNG_CR_BLENDMETHOD_Msk, method << TRNG_CR_BLENDMETHOD_Pos);
80008aaa:	300047b7          	lui	a5,0x30004
80008aae:	4398                	lw	a4,0(a5)
80008ab0:	400007b7          	lui	a5,0x40000
80008ab4:	17fd                	addi	a5,a5,-1 # 3fffffff <STACK_SIZE+0x3ffff7ff>
80008ab6:	00f776b3          	and	a3,a4,a5
80008aba:	fec42783          	lw	a5,-20(s0)
80008abe:	01e79713          	slli	a4,a5,0x1e
80008ac2:	300047b7          	lui	a5,0x30004
80008ac6:	8f55                	or	a4,a4,a3
80008ac8:	c398                	sw	a4,0(a5)
}
80008aca:	0001                	nop
80008acc:	4472                	lw	s0,28(sp)
80008ace:	6105                	addi	sp,sp,32
80008ad0:	8082                	ret

80008ad2 <TRNG_GetFIFOlength>:
/**
  * @brief   Получение количества доступных 32-битных слов в буфере FIFO
  * @retval  length количество доступных 32-битных слов в буфере FIFO
  */
__STATIC_INLINE uint32_t TRNG_GetFIFOlength()
{
80008ad2:	1141                	addi	sp,sp,-16
80008ad4:	c622                	sw	s0,12(sp)
80008ad6:	0800                	addi	s0,sp,16
	return (uint32_t) READ_REG(TRNG->FIFOLEV);
80008ad8:	300047b7          	lui	a5,0x30004
80008adc:	43dc                	lw	a5,4(a5)
}
80008ade:	853e                	mv	a0,a5
80008ae0:	4432                	lw	s0,12(sp)
80008ae2:	0141                	addi	sp,sp,16
80008ae4:	8082                	ret

80008ae6 <TRNG_GetFIFOValue>:
/**
  * @brief   Получение значение в FIFO буфере
  * @retval  Val значение ячейки в FIFO
  */
__STATIC_INLINE uint32_t TRNG_GetFIFOValue()
{
80008ae6:	1141                	addi	sp,sp,-16
80008ae8:	c622                	sw	s0,12(sp)
80008aea:	0800                	addi	s0,sp,16
	return (uint32_t) READ_REG(TRNG->FIFO[0].FIFO);
80008aec:	300047b7          	lui	a5,0x30004
80008af0:	0807a783          	lw	a5,128(a5) # 30004080 <STACK_SIZE+0x30003880>
}
80008af4:	853e                	mv	a0,a5
80008af6:	4432                	lw	s0,12(sp)
80008af8:	0141                	addi	sp,sp,16
80008afa:	8082                	ret

80008afc <TRNG_DeInit>:
/**
  * @brief   Устанавливает все регистры TRNG значениями по умолчанию
  * @retval  void
  */
void TRNG_DeInit()
{
80008afc:	1141                	addi	sp,sp,-16
80008afe:	c606                	sw	ra,12(sp)
80008b00:	c422                	sw	s0,8(sp)
80008b02:	0800                	addi	s0,sp,16
	TRNG_SwResetCmd(ENABLE);
80008b04:	4505                	li	a0,1
80008b06:	3de1                	jal	800089de <TRNG_SwResetCmd>

    RCU_APBRstCmd(RCU_APBRst_TRNG, DISABLE);
80008b08:	4581                	li	a1,0
80008b0a:	4541                	li	a0,16
80008b0c:	3d11                	jal	80008920 <RCU_APBRstCmd>
    RCU_APBRstCmd(RCU_APBRst_TRNG, ENABLE);
80008b0e:	4585                	li	a1,1
80008b10:	4541                	li	a0,16
80008b12:	3539                	jal	80008920 <RCU_APBRstCmd>

    TRNG_SwResetCmd(DISABLE);
80008b14:	4501                	li	a0,0
80008b16:	35e1                	jal	800089de <TRNG_SwResetCmd>
}
80008b18:	0001                	nop
80008b1a:	40b2                	lw	ra,12(sp)
80008b1c:	4422                	lw	s0,8(sp)
80008b1e:	0141                	addi	sp,sp,16
80008b20:	8082                	ret

80008b22 <TRNG_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref TRNG_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void TRNG_Init(TRNG_Init_TypeDef* InitStruct)
{
80008b22:	1101                	addi	sp,sp,-32
80008b24:	ce06                	sw	ra,28(sp)
80008b26:	cc22                	sw	s0,24(sp)
80008b28:	1000                	addi	s0,sp,32
80008b2a:	fea42623          	sw	a0,-20(s0)
	TRNG_PseudorandomGeneratorCmd(InitStruct->PseudoRandomEnable);
80008b2e:	fec42783          	lw	a5,-20(s0)
80008b32:	439c                	lw	a5,0(a5)
80008b34:	853e                	mv	a0,a5
80008b36:	3d81                	jal	80008986 <TRNG_PseudorandomGeneratorCmd>
//	TRNG_TestSourceCmd(InitStruct->TestSourceEnable);
	TRNG_BypassHandlerCmd(InitStruct->BypassHandler);
80008b38:	fec42783          	lw	a5,-20(s0)
80008b3c:	43dc                	lw	a5,4(a5)
80008b3e:	853e                	mv	a0,a5
80008b40:	3d8d                	jal	800089b2 <TRNG_BypassHandlerCmd>
//	TRNG_ITTestFailCmd(InitStruct->ITOnAnyTestFail);
//	TRNG_ITFIFOfullCmd(InitStruct->ITOnFIFOfull);
	TRNG_ForceGeneratorCmd(InitStruct->ForceGenerator);
80008b42:	fec42783          	lw	a5,-20(s0)
80008b46:	479c                	lw	a5,8(a5)
80008b48:	853e                	mv	a0,a5
80008b4a:	35c1                	jal	80008a0a <TRNG_ForceGeneratorCmd>
//	TRNG_IgnoreHardwareTestsCmd(InitStruct->IgnoreHardwareTests);
	TRNG_SetBlockAmountForHandler(InitStruct->AmountBlocksForHandler);
80008b4c:	fec42783          	lw	a5,-20(s0)
80008b50:	47dc                	lw	a5,12(a5)
80008b52:	853e                	mv	a0,a5
80008b54:	35e5                	jal	80008a3c <TRNG_SetBlockAmountForHandler>
	TRNG_FIFOfillOnStartCmd(InitStruct->FIFOfillOnStart);
80008b56:	fec42783          	lw	a5,-20(s0)
80008b5a:	4b9c                	lw	a5,16(a5)
80008b5c:	853e                	mv	a0,a5
80008b5e:	3f01                	jal	80008a6e <TRNG_FIFOfillOnStartCmd>
//	TRNG_RepeatTestDisableCmd(InitStruct->RepeatTestDisable);
//	TRNG_ProportionTestDisableCmd(InitStruct->ProportionTestDisable);
//	TRNG_AutoCorrelationTestDisableConfig(InitStruct->AutocorrelationTestDisable);
//	TRNG_CorrelationTestDisableConfig(InitStruct->CorrelationTestDisable);
	TRNG_BlendMethodConfig(InitStruct->BlendMethod);
80008b60:	fec42783          	lw	a5,-20(s0)
80008b64:	4bdc                	lw	a5,20(a5)
80008b66:	853e                	mv	a0,a5
80008b68:	3f25                	jal	80008aa0 <TRNG_BlendMethodConfig>
	TRNG_SwResetCmd(DISABLE);
80008b6a:	4501                	li	a0,0
80008b6c:	3d8d                	jal	800089de <TRNG_SwResetCmd>
}
80008b6e:	0001                	nop
80008b70:	40f2                	lw	ra,28(sp)
80008b72:	4462                	lw	s0,24(sp)
80008b74:	6105                	addi	sp,sp,32
80008b76:	8082                	ret

80008b78 <TRNG_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref TRNG_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void TRNG_StructInit(TRNG_Init_TypeDef* InitStruct)
{
80008b78:	1101                	addi	sp,sp,-32
80008b7a:	ce22                	sw	s0,28(sp)
80008b7c:	1000                	addi	s0,sp,32
80008b7e:	fea42623          	sw	a0,-20(s0)
	InitStruct->PseudoRandomEnable = DISABLE;
80008b82:	fec42783          	lw	a5,-20(s0)
80008b86:	0007a023          	sw	zero,0(a5)
//	InitStruct->TestSourceEnable = DISABLE;
	InitStruct->BypassHandler = DISABLE;
80008b8a:	fec42783          	lw	a5,-20(s0)
80008b8e:	0007a223          	sw	zero,4(a5)
//	InitStruct->ITOnAnyTestFail = DISABLE;
//	InitStruct->ITOnFIFOfull = DISABLE;
	InitStruct->ForceGenerator = DISABLE;
80008b92:	fec42783          	lw	a5,-20(s0)
80008b96:	0007a423          	sw	zero,8(a5)
//	InitStruct->IgnoreHardwareTests = DISABLE;
	InitStruct->AmountBlocksForHandler = 0x0;
80008b9a:	fec42783          	lw	a5,-20(s0)
80008b9e:	0007a623          	sw	zero,12(a5)
	InitStruct->FIFOfillOnStart = DISABLE;
80008ba2:	fec42783          	lw	a5,-20(s0)
80008ba6:	0007a823          	sw	zero,16(a5)
//	InitStruct->RepeatTestDisable = DISABLE;
//	InitStruct->ProportionTestDisable = DISABLE;
//	InitStruct->AutocorrelationTestDisable = TRNG_AUTOCORRELATIONDISABLE_Nothing;
//	InitStruct->CorrelationTestDisable = TRNG_CORRELATIONDISABLE_Nothing;
	InitStruct->BlendMethod = TRNG_BLENDMETHOD_Concatenation;
80008baa:	fec42783          	lw	a5,-20(s0)
80008bae:	0007aa23          	sw	zero,20(a5)
	InitStruct->WarmPeriod = 0x00000200;
80008bb2:	fec42783          	lw	a5,-20(s0)
80008bb6:	20000713          	li	a4,512
80008bba:	cf98                	sw	a4,24(a5)
	InitStruct->CoolPeriod = 0x00000000;
80008bbc:	fec42783          	lw	a5,-20(s0)
80008bc0:	0007ae23          	sw	zero,28(a5)
	InitStruct->SamplePeriod = 0x0000001E;
80008bc4:	fec42783          	lw	a5,-20(s0)
80008bc8:	4779                	li	a4,30
80008bca:	d398                	sw	a4,32(a5)
}
80008bcc:	0001                	nop
80008bce:	4472                	lw	s0,28(sp)
80008bd0:	6105                	addi	sp,sp,32
80008bd2:	8082                	ret

80008bd4 <TRNG_GenerateKey>:
  * @param   key Ссылка на память, куда будет сохранен ключ размерности keyLength
  * @param   keyLength Размерность ключа в 32-битных словах
  * @retval  void
  */
void TRNG_GenerateKey(uint32_t *key, uint32_t keyLength)
{
80008bd4:	715d                	addi	sp,sp,-80
80008bd6:	c686                	sw	ra,76(sp)
80008bd8:	c4a2                	sw	s0,72(sp)
80008bda:	c2a6                	sw	s1,68(sp)
80008bdc:	0880                	addi	s0,sp,80
80008bde:	faa42e23          	sw	a0,-68(s0)
80008be2:	fab42c23          	sw	a1,-72(s0)
	TRNG_DeInit();
80008be6:	3f19                	jal	80008afc <TRNG_DeInit>
	RCU_APBClkCmd(RCU_APBClk_TRNG, ENABLE);
80008be8:	4585                	li	a1,1
80008bea:	4541                	li	a0,16
80008bec:	39dd                	jal	800088e2 <RCU_APBClkCmd>
	RCU_APBRstCmd(RCU_APBRst_TRNG, ENABLE);
80008bee:	4585                	li	a1,1
80008bf0:	4541                	li	a0,16
80008bf2:	333d                	jal	80008920 <RCU_APBRstCmd>
	TRNG_SwResetCmd(ENABLE);
80008bf4:	4505                	li	a0,1
80008bf6:	33e5                	jal	800089de <TRNG_SwResetCmd>
	TRNG_Init_TypeDef trngInit;
	TRNG_StructInit(&trngInit);
80008bf8:	fcc40793          	addi	a5,s0,-52
80008bfc:	853e                	mv	a0,a5
80008bfe:	3fad                	jal	80008b78 <TRNG_StructInit>

	// Start filling FIFO with noise source, with conditioning, all start-up tests and wait until interrupt triggers
	trngInit.WarmPeriod       = 0x00000200; //
80008c00:	20000793          	li	a5,512
80008c04:	fef42223          	sw	a5,-28(s0)
	trngInit.SamplePeriod     = 0x00000020;
80008c08:	02000793          	li	a5,32
80008c0c:	fef42623          	sw	a5,-20(s0)
	trngInit.CoolPeriod       = 0x00000000;
80008c10:	fe042423          	sw	zero,-24(s0)
	trngInit.AmountBlocksForHandler = 0x4;
80008c14:	4791                	li	a5,4
80008c16:	fcf42c23          	sw	a5,-40(s0)
	trngInit.BypassHandler    = DISABLE;
80008c1a:	fc042823          	sw	zero,-48(s0)

	TRNG_Init(&trngInit);
80008c1e:	fcc40793          	addi	a5,s0,-52
80008c22:	853e                	mv	a0,a5
80008c24:	3dfd                	jal	80008b22 <TRNG_Init>

	TRNG_StartCmd(ENABLE);
80008c26:	4505                	li	a0,1
80008c28:	3b1d                	jal	8000895e <TRNG_StartCmd>

	while (TRNG_GetFIFOlength() != keyLength) {}
80008c2a:	0001                	nop
80008c2c:	355d                	jal	80008ad2 <TRNG_GetFIFOlength>
80008c2e:	872a                	mv	a4,a0
80008c30:	fb842783          	lw	a5,-72(s0)
80008c34:	fee79ce3          	bne	a5,a4,80008c2c <TRNG_GenerateKey+0x58>

	TRNG_StartCmd(DISABLE);
80008c38:	4501                	li	a0,0
80008c3a:	3315                	jal	8000895e <TRNG_StartCmd>

	while (keyLength--)
80008c3c:	a811                	j	80008c50 <TRNG_GenerateKey+0x7c>
	{
		*key++ = TRNG_GetFIFOValue();
80008c3e:	fbc42483          	lw	s1,-68(s0)
80008c42:	00448793          	addi	a5,s1,4
80008c46:	faf42e23          	sw	a5,-68(s0)
80008c4a:	3d71                	jal	80008ae6 <TRNG_GetFIFOValue>
80008c4c:	87aa                	mv	a5,a0
80008c4e:	c09c                	sw	a5,0(s1)
	while (keyLength--)
80008c50:	fb842783          	lw	a5,-72(s0)
80008c54:	fff78713          	addi	a4,a5,-1
80008c58:	fae42c23          	sw	a4,-72(s0)
80008c5c:	f3ed                	bnez	a5,80008c3e <TRNG_GenerateKey+0x6a>
	}

	TRNG_SwResetCmd(ENABLE);
80008c5e:	4505                	li	a0,1
80008c60:	3bbd                	jal	800089de <TRNG_SwResetCmd>
}
80008c62:	0001                	nop
80008c64:	40b6                	lw	ra,76(sp)
80008c66:	4426                	lw	s0,72(sp)
80008c68:	4496                	lw	s1,68(sp)
80008c6a:	6161                	addi	sp,sp,80
80008c6c:	8082                	ret

80008c6e <RCU_UARTRstCmd>:
{
80008c6e:	1101                	addi	sp,sp,-32
80008c70:	ce22                	sw	s0,28(sp)
80008c72:	1000                	addi	s0,sp,32
80008c74:	fea42623          	sw	a0,-20(s0)
80008c78:	feb42423          	sw	a1,-24(s0)
    WRITE_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.RSTDIS, State);
80008c7c:	3000e6b7          	lui	a3,0x3000e
80008c80:	fe842783          	lw	a5,-24(s0)
80008c84:	8b85                	andi	a5,a5,1
80008c86:	0ff7f713          	zext.b	a4,a5
80008c8a:	fec42783          	lw	a5,-20(s0)
80008c8e:	07f1                	addi	a5,a5,28
80008c90:	078a                	slli	a5,a5,0x2
80008c92:	97b6                	add	a5,a5,a3
80008c94:	8b05                	andi	a4,a4,1
80008c96:	0722                	slli	a4,a4,0x8
80008c98:	4394                	lw	a3,0(a5)
80008c9a:	eff6f693          	andi	a3,a3,-257
80008c9e:	8f55                	or	a4,a4,a3
80008ca0:	c398                	sw	a4,0(a5)
}
80008ca2:	0001                	nop
80008ca4:	4472                	lw	s0,28(sp)
80008ca6:	6105                	addi	sp,sp,32
80008ca8:	8082                	ret

80008caa <UART_DataWidthConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3|4
  * @param   DataWidth  Значение разрядности слова
  * @retval  void
  */
__STATIC_INLINE void UART_DataWidthConfig(UART_TypeDef* UARTx, UART_DataWidth_TypeDef DataWidth)
{
80008caa:	1101                	addi	sp,sp,-32
80008cac:	ce22                	sw	s0,28(sp)
80008cae:	1000                	addi	s0,sp,32
80008cb0:	fea42623          	sw	a0,-20(s0)
80008cb4:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_DATA_WIDTH(DataWidth));

    WRITE_REG(UARTx->LCRH_bit.WLEN, DataWidth);
80008cb8:	fe842783          	lw	a5,-24(s0)
80008cbc:	8b8d                	andi	a5,a5,3
80008cbe:	0ff7f713          	zext.b	a4,a5
80008cc2:	fec42783          	lw	a5,-20(s0)
80008cc6:	8b0d                	andi	a4,a4,3
80008cc8:	0716                	slli	a4,a4,0x5
80008cca:	02c7c683          	lbu	a3,44(a5)
80008cce:	f9f6f693          	andi	a3,a3,-97
80008cd2:	8f55                	or	a4,a4,a3
80008cd4:	02e78623          	sb	a4,44(a5)
}
80008cd8:	0001                	nop
80008cda:	4472                	lw	s0,28(sp)
80008cdc:	6105                	addi	sp,sp,32
80008cde:	8082                	ret

80008ce0 <UART_StopBitConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3|4
  * @param   StopBit  Количество стоп-бит
  * @retval  void
  */
__STATIC_INLINE void UART_StopBitConfig(UART_TypeDef* UARTx, UART_StopBit_TypeDef StopBit)
{
80008ce0:	1101                	addi	sp,sp,-32
80008ce2:	ce22                	sw	s0,28(sp)
80008ce4:	1000                	addi	s0,sp,32
80008ce6:	fea42623          	sw	a0,-20(s0)
80008cea:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_STOP_BIT(StopBit));

    WRITE_REG(UARTx->LCRH_bit.STP2, StopBit);
80008cee:	fe842783          	lw	a5,-24(s0)
80008cf2:	8b85                	andi	a5,a5,1
80008cf4:	0ff7f713          	zext.b	a4,a5
80008cf8:	fec42783          	lw	a5,-20(s0)
80008cfc:	8b05                	andi	a4,a4,1
80008cfe:	070e                	slli	a4,a4,0x3
80008d00:	02c7c683          	lbu	a3,44(a5)
80008d04:	9add                	andi	a3,a3,-9
80008d06:	8f55                	or	a4,a4,a3
80008d08:	02e78623          	sb	a4,44(a5)
}
80008d0c:	0001                	nop
80008d0e:	4472                	lw	s0,28(sp)
80008d10:	6105                	addi	sp,sp,32
80008d12:	8082                	ret

80008d14 <UART_ParityBitConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3|4
  * @param   ParityBit  Режим
  * @retval  void
  */
__STATIC_INLINE void UART_ParityBitConfig(UART_TypeDef* UARTx, UART_ParityBit_TypeDef ParityBit)
{
80008d14:	1101                	addi	sp,sp,-32
80008d16:	ce22                	sw	s0,28(sp)
80008d18:	1000                	addi	s0,sp,32
80008d1a:	fea42623          	sw	a0,-20(s0)
80008d1e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_PARITY_BIT(ParityBit));

    MODIFY_REG(UARTx->LCRH, UART_LCRH_PEN_Msk | UART_LCRH_SPS_Msk | UART_LCRH_EPS_Msk, ParityBit);
80008d22:	fec42783          	lw	a5,-20(s0)
80008d26:	57dc                	lw	a5,44(a5)
80008d28:	f797f713          	andi	a4,a5,-135
80008d2c:	fe842783          	lw	a5,-24(s0)
80008d30:	8f5d                	or	a4,a4,a5
80008d32:	fec42783          	lw	a5,-20(s0)
80008d36:	d7d8                	sw	a4,44(a5)
}
80008d38:	0001                	nop
80008d3a:	4472                	lw	s0,28(sp)
80008d3c:	6105                	addi	sp,sp,32
80008d3e:	8082                	ret

80008d40 <UART_BaudDivConfig>:
  *                   Параметр принимает любое значение из диапазона 0-63. В случае, если IntDiv
  *                   равен 65535, значение FracDiv может быть только 0.
  * @retval  void
  */
__STATIC_INLINE void UART_BaudDivConfig(UART_TypeDef* UARTx, uint32_t IntDiv, uint32_t FracDiv)
{
80008d40:	1101                	addi	sp,sp,-32
80008d42:	ce22                	sw	s0,28(sp)
80008d44:	1000                	addi	s0,sp,32
80008d46:	fea42623          	sw	a0,-20(s0)
80008d4a:	feb42423          	sw	a1,-24(s0)
80008d4e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_INT_DIV(IntDiv));
    assert_param(IS_UART_FRAC_DIV(FracDiv));

    WRITE_REG(UARTx->IBRD, IntDiv);
80008d52:	fec42783          	lw	a5,-20(s0)
80008d56:	fe842703          	lw	a4,-24(s0)
80008d5a:	d3d8                	sw	a4,36(a5)
    WRITE_REG(UARTx->FBRD, FracDiv);
80008d5c:	fec42783          	lw	a5,-20(s0)
80008d60:	fe442703          	lw	a4,-28(s0)
80008d64:	d798                	sw	a4,40(a5)
}
80008d66:	0001                	nop
80008d68:	4472                	lw	s0,28(sp)
80008d6a:	6105                	addi	sp,sp,32
80008d6c:	8082                	ret

80008d6e <UART_FIFOCmd>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3|4
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void UART_FIFOCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80008d6e:	1101                	addi	sp,sp,-32
80008d70:	ce22                	sw	s0,28(sp)
80008d72:	1000                	addi	s0,sp,32
80008d74:	fea42623          	sw	a0,-20(s0)
80008d78:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->LCRH_bit.FEN, State);
80008d7c:	fe842783          	lw	a5,-24(s0)
80008d80:	8b85                	andi	a5,a5,1
80008d82:	0ff7f713          	zext.b	a4,a5
80008d86:	fec42783          	lw	a5,-20(s0)
80008d8a:	8b05                	andi	a4,a4,1
80008d8c:	0712                	slli	a4,a4,0x4
80008d8e:	02c7c683          	lbu	a3,44(a5)
80008d92:	9abd                	andi	a3,a3,-17
80008d94:	8f55                	or	a4,a4,a3
80008d96:	02e78623          	sb	a4,44(a5)
}
80008d9a:	0001                	nop
80008d9c:	4472                	lw	s0,28(sp)
80008d9e:	6105                	addi	sp,sp,32
80008da0:	8082                	ret

80008da2 <UART_RxCmd>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3|4
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void UART_RxCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80008da2:	1101                	addi	sp,sp,-32
80008da4:	ce22                	sw	s0,28(sp)
80008da6:	1000                	addi	s0,sp,32
80008da8:	fea42623          	sw	a0,-20(s0)
80008dac:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->CR_bit.RXE, State);
80008db0:	fe842783          	lw	a5,-24(s0)
80008db4:	8b85                	andi	a5,a5,1
80008db6:	0ff7f713          	zext.b	a4,a5
80008dba:	fec42783          	lw	a5,-20(s0)
80008dbe:	8b05                	andi	a4,a4,1
80008dc0:	0726                	slli	a4,a4,0x9
80008dc2:	0307d683          	lhu	a3,48(a5)
80008dc6:	dff6f693          	andi	a3,a3,-513
80008dca:	8f55                	or	a4,a4,a3
80008dcc:	02e79823          	sh	a4,48(a5)
}
80008dd0:	0001                	nop
80008dd2:	4472                	lw	s0,28(sp)
80008dd4:	6105                	addi	sp,sp,32
80008dd6:	8082                	ret

80008dd8 <UART_TxCmd>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3|4
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void UART_TxCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80008dd8:	1101                	addi	sp,sp,-32
80008dda:	ce22                	sw	s0,28(sp)
80008ddc:	1000                	addi	s0,sp,32
80008dde:	fea42623          	sw	a0,-20(s0)
80008de2:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->CR_bit.TXE, State);
80008de6:	fe842783          	lw	a5,-24(s0)
80008dea:	8b85                	andi	a5,a5,1
80008dec:	0ff7f713          	zext.b	a4,a5
80008df0:	fec42783          	lw	a5,-20(s0)
80008df4:	8b05                	andi	a4,a4,1
80008df6:	0722                	slli	a4,a4,0x8
80008df8:	0307d683          	lhu	a3,48(a5)
80008dfc:	eff6f693          	andi	a3,a3,-257
80008e00:	8f55                	or	a4,a4,a3
80008e02:	02e79823          	sh	a4,48(a5)
}
80008e06:	0001                	nop
80008e08:	4472                	lw	s0,28(sp)
80008e0a:	6105                	addi	sp,sp,32
80008e0c:	8082                	ret

80008e0e <UART_AutoBaudConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3|4
  * @param   State  Выбор состояния
  * @retval  void
  */
void UART_AutoBaudConfig(UART_TypeDef* UARTx, uint32_t BaudRate)
{
80008e0e:	7179                	addi	sp,sp,-48
80008e10:	d606                	sw	ra,44(sp)
80008e12:	d422                	sw	s0,40(sp)
80008e14:	1800                	addi	s0,sp,48
80008e16:	fca42e23          	sw	a0,-36(s0)
80008e1a:	fcb42c23          	sw	a1,-40(s0)
    UART_Num_TypeDef UARTx_Num;
    uint32_t uart_clk_freq, int_div, frac_div;

    assert_param(IS_UART_PERIPH(UARTx));

    if (UARTx == UART0) {
80008e1e:	fdc42703          	lw	a4,-36(s0)
80008e22:	300067b7          	lui	a5,0x30006
80008e26:	00f71563          	bne	a4,a5,80008e30 <UART_AutoBaudConfig+0x22>
        UARTx_Num = UART0_Num;
80008e2a:	fe042623          	sw	zero,-20(s0)
80008e2e:	a091                	j	80008e72 <UART_AutoBaudConfig+0x64>
    } else if (UARTx == UART1) {
80008e30:	fdc42703          	lw	a4,-36(s0)
80008e34:	300077b7          	lui	a5,0x30007
80008e38:	00f71663          	bne	a4,a5,80008e44 <UART_AutoBaudConfig+0x36>
        UARTx_Num = UART1_Num;
80008e3c:	4785                	li	a5,1
80008e3e:	fef42623          	sw	a5,-20(s0)
80008e42:	a805                	j	80008e72 <UART_AutoBaudConfig+0x64>
    } else if (UARTx == UART2) {
80008e44:	fdc42703          	lw	a4,-36(s0)
80008e48:	300087b7          	lui	a5,0x30008
80008e4c:	00f71663          	bne	a4,a5,80008e58 <UART_AutoBaudConfig+0x4a>
        UARTx_Num = UART2_Num;
80008e50:	4789                	li	a5,2
80008e52:	fef42623          	sw	a5,-20(s0)
80008e56:	a831                	j	80008e72 <UART_AutoBaudConfig+0x64>
    } else if (UARTx == UART3) {
80008e58:	fdc42703          	lw	a4,-36(s0)
80008e5c:	300097b7          	lui	a5,0x30009
80008e60:	00f71663          	bne	a4,a5,80008e6c <UART_AutoBaudConfig+0x5e>
        UARTx_Num = UART3_Num;        
80008e64:	478d                	li	a5,3
80008e66:	fef42623          	sw	a5,-20(s0)
80008e6a:	a021                	j	80008e72 <UART_AutoBaudConfig+0x64>
    } else /*if (UARTx == UART4)*/ {
        UARTx_Num = UART4_Num;
80008e6c:	4791                	li	a5,4
80008e6e:	fef42623          	sw	a5,-20(s0)
    }

    uart_clk_freq = RCU_GetUARTClkFreq(UARTx_Num);
80008e72:	fec42503          	lw	a0,-20(s0)
80008e76:	b28ff0ef          	jal	ra,8000819e <RCU_GetUARTClkFreq>
80008e7a:	fea42423          	sw	a0,-24(s0)
    int_div = uart_clk_freq / (16 * BaudRate);
80008e7e:	fd842783          	lw	a5,-40(s0)
80008e82:	0792                	slli	a5,a5,0x4
80008e84:	fe842703          	lw	a4,-24(s0)
80008e88:	02f757b3          	divu	a5,a4,a5
80008e8c:	fef42223          	sw	a5,-28(s0)
    frac_div = (uint32_t)((uart_clk_freq / (16.0f * BaudRate) - int_div) * 64.0f + 0.5f);
80008e90:	fe842783          	lw	a5,-24(s0)
80008e94:	d017f753          	fcvt.s.wu	fa4,a5
80008e98:	fd842783          	lw	a5,-40(s0)
80008e9c:	d017f6d3          	fcvt.s.wu	fa3,a5
80008ea0:	8000a7b7          	lui	a5,0x8000a
80008ea4:	9007a787          	flw	fa5,-1792(a5) # 80009900 <__data_source_start+0xfffffedc>
80008ea8:	10f6f7d3          	fmul.s	fa5,fa3,fa5
80008eac:	18f77753          	fdiv.s	fa4,fa4,fa5
80008eb0:	fe442783          	lw	a5,-28(s0)
80008eb4:	d017f7d3          	fcvt.s.wu	fa5,a5
80008eb8:	08f77753          	fsub.s	fa4,fa4,fa5
80008ebc:	8000a7b7          	lui	a5,0x8000a
80008ec0:	9047a787          	flw	fa5,-1788(a5) # 80009904 <__data_source_start+0xfffffee0>
80008ec4:	10f77753          	fmul.s	fa4,fa4,fa5
80008ec8:	8000a7b7          	lui	a5,0x8000a
80008ecc:	9087a787          	flw	fa5,-1784(a5) # 80009908 <__data_source_start+0xfffffee4>
80008ed0:	00f777d3          	fadd.s	fa5,fa4,fa5
80008ed4:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80008ed8:	fef42023          	sw	a5,-32(s0)
    UART_BaudDivConfig(UARTx, int_div, frac_div);
80008edc:	fe042603          	lw	a2,-32(s0)
80008ee0:	fe442583          	lw	a1,-28(s0)
80008ee4:	fdc42503          	lw	a0,-36(s0)
80008ee8:	3da1                	jal	80008d40 <UART_BaudDivConfig>
}
80008eea:	0001                	nop
80008eec:	50b2                	lw	ra,44(sp)
80008eee:	5422                	lw	s0,40(sp)
80008ef0:	6145                	addi	sp,sp,48
80008ef2:	8082                	ret

80008ef4 <UART_DeInit>:
  * @brief   Устанавливает все регистры UART значениями по умолчанию
  * @param   UARTx   Выбор модуля UART, где x=0|1|2|3|4
  * @retval  void
  */
void UART_DeInit(UART_TypeDef* UARTx)
{
80008ef4:	7179                	addi	sp,sp,-48
80008ef6:	d606                	sw	ra,44(sp)
80008ef8:	d422                	sw	s0,40(sp)
80008efa:	1800                	addi	s0,sp,48
80008efc:	fca42e23          	sw	a0,-36(s0)
    UART_Num_TypeDef UARTx_Num;

    assert_param(IS_UART_PERIPH(UARTx));

    if (UARTx == UART0) {
80008f00:	fdc42703          	lw	a4,-36(s0)
80008f04:	300067b7          	lui	a5,0x30006
80008f08:	00f71563          	bne	a4,a5,80008f12 <UART_DeInit+0x1e>
        UARTx_Num = UART0_Num;
80008f0c:	fe042623          	sw	zero,-20(s0)
80008f10:	a091                	j	80008f54 <UART_DeInit+0x60>
    } else if (UARTx == UART1) {
80008f12:	fdc42703          	lw	a4,-36(s0)
80008f16:	300077b7          	lui	a5,0x30007
80008f1a:	00f71663          	bne	a4,a5,80008f26 <UART_DeInit+0x32>
        UARTx_Num = UART1_Num;
80008f1e:	4785                	li	a5,1
80008f20:	fef42623          	sw	a5,-20(s0)
80008f24:	a805                	j	80008f54 <UART_DeInit+0x60>
    } else if (UARTx == UART2) {
80008f26:	fdc42703          	lw	a4,-36(s0)
80008f2a:	300087b7          	lui	a5,0x30008
80008f2e:	00f71663          	bne	a4,a5,80008f3a <UART_DeInit+0x46>
        UARTx_Num = UART2_Num;
80008f32:	4789                	li	a5,2
80008f34:	fef42623          	sw	a5,-20(s0)
80008f38:	a831                	j	80008f54 <UART_DeInit+0x60>
    } else if (UARTx == UART3) {
80008f3a:	fdc42703          	lw	a4,-36(s0)
80008f3e:	300097b7          	lui	a5,0x30009
80008f42:	00f71663          	bne	a4,a5,80008f4e <UART_DeInit+0x5a>
        UARTx_Num = UART3_Num;        
80008f46:	478d                	li	a5,3
80008f48:	fef42623          	sw	a5,-20(s0)
80008f4c:	a021                	j	80008f54 <UART_DeInit+0x60>
    } else /*if (UARTx == UART4)*/ {
        UARTx_Num = UART4_Num;
80008f4e:	4791                	li	a5,4
80008f50:	fef42623          	sw	a5,-20(s0)
    }

    RCU_UARTRstCmd(UARTx_Num, DISABLE);
80008f54:	4581                	li	a1,0
80008f56:	fec42503          	lw	a0,-20(s0)
80008f5a:	3b11                	jal	80008c6e <RCU_UARTRstCmd>
    RCU_UARTRstCmd(UARTx_Num, ENABLE);
80008f5c:	4585                	li	a1,1
80008f5e:	fec42503          	lw	a0,-20(s0)
80008f62:	3331                	jal	80008c6e <RCU_UARTRstCmd>
}
80008f64:	0001                	nop
80008f66:	50b2                	lw	ra,44(sp)
80008f68:	5422                	lw	s0,40(sp)
80008f6a:	6145                	addi	sp,sp,48
80008f6c:	8082                	ret

80008f6e <UART_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref UART_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void UART_Init(UART_TypeDef* UARTx, UART_Init_TypeDef* InitStruct)
{
80008f6e:	1101                	addi	sp,sp,-32
80008f70:	ce06                	sw	ra,28(sp)
80008f72:	cc22                	sw	s0,24(sp)
80008f74:	1000                	addi	s0,sp,32
80008f76:	fea42623          	sw	a0,-20(s0)
80008f7a:	feb42423          	sw	a1,-24(s0)
    UART_AutoBaudConfig(UARTx, InitStruct->BaudRate);
80008f7e:	fe842783          	lw	a5,-24(s0)
80008f82:	47dc                	lw	a5,12(a5)
80008f84:	85be                	mv	a1,a5
80008f86:	fec42503          	lw	a0,-20(s0)
80008f8a:	3551                	jal	80008e0e <UART_AutoBaudConfig>
    UART_DataWidthConfig(UARTx, InitStruct->DataWidth);
80008f8c:	fe842783          	lw	a5,-24(s0)
80008f90:	479c                	lw	a5,8(a5)
80008f92:	85be                	mv	a1,a5
80008f94:	fec42503          	lw	a0,-20(s0)
80008f98:	3b09                	jal	80008caa <UART_DataWidthConfig>
    UART_StopBitConfig(UARTx, InitStruct->StopBit);
80008f9a:	fe842783          	lw	a5,-24(s0)
80008f9e:	439c                	lw	a5,0(a5)
80008fa0:	85be                	mv	a1,a5
80008fa2:	fec42503          	lw	a0,-20(s0)
80008fa6:	3b2d                	jal	80008ce0 <UART_StopBitConfig>
    UART_ParityBitConfig(UARTx, InitStruct->ParityBit);
80008fa8:	fe842783          	lw	a5,-24(s0)
80008fac:	43dc                	lw	a5,4(a5)
80008fae:	85be                	mv	a1,a5
80008fb0:	fec42503          	lw	a0,-20(s0)
80008fb4:	3385                	jal	80008d14 <UART_ParityBitConfig>
    UART_FIFOCmd(UARTx, InitStruct->FIFO);
80008fb6:	fe842783          	lw	a5,-24(s0)
80008fba:	4b9c                	lw	a5,16(a5)
80008fbc:	85be                	mv	a1,a5
80008fbe:	fec42503          	lw	a0,-20(s0)
80008fc2:	3375                	jal	80008d6e <UART_FIFOCmd>
    UART_TxCmd(UARTx, InitStruct->Tx);
80008fc4:	fe842783          	lw	a5,-24(s0)
80008fc8:	4f9c                	lw	a5,24(a5)
80008fca:	85be                	mv	a1,a5
80008fcc:	fec42503          	lw	a0,-20(s0)
80008fd0:	3521                	jal	80008dd8 <UART_TxCmd>
    UART_RxCmd(UARTx, InitStruct->Rx);
80008fd2:	fe842783          	lw	a5,-24(s0)
80008fd6:	4bdc                	lw	a5,20(a5)
80008fd8:	85be                	mv	a1,a5
80008fda:	fec42503          	lw	a0,-20(s0)
80008fde:	33d1                	jal	80008da2 <UART_RxCmd>
}
80008fe0:	0001                	nop
80008fe2:	40f2                	lw	ra,28(sp)
80008fe4:	4462                	lw	s0,24(sp)
80008fe6:	6105                	addi	sp,sp,32
80008fe8:	8082                	ret

80008fea <UART_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref UART_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void UART_StructInit(UART_Init_TypeDef* InitStruct)
{
80008fea:	1101                	addi	sp,sp,-32
80008fec:	ce22                	sw	s0,28(sp)
80008fee:	1000                	addi	s0,sp,32
80008ff0:	fea42623          	sw	a0,-20(s0)
    InitStruct->BaudRate = 9600;
80008ff4:	fec42783          	lw	a5,-20(s0)
80008ff8:	6709                	lui	a4,0x2
80008ffa:	58070713          	addi	a4,a4,1408 # 2580 <STACK_SIZE+0x1d80>
80008ffe:	c7d8                	sw	a4,12(a5)
    InitStruct->DataWidth = UART_DataWidth_8;
80009000:	fec42783          	lw	a5,-20(s0)
80009004:	470d                	li	a4,3
80009006:	c798                	sw	a4,8(a5)
    InitStruct->FIFO = DISABLE;
80009008:	fec42783          	lw	a5,-20(s0)
8000900c:	0007a823          	sw	zero,16(a5) # 30009010 <STACK_SIZE+0x30008810>
    InitStruct->ParityBit = UART_ParityBit_Disable;
80009010:	fec42783          	lw	a5,-20(s0)
80009014:	0007a223          	sw	zero,4(a5)
    InitStruct->StopBit = UART_StopBit_1;
80009018:	fec42783          	lw	a5,-20(s0)
8000901c:	0007a023          	sw	zero,0(a5)
    InitStruct->Rx = DISABLE;
80009020:	fec42783          	lw	a5,-20(s0)
80009024:	0007aa23          	sw	zero,20(a5)
    InitStruct->Tx = DISABLE;
80009028:	fec42783          	lw	a5,-20(s0)
8000902c:	0007ac23          	sw	zero,24(a5)
}
80009030:	0001                	nop
80009032:	4472                	lw	s0,28(sp)
80009034:	6105                	addi	sp,sp,32
80009036:	8082                	ret

80009038 <memcpy>:
80009038:	832a                	mv	t1,a0
8000903a:	ca09                	beqz	a2,8000904c <memcpy+0x14>
8000903c:	00058383          	lb	t2,0(a1)
80009040:	00730023          	sb	t2,0(t1)
80009044:	167d                	addi	a2,a2,-1 # 3000ffff <STACK_SIZE+0x3000f7ff>
80009046:	0305                	addi	t1,t1,1
80009048:	0585                	addi	a1,a1,1
8000904a:	fa6d                	bnez	a2,8000903c <memcpy+0x4>
8000904c:	8082                	ret

8000904e <memset>:
8000904e:	832a                	mv	t1,a0
80009050:	c611                	beqz	a2,8000905c <memset+0xe>
80009052:	00b30023          	sb	a1,0(t1)
80009056:	167d                	addi	a2,a2,-1
80009058:	0305                	addi	t1,t1,1
8000905a:	fe65                	bnez	a2,80009052 <memset+0x4>
8000905c:	8082                	ret

8000905e <__udivdi3>:
8000905e:	8832                	mv	a6,a2
80009060:	88aa                	mv	a7,a0
80009062:	872e                	mv	a4,a1
80009064:	eec5                	bnez	a3,8000911c <__udivdi3+0xbe>
80009066:	10c5f363          	bgeu	a1,a2,8000916c <__udivdi3+0x10e>
8000906a:	67c1                	lui	a5,0x10
8000906c:	1af66063          	bltu	a2,a5,8000920c <__udivdi3+0x1ae>
80009070:	010007b7          	lui	a5,0x1000
80009074:	00f637b3          	sltu	a5,a2,a5
80009078:	40f007b3          	neg	a5,a5
8000907c:	9be1                	andi	a5,a5,-8
8000907e:	07e1                	addi	a5,a5,24 # 1000018 <STACK_SIZE+0xfff818>
80009080:	00f65333          	srl	t1,a2,a5
80009084:	00001697          	auipc	a3,0x1
80009088:	88868693          	addi	a3,a3,-1912 # 8000990c <__clz_tab>
8000908c:	969a                	add	a3,a3,t1
8000908e:	0006c683          	lbu	a3,0(a3)
80009092:	02000313          	li	t1,32
80009096:	97b6                	add	a5,a5,a3
80009098:	40f306b3          	sub	a3,t1,a5
8000909c:	00f30b63          	beq	t1,a5,800090b2 <__udivdi3+0x54>
800090a0:	00d59733          	sll	a4,a1,a3
800090a4:	00f557b3          	srl	a5,a0,a5
800090a8:	00d61833          	sll	a6,a2,a3
800090ac:	8f5d                	or	a4,a4,a5
800090ae:	00d518b3          	sll	a7,a0,a3
800090b2:	01085613          	srli	a2,a6,0x10
800090b6:	02c75533          	divu	a0,a4,a2
800090ba:	01081693          	slli	a3,a6,0x10
800090be:	82c1                	srli	a3,a3,0x10
800090c0:	0108d793          	srli	a5,a7,0x10
800090c4:	02c77733          	remu	a4,a4,a2
800090c8:	02a685b3          	mul	a1,a3,a0
800090cc:	0742                	slli	a4,a4,0x10
800090ce:	8fd9                	or	a5,a5,a4
800090d0:	00b7fa63          	bgeu	a5,a1,800090e4 <__udivdi3+0x86>
800090d4:	97c2                	add	a5,a5,a6
800090d6:	fff50713          	addi	a4,a0,-1 # 27ffffff <STACK_SIZE+0x27fff7ff>
800090da:	0107e463          	bltu	a5,a6,800090e2 <__udivdi3+0x84>
800090de:	32b7e163          	bltu	a5,a1,80009400 <__udivdi3+0x3a2>
800090e2:	853a                	mv	a0,a4
800090e4:	8f8d                	sub	a5,a5,a1
800090e6:	02c7d733          	divu	a4,a5,a2
800090ea:	08c2                	slli	a7,a7,0x10
800090ec:	0108d893          	srli	a7,a7,0x10
800090f0:	02c7f7b3          	remu	a5,a5,a2
800090f4:	02e686b3          	mul	a3,a3,a4
800090f8:	07c2                	slli	a5,a5,0x10
800090fa:	00f8e8b3          	or	a7,a7,a5
800090fe:	00d8fb63          	bgeu	a7,a3,80009114 <__udivdi3+0xb6>
80009102:	98c2                	add	a7,a7,a6
80009104:	fff70793          	addi	a5,a4,-1
80009108:	0108e563          	bltu	a7,a6,80009112 <__udivdi3+0xb4>
8000910c:	1779                	addi	a4,a4,-2
8000910e:	00d8e363          	bltu	a7,a3,80009114 <__udivdi3+0xb6>
80009112:	873e                	mv	a4,a5
80009114:	0542                	slli	a0,a0,0x10
80009116:	8d59                	or	a0,a0,a4
80009118:	4581                	li	a1,0
8000911a:	8082                	ret
8000911c:	00d5f563          	bgeu	a1,a3,80009126 <__udivdi3+0xc8>
80009120:	4581                	li	a1,0
80009122:	4501                	li	a0,0
80009124:	8082                	ret
80009126:	67c1                	lui	a5,0x10
80009128:	18f6ea63          	bltu	a3,a5,800092bc <__udivdi3+0x25e>
8000912c:	010007b7          	lui	a5,0x1000
80009130:	00f6b7b3          	sltu	a5,a3,a5
80009134:	40f007b3          	neg	a5,a5
80009138:	9be1                	andi	a5,a5,-8
8000913a:	07e1                	addi	a5,a5,24 # 1000018 <STACK_SIZE+0xfff818>
8000913c:	00f6d833          	srl	a6,a3,a5
80009140:	00000717          	auipc	a4,0x0
80009144:	7cc70713          	addi	a4,a4,1996 # 8000990c <__clz_tab>
80009148:	9742                	add	a4,a4,a6
8000914a:	00074703          	lbu	a4,0(a4)
8000914e:	02000893          	li	a7,32
80009152:	973e                	add	a4,a4,a5
80009154:	40e88833          	sub	a6,a7,a4
80009158:	18e89763          	bne	a7,a4,800092e6 <__udivdi3+0x288>
8000915c:	28b6e463          	bltu	a3,a1,800093e4 <__udivdi3+0x386>
80009160:	00c53533          	sltu	a0,a0,a2
80009164:	00154513          	xori	a0,a0,1
80009168:	4581                	li	a1,0
8000916a:	8082                	ret
8000916c:	c655                	beqz	a2,80009218 <__udivdi3+0x1ba>
8000916e:	67c1                	lui	a5,0x10
80009170:	26f67263          	bgeu	a2,a5,800093d4 <__udivdi3+0x376>
80009174:	10063713          	sltiu	a4,a2,256
80009178:	00174713          	xori	a4,a4,1
8000917c:	070e                	slli	a4,a4,0x3
8000917e:	00e656b3          	srl	a3,a2,a4
80009182:	00000797          	auipc	a5,0x0
80009186:	78a78793          	addi	a5,a5,1930 # 8000990c <__clz_tab>
8000918a:	97b6                	add	a5,a5,a3
8000918c:	0007c783          	lbu	a5,0(a5)
80009190:	02000693          	li	a3,32
80009194:	97ba                	add	a5,a5,a4
80009196:	40f68eb3          	sub	t4,a3,a5
8000919a:	08f69f63          	bne	a3,a5,80009238 <__udivdi3+0x1da>
8000919e:	40c587b3          	sub	a5,a1,a2
800091a2:	01065693          	srli	a3,a2,0x10
800091a6:	0642                	slli	a2,a2,0x10
800091a8:	8241                	srli	a2,a2,0x10
800091aa:	4585                	li	a1,1
800091ac:	02d7d533          	divu	a0,a5,a3
800091b0:	0108d713          	srli	a4,a7,0x10
800091b4:	02d7f7b3          	remu	a5,a5,a3
800091b8:	02c50333          	mul	t1,a0,a2
800091bc:	07c2                	slli	a5,a5,0x10
800091be:	8fd9                	or	a5,a5,a4
800091c0:	0067fa63          	bgeu	a5,t1,800091d4 <__udivdi3+0x176>
800091c4:	97c2                	add	a5,a5,a6
800091c6:	fff50713          	addi	a4,a0,-1
800091ca:	0107e463          	bltu	a5,a6,800091d2 <__udivdi3+0x174>
800091ce:	2267e663          	bltu	a5,t1,800093fa <__udivdi3+0x39c>
800091d2:	853a                	mv	a0,a4
800091d4:	406787b3          	sub	a5,a5,t1
800091d8:	02d7d733          	divu	a4,a5,a3
800091dc:	08c2                	slli	a7,a7,0x10
800091de:	0108d893          	srli	a7,a7,0x10
800091e2:	02d7f7b3          	remu	a5,a5,a3
800091e6:	02c70633          	mul	a2,a4,a2
800091ea:	07c2                	slli	a5,a5,0x10
800091ec:	00f8e8b3          	or	a7,a7,a5
800091f0:	00c8fb63          	bgeu	a7,a2,80009206 <__udivdi3+0x1a8>
800091f4:	98c2                	add	a7,a7,a6
800091f6:	fff70793          	addi	a5,a4,-1
800091fa:	0108e563          	bltu	a7,a6,80009204 <__udivdi3+0x1a6>
800091fe:	1779                	addi	a4,a4,-2
80009200:	00c8e363          	bltu	a7,a2,80009206 <__udivdi3+0x1a8>
80009204:	873e                	mv	a4,a5
80009206:	0542                	slli	a0,a0,0x10
80009208:	8d59                	or	a0,a0,a4
8000920a:	8082                	ret
8000920c:	10063793          	sltiu	a5,a2,256
80009210:	0017c793          	xori	a5,a5,1
80009214:	078e                	slli	a5,a5,0x3
80009216:	b5ad                	j	80009080 <__udivdi3+0x22>
80009218:	4681                	li	a3,0
8000921a:	00000797          	auipc	a5,0x0
8000921e:	6f278793          	addi	a5,a5,1778 # 8000990c <__clz_tab>
80009222:	97b6                	add	a5,a5,a3
80009224:	0007c783          	lbu	a5,0(a5)
80009228:	4701                	li	a4,0
8000922a:	02000693          	li	a3,32
8000922e:	97ba                	add	a5,a5,a4
80009230:	40f68eb3          	sub	t4,a3,a5
80009234:	f6f685e3          	beq	a3,a5,8000919e <__udivdi3+0x140>
80009238:	01d61833          	sll	a6,a2,t4
8000923c:	00f5d333          	srl	t1,a1,a5
80009240:	01085693          	srli	a3,a6,0x10
80009244:	02d35e33          	divu	t3,t1,a3
80009248:	01081613          	slli	a2,a6,0x10
8000924c:	01d595b3          	sll	a1,a1,t4
80009250:	8241                	srli	a2,a2,0x10
80009252:	00f557b3          	srl	a5,a0,a5
80009256:	8fcd                	or	a5,a5,a1
80009258:	0107d713          	srli	a4,a5,0x10
8000925c:	01d518b3          	sll	a7,a0,t4
80009260:	02d37333          	remu	t1,t1,a3
80009264:	03c605b3          	mul	a1,a2,t3
80009268:	0342                	slli	t1,t1,0x10
8000926a:	00676733          	or	a4,a4,t1
8000926e:	00b77b63          	bgeu	a4,a1,80009284 <__udivdi3+0x226>
80009272:	9742                	add	a4,a4,a6
80009274:	fffe0513          	addi	a0,t3,-1
80009278:	17076d63          	bltu	a4,a6,800093f2 <__udivdi3+0x394>
8000927c:	16b77b63          	bgeu	a4,a1,800093f2 <__udivdi3+0x394>
80009280:	1e79                	addi	t3,t3,-2
80009282:	9742                	add	a4,a4,a6
80009284:	8f0d                	sub	a4,a4,a1
80009286:	02d75533          	divu	a0,a4,a3
8000928a:	07c2                	slli	a5,a5,0x10
8000928c:	83c1                	srli	a5,a5,0x10
8000928e:	02d77733          	remu	a4,a4,a3
80009292:	02a60333          	mul	t1,a2,a0
80009296:	0742                	slli	a4,a4,0x10
80009298:	8fd9                	or	a5,a5,a4
8000929a:	0067fb63          	bgeu	a5,t1,800092b0 <__udivdi3+0x252>
8000929e:	97c2                	add	a5,a5,a6
800092a0:	fff50713          	addi	a4,a0,-1
800092a4:	1507e363          	bltu	a5,a6,800093ea <__udivdi3+0x38c>
800092a8:	1467f163          	bgeu	a5,t1,800093ea <__udivdi3+0x38c>
800092ac:	1579                	addi	a0,a0,-2
800092ae:	97c2                	add	a5,a5,a6
800092b0:	010e1593          	slli	a1,t3,0x10
800092b4:	406787b3          	sub	a5,a5,t1
800092b8:	8dc9                	or	a1,a1,a0
800092ba:	bdcd                	j	800091ac <__udivdi3+0x14e>
800092bc:	1006b793          	sltiu	a5,a3,256
800092c0:	0017c793          	xori	a5,a5,1
800092c4:	078e                	slli	a5,a5,0x3
800092c6:	00f6d833          	srl	a6,a3,a5
800092ca:	00000717          	auipc	a4,0x0
800092ce:	64270713          	addi	a4,a4,1602 # 8000990c <__clz_tab>
800092d2:	9742                	add	a4,a4,a6
800092d4:	00074703          	lbu	a4,0(a4)
800092d8:	02000893          	li	a7,32
800092dc:	973e                	add	a4,a4,a5
800092de:	40e88833          	sub	a6,a7,a4
800092e2:	e6e88de3          	beq	a7,a4,8000915c <__udivdi3+0xfe>
800092e6:	00e65e33          	srl	t3,a2,a4
800092ea:	010696b3          	sll	a3,a3,a6
800092ee:	00de6e33          	or	t3,t3,a3
800092f2:	00e5d8b3          	srl	a7,a1,a4
800092f6:	010e5e93          	srli	t4,t3,0x10
800092fa:	03d8d7b3          	divu	a5,a7,t4
800092fe:	010e1313          	slli	t1,t3,0x10
80009302:	010595b3          	sll	a1,a1,a6
80009306:	01035313          	srli	t1,t1,0x10
8000930a:	00e55733          	srl	a4,a0,a4
8000930e:	8f4d                	or	a4,a4,a1
80009310:	01075693          	srli	a3,a4,0x10
80009314:	01061633          	sll	a2,a2,a6
80009318:	03d8f8b3          	remu	a7,a7,t4
8000931c:	02f305b3          	mul	a1,t1,a5
80009320:	08c2                	slli	a7,a7,0x10
80009322:	0116e6b3          	or	a3,a3,a7
80009326:	00b6fb63          	bgeu	a3,a1,8000933c <__udivdi3+0x2de>
8000932a:	96f2                	add	a3,a3,t3
8000932c:	fff78893          	addi	a7,a5,-1
80009330:	0dc6e363          	bltu	a3,t3,800093f6 <__udivdi3+0x398>
80009334:	0cb6f163          	bgeu	a3,a1,800093f6 <__udivdi3+0x398>
80009338:	17f9                	addi	a5,a5,-2
8000933a:	96f2                	add	a3,a3,t3
8000933c:	8e8d                	sub	a3,a3,a1
8000933e:	03d6d5b3          	divu	a1,a3,t4
80009342:	0742                	slli	a4,a4,0x10
80009344:	8341                	srli	a4,a4,0x10
80009346:	03d6f6b3          	remu	a3,a3,t4
8000934a:	02b308b3          	mul	a7,t1,a1
8000934e:	06c2                	slli	a3,a3,0x10
80009350:	8f55                	or	a4,a4,a3
80009352:	01177b63          	bgeu	a4,a7,80009368 <__udivdi3+0x30a>
80009356:	9772                	add	a4,a4,t3
80009358:	fff58693          	addi	a3,a1,-1
8000935c:	09c76963          	bltu	a4,t3,800093ee <__udivdi3+0x390>
80009360:	09177763          	bgeu	a4,a7,800093ee <__udivdi3+0x390>
80009364:	15f9                	addi	a1,a1,-2
80009366:	9772                	add	a4,a4,t3
80009368:	07c2                	slli	a5,a5,0x10
8000936a:	6ec1                	lui	t4,0x10
8000936c:	8fcd                	or	a5,a5,a1
8000936e:	fffe8693          	addi	a3,t4,-1 # ffff <STACK_SIZE+0xf7ff>
80009372:	00d7f5b3          	and	a1,a5,a3
80009376:	0107d313          	srli	t1,a5,0x10
8000937a:	8ef1                	and	a3,a3,a2
8000937c:	8241                	srli	a2,a2,0x10
8000937e:	02d58e33          	mul	t3,a1,a3
80009382:	41170733          	sub	a4,a4,a7
80009386:	02d306b3          	mul	a3,t1,a3
8000938a:	010e5893          	srli	a7,t3,0x10
8000938e:	02c585b3          	mul	a1,a1,a2
80009392:	95b6                	add	a1,a1,a3
80009394:	95c6                	add	a1,a1,a7
80009396:	02c30333          	mul	t1,t1,a2
8000939a:	00d5f363          	bgeu	a1,a3,800093a0 <__udivdi3+0x342>
8000939e:	9376                	add	t1,t1,t4
800093a0:	0105d693          	srli	a3,a1,0x10
800093a4:	969a                	add	a3,a3,t1
800093a6:	02d76363          	bltu	a4,a3,800093cc <__udivdi3+0x36e>
800093aa:	00d70563          	beq	a4,a3,800093b4 <__udivdi3+0x356>
800093ae:	853e                	mv	a0,a5
800093b0:	4581                	li	a1,0
800093b2:	8082                	ret
800093b4:	66c1                	lui	a3,0x10
800093b6:	16fd                	addi	a3,a3,-1 # ffff <STACK_SIZE+0xf7ff>
800093b8:	00d5f733          	and	a4,a1,a3
800093bc:	0742                	slli	a4,a4,0x10
800093be:	00de7e33          	and	t3,t3,a3
800093c2:	01051533          	sll	a0,a0,a6
800093c6:	9772                	add	a4,a4,t3
800093c8:	fee573e3          	bgeu	a0,a4,800093ae <__udivdi3+0x350>
800093cc:	fff78513          	addi	a0,a5,-1
800093d0:	4581                	li	a1,0
800093d2:	8082                	ret
800093d4:	010007b7          	lui	a5,0x1000
800093d8:	02f67763          	bgeu	a2,a5,80009406 <__udivdi3+0x3a8>
800093dc:	01065693          	srli	a3,a2,0x10
800093e0:	4741                	li	a4,16
800093e2:	b345                	j	80009182 <__udivdi3+0x124>
800093e4:	4581                	li	a1,0
800093e6:	4505                	li	a0,1
800093e8:	8082                	ret
800093ea:	853a                	mv	a0,a4
800093ec:	b5d1                	j	800092b0 <__udivdi3+0x252>
800093ee:	85b6                	mv	a1,a3
800093f0:	bfa5                	j	80009368 <__udivdi3+0x30a>
800093f2:	8e2a                	mv	t3,a0
800093f4:	bd41                	j	80009284 <__udivdi3+0x226>
800093f6:	87c6                	mv	a5,a7
800093f8:	b791                	j	8000933c <__udivdi3+0x2de>
800093fa:	1579                	addi	a0,a0,-2
800093fc:	97c2                	add	a5,a5,a6
800093fe:	bbd9                	j	800091d4 <__udivdi3+0x176>
80009400:	1579                	addi	a0,a0,-2
80009402:	97c2                	add	a5,a5,a6
80009404:	b1c5                	j	800090e4 <__udivdi3+0x86>
80009406:	01865693          	srli	a3,a2,0x18
8000940a:	4761                	li	a4,24
8000940c:	bb9d                	j	80009182 <__udivdi3+0x124>
