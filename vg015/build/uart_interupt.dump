
build/uart_interupt.elf:     file format elf32-littleriscv


Disassembly of section .text.startup:

80000000 <_start>:
    .section ".startup.entry","ax",@progbits

    ## Entry point
_start:
    ## reset mstatus
    csrw  mstatus, zero
80000000:	30001073          	csrw	mstatus,zero
li x31, 0
#endif // !__riscv_32e
#endif // PLF_INIT_REGS

    ## setup gp
    load_addrword_abs gp, __global_pointer$
80000004:	400001b7          	lui	gp,0x40000
80000008:	78018193          	addi	gp,gp,1920 # 40000780 <__global_pointer$>
    ## setup MTVEC
    load_addrword_abs t0, trap_entry
8000000c:	800002b7          	lui	t0,0x80000
80000010:	14028293          	addi	t0,t0,320 # 80000140 <__data_source_start+0xffff72ec>
    csrw  mtvec, t0
80000014:	30529073          	csrw	mtvec,t0
    ## setup MIE, MIP


    csrw  mie, zero
80000018:	30401073          	csrw	mie,zero
    csrw  mip, zero
8000001c:	34401073          	csrw	mip,zero
    load_const_int32 t1, __TEXT_INIT_SIZE__
    cache_flush t0, t1
#endif // PLF_CACHE_CFG

    ## init FPU (if supported)
    csrr  a0, misa
80000020:	30102573          	csrr	a0,misa
    andi  a0, a0, (1 << ('F' - 'A')) | (1 << ('D' - 'A'))
80000024:	02857513          	andi	a0,a0,40
    beqz  a0, 1f
80000028:	00050863          	beqz	a0,80000038 <_start+0x38>
    li    a0, (1 << 13) // mstatus.FS = 1 (initial)
8000002c:	00002537          	lui	a0,0x2
    csrs  mstatus, a0
80000030:	30052073          	csrs	mstatus,a0
    csrw  fcsr, zero
80000034:	00301073          	fscsr	zero
#else
#define slave_hart_start _hart_halt
#endif // PLF_SMP_SUPPORT

    ## park/prep SMP slaves
    csrr  a0, mhartid
80000038:	f1402573          	csrr	a0,mhartid
#if PLF_SMP_MASTER_HARTID > 0
    li    t0, PLF_SMP_MASTER_HARTID
    bne   a0, t0, slave_hart_start
#endif // PLF_SMP_MASTER_HARTID > 0
#else // PLF_SMP_MASTER_HARTID
    bnez  a0, slave_hart_start
8000003c:	04051463          	bnez	a0,80000084 <_hart_halt>
#endif // PLF_SMP_MASTER_HARTID

    ## init HART#0 sp, tp
    load_addrword_abs sp, __TLS0_BASE__
80000040:	40040137          	lui	sp,0x40040
80000044:	00010113          	mv	sp,sp
    mv    tp, sp
80000048:	00010213          	mv	tp,sp
    csrw  mscratch, sp
8000004c:	34011073          	csrw	mscratch,sp
    // reserve trap stack space
    li    t0, PLF_TRAP_STACK
    sub   sp, sp, t0
#endif // PLF_TRAP_STACK
    ## platform init
    load_addrword t0, plf_init
80000050:	800002b7          	lui	t0,0x80000
80000054:	0ae28293          	addi	t0,t0,174 # 800000ae <__data_source_start+0xffff725a>
    jalr  t0
80000058:	000280e7          	jalr	t0
    ## jal  plf_init
    ## application-specific initialization hook
    load_addrword t0, app_init
8000005c:	800002b7          	lui	t0,0x80000
80000060:	09c28293          	addi	t0,t0,156 # 8000009c <__data_source_start+0xffff7248>
    jalr  t0
80000064:	000280e7          	jalr	t0
    ## jal  app_init
    ## main() args
    li    a0, 0
80000068:	00000513          	li	a0,0
    li    a1, 0
8000006c:	00000593          	li	a1,0
#if PLF_SMP_NON_COHERENT
    clflush t1
#endif // PLF_SMP_NON_COHERENT
#endif // PLF_SMP_SUPPORT
    ## start main
    load_addrword t0, main
80000070:	800032b7          	lui	t0,0x80003
80000074:	e0228293          	addi	t0,t0,-510 # 80002e02 <__data_source_start+0xffff9fae>
    load_addrword ra, exit
80000078:	800000b7          	lui	ra,0x80000
8000007c:	09408093          	addi	ra,ra,148 # 80000094 <__data_source_start+0xffff7240>
    jr    t0
80000080:	00028067          	jr	t0

80000084 <_hart_halt>:
1:  wfi
    j     1b
#endif // PLF_SMP_SUPPORT
#else // PLF_HTIF_BASE
    ## disable interrupts
    csrci mstatus, 0xf
80000084:	3007f073          	csrci	mstatus,15
    csrw  mie, zero
80000088:	30401073          	csrw	mie,zero
1:  wfi
8000008c:	10500073          	wfi
    j     1b
80000090:	ffdff06f          	j	8000008c <_hart_halt+0x8>

80000094 <exit>:
#endif // PLF_HTIF_BASE

exit:
    nop
80000094:	00000013          	nop

80000098 <abort>:
abort:
    j     _hart_halt
80000098:	fedff06f          	j	80000084 <_hart_halt>

8000009c <app_init>:
    jr    t0
#endif // PLF_SMP_SUPPORT

    ## stubs
app_init:
    ret
8000009c:	00008067          	ret

800000a0 <plf_init_noreloc>:
extern void plf_init_relocate(void) __attribute__((weak));

extern char __bss_start[], __bss_end[];

void __init plf_init_noreloc(void)
{
800000a0:	1141                	addi	sp,sp,-16 # 4003fff0 <__STACK_START__+0x7f0>
800000a2:	c622                	sw	s0,12(sp)
800000a4:	0800                	addi	s0,sp,16
    // do nothing
}
800000a6:	0001                	nop
800000a8:	4432                	lw	s0,12(sp)
800000aa:	0141                	addi	sp,sp,16
800000ac:	8082                	ret

800000ae <plf_init_generic>:

void __init plf_init_generic(void)
{
800000ae:	1141                	addi	sp,sp,-16
800000b0:	c606                	sw	ra,12(sp)
800000b2:	c422                	sw	s0,8(sp)
800000b4:	0800                	addi	s0,sp,16
    // init BSS
    memset(__bss_start, 0, (size_t)(__bss_end - __bss_start));
800000b6:	f2018713          	addi	a4,gp,-224 # 400006a0 <__BSS_END__>
800000ba:	e1818793          	addi	a5,gp,-488 # 40000598 <SystemCoreClock>
800000be:	40f707b3          	sub	a5,a4,a5
800000c2:	863e                	mv	a2,a5
800000c4:	4581                	li	a1,0
800000c6:	e1818513          	addi	a0,gp,-488 # 40000598 <SystemCoreClock>
800000ca:	111080ef          	jal	ra,800089da <memset>

    memcpy((void*)&__data_target_start,
           (const void*)&__data_source_start,
           (&__data_target_end - &__data_target_start));
800000ce:	e1818713          	addi	a4,gp,-488 # 40000598 <SystemCoreClock>
800000d2:	89018793          	addi	a5,gp,-1904 # 40000010 <mach_plic_handler>
800000d6:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__data_target_start,
800000da:	863e                	mv	a2,a5
800000dc:	800097b7          	lui	a5,0x80009
800000e0:	e5478593          	addi	a1,a5,-428 # 80008e54 <__data_source_start+0x0>
800000e4:	89018513          	addi	a0,gp,-1904 # 40000010 <mach_plic_handler>
800000e8:	0dd080ef          	jal	ra,800089c4 <memcpy>

    memcpy((void*)&__sdata_target_start,
              (const void*)&__sdata_source_start,
              (&__sdata_target_end - &__sdata_target_start));
800000ec:	88c18713          	addi	a4,gp,-1908 # 4000000c <__sdata_target_end>
800000f0:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
800000f4:	40f707b3          	sub	a5,a4,a5
    memcpy((void*)&__sdata_target_start,
800000f8:	863e                	mv	a2,a5
800000fa:	800097b7          	lui	a5,0x80009
800000fe:	e4878593          	addi	a1,a5,-440 # 80008e48 <__data_source_start+0xfffffff4>
80000102:	88018513          	addi	a0,gp,-1920 # 40000000 <g_btn_last_state>
80000106:	0bf080ef          	jal	ra,800089c4 <memcpy>
}
8000010a:	0001                	nop
8000010c:	40b2                	lw	ra,12(sp)
8000010e:	4422                	lw	s0,8(sp)
80000110:	0141                	addi	sp,sp,16
80000112:	8082                	ret

Disassembly of section .text.crt:

80000140 <trap_entry>:
    .section ".text.crt.trap_entry","ax",@progbits
    .align 6
    .type trap_entry, @function
trap_entry:
    ## save context
    context_save
80000140:	fe512e23          	sw	t0,-4(sp)
80000144:	00010293          	mv	t0,sp
80000148:	f8010113          	addi	sp,sp,-128
8000014c:	ff017113          	andi	sp,sp,-16
80000150:	00112223          	sw	ra,4(sp)
80000154:	00512423          	sw	t0,8(sp)
80000158:	ffc2a283          	lw	t0,-4(t0)
8000015c:	00312623          	sw	gp,12(sp)
80000160:	00412823          	sw	tp,16(sp)
80000164:	00512a23          	sw	t0,20(sp)
80000168:	00612c23          	sw	t1,24(sp)
8000016c:	00712e23          	sw	t2,28(sp)
80000170:	02812023          	sw	s0,32(sp)
80000174:	02912223          	sw	s1,36(sp)
80000178:	02a12423          	sw	a0,40(sp)
8000017c:	02b12623          	sw	a1,44(sp)
80000180:	02c12823          	sw	a2,48(sp)
80000184:	02d12a23          	sw	a3,52(sp)
80000188:	02e12c23          	sw	a4,56(sp)
8000018c:	02f12e23          	sw	a5,60(sp)
80000190:	05012023          	sw	a6,64(sp)
80000194:	05112223          	sw	a7,68(sp)
80000198:	05212423          	sw	s2,72(sp)
8000019c:	05312623          	sw	s3,76(sp)
800001a0:	05412823          	sw	s4,80(sp)
800001a4:	05512a23          	sw	s5,84(sp)
800001a8:	05612c23          	sw	s6,88(sp)
800001ac:	05712e23          	sw	s7,92(sp)
800001b0:	07812023          	sw	s8,96(sp)
800001b4:	07912223          	sw	s9,100(sp)
800001b8:	07a12423          	sw	s10,104(sp)
800001bc:	07b12623          	sw	s11,108(sp)
800001c0:	07c12823          	sw	t3,112(sp)
800001c4:	07d12a23          	sw	t4,116(sp)
800001c8:	07e12c23          	sw	t5,120(sp)
800001cc:	07f12e23          	sw	t6,124(sp)
800001d0:	34002273          	csrr	tp,mscratch
800001d4:	34102373          	csrr	t1,mepc
800001d8:	00612023          	sw	t1,0(sp)
    ## save mstatus priv stack
    csrr s0, mstatus
800001dc:	30002473          	csrr	s0,mstatus
    ## load trap handler args
    csrr a0, mcause
800001e0:	34202573          	csrr	a0,mcause
    csrr a1, mepc
800001e4:	341025f3          	csrr	a1,mepc
    mv   a2, sp
800001e8:	00010613          	mv	a2,sp

    ## setup gp
    load_addrword_abs gp, __global_pointer$
800001ec:	400001b7          	lui	gp,0x40000
800001f0:	78018193          	addi	gp,gp,1920 # 40000780 <__global_pointer$>
    ## call trap handler
    load_addrword t0, trap_handler
800001f4:	800012b7          	lui	t0,0x80001
800001f8:	cfc28293          	addi	t0,t0,-772 # 80000cfc <__data_source_start+0xffff7ea8>
    jalr t0
800001fc:	000280e7          	jalr	t0

    ## restore mstatus priv stack
    csrw mstatus, s0
80000200:	30041073          	csrw	mstatus,s0
    ## restore context
    context_restore
80000204:	00012303          	lw	t1,0(sp)
80000208:	34131073          	csrw	mepc,t1
8000020c:	00c12183          	lw	gp,12(sp)
80000210:	01012203          	lw	tp,16(sp)
80000214:	01412283          	lw	t0,20(sp)
80000218:	01812303          	lw	t1,24(sp)
8000021c:	01c12383          	lw	t2,28(sp)
80000220:	02012403          	lw	s0,32(sp)
80000224:	02412483          	lw	s1,36(sp)
80000228:	02812503          	lw	a0,40(sp)
8000022c:	02c12583          	lw	a1,44(sp)
80000230:	03012603          	lw	a2,48(sp)
80000234:	03412683          	lw	a3,52(sp)
80000238:	03812703          	lw	a4,56(sp)
8000023c:	03c12783          	lw	a5,60(sp)
80000240:	04012803          	lw	a6,64(sp)
80000244:	04412883          	lw	a7,68(sp)
80000248:	04812903          	lw	s2,72(sp)
8000024c:	04c12983          	lw	s3,76(sp)
80000250:	05012a03          	lw	s4,80(sp)
80000254:	05412a83          	lw	s5,84(sp)
80000258:	05812b03          	lw	s6,88(sp)
8000025c:	05c12b83          	lw	s7,92(sp)
80000260:	06012c03          	lw	s8,96(sp)
80000264:	06412c83          	lw	s9,100(sp)
80000268:	06812d03          	lw	s10,104(sp)
8000026c:	06c12d83          	lw	s11,108(sp)
80000270:	07012e03          	lw	t3,112(sp)
80000274:	07412e83          	lw	t4,116(sp)
80000278:	07812f03          	lw	t5,120(sp)
8000027c:	07c12f83          	lw	t6,124(sp)
80000280:	00412083          	lw	ra,4(sp)
80000284:	00812103          	lw	sp,8(sp)
    mret
80000288:	30200073          	mret
	...

Disassembly of section .text:

800002c4 <ADCSAR_SEQ_SwStartEnCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SwStartEnCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
800002c4:	1101                	addi	sp,sp,-32
800002c6:	ce22                	sw	s0,28(sp)
800002c8:	1000                	addi	s0,sp,32
800002ca:	fea42623          	sw	a0,-20(s0)
800002ce:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQSYNC, 1 << (uint32_t)SEQ_Num, State << (uint32_t)SEQ_Num);
800002d2:	300107b7          	lui	a5,0x30010
800002d6:	43dc                	lw	a5,4(a5)
800002d8:	fec42703          	lw	a4,-20(s0)
800002dc:	4685                	li	a3,1
800002de:	00e69733          	sll	a4,a3,a4
800002e2:	fff74713          	not	a4,a4
800002e6:	00e7f6b3          	and	a3,a5,a4
800002ea:	fec42783          	lw	a5,-20(s0)
800002ee:	fe842703          	lw	a4,-24(s0)
800002f2:	00f71733          	sll	a4,a4,a5
800002f6:	300107b7          	lui	a5,0x30010
800002fa:	8f55                	or	a4,a4,a3
800002fc:	c3d8                	sw	a4,4(a5)
}
800002fe:	0001                	nop
80000300:	4472                	lw	s0,28(sp)
80000302:	6105                	addi	sp,sp,32
80000304:	8082                	ret

80000306 <ADCSAR_SEQ_SwStartCmd>:
/**
  * @brief   Генерация импульса программного запуска
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SwStartCmd(void)
{
80000306:	1141                	addi	sp,sp,-16
80000308:	c622                	sw	s0,12(sp)
8000030a:	0800                	addi	s0,sp,16
    WRITE_REG(ADCSAR->SEQSYNC_bit.GSYNC, 1);
8000030c:	300107b7          	lui	a5,0x30010
80000310:	43d4                	lw	a3,4(a5)
80000312:	80000737          	lui	a4,0x80000
80000316:	8f55                	or	a4,a4,a3
80000318:	c3d8                	sw	a4,4(a5)
}
8000031a:	0001                	nop
8000031c:	4432                	lw	s0,12(sp)
8000031e:	0141                	addi	sp,sp,16
80000320:	8082                	ret

80000322 <ADCSAR_SEQ_FIFOFullStatusClear>:
  * @brief   Сброс статуса заполнения буфера секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_FIFOFullStatusClear(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
80000322:	1101                	addi	sp,sp,-32
80000324:	ce22                	sw	s0,28(sp)
80000326:	1000                	addi	s0,sp,32
80000328:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    WRITE_REG(ADCSAR->FSTAT, 1 << ((uint32_t)SEQ_Num + ADCSAR_FSTAT_OV0_Pos));
8000032c:	fec42783          	lw	a5,-20(s0)
80000330:	4705                	li	a4,1
80000332:	00f71733          	sll	a4,a4,a5
80000336:	300107b7          	lui	a5,0x30010
8000033a:	c798                	sw	a4,8(a5)
}
8000033c:	0001                	nop
8000033e:	4472                	lw	s0,28(sp)
80000340:	6105                	addi	sp,sp,32
80000342:	8082                	ret

80000344 <ADCSAR_SEQ_FIFOEmptyStatusClear>:
  * @brief   Сброс статуса пустоты буфера секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_FIFOEmptyStatusClear(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
80000344:	1101                	addi	sp,sp,-32
80000346:	ce22                	sw	s0,28(sp)
80000348:	1000                	addi	s0,sp,32
8000034a:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    WRITE_REG(ADCSAR->FSTAT, 1 << ((uint32_t)SEQ_Num + ADCSAR_FSTAT_UN0_Pos));
8000034e:	fec42783          	lw	a5,-20(s0)
80000352:	07a1                	addi	a5,a5,8 # 30010008 <STACK_SIZE+0x3000f808>
80000354:	4705                	li	a4,1
80000356:	00f71733          	sll	a4,a4,a5
8000035a:	300107b7          	lui	a5,0x30010
8000035e:	c798                	sw	a4,8(a5)
}
80000360:	0001                	nop
80000362:	4472                	lw	s0,28(sp)
80000364:	6105                	addi	sp,sp,32
80000366:	8082                	ret

80000368 <ADCSAR_SEQ_StartEventConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   StartEvent  Выбор события
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_StartEventConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_StartEvent_TypeDef StartEvent)
{
80000368:	1101                	addi	sp,sp,-32
8000036a:	ce22                	sw	s0,28(sp)
8000036c:	1000                	addi	s0,sp,32
8000036e:	fea42623          	sw	a0,-20(s0)
80000372:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    MODIFY_REG(ADCSAR->EMUX, 0xF << ((uint32_t)SEQ_Num * 4), StartEvent << ((uint32_t)SEQ_Num * 4));
80000376:	300107b7          	lui	a5,0x30010
8000037a:	4fdc                	lw	a5,28(a5)
8000037c:	fec42703          	lw	a4,-20(s0)
80000380:	070a                	slli	a4,a4,0x2
80000382:	46bd                	li	a3,15
80000384:	00e69733          	sll	a4,a3,a4
80000388:	fff74713          	not	a4,a4
8000038c:	00e7f6b3          	and	a3,a5,a4
80000390:	fec42783          	lw	a5,-20(s0)
80000394:	078a                	slli	a5,a5,0x2
80000396:	fe842703          	lw	a4,-24(s0)
8000039a:	00f71733          	sll	a4,a4,a5
8000039e:	300107b7          	lui	a5,0x30010
800003a2:	8f55                	or	a4,a4,a3
800003a4:	cfd8                	sw	a4,28(a5)
}
800003a6:	0001                	nop
800003a8:	4472                	lw	s0,28(sp)
800003aa:	6105                	addi	sp,sp,32
800003ac:	8082                	ret

800003ae <ADCSAR_SEQ_GetFIFOLoad>:
  * @brief   Получение текущего значения количества результатов в буфере секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  Val  Значение
  */
__STATIC_INLINE uint32_t ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
800003ae:	1101                	addi	sp,sp,-32
800003b0:	ce22                	sw	s0,28(sp)
800003b2:	1000                	addi	s0,sp,32
800003b4:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    return READ_REG(ADCSAR->SEQ[SEQ_Num].SFLOAD_bit.VAL);
800003b8:	30010737          	lui	a4,0x30010
800003bc:	fec42783          	lw	a5,-20(s0)
800003c0:	079a                	slli	a5,a5,0x6
800003c2:	97ba                	add	a5,a5,a4
800003c4:	5bfc                	lw	a5,116(a5)
800003c6:	03f7f793          	andi	a5,a5,63
800003ca:	0ff7f793          	zext.b	a5,a5
}
800003ce:	853e                	mv	a0,a5
800003d0:	4472                	lw	s0,28(sp)
800003d2:	6105                	addi	sp,sp,32
800003d4:	8082                	ret

800003d6 <ADCSAR_SEQ_GetFIFOData>:
  * @brief   Получение результата измерения из буфера секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  Val  Значение
  */
__STATIC_INLINE uint32_t ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
800003d6:	1101                	addi	sp,sp,-32
800003d8:	ce22                	sw	s0,28(sp)
800003da:	1000                	addi	s0,sp,32
800003dc:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    return READ_REG(ADCSAR->SEQ[SEQ_Num].SFIFO_bit.DATA);
800003e0:	30010737          	lui	a4,0x30010
800003e4:	fec42783          	lw	a5,-20(s0)
800003e8:	079a                	slli	a5,a5,0x6
800003ea:	97ba                	add	a5,a5,a4
800003ec:	5fbc                	lw	a5,120(a5)
800003ee:	873e                	mv	a4,a5
800003f0:	6785                	lui	a5,0x1
800003f2:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
800003f4:	8ff9                	and	a5,a5,a4
800003f6:	07c2                	slli	a5,a5,0x10
800003f8:	83c1                	srli	a5,a5,0x10
}
800003fa:	853e                	mv	a0,a5
800003fc:	4472                	lw	s0,28(sp)
800003fe:	6105                	addi	sp,sp,32
80000400:	8082                	ret

80000402 <ADCSAR_SEQ_ITCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ITCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80000402:	1101                	addi	sp,sp,-32
80000404:	ce22                	sw	s0,28(sp)
80000406:	1000                	addi	s0,sp,32
80000408:	fea42623          	sw	a0,-20(s0)
8000040c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->IM, 1 << ((uint32_t)SEQ_Num + ADCSAR_IM_SEQIM0_Pos), State << ((uint32_t)SEQ_Num + ADCSAR_IM_SEQIM0_Pos));
80000410:	300107b7          	lui	a5,0x30010
80000414:	53dc                	lw	a5,36(a5)
80000416:	fec42703          	lw	a4,-20(s0)
8000041a:	4685                	li	a3,1
8000041c:	00e69733          	sll	a4,a3,a4
80000420:	fff74713          	not	a4,a4
80000424:	00e7f6b3          	and	a3,a5,a4
80000428:	fec42783          	lw	a5,-20(s0)
8000042c:	fe842703          	lw	a4,-24(s0)
80000430:	00f71733          	sll	a4,a4,a5
80000434:	300107b7          	lui	a5,0x30010
80000438:	8f55                	or	a4,a4,a3
8000043a:	d3d8                	sw	a4,36(a5)
}
8000043c:	0001                	nop
8000043e:	4472                	lw	s0,28(sp)
80000440:	6105                	addi	sp,sp,32
80000442:	8082                	ret

80000444 <ADCSAR_SEQ_ITConfig>:
  *                   0 - по каждому запросу, 0xFF - каждые 256 запросов.
  * @param   ITCountNoRst  Активация режима, где счетчик прерывания не будет сбрасываться по запуску секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ITConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t ITCount, FunctionalState ITCountNoRst)
{
80000444:	1101                	addi	sp,sp,-32
80000446:	ce22                	sw	s0,28(sp)
80000448:	1000                	addi	s0,sp,32
8000044a:	fea42623          	sw	a0,-20(s0)
8000044e:	feb42423          	sw	a1,-24(s0)
80000452:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_IT_COUNT_VAL(ITCount));
    assert_param(IS_FUNCTIONAL_STATE(ITCountNoRst));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.ICNT, ITCount);
80000456:	300106b7          	lui	a3,0x30010
8000045a:	fe842783          	lw	a5,-24(s0)
8000045e:	0ff7f713          	zext.b	a4,a5
80000462:	fec42783          	lw	a5,-20(s0)
80000466:	079a                	slli	a5,a5,0x6
80000468:	97b6                	add	a5,a5,a3
8000046a:	06e78323          	sb	a4,102(a5) # 30010066 <STACK_SIZE+0x3000f866>
    MODIFY_REG(ADCSAR->CICNT, 1 << ((uint32_t)SEQ_Num + ADCSAR_CICNT_ICNT0_Pos), ITCountNoRst << ((uint32_t)SEQ_Num + ADCSAR_CICNT_ICNT0_Pos));
8000046e:	300107b7          	lui	a5,0x30010
80000472:	4f9c                	lw	a5,24(a5)
80000474:	fec42703          	lw	a4,-20(s0)
80000478:	4685                	li	a3,1
8000047a:	00e69733          	sll	a4,a3,a4
8000047e:	fff74713          	not	a4,a4
80000482:	00e7f6b3          	and	a3,a5,a4
80000486:	fec42783          	lw	a5,-20(s0)
8000048a:	fe442703          	lw	a4,-28(s0)
8000048e:	00f71733          	sll	a4,a4,a5
80000492:	300107b7          	lui	a5,0x30010
80000496:	8f55                	or	a4,a4,a3
80000498:	cf98                	sw	a4,24(a5)
}
8000049a:	0001                	nop
8000049c:	4472                	lw	s0,28(sp)
8000049e:	6105                	addi	sp,sp,32
800004a0:	8082                	ret

800004a2 <ADCSAR_SEQ_ITStatusClear>:
  * @brief   Сброс флага прерывания секвенсора
  * @param   SEQ_Num  Выбор секвенсора
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ITStatusClear(ADCSAR_SEQ_Num_TypeDef SEQ_Num)
{
800004a2:	1101                	addi	sp,sp,-32
800004a4:	ce22                	sw	s0,28(sp)
800004a6:	1000                	addi	s0,sp,32
800004a8:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    WRITE_REG(ADCSAR->IC, 1 << ((uint32_t)SEQ_Num + ADCSAR_IC_SEQIC0_Pos));
800004ac:	fec42783          	lw	a5,-20(s0)
800004b0:	4705                	li	a4,1
800004b2:	00f71733          	sll	a4,a4,a5
800004b6:	300107b7          	lui	a5,0x30010
800004ba:	d7d8                	sw	a4,44(a5)
}
800004bc:	0001                	nop
800004be:	4472                	lw	s0,28(sp)
800004c0:	6105                	addi	sp,sp,32
800004c2:	8082                	ret

800004c4 <classify_code_char>:
void ADC_IRQHandler(void);

static volatile uint8_t s_adc_irq_flag = 0;

static char classify_code_char(uint16_t code)
{
800004c4:	1101                	addi	sp,sp,-32
800004c6:	ce22                	sw	s0,28(sp)
800004c8:	1000                	addi	s0,sp,32
800004ca:	87aa                	mv	a5,a0
800004cc:	fef41723          	sh	a5,-18(s0)
    if (code <= ADCSAR_THR_SHORT_MAX) return 'T';
800004d0:	fee45703          	lhu	a4,-18(s0)
800004d4:	03100793          	li	a5,49
800004d8:	00e7e563          	bltu	a5,a4,800004e2 <classify_code_char+0x1e>
800004dc:	05400793          	li	a5,84
800004e0:	a891                	j	80000534 <classify_code_char+0x70>
    if (code >= ADCSAR_THR_TAMPER_MIN) return 'S';
800004e2:	fee45703          	lhu	a4,-18(s0)
800004e6:	0f000793          	li	a5,240
800004ea:	00e7f563          	bgeu	a5,a4,800004f4 <classify_code_char+0x30>
800004ee:	05300793          	li	a5,83
800004f2:	a089                	j	80000534 <classify_code_char+0x70>
    if (code >= ADCSAR_THR_ALARM_MIN && code <= ADCSAR_THR_ALARM_MAX) return 'A';
800004f4:	fee45703          	lhu	a4,-18(s0)
800004f8:	03100793          	li	a5,49
800004fc:	00e7fb63          	bgeu	a5,a4,80000512 <classify_code_char+0x4e>
80000500:	fee45703          	lhu	a4,-18(s0)
80000504:	07800793          	li	a5,120
80000508:	00e7e563          	bltu	a5,a4,80000512 <classify_code_char+0x4e>
8000050c:	04100793          	li	a5,65
80000510:	a015                	j	80000534 <classify_code_char+0x70>
    if (code >= ADCSAR_THR_NORMAL_MIN && code <= ADCSAR_THR_NORMAL_MAX) return 'N';
80000512:	fee45703          	lhu	a4,-18(s0)
80000516:	07800793          	li	a5,120
8000051a:	00e7fb63          	bgeu	a5,a4,80000530 <classify_code_char+0x6c>
8000051e:	fee45703          	lhu	a4,-18(s0)
80000522:	0f000793          	li	a5,240
80000526:	00e7e563          	bltu	a5,a4,80000530 <classify_code_char+0x6c>
8000052a:	04e00793          	li	a5,78
8000052e:	a019                	j	80000534 <classify_code_char+0x70>
    return 'U';
80000530:	05500793          	li	a5,85
}
80000534:	853e                	mv	a0,a5
80000536:	4472                	lw	s0,28(sp)
80000538:	6105                	addi	sp,sp,32
8000053a:	8082                	ret

8000053c <adcsar_classify_code>:

char adcsar_classify_code(uint16_t code)
{
8000053c:	1101                	addi	sp,sp,-32
8000053e:	ce06                	sw	ra,28(sp)
80000540:	cc22                	sw	s0,24(sp)
80000542:	1000                	addi	s0,sp,32
80000544:	87aa                	mv	a5,a0
80000546:	fef41723          	sh	a5,-18(s0)
    return classify_code_char(code);
8000054a:	fee45783          	lhu	a5,-18(s0)
8000054e:	853e                	mv	a0,a5
80000550:	3f95                	jal	800004c4 <classify_code_char>
80000552:	87aa                	mv	a5,a0
}
80000554:	853e                	mv	a0,a5
80000556:	40f2                	lw	ra,28(sp)
80000558:	4462                	lw	s0,24(sp)
8000055a:	6105                	addi	sp,sp,32
8000055c:	8082                	ret

8000055e <state_from_char>:

static adcsar_state_t state_from_char(char c)
{
8000055e:	1101                	addi	sp,sp,-32
80000560:	ce22                	sw	s0,28(sp)
80000562:	1000                	addi	s0,sp,32
80000564:	87aa                	mv	a5,a0
80000566:	fef407a3          	sb	a5,-17(s0)
    switch (c) {
8000056a:	fef44783          	lbu	a5,-17(s0)
8000056e:	05400713          	li	a4,84
80000572:	02e78763          	beq	a5,a4,800005a0 <state_from_char+0x42>
80000576:	05400713          	li	a4,84
8000057a:	02f74b63          	blt	a4,a5,800005b0 <state_from_char+0x52>
8000057e:	05300713          	li	a4,83
80000582:	02e78563          	beq	a5,a4,800005ac <state_from_char+0x4e>
80000586:	05300713          	li	a4,83
8000058a:	02f74363          	blt	a4,a5,800005b0 <state_from_char+0x52>
8000058e:	04100713          	li	a4,65
80000592:	00e78963          	beq	a5,a4,800005a4 <state_from_char+0x46>
80000596:	04e00713          	li	a4,78
8000059a:	00e78763          	beq	a5,a4,800005a8 <state_from_char+0x4a>
8000059e:	a809                	j	800005b0 <state_from_char+0x52>
    case 'T': return ADCSAR_STATE_SHORT;
800005a0:	4785                	li	a5,1
800005a2:	a801                	j	800005b2 <state_from_char+0x54>
    case 'A': return ADCSAR_STATE_ALARM;
800005a4:	4789                	li	a5,2
800005a6:	a031                	j	800005b2 <state_from_char+0x54>
    case 'N': return ADCSAR_STATE_NORMAL;
800005a8:	478d                	li	a5,3
800005aa:	a021                	j	800005b2 <state_from_char+0x54>
    case 'S': return ADCSAR_STATE_TAMPER;
800005ac:	4791                	li	a5,4
800005ae:	a011                	j	800005b2 <state_from_char+0x54>
    default:  return ADCSAR_STATE_UNDEF;
800005b0:	4781                	li	a5,0
    }
}
800005b2:	853e                	mv	a0,a5
800005b4:	4472                	lw	s0,28(sp)
800005b6:	6105                	addi	sp,sp,32
800005b8:	8082                	ret

800005ba <adcsar_init>:

void adcsar_init(void)
{
800005ba:	1101                	addi	sp,sp,-32
800005bc:	ce06                	sw	ra,28(sp)
800005be:	cc22                	sw	s0,24(sp)
800005c0:	1000                	addi	s0,sp,32
    PMUSYS->ADCPWRCFG_bit.LDOEN = 1;
800005c2:	3000f7b7          	lui	a5,0x3000f
800005c6:	0107c703          	lbu	a4,16(a5) # 3000f010 <STACK_SIZE+0x3000e810>
800005ca:	00176713          	ori	a4,a4,1
800005ce:	00e78823          	sb	a4,16(a5)
    PMUSYS->ADCPWRCFG_bit.LVLDIS = 0;
800005d2:	3000f7b7          	lui	a5,0x3000f
800005d6:	0107c703          	lbu	a4,16(a5) # 3000f010 <STACK_SIZE+0x3000e810>
800005da:	9b75                	andi	a4,a4,-3
800005dc:	00e78823          	sb	a4,16(a5)

    RCU->ADCSARCLKCFG_bit.CLKSEL = 1;
800005e0:	3000e7b7          	lui	a5,0x3000e
800005e4:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
800005e8:	fffd0737          	lui	a4,0xfffd0
800005ec:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc71ab>
800005ee:	8ef9                	and	a3,a3,a4
800005f0:	6741                	lui	a4,0x10
800005f2:	8f55                	or	a4,a4,a3
800005f4:	0ae7a823          	sw	a4,176(a5)
    RCU->ADCSARCLKCFG_bit.DIVN = 2;
800005f8:	3000e7b7          	lui	a5,0x3000e
800005fc:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80000600:	c1000737          	lui	a4,0xc1000
80000604:	177d                	addi	a4,a4,-1 # c0ffffff <__data_source_start+0x40ff71ab>
80000606:	8ef9                	and	a3,a3,a4
80000608:	02000737          	lui	a4,0x2000
8000060c:	8f55                	or	a4,a4,a3
8000060e:	0ae7a823          	sw	a4,176(a5)
    RCU->ADCSARCLKCFG_bit.DIVEN = 1;
80000612:	3000e7b7          	lui	a5,0x3000e
80000616:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
8000061a:	00100737          	lui	a4,0x100
8000061e:	8f55                	or	a4,a4,a3
80000620:	0ae7a823          	sw	a4,176(a5)

    RCU->CGCFGAPB_bit.ADCSAREN = 1;
80000624:	3000e7b7          	lui	a5,0x3000e
80000628:	4794                	lw	a3,8(a5)
8000062a:	6741                	lui	a4,0x10
8000062c:	8f55                	or	a4,a4,a3
8000062e:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.ADCSAREN = 1;
80000630:	3000e7b7          	lui	a5,0x3000e
80000634:	4f94                	lw	a3,24(a5)
80000636:	6741                	lui	a4,0x10
80000638:	8f55                	or	a4,a4,a3
8000063a:	cf98                	sw	a4,24(a5)
    RCU->ADCSARCLKCFG_bit.CLKEN = 1;
8000063c:	3000e7b7          	lui	a5,0x3000e
80000640:	0b07a703          	lw	a4,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80000644:	00176713          	ori	a4,a4,1
80000648:	0ae7a823          	sw	a4,176(a5)
    RCU->ADCSARCLKCFG_bit.RSTDIS = 1;
8000064c:	3000e7b7          	lui	a5,0x3000e
80000650:	0b07a703          	lw	a4,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80000654:	10076713          	ori	a4,a4,256
80000658:	0ae7a823          	sw	a4,176(a5)

    ADCSAR->ACTL_bit.SELRES = ADCSAR_ACTL_SELRES_8bit;
8000065c:	300107b7          	lui	a5,0x30010
80000660:	5407a703          	lw	a4,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
80000664:	fcf77713          	andi	a4,a4,-49
80000668:	01076713          	ori	a4,a4,16
8000066c:	54e7a023          	sw	a4,1344(a5)
    ADCSAR->ACTL_bit.CALEN = 1;
80000670:	300107b7          	lui	a5,0x30010
80000674:	5407a703          	lw	a4,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
80000678:	10076713          	ori	a4,a4,256
8000067c:	54e7a023          	sw	a4,1344(a5)
    ADCSAR->ACTL_bit.ADCEN = 1;
80000680:	300107b7          	lui	a5,0x30010
80000684:	5407a703          	lw	a4,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
80000688:	00176713          	ori	a4,a4,1
8000068c:	54e7a023          	sw	a4,1344(a5)

    ADCSAR->EMUX_bit.EM0 = 0;
80000690:	300107b7          	lui	a5,0x30010
80000694:	01c7c703          	lbu	a4,28(a5) # 3001001c <STACK_SIZE+0x3000f81c>
80000698:	9b41                	andi	a4,a4,-16
8000069a:	00e78e23          	sb	a4,28(a5)
    ADCSAR->SEQ[0].SRQCTL_bit.RQMAX = 0x0;
8000069e:	300107b7          	lui	a5,0x30010
800006a2:	0587d703          	lhu	a4,88(a5) # 30010058 <STACK_SIZE+0x3000f858>
800006a6:	9b61                	andi	a4,a4,-8
800006a8:	04e79c23          	sh	a4,88(a5)
    ADCSAR->SEQ[0].SRQSEL_bit.RQ0 = 0x0;
800006ac:	300107b7          	lui	a5,0x30010
800006b0:	43b8                	lw	a4,64(a5)
800006b2:	9b41                	andi	a4,a4,-16
800006b4:	c3b8                	sw	a4,64(a5)
    ADCSAR->SEQEN_bit.SEQEN0 = 1;
800006b6:	300107b7          	lui	a5,0x30010
800006ba:	0007c703          	lbu	a4,0(a5) # 30010000 <STACK_SIZE+0x3000f800>
800006be:	00176713          	ori	a4,a4,1
800006c2:	00e78023          	sb	a4,0(a5)
    ADCSAR_SEQ_StartEventConfig(ADCSAR_SEQ_Num_0, ADCSAR_SEQ_StartEvent_SwReq);
800006c6:	4581                	li	a1,0
800006c8:	4501                	li	a0,0
800006ca:	3979                	jal	80000368 <ADCSAR_SEQ_StartEventConfig>
    ADCSAR_SEQ_SwStartEnCmd(ADCSAR_SEQ_Num_0, ENABLE);
800006cc:	4585                	li	a1,1
800006ce:	4501                	li	a0,0
800006d0:	3ed5                	jal	800002c4 <ADCSAR_SEQ_SwStartEnCmd>

    {
        uint32_t guard = 1000000;
800006d2:	000f47b7          	lui	a5,0xf4
800006d6:	24078793          	addi	a5,a5,576 # f4240 <STACK_SIZE+0xf3a40>
800006da:	fef42623          	sw	a5,-20(s0)
        while (!ADCSAR->ACTL_bit.ADCRDY && guard--) ;
800006de:	0001                	nop
800006e0:	300107b7          	lui	a5,0x30010
800006e4:	5407a783          	lw	a5,1344(a5) # 30010540 <STACK_SIZE+0x3000fd40>
800006e8:	8385                	srli	a5,a5,0x1
800006ea:	8b85                	andi	a5,a5,1
800006ec:	0ff7f793          	zext.b	a5,a5
800006f0:	eb81                	bnez	a5,80000700 <adcsar_init+0x146>
800006f2:	fec42783          	lw	a5,-20(s0)
800006f6:	fff78713          	addi	a4,a5,-1
800006fa:	fee42623          	sw	a4,-20(s0)
800006fe:	f3ed                	bnez	a5,800006e0 <adcsar_init+0x126>
    }
    ADCSAR->SEQSYNC_bit.SYNC0 = 1;
80000700:	300107b7          	lui	a5,0x30010
80000704:	43d8                	lw	a4,4(a5)
80000706:	00176713          	ori	a4,a4,1
8000070a:	c3d8                	sw	a4,4(a5)
    ADCSAR->SEQSYNC_bit.GSYNC = 1;
8000070c:	300107b7          	lui	a5,0x30010
80000710:	43d4                	lw	a3,4(a5)
80000712:	80000737          	lui	a4,0x80000
80000716:	8f55                	or	a4,a4,a3
80000718:	c3d8                	sw	a4,4(a5)

    ADCSAR_SEQ_ITConfig(ADCSAR_SEQ_Num_0, ADCSAR_SEQ_ReqNum_0, ENABLE);
8000071a:	4605                	li	a2,1
8000071c:	4581                	li	a1,0
8000071e:	4501                	li	a0,0
80000720:	3315                	jal	80000444 <ADCSAR_SEQ_ITConfig>
    ADCSAR_SEQ_ITCmd(ADCSAR_SEQ_Num_0, ENABLE);
80000722:	4585                	li	a1,1
80000724:	4501                	li	a0,0
80000726:	39f1                	jal	80000402 <ADCSAR_SEQ_ITCmd>
    ADCSAR_SEQ_ITStatusClear(ADCSAR_SEQ_Num_0);
80000728:	4501                	li	a0,0
8000072a:	3ba5                	jal	800004a2 <ADCSAR_SEQ_ITStatusClear>
    ADCSAR_SEQ_FIFOFullStatusClear(ADCSAR_SEQ_Num_0);
8000072c:	4501                	li	a0,0
8000072e:	3ed5                	jal	80000322 <ADCSAR_SEQ_FIFOFullStatusClear>
    ADCSAR_SEQ_FIFOEmptyStatusClear(ADCSAR_SEQ_Num_0);
80000730:	4501                	li	a0,0
80000732:	3909                	jal	80000344 <ADCSAR_SEQ_FIFOEmptyStatusClear>

    PLIC_SetIrqHandler(Plic_Mach_Target, IsrVect_IRQ_ADC, ADC_IRQHandler);
80000734:	800017b7          	lui	a5,0x80001
80000738:	81c78613          	addi	a2,a5,-2020 # 8000081c <__data_source_start+0xffff79c8>
8000073c:	45f5                	li	a1,29
8000073e:	4501                	li	a0,0
80000740:	2e05                	jal	80000a70 <PLIC_SetIrqHandler>
    PLIC_SetPriority(IsrVect_IRQ_ADC, 1);
80000742:	4585                	li	a1,1
80000744:	4575                	li	a0,29
80000746:	2e9d                	jal	80000abc <PLIC_SetPriority>
    PLIC_IntEnable(Plic_Mach_Target, IsrVect_IRQ_ADC);
80000748:	45f5                	li	a1,29
8000074a:	4501                	li	a0,0
8000074c:	2e69                	jal	80000ae6 <PLIC_IntEnable>
    PLIC_SetThreshold(Plic_Mach_Target, 0);
8000074e:	4581                	li	a1,0
80000750:	4501                	li	a0,0
80000752:	2305                	jal	80000c72 <PLIC_SetThreshold>

    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
80000754:	a019                	j	8000075a <adcsar_init+0x1a0>
        (void)ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_0);
80000756:	4501                	li	a0,0
80000758:	39bd                	jal	800003d6 <ADCSAR_SEQ_GetFIFOData>
    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
8000075a:	4501                	li	a0,0
8000075c:	3989                	jal	800003ae <ADCSAR_SEQ_GetFIFOLoad>
8000075e:	87aa                	mv	a5,a0
80000760:	fbfd                	bnez	a5,80000756 <adcsar_init+0x19c>
    }
}
80000762:	0001                	nop
80000764:	0001                	nop
80000766:	40f2                	lw	ra,28(sp)
80000768:	4462                	lw	s0,24(sp)
8000076a:	6105                	addi	sp,sp,32
8000076c:	8082                	ret

8000076e <adcsar_start>:

void adcsar_start(void)
{
8000076e:	1141                	addi	sp,sp,-16
80000770:	c606                	sw	ra,12(sp)
80000772:	c422                	sw	s0,8(sp)
80000774:	0800                	addi	s0,sp,16
    ADCSAR_SEQ_SwStartCmd();
80000776:	3e41                	jal	80000306 <ADCSAR_SEQ_SwStartCmd>
}
80000778:	0001                	nop
8000077a:	40b2                	lw	ra,12(sp)
8000077c:	4422                	lw	s0,8(sp)
8000077e:	0141                	addi	sp,sp,16
80000780:	8082                	ret

80000782 <adcsar_poll>:

bool adcsar_poll(adcsar_sample_t *out_sample)
{
80000782:	7179                	addi	sp,sp,-48
80000784:	d606                	sw	ra,44(sp)
80000786:	d422                	sw	s0,40(sp)
80000788:	1800                	addi	s0,sp,48
8000078a:	fca42e23          	sw	a0,-36(s0)
    if (!s_adc_irq_flag) {
8000078e:	e4c1c783          	lbu	a5,-436(gp) # 400005cc <s_adc_irq_flag>
80000792:	0ff7f793          	zext.b	a5,a5
80000796:	e399                	bnez	a5,8000079c <adcsar_poll+0x1a>
        return false;
80000798:	4781                	li	a5,0
8000079a:	a8a5                	j	80000812 <adcsar_poll+0x90>
    }

    s_adc_irq_flag = 0;
8000079c:	e4018623          	sb	zero,-436(gp) # 400005cc <s_adc_irq_flag>

    uint32_t load = ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0);
800007a0:	4501                	li	a0,0
800007a2:	3131                	jal	800003ae <ADCSAR_SEQ_GetFIFOLoad>
800007a4:	fea42623          	sw	a0,-20(s0)
    if (!load) {
800007a8:	fec42783          	lw	a5,-20(s0)
800007ac:	e399                	bnez	a5,800007b2 <adcsar_poll+0x30>
        return false;
800007ae:	4781                	li	a5,0
800007b0:	a08d                	j	80000812 <adcsar_poll+0x90>
    }

    uint32_t raw = ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_0);
800007b2:	4501                	li	a0,0
800007b4:	310d                	jal	800003d6 <ADCSAR_SEQ_GetFIFOData>
800007b6:	fea42423          	sw	a0,-24(s0)

    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
800007ba:	a019                	j	800007c0 <adcsar_poll+0x3e>
        (void)ADCSAR_SEQ_GetFIFOData(ADCSAR_SEQ_Num_0);
800007bc:	4501                	li	a0,0
800007be:	3921                	jal	800003d6 <ADCSAR_SEQ_GetFIFOData>
    while (ADCSAR_SEQ_GetFIFOLoad(ADCSAR_SEQ_Num_0)) {
800007c0:	4501                	li	a0,0
800007c2:	36f5                	jal	800003ae <ADCSAR_SEQ_GetFIFOLoad>
800007c4:	87aa                	mv	a5,a0
800007c6:	fbfd                	bnez	a5,800007bc <adcsar_poll+0x3a>
    }

    char state_char = classify_code_char((uint16_t)raw);
800007c8:	fe842783          	lw	a5,-24(s0)
800007cc:	07c2                	slli	a5,a5,0x10
800007ce:	83c1                	srli	a5,a5,0x10
800007d0:	853e                	mv	a0,a5
800007d2:	39cd                	jal	800004c4 <classify_code_char>
800007d4:	87aa                	mv	a5,a0
800007d6:	fef403a3          	sb	a5,-25(s0)
    if (out_sample) {
800007da:	fdc42783          	lw	a5,-36(s0)
800007de:	cb85                	beqz	a5,8000080e <adcsar_poll+0x8c>
        out_sample->raw_code = (uint16_t)raw;
800007e0:	fe842783          	lw	a5,-24(s0)
800007e4:	01079713          	slli	a4,a5,0x10
800007e8:	8341                	srli	a4,a4,0x10
800007ea:	fdc42783          	lw	a5,-36(s0)
800007ee:	00e79023          	sh	a4,0(a5)
        out_sample->state_char = state_char;
800007f2:	fdc42783          	lw	a5,-36(s0)
800007f6:	fe744703          	lbu	a4,-25(s0)
800007fa:	00e78423          	sb	a4,8(a5)
        out_sample->state = state_from_char(state_char);
800007fe:	fe744783          	lbu	a5,-25(s0)
80000802:	853e                	mv	a0,a5
80000804:	3ba9                	jal	8000055e <state_from_char>
80000806:	872a                	mv	a4,a0
80000808:	fdc42783          	lw	a5,-36(s0)
8000080c:	c3d8                	sw	a4,4(a5)
    }

    ADCSAR_SEQ_SwStartCmd();
8000080e:	3ce5                	jal	80000306 <ADCSAR_SEQ_SwStartCmd>
    return true;
80000810:	4785                	li	a5,1
}
80000812:	853e                	mv	a0,a5
80000814:	50b2                	lw	ra,44(sp)
80000816:	5422                	lw	s0,40(sp)
80000818:	6145                	addi	sp,sp,48
8000081a:	8082                	ret

8000081c <ADC_IRQHandler>:

void ADC_IRQHandler(void)
{
8000081c:	1141                	addi	sp,sp,-16
8000081e:	c606                	sw	ra,12(sp)
80000820:	c422                	sw	s0,8(sp)
80000822:	0800                	addi	s0,sp,16
    ADCSAR_SEQ_ITStatusClear(ADCSAR_SEQ_Num_0);
80000824:	4501                	li	a0,0
80000826:	39b5                	jal	800004a2 <ADCSAR_SEQ_ITStatusClear>
    s_adc_irq_flag = 1;
80000828:	4705                	li	a4,1
8000082a:	e4e18623          	sb	a4,-436(gp) # 400005cc <s_adc_irq_flag>
}
8000082e:	0001                	nop
80000830:	40b2                	lw	ra,12(sp)
80000832:	4422                	lw	s0,8(sp)
80000834:	0141                	addi	sp,sp,16
80000836:	8082                	ret

80000838 <config_storage_default>:
// Глобальный счётчик миллисекунд из main.c
extern volatile uint32_t ms_ticks;
#include "../device/Include/system_k1921vg015.h"

void config_storage_default(config_storage_t *cfg) //загружаем дефолтный конфиг
{
80000838:	1101                	addi	sp,sp,-32
8000083a:	ce06                	sw	ra,28(sp)
8000083c:	cc22                	sw	s0,24(sp)
8000083e:	1000                	addi	s0,sp,32
80000840:	fea42623          	sw	a0,-20(s0)
    if (!cfg) return;
80000844:	fec42783          	lw	a5,-20(s0)
80000848:	c7b9                	beqz	a5,80000896 <config_storage_default+0x5e>
    memset(cfg, 0, sizeof(*cfg));
8000084a:	4655                	li	a2,21
8000084c:	4581                	li	a1,0
8000084e:	fec42503          	lw	a0,-20(s0)
80000852:	188080ef          	jal	ra,800089da <memset>
    cfg->osdp_addr = 0x01; 
80000856:	fec42783          	lw	a5,-20(s0)
8000085a:	4705                	li	a4,1
8000085c:	00e78023          	sb	a4,0(a5)
    cfg->osdp_baud = 115200;  
80000860:	fec42783          	lw	a5,-20(s0)
80000864:	0017c703          	lbu	a4,1(a5)
80000868:	8b01                	andi	a4,a4,0
8000086a:	00e780a3          	sb	a4,1(a5)
8000086e:	0027c703          	lbu	a4,2(a5)
80000872:	8b01                	andi	a4,a4,0
80000874:	fc276713          	ori	a4,a4,-62
80000878:	00e78123          	sb	a4,2(a5)
8000087c:	0037c703          	lbu	a4,3(a5)
80000880:	8b01                	andi	a4,a4,0
80000882:	00176713          	ori	a4,a4,1
80000886:	00e781a3          	sb	a4,3(a5)
8000088a:	0047c703          	lbu	a4,4(a5)
8000088e:	8b01                	andi	a4,a4,0
80000890:	00e78223          	sb	a4,4(a5)
80000894:	a011                	j	80000898 <config_storage_default+0x60>
    if (!cfg) return;
80000896:	0001                	nop
}
80000898:	40f2                	lw	ra,28(sp)
8000089a:	4462                	lw	s0,24(sp)
8000089c:	6105                	addi	sp,sp,32
8000089e:	8082                	ret

800008a0 <config_storage_load>:

bool config_storage_load(config_storage_t *cfg) //читаем конфиг с самого eeprom и проверяем его правильность
{
800008a0:	715d                	addi	sp,sp,-80
800008a2:	c686                	sw	ra,76(sp)
800008a4:	c4a2                	sw	s0,72(sp)
800008a6:	0880                	addi	s0,sp,80
800008a8:	faa42e23          	sw	a0,-68(s0)
    if (!cfg) return false;
800008ac:	fbc42783          	lw	a5,-68(s0)
800008b0:	e399                	bnez	a5,800008b6 <config_storage_load+0x16>
800008b2:	4781                	li	a5,0
800008b4:	a291                	j	800009f8 <config_storage_load+0x158>

    config_storage_t tmp;
    // Инициализируем буфер нулями на случай ошибки чтения
    memset(&tmp, 0, sizeof(tmp));
800008b6:	fc440793          	addi	a5,s0,-60
800008ba:	4655                	li	a2,21
800008bc:	4581                	li	a1,0
800008be:	853e                	mv	a0,a5
800008c0:	11a080ef          	jal	ra,800089da <memset>
    
    // Первая попытка чтения (может не пройти сразу после инициализации)
    eeprom_read_bytes(CONFIG_EEPROM_BASE, (uint8_t *)&tmp, sizeof(tmp));
800008c4:	fc440793          	addi	a5,s0,-60
800008c8:	4655                	li	a2,21
800008ca:	85be                	mv	a1,a5
800008cc:	4501                	li	a0,0
800008ce:	75a010ef          	jal	ra,80002028 <eeprom_read_bytes>

    // Ждём завершения асинхронной операции с таймаутом по ms_ticks
    uint32_t start_ms = ms_ticks;
800008d2:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
800008d6:	fef42023          	sw	a5,-32(s0)
    while (eeprom_is_busy()) {
800008da:	a821                	j	800008f2 <config_storage_load+0x52>
        if ((ms_ticks - start_ms) > 50u) { // 50 мс таймаут на чтение
800008dc:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
800008e0:	fe042783          	lw	a5,-32(s0)
800008e4:	8f1d                	sub	a4,a4,a5
800008e6:	03200793          	li	a5,50
800008ea:	00e7f463          	bgeu	a5,a4,800008f2 <config_storage_load+0x52>
            return false;
800008ee:	4781                	li	a5,0
800008f0:	a221                	j	800009f8 <config_storage_load+0x158>
    while (eeprom_is_busy()) {
800008f2:	354010ef          	jal	ra,80001c46 <eeprom_is_busy>
800008f6:	87aa                	mv	a5,a0
800008f8:	f3f5                	bnez	a5,800008dc <config_storage_load+0x3c>
        }
    }
    if (eeprom_had_error()) {
800008fa:	362010ef          	jal	ra,80001c5c <eeprom_had_error>
800008fe:	87aa                	mv	a5,a0
80000900:	c399                	beqz	a5,80000906 <config_storage_load+0x66>
        return false;
80000902:	4781                	li	a5,0
80000904:	a8d5                	j	800009f8 <config_storage_load+0x158>
    }
    
    // Если первое чтение вернуло только нули, пробуем ещё раз через небольшую паузу
    bool first_read_all_zero = true;
80000906:	4785                	li	a5,1
80000908:	fef407a3          	sb	a5,-17(s0)
    for (size_t i = 0; i < sizeof(tmp); i++) {
8000090c:	fe042423          	sw	zero,-24(s0)
80000910:	a00d                	j	80000932 <config_storage_load+0x92>
        if (((uint8_t*)&tmp)[i] != 0) {
80000912:	fc440713          	addi	a4,s0,-60
80000916:	fe842783          	lw	a5,-24(s0)
8000091a:	97ba                	add	a5,a5,a4
8000091c:	0007c783          	lbu	a5,0(a5)
80000920:	c781                	beqz	a5,80000928 <config_storage_load+0x88>
            first_read_all_zero = false;
80000922:	fe0407a3          	sb	zero,-17(s0)
            break;
80000926:	a819                	j	8000093c <config_storage_load+0x9c>
    for (size_t i = 0; i < sizeof(tmp); i++) {
80000928:	fe842783          	lw	a5,-24(s0)
8000092c:	0785                	addi	a5,a5,1
8000092e:	fef42423          	sw	a5,-24(s0)
80000932:	fe842703          	lw	a4,-24(s0)
80000936:	47d1                	li	a5,20
80000938:	fce7fde3          	bgeu	a5,a4,80000912 <config_storage_load+0x72>
        }
    }
    
    if (first_read_all_zero) {
8000093c:	fef44783          	lbu	a5,-17(s0)
80000940:	c3c5                	beqz	a5,800009e0 <config_storage_load+0x140>
        // Задержка для стабилизации шины перед повторной попыткой (5 мс достаточно)
        uint32_t cpu_freq = SystemCoreClock;
80000942:	e181a783          	lw	a5,-488(gp) # 40000598 <SystemCoreClock>
80000946:	fef42223          	sw	a5,-28(s0)
        if (cpu_freq == 0) cpu_freq = 16000000;
8000094a:	fe442783          	lw	a5,-28(s0)
8000094e:	e799                	bnez	a5,8000095c <config_storage_load+0xbc>
80000950:	00f427b7          	lui	a5,0xf42
80000954:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80000958:	fef42223          	sw	a5,-28(s0)
        uint32_t delay_5ms = (5 * cpu_freq) / 1000; // 5 мс
8000095c:	fe442703          	lw	a4,-28(s0)
80000960:	87ba                	mv	a5,a4
80000962:	078a                	slli	a5,a5,0x2
80000964:	973e                	add	a4,a4,a5
80000966:	3e800793          	li	a5,1000
8000096a:	02f757b3          	divu	a5,a4,a5
8000096e:	fcf42e23          	sw	a5,-36(s0)
        for (volatile uint32_t i = 0; i < delay_5ms; ++i) {
80000972:	fc042023          	sw	zero,-64(s0)
80000976:	a039                	j	80000984 <config_storage_load+0xe4>
            __asm volatile("nop");
80000978:	0001                	nop
        for (volatile uint32_t i = 0; i < delay_5ms; ++i) {
8000097a:	fc042783          	lw	a5,-64(s0)
8000097e:	0785                	addi	a5,a5,1
80000980:	fcf42023          	sw	a5,-64(s0)
80000984:	fc042783          	lw	a5,-64(s0)
80000988:	fdc42703          	lw	a4,-36(s0)
8000098c:	fee7e6e3          	bltu	a5,a4,80000978 <config_storage_load+0xd8>
        }
        
        // Повторная попытка чтения
        memset(&tmp, 0, sizeof(tmp));
80000990:	fc440793          	addi	a5,s0,-60
80000994:	4655                	li	a2,21
80000996:	4581                	li	a1,0
80000998:	853e                	mv	a0,a5
8000099a:	040080ef          	jal	ra,800089da <memset>
        eeprom_read_bytes(CONFIG_EEPROM_BASE, (uint8_t *)&tmp, sizeof(tmp));
8000099e:	fc440793          	addi	a5,s0,-60
800009a2:	4655                	li	a2,21
800009a4:	85be                	mv	a1,a5
800009a6:	4501                	li	a0,0
800009a8:	680010ef          	jal	ra,80002028 <eeprom_read_bytes>

        start_ms = ms_ticks;
800009ac:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
800009b0:	fef42023          	sw	a5,-32(s0)
        while (eeprom_is_busy()) {
800009b4:	a821                	j	800009cc <config_storage_load+0x12c>
            if ((ms_ticks - start_ms) > 50u) {
800009b6:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
800009ba:	fe042783          	lw	a5,-32(s0)
800009be:	8f1d                	sub	a4,a4,a5
800009c0:	03200793          	li	a5,50
800009c4:	00e7f463          	bgeu	a5,a4,800009cc <config_storage_load+0x12c>
                return false;
800009c8:	4781                	li	a5,0
800009ca:	a03d                	j	800009f8 <config_storage_load+0x158>
        while (eeprom_is_busy()) {
800009cc:	27a010ef          	jal	ra,80001c46 <eeprom_is_busy>
800009d0:	87aa                	mv	a5,a0
800009d2:	f3f5                	bnez	a5,800009b6 <config_storage_load+0x116>
            }
        }
        if (eeprom_had_error()) {
800009d4:	288010ef          	jal	ra,80001c5c <eeprom_had_error>
800009d8:	87aa                	mv	a5,a0
800009da:	c399                	beqz	a5,800009e0 <config_storage_load+0x140>
            return false;
800009dc:	4781                	li	a5,0
800009de:	a829                	j	800009f8 <config_storage_load+0x158>
        }
    }

    // Никакой дополнительной валидации (magic/CRC) больше нет — просто копируем
    memcpy(cfg, &tmp, sizeof(tmp));
800009e0:	fbc42783          	lw	a5,-68(s0)
800009e4:	86be                	mv	a3,a5
800009e6:	fc440793          	addi	a5,s0,-60
800009ea:	4755                	li	a4,21
800009ec:	863a                	mv	a2,a4
800009ee:	85be                	mv	a1,a5
800009f0:	8536                	mv	a0,a3
800009f2:	7d3070ef          	jal	ra,800089c4 <memcpy>

    return true;
800009f6:	4785                	li	a5,1
}
800009f8:	853e                	mv	a0,a5
800009fa:	40b6                	lw	ra,76(sp)
800009fc:	4426                	lw	s0,72(sp)
800009fe:	6161                	addi	sp,sp,80
80000a00:	8082                	ret

80000a02 <config_storage_save>:

void config_storage_save(const config_storage_t *cfg_in)  //загружаем изменённый конфиг
{
80000a02:	7139                	addi	sp,sp,-64
80000a04:	de06                	sw	ra,60(sp)
80000a06:	dc22                	sw	s0,56(sp)
80000a08:	0080                	addi	s0,sp,64
80000a0a:	fca42623          	sw	a0,-52(s0)
    if (!cfg_in) return;
80000a0e:	fcc42783          	lw	a5,-52(s0)
80000a12:	cba1                	beqz	a5,80000a62 <config_storage_save+0x60>

    config_storage_t tmp;
    memcpy(&tmp, cfg_in, sizeof(tmp));
80000a14:	fcc42703          	lw	a4,-52(s0)
80000a18:	fd440793          	addi	a5,s0,-44
80000a1c:	86ba                	mv	a3,a4
80000a1e:	4755                	li	a4,21
80000a20:	863a                	mv	a2,a4
80000a22:	85b6                	mv	a1,a3
80000a24:	853e                	mv	a0,a5
80000a26:	79f070ef          	jal	ra,800089c4 <memcpy>

    eeprom_write_bytes(CONFIG_EEPROM_BASE, (const uint8_t *)&tmp, sizeof(tmp));
80000a2a:	fd440793          	addi	a5,s0,-44
80000a2e:	4655                	li	a2,21
80000a30:	85be                	mv	a1,a5
80000a32:	4501                	li	a0,0
80000a34:	4c2010ef          	jal	ra,80001ef6 <eeprom_write_bytes>

    // Ожидание завершения записи с таймаутом
    uint32_t start_ms = ms_ticks;
80000a38:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
80000a3c:	fef42623          	sw	a5,-20(s0)
    while (eeprom_is_busy()) {
80000a40:	a811                	j	80000a54 <config_storage_save+0x52>
        if ((ms_ticks - start_ms) > 50u) { // 50 мс на запись конфигурации
80000a42:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80000a46:	fec42783          	lw	a5,-20(s0)
80000a4a:	8f1d                	sub	a4,a4,a5
80000a4c:	03200793          	li	a5,50
80000a50:	00e7eb63          	bltu	a5,a4,80000a66 <config_storage_save+0x64>
    while (eeprom_is_busy()) {
80000a54:	1f2010ef          	jal	ra,80001c46 <eeprom_is_busy>
80000a58:	87aa                	mv	a5,a0
80000a5a:	f7e5                	bnez	a5,80000a42 <config_storage_save+0x40>
            return;
        }
    }
    if (eeprom_had_error()) {
80000a5c:	200010ef          	jal	ra,80001c5c <eeprom_had_error>
80000a60:	a021                	j	80000a68 <config_storage_save+0x66>
    if (!cfg_in) return;
80000a62:	0001                	nop
80000a64:	a011                	j	80000a68 <config_storage_save+0x66>
            return;
80000a66:	0001                	nop
        return;
    }
}
80000a68:	50f2                	lw	ra,60(sp)
80000a6a:	5462                	lw	s0,56(sp)
80000a6c:	6121                	addi	sp,sp,64
80000a6e:	8082                	ret

80000a70 <PLIC_SetIrqHandler>:
/*
 * Set PLIC handler function for isr num
 */

void PLIC_SetIrqHandler (uint8_t target, uint32_t isr_num, irqfunc* func)
{
80000a70:	1101                	addi	sp,sp,-32
80000a72:	ce22                	sw	s0,28(sp)
80000a74:	1000                	addi	s0,sp,32
80000a76:	87aa                	mv	a5,a0
80000a78:	feb42423          	sw	a1,-24(s0)
80000a7c:	fec42223          	sw	a2,-28(s0)
80000a80:	fef407a3          	sb	a5,-17(s0)
    if(target == Plic_Mach_Target) {
80000a84:	fef44783          	lbu	a5,-17(s0)
80000a88:	ef89                	bnez	a5,80000aa2 <PLIC_SetIrqHandler+0x32>
        mach_plic_handler[isr_num] = func;
80000a8a:	400007b7          	lui	a5,0x40000
80000a8e:	01078713          	addi	a4,a5,16 # 40000010 <mach_plic_handler>
80000a92:	fe842783          	lw	a5,-24(s0)
80000a96:	078a                	slli	a5,a5,0x2
80000a98:	97ba                	add	a5,a5,a4
80000a9a:	fe442703          	lw	a4,-28(s0)
80000a9e:	c398                	sw	a4,0(a5)
    } else {
        supervisor_plic_handler[isr_num] = func;
    }
}
80000aa0:	a811                	j	80000ab4 <PLIC_SetIrqHandler+0x44>
        supervisor_plic_handler[isr_num] = func;
80000aa2:	91018713          	addi	a4,gp,-1776 # 40000090 <supervisor_plic_handler>
80000aa6:	fe842783          	lw	a5,-24(s0)
80000aaa:	078a                	slli	a5,a5,0x2
80000aac:	97ba                	add	a5,a5,a4
80000aae:	fe442703          	lw	a4,-28(s0)
80000ab2:	c398                	sw	a4,0(a5)
}
80000ab4:	0001                	nop
80000ab6:	4472                	lw	s0,28(sp)
80000ab8:	6105                	addi	sp,sp,32
80000aba:	8082                	ret

80000abc <PLIC_SetPriority>:
/*
 * Set PLIC irq priority
 */

void PLIC_SetPriority (uint32_t isr_num, uint8_t pri)
{
80000abc:	1101                	addi	sp,sp,-32
80000abe:	ce22                	sw	s0,28(sp)
80000ac0:	1000                	addi	s0,sp,32
80000ac2:	fea42623          	sw	a0,-20(s0)
80000ac6:	87ae                	mv	a5,a1
80000ac8:	fef405a3          	sb	a5,-21(s0)
    PLIC->PRI[isr_num] = pri;
80000acc:	0c0006b7          	lui	a3,0xc000
80000ad0:	feb44703          	lbu	a4,-21(s0)
80000ad4:	fec42783          	lw	a5,-20(s0)
80000ad8:	078a                	slli	a5,a5,0x2
80000ada:	97b6                	add	a5,a5,a3
80000adc:	c398                	sw	a4,0(a5)
}
80000ade:	0001                	nop
80000ae0:	4472                	lw	s0,28(sp)
80000ae2:	6105                	addi	sp,sp,32
80000ae4:	8082                	ret

80000ae6 <PLIC_IntEnable>:
/*
 * Enable PLIC irq
 */

void PLIC_IntEnable (uint8_t target, uint32_t isr_num)
{
80000ae6:	7179                	addi	sp,sp,-48
80000ae8:	d622                	sw	s0,44(sp)
80000aea:	1800                	addi	s0,sp,48
80000aec:	87aa                	mv	a5,a0
80000aee:	fcb42c23          	sw	a1,-40(s0)
80000af2:	fcf40fa3          	sb	a5,-33(s0)
	uint32_t value;

	//read - modify - write operation

    if(target == Plic_Mach_Target) {
80000af6:	fdf44783          	lbu	a5,-33(s0)
80000afa:	eb9d                	bnez	a5,80000b30 <PLIC_IntEnable+0x4a>
    	value  = PLIC->MIEM0;
80000afc:	0c000737          	lui	a4,0xc000
80000b00:	6789                	lui	a5,0x2
80000b02:	97ba                	add	a5,a5,a4
80000b04:	439c                	lw	a5,0(a5)
80000b06:	fef42623          	sw	a5,-20(s0)
    	value |= (1<<isr_num);
80000b0a:	fd842783          	lw	a5,-40(s0)
80000b0e:	4705                	li	a4,1
80000b10:	00f717b3          	sll	a5,a4,a5
80000b14:	873e                	mv	a4,a5
80000b16:	fec42783          	lw	a5,-20(s0)
80000b1a:	8fd9                	or	a5,a5,a4
80000b1c:	fef42623          	sw	a5,-20(s0)
    	PLIC->MIEM0 = value;
80000b20:	0c000737          	lui	a4,0xc000
80000b24:	6789                	lui	a5,0x2
80000b26:	97ba                	add	a5,a5,a4
80000b28:	fec42703          	lw	a4,-20(s0)
80000b2c:	c398                	sw	a4,0(a5)
    } else {
    	value = PLIC->UIEM0;
    	value |= (1<<isr_num);
    	PLIC->UIEM0 = value;
    }
}
80000b2e:	a825                	j	80000b66 <PLIC_IntEnable+0x80>
    	value = PLIC->UIEM0;
80000b30:	0c000737          	lui	a4,0xc000
80000b34:	6789                	lui	a5,0x2
80000b36:	97ba                	add	a5,a5,a4
80000b38:	0807a783          	lw	a5,128(a5) # 2080 <STACK_SIZE+0x1880>
80000b3c:	fef42623          	sw	a5,-20(s0)
    	value |= (1<<isr_num);
80000b40:	fd842783          	lw	a5,-40(s0)
80000b44:	4705                	li	a4,1
80000b46:	00f717b3          	sll	a5,a4,a5
80000b4a:	873e                	mv	a4,a5
80000b4c:	fec42783          	lw	a5,-20(s0)
80000b50:	8fd9                	or	a5,a5,a4
80000b52:	fef42623          	sw	a5,-20(s0)
    	PLIC->UIEM0 = value;
80000b56:	0c000737          	lui	a4,0xc000
80000b5a:	6789                	lui	a5,0x2
80000b5c:	97ba                	add	a5,a5,a4
80000b5e:	fec42703          	lw	a4,-20(s0)
80000b62:	08e7a023          	sw	a4,128(a5) # 2080 <STACK_SIZE+0x1880>
}
80000b66:	0001                	nop
80000b68:	5432                	lw	s0,44(sp)
80000b6a:	6145                	addi	sp,sp,48
80000b6c:	8082                	ret

80000b6e <PLIC_IntDisable>:
/*
 * Disable PLIC irq
 */

void PLIC_IntDisable (uint8_t target, uint32_t isr_num)
{
80000b6e:	7179                	addi	sp,sp,-48
80000b70:	d622                	sw	s0,44(sp)
80000b72:	1800                	addi	s0,sp,48
80000b74:	87aa                	mv	a5,a0
80000b76:	fcb42c23          	sw	a1,-40(s0)
80000b7a:	fcf40fa3          	sb	a5,-33(s0)
	uint32_t value;

	//read - modify - write operation

	if(target == Plic_Mach_Target) {
80000b7e:	fdf44783          	lbu	a5,-33(s0)
80000b82:	ef8d                	bnez	a5,80000bbc <PLIC_IntDisable+0x4e>
		value  = PLIC->MIEM0;
80000b84:	0c000737          	lui	a4,0xc000
80000b88:	6789                	lui	a5,0x2
80000b8a:	97ba                	add	a5,a5,a4
80000b8c:	439c                	lw	a5,0(a5)
80000b8e:	fef42623          	sw	a5,-20(s0)
		value &= ~(1<<isr_num);
80000b92:	fd842783          	lw	a5,-40(s0)
80000b96:	4705                	li	a4,1
80000b98:	00f717b3          	sll	a5,a4,a5
80000b9c:	fff7c793          	not	a5,a5
80000ba0:	873e                	mv	a4,a5
80000ba2:	fec42783          	lw	a5,-20(s0)
80000ba6:	8ff9                	and	a5,a5,a4
80000ba8:	fef42623          	sw	a5,-20(s0)
		PLIC->MIEM0 = value;
80000bac:	0c000737          	lui	a4,0xc000
80000bb0:	6789                	lui	a5,0x2
80000bb2:	97ba                	add	a5,a5,a4
80000bb4:	fec42703          	lw	a4,-20(s0)
80000bb8:	c398                	sw	a4,0(a5)
	} else {
		value  = PLIC->UIEM0;
		value &= ~(1<<isr_num);
		PLIC->UIEM0 = value;
	}
}
80000bba:	a835                	j	80000bf6 <PLIC_IntDisable+0x88>
		value  = PLIC->UIEM0;
80000bbc:	0c000737          	lui	a4,0xc000
80000bc0:	6789                	lui	a5,0x2
80000bc2:	97ba                	add	a5,a5,a4
80000bc4:	0807a783          	lw	a5,128(a5) # 2080 <STACK_SIZE+0x1880>
80000bc8:	fef42623          	sw	a5,-20(s0)
		value &= ~(1<<isr_num);
80000bcc:	fd842783          	lw	a5,-40(s0)
80000bd0:	4705                	li	a4,1
80000bd2:	00f717b3          	sll	a5,a4,a5
80000bd6:	fff7c793          	not	a5,a5
80000bda:	873e                	mv	a4,a5
80000bdc:	fec42783          	lw	a5,-20(s0)
80000be0:	8ff9                	and	a5,a5,a4
80000be2:	fef42623          	sw	a5,-20(s0)
		PLIC->UIEM0 = value;
80000be6:	0c000737          	lui	a4,0xc000
80000bea:	6789                	lui	a5,0x2
80000bec:	97ba                	add	a5,a5,a4
80000bee:	fec42703          	lw	a4,-20(s0)
80000bf2:	08e7a023          	sw	a4,128(a5) # 2080 <STACK_SIZE+0x1880>
}
80000bf6:	0001                	nop
80000bf8:	5432                	lw	s0,44(sp)
80000bfa:	6145                	addi	sp,sp,48
80000bfc:	8082                	ret

80000bfe <PLIC_ClaimIrq>:
/*
 * Get current isr number
 */

uint32_t PLIC_ClaimIrq (uint8_t target)
{
80000bfe:	1101                	addi	sp,sp,-32
80000c00:	ce22                	sw	s0,28(sp)
80000c02:	1000                	addi	s0,sp,32
80000c04:	87aa                	mv	a5,a0
80000c06:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
80000c0a:	fef44783          	lbu	a5,-17(s0)
80000c0e:	eb81                	bnez	a5,80000c1e <PLIC_ClaimIrq+0x20>
		return (uint32_t)(PLIC->MICC);
80000c10:	0c000737          	lui	a4,0xc000
80000c14:	002007b7          	lui	a5,0x200
80000c18:	97ba                	add	a5,a5,a4
80000c1a:	43dc                	lw	a5,4(a5)
80000c1c:	a039                	j	80000c2a <PLIC_ClaimIrq+0x2c>
	} else {
		return (uint32_t)(PLIC->UICC);
80000c1e:	0c000737          	lui	a4,0xc000
80000c22:	002017b7          	lui	a5,0x201
80000c26:	97ba                	add	a5,a5,a4
80000c28:	43dc                	lw	a5,4(a5)
	}
}
80000c2a:	853e                	mv	a0,a5
80000c2c:	4472                	lw	s0,28(sp)
80000c2e:	6105                	addi	sp,sp,32
80000c30:	8082                	ret

80000c32 <PLIC_ClaimComplete>:
/*
 * Set current isr as completed
 */

void PLIC_ClaimComplete (uint8_t target, uint32_t isrnum)
{
80000c32:	1101                	addi	sp,sp,-32
80000c34:	ce22                	sw	s0,28(sp)
80000c36:	1000                	addi	s0,sp,32
80000c38:	87aa                	mv	a5,a0
80000c3a:	feb42423          	sw	a1,-24(s0)
80000c3e:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
80000c42:	fef44783          	lbu	a5,-17(s0)
80000c46:	eb91                	bnez	a5,80000c5a <PLIC_ClaimComplete+0x28>
		PLIC->MICC = isrnum;
80000c48:	0c000737          	lui	a4,0xc000
80000c4c:	002007b7          	lui	a5,0x200
80000c50:	97ba                	add	a5,a5,a4
80000c52:	fe842703          	lw	a4,-24(s0)
80000c56:	c3d8                	sw	a4,4(a5)
	} else {
		PLIC->UICC = isrnum;
	}
}
80000c58:	a809                	j	80000c6a <PLIC_ClaimComplete+0x38>
		PLIC->UICC = isrnum;
80000c5a:	0c000737          	lui	a4,0xc000
80000c5e:	002017b7          	lui	a5,0x201
80000c62:	97ba                	add	a5,a5,a4
80000c64:	fe842703          	lw	a4,-24(s0)
80000c68:	c3d8                	sw	a4,4(a5)
}
80000c6a:	0001                	nop
80000c6c:	4472                	lw	s0,28(sp)
80000c6e:	6105                	addi	sp,sp,32
80000c70:	8082                	ret

80000c72 <PLIC_SetThreshold>:

/*
 * Set threshold for irqs
 */

void PLIC_SetThreshold(uint8_t target, uint32_t value) {
80000c72:	1101                	addi	sp,sp,-32
80000c74:	ce22                	sw	s0,28(sp)
80000c76:	1000                	addi	s0,sp,32
80000c78:	87aa                	mv	a5,a0
80000c7a:	feb42423          	sw	a1,-24(s0)
80000c7e:	fef407a3          	sb	a5,-17(s0)
	if(target == Plic_Mach_Target) {
80000c82:	fef44783          	lbu	a5,-17(s0)
80000c86:	eb91                	bnez	a5,80000c9a <PLIC_SetThreshold+0x28>
		PLIC->MTHR = value;
80000c88:	0c000737          	lui	a4,0xc000
80000c8c:	002007b7          	lui	a5,0x200
80000c90:	97ba                	add	a5,a5,a4
80000c92:	fe842703          	lw	a4,-24(s0)
80000c96:	c398                	sw	a4,0(a5)
	} else {
		PLIC->UTHR = value;
	}
}
80000c98:	a809                	j	80000caa <PLIC_SetThreshold+0x38>
		PLIC->UTHR = value;
80000c9a:	0c000737          	lui	a4,0xc000
80000c9e:	002017b7          	lui	a5,0x201
80000ca2:	97ba                	add	a5,a5,a4
80000ca4:	fe842703          	lw	a4,-24(s0)
80000ca8:	c398                	sw	a4,0(a5)
}
80000caa:	0001                	nop
80000cac:	4472                	lw	s0,28(sp)
80000cae:	6105                	addi	sp,sp,32
80000cb0:	8082                	ret

80000cb2 <PLIC_MachHandler>:


void PLIC_MachHandler(void) {
80000cb2:	1101                	addi	sp,sp,-32
80000cb4:	ce06                	sw	ra,28(sp)
80000cb6:	cc22                	sw	s0,24(sp)
80000cb8:	1000                	addi	s0,sp,32

	// handle interrupt
	uint32_t isr_num = PLIC_ClaimIrq(Plic_Mach_Target);
80000cba:	4501                	li	a0,0
80000cbc:	3789                	jal	80000bfe <PLIC_ClaimIrq>
80000cbe:	fea42623          	sw	a0,-20(s0)
	// check if handler exist
	if(mach_plic_handler[isr_num] != NULL_IRQ) {
80000cc2:	400007b7          	lui	a5,0x40000
80000cc6:	01078713          	addi	a4,a5,16 # 40000010 <mach_plic_handler>
80000cca:	fec42783          	lw	a5,-20(s0)
80000cce:	078a                	slli	a5,a5,0x2
80000cd0:	97ba                	add	a5,a5,a4
80000cd2:	439c                	lw	a5,0(a5)
80000cd4:	cf99                	beqz	a5,80000cf2 <PLIC_MachHandler+0x40>
		// call isr handler
		mach_plic_handler[isr_num]();
80000cd6:	400007b7          	lui	a5,0x40000
80000cda:	01078713          	addi	a4,a5,16 # 40000010 <mach_plic_handler>
80000cde:	fec42783          	lw	a5,-20(s0)
80000ce2:	078a                	slli	a5,a5,0x2
80000ce4:	97ba                	add	a5,a5,a4
80000ce6:	439c                	lw	a5,0(a5)
80000ce8:	9782                	jalr	a5
		// set isr completes
		PLIC_ClaimComplete(Plic_Mach_Target, isr_num);
80000cea:	fec42583          	lw	a1,-20(s0)
80000cee:	4501                	li	a0,0
80000cf0:	3789                	jal	80000c32 <PLIC_ClaimComplete>
	}
}
80000cf2:	0001                	nop
80000cf4:	40f2                	lw	ra,28(sp)
80000cf6:	4462                	lw	s0,24(sp)
80000cf8:	6105                	addi	sp,sp,32
80000cfa:	8082                	ret

80000cfc <trap_handler>:
#define MCAUSE_EXCEPT_STAMOADDRMISALGN  0x6
#define MCAUSE_EXCEPT_STAMOACCSFAULT    0x7
#define MCAUSE_EXCEPT_ECALLFRM_M_MODE   0xB

void trap_handler (void)
{
80000cfc:	1101                	addi	sp,sp,-32
80000cfe:	ce06                	sw	ra,28(sp)
80000d00:	cc22                	sw	s0,24(sp)
80000d02:	1000                	addi	s0,sp,32
	uint32_t mcause_val = read_csr(mcause);
80000d04:	342027f3          	csrr	a5,mcause
80000d08:	fef42623          	sw	a5,-20(s0)
80000d0c:	fec42783          	lw	a5,-20(s0)
80000d10:	fef42423          	sw	a5,-24(s0)

	if((mcause_val & MCAUSE_INTERRUPT_FLAG) == 0) {
80000d14:	fe842783          	lw	a5,-24(s0)
80000d18:	0207c463          	bltz	a5,80000d40 <trap_handler+0x44>
		// handle exception
		switch (mcause_val & MCAUSE_EXCEPT_MASK)
80000d1c:	fe842783          	lw	a5,-24(s0)
80000d20:	8bbd                	andi	a5,a5,15
80000d22:	472d                	li	a4,11
80000d24:	00f76b63          	bltu	a4,a5,80000d3a <trap_handler+0x3e>
80000d28:	00279713          	slli	a4,a5,0x2
80000d2c:	800097b7          	lui	a5,0x80009
80000d30:	9ec78793          	addi	a5,a5,-1556 # 800089ec <__data_source_start+0xfffffb98>
80000d34:	97ba                	add	a5,a5,a4
80000d36:	439c                	lw	a5,0(a5)
80000d38:	8782                	jr	a5
			case MCAUSE_EXCEPT_ECALLFRM_M_MODE:
				break;

			default: // MCAUSE_EXCEPT UNKNOWN

				break;
80000d3a:	0001                	nop
		}

		while(1) {}; //TRAP
80000d3c:	0001                	nop
80000d3e:	bffd                	j	80000d3c <trap_handler+0x40>
	} else {
		// handle interrupt
		PLIC_MachHandler();
80000d40:	3f8d                	jal	80000cb2 <PLIC_MachHandler>
	}
}
80000d42:	0001                	nop
80000d44:	40f2                	lw	ra,28(sp)
80000d46:	4462                	lw	s0,24(sp)
80000d48:	6105                	addi	sp,sp,32
80000d4a:	8082                	ret

80000d4c <PrintChar>:
 *
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
void PrintChar(char c)
{
80000d4c:	1101                	addi	sp,sp,-32
80000d4e:	ce06                	sw	ra,28(sp)
80000d50:	cc22                	sw	s0,24(sp)
80000d52:	1000                	addi	s0,sp,32
80000d54:	87aa                	mv	a5,a0
80000d56:	fef407a3          	sb	a5,-17(s0)
	retarget_put_char(c);
80000d5a:	fef44783          	lbu	a5,-17(s0)
80000d5e:	853e                	mv	a0,a5
80000d60:	349000ef          	jal	ra,800018a8 <retarget_put_char>
}
80000d64:	0001                	nop
80000d66:	40f2                	lw	ra,28(sp)
80000d68:	4462                	lw	s0,24(sp)
80000d6a:	6105                	addi	sp,sp,32
80000d6c:	8082                	ret

80000d6e <PutChar>:
 *
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
signed int PutChar(char *pStr, char c)
{
80000d6e:	1101                	addi	sp,sp,-32
80000d70:	ce22                	sw	s0,28(sp)
80000d72:	1000                	addi	s0,sp,32
80000d74:	fea42623          	sw	a0,-20(s0)
80000d78:	87ae                	mv	a5,a1
80000d7a:	fef405a3          	sb	a5,-21(s0)
    *pStr = c;
80000d7e:	fec42783          	lw	a5,-20(s0)
80000d82:	feb44703          	lbu	a4,-21(s0)
80000d86:	00e78023          	sb	a4,0(a5)
    return 1;
80000d8a:	4785                	li	a5,1
}
80000d8c:	853e                	mv	a0,a5
80000d8e:	4472                	lw	s0,28(sp)
80000d90:	6105                	addi	sp,sp,32
80000d92:	8082                	ret

80000d94 <PutString>:
 * @param  pStr     Storage string.
 * @param  pSource  Source string.
 * @return  The size of the written
 */
signed int PutString(char *pStr, const char *pSource)
{
80000d94:	7179                	addi	sp,sp,-48
80000d96:	d622                	sw	s0,44(sp)
80000d98:	1800                	addi	s0,sp,48
80000d9a:	fca42e23          	sw	a0,-36(s0)
80000d9e:	fcb42c23          	sw	a1,-40(s0)
    signed int num = 0;
80000da2:	fe042623          	sw	zero,-20(s0)

    while (*pSource != 0) {
80000da6:	a035                	j	80000dd2 <PutString+0x3e>

        *pStr++ = *pSource++;
80000da8:	fd842703          	lw	a4,-40(s0)
80000dac:	00170793          	addi	a5,a4,1 # c000001 <STACK_SIZE+0xbfff801>
80000db0:	fcf42c23          	sw	a5,-40(s0)
80000db4:	fdc42783          	lw	a5,-36(s0)
80000db8:	00178693          	addi	a3,a5,1
80000dbc:	fcd42e23          	sw	a3,-36(s0)
80000dc0:	00074703          	lbu	a4,0(a4)
80000dc4:	00e78023          	sb	a4,0(a5)
        num++;
80000dc8:	fec42783          	lw	a5,-20(s0)
80000dcc:	0785                	addi	a5,a5,1
80000dce:	fef42623          	sw	a5,-20(s0)
    while (*pSource != 0) {
80000dd2:	fd842783          	lw	a5,-40(s0)
80000dd6:	0007c783          	lbu	a5,0(a5)
80000dda:	f7f9                	bnez	a5,80000da8 <PutString+0x14>
    }

    return num;
80000ddc:	fec42783          	lw	a5,-20(s0)
}
80000de0:	853e                	mv	a0,a5
80000de2:	5432                	lw	s0,44(sp)
80000de4:	6145                	addi	sp,sp,48
80000de6:	8082                	ret

80000de8 <PutUnsignedInt>:
signed int PutUnsignedInt(
    char *pStr,
    char fill,
    signed int width,
    unsigned int value)
{
80000de8:	7179                	addi	sp,sp,-48
80000dea:	d606                	sw	ra,44(sp)
80000dec:	d422                	sw	s0,40(sp)
80000dee:	1800                	addi	s0,sp,48
80000df0:	fca42e23          	sw	a0,-36(s0)
80000df4:	87ae                	mv	a5,a1
80000df6:	fcc42a23          	sw	a2,-44(s0)
80000dfa:	fcd42823          	sw	a3,-48(s0)
80000dfe:	fcf40da3          	sb	a5,-37(s0)
    signed int num = 0;
80000e02:	fe042623          	sw	zero,-20(s0)

    /* Take current digit into account when calculating width */
    width--;
80000e06:	fd442783          	lw	a5,-44(s0)
80000e0a:	17fd                	addi	a5,a5,-1
80000e0c:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively write upper digits */
    if ((value / 10) > 0) {
80000e10:	fd042703          	lw	a4,-48(s0)
80000e14:	47a5                	li	a5,9
80000e16:	04e7ff63          	bgeu	a5,a4,80000e74 <PutUnsignedInt+0x8c>

        num = PutUnsignedInt(pStr, fill, width, value / 10);
80000e1a:	fd042703          	lw	a4,-48(s0)
80000e1e:	47a9                	li	a5,10
80000e20:	02f75733          	divu	a4,a4,a5
80000e24:	fdb44783          	lbu	a5,-37(s0)
80000e28:	86ba                	mv	a3,a4
80000e2a:	fd442603          	lw	a2,-44(s0)
80000e2e:	85be                	mv	a1,a5
80000e30:	fdc42503          	lw	a0,-36(s0)
80000e34:	3f55                	jal	80000de8 <PutUnsignedInt>
80000e36:	fea42623          	sw	a0,-20(s0)
        pStr += num;
80000e3a:	fec42783          	lw	a5,-20(s0)
80000e3e:	fdc42703          	lw	a4,-36(s0)
80000e42:	97ba                	add	a5,a5,a4
80000e44:	fcf42e23          	sw	a5,-36(s0)
80000e48:	a815                	j	80000e7c <PutUnsignedInt+0x94>
    /* Write filler characters */
    else {

        while (width > 0) {

            PutChar(pStr, fill);
80000e4a:	fdb44783          	lbu	a5,-37(s0)
80000e4e:	85be                	mv	a1,a5
80000e50:	fdc42503          	lw	a0,-36(s0)
80000e54:	3f29                	jal	80000d6e <PutChar>
            pStr++;
80000e56:	fdc42783          	lw	a5,-36(s0)
80000e5a:	0785                	addi	a5,a5,1
80000e5c:	fcf42e23          	sw	a5,-36(s0)
            num++;
80000e60:	fec42783          	lw	a5,-20(s0)
80000e64:	0785                	addi	a5,a5,1
80000e66:	fef42623          	sw	a5,-20(s0)
            width--;
80000e6a:	fd442783          	lw	a5,-44(s0)
80000e6e:	17fd                	addi	a5,a5,-1
80000e70:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
80000e74:	fd442783          	lw	a5,-44(s0)
80000e78:	fcf049e3          	bgtz	a5,80000e4a <PutUnsignedInt+0x62>
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (value % 10) + '0');
80000e7c:	fd042703          	lw	a4,-48(s0)
80000e80:	47a9                	li	a5,10
80000e82:	02f777b3          	remu	a5,a4,a5
80000e86:	0ff7f793          	zext.b	a5,a5
80000e8a:	03078793          	addi	a5,a5,48
80000e8e:	0ff7f793          	zext.b	a5,a5
80000e92:	85be                	mv	a1,a5
80000e94:	fdc42503          	lw	a0,-36(s0)
80000e98:	3dd9                	jal	80000d6e <PutChar>
80000e9a:	872a                	mv	a4,a0
80000e9c:	fec42783          	lw	a5,-20(s0)
80000ea0:	97ba                	add	a5,a5,a4
80000ea2:	fef42623          	sw	a5,-20(s0)

    return num;
80000ea6:	fec42783          	lw	a5,-20(s0)
}
80000eaa:	853e                	mv	a0,a5
80000eac:	50b2                	lw	ra,44(sp)
80000eae:	5422                	lw	s0,40(sp)
80000eb0:	6145                	addi	sp,sp,48
80000eb2:	8082                	ret

80000eb4 <PutSignedInt>:
signed int PutSignedInt(
    char *pStr,
    char fill,
    signed int width,
    signed int value)
{
80000eb4:	7179                	addi	sp,sp,-48
80000eb6:	d606                	sw	ra,44(sp)
80000eb8:	d422                	sw	s0,40(sp)
80000eba:	1800                	addi	s0,sp,48
80000ebc:	fca42e23          	sw	a0,-36(s0)
80000ec0:	87ae                	mv	a5,a1
80000ec2:	fcc42a23          	sw	a2,-44(s0)
80000ec6:	fcd42823          	sw	a3,-48(s0)
80000eca:	fcf40da3          	sb	a5,-37(s0)
    signed int num = 0;
80000ece:	fe042623          	sw	zero,-20(s0)
    unsigned int absolute;

    /* Compute absolute value */
    if (value < 0) {
80000ed2:	fd042783          	lw	a5,-48(s0)
80000ed6:	0007d963          	bgez	a5,80000ee8 <PutSignedInt+0x34>

        absolute = -value;
80000eda:	fd042783          	lw	a5,-48(s0)
80000ede:	40f007b3          	neg	a5,a5
80000ee2:	fef42423          	sw	a5,-24(s0)
80000ee6:	a029                	j	80000ef0 <PutSignedInt+0x3c>
    }
    else {

        absolute = value;
80000ee8:	fd042783          	lw	a5,-48(s0)
80000eec:	fef42423          	sw	a5,-24(s0)
    }

    /* Take current digit into account when calculating width */
    width--;
80000ef0:	fd442783          	lw	a5,-44(s0)
80000ef4:	17fd                	addi	a5,a5,-1
80000ef6:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively write upper digits */
    if ((absolute / 10) > 0) {
80000efa:	fe842703          	lw	a4,-24(s0)
80000efe:	47a5                	li	a5,9
80000f00:	06e7f363          	bgeu	a5,a4,80000f66 <PutSignedInt+0xb2>

        if (value < 0) {
80000f04:	fd042783          	lw	a5,-48(s0)
80000f08:	0207d663          	bgez	a5,80000f34 <PutSignedInt+0x80>

            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
80000f0c:	fe842703          	lw	a4,-24(s0)
80000f10:	47a9                	li	a5,10
80000f12:	02f757b3          	divu	a5,a4,a5
80000f16:	40f007b3          	neg	a5,a5
80000f1a:	873e                	mv	a4,a5
80000f1c:	fdb44783          	lbu	a5,-37(s0)
80000f20:	86ba                	mv	a3,a4
80000f22:	fd442603          	lw	a2,-44(s0)
80000f26:	85be                	mv	a1,a5
80000f28:	fdc42503          	lw	a0,-36(s0)
80000f2c:	3761                	jal	80000eb4 <PutSignedInt>
80000f2e:	fea42623          	sw	a0,-20(s0)
80000f32:	a015                	j	80000f56 <PutSignedInt+0xa2>
        }
        else {

            num = PutSignedInt(pStr, fill, width, absolute / 10);
80000f34:	fe842703          	lw	a4,-24(s0)
80000f38:	47a9                	li	a5,10
80000f3a:	02f757b3          	divu	a5,a4,a5
80000f3e:	873e                	mv	a4,a5
80000f40:	fdb44783          	lbu	a5,-37(s0)
80000f44:	86ba                	mv	a3,a4
80000f46:	fd442603          	lw	a2,-44(s0)
80000f4a:	85be                	mv	a1,a5
80000f4c:	fdc42503          	lw	a0,-36(s0)
80000f50:	3795                	jal	80000eb4 <PutSignedInt>
80000f52:	fea42623          	sw	a0,-20(s0)
        }
        pStr += num;
80000f56:	fec42783          	lw	a5,-20(s0)
80000f5a:	fdc42703          	lw	a4,-36(s0)
80000f5e:	97ba                	add	a5,a5,a4
80000f60:	fcf42e23          	sw	a5,-36(s0)
80000f64:	a885                	j	80000fd4 <PutSignedInt+0x120>
    }
    else {

        /* Reserve space for sign */
        if (value < 0) {
80000f66:	fd042783          	lw	a5,-48(s0)
80000f6a:	0207dd63          	bgez	a5,80000fa4 <PutSignedInt+0xf0>

            width--;
80000f6e:	fd442783          	lw	a5,-44(s0)
80000f72:	17fd                	addi	a5,a5,-1
80000f74:	fcf42a23          	sw	a5,-44(s0)
        }

        /* Write filler characters */
        while (width > 0) {
80000f78:	a035                	j	80000fa4 <PutSignedInt+0xf0>

            PutChar(pStr, fill);
80000f7a:	fdb44783          	lbu	a5,-37(s0)
80000f7e:	85be                	mv	a1,a5
80000f80:	fdc42503          	lw	a0,-36(s0)
80000f84:	33ed                	jal	80000d6e <PutChar>
            pStr++;
80000f86:	fdc42783          	lw	a5,-36(s0)
80000f8a:	0785                	addi	a5,a5,1
80000f8c:	fcf42e23          	sw	a5,-36(s0)
            num++;
80000f90:	fec42783          	lw	a5,-20(s0)
80000f94:	0785                	addi	a5,a5,1
80000f96:	fef42623          	sw	a5,-20(s0)
            width--;
80000f9a:	fd442783          	lw	a5,-44(s0)
80000f9e:	17fd                	addi	a5,a5,-1
80000fa0:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
80000fa4:	fd442783          	lw	a5,-44(s0)
80000fa8:	fcf049e3          	bgtz	a5,80000f7a <PutSignedInt+0xc6>
        }

        /* Write sign */
        if (value < 0) {
80000fac:	fd042783          	lw	a5,-48(s0)
80000fb0:	0207d263          	bgez	a5,80000fd4 <PutSignedInt+0x120>

            num += PutChar(pStr, '-');
80000fb4:	02d00593          	li	a1,45
80000fb8:	fdc42503          	lw	a0,-36(s0)
80000fbc:	3b4d                	jal	80000d6e <PutChar>
80000fbe:	872a                	mv	a4,a0
80000fc0:	fec42783          	lw	a5,-20(s0)
80000fc4:	97ba                	add	a5,a5,a4
80000fc6:	fef42623          	sw	a5,-20(s0)
            pStr++;
80000fca:	fdc42783          	lw	a5,-36(s0)
80000fce:	0785                	addi	a5,a5,1
80000fd0:	fcf42e23          	sw	a5,-36(s0)
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (absolute % 10) + '0');
80000fd4:	fe842703          	lw	a4,-24(s0)
80000fd8:	47a9                	li	a5,10
80000fda:	02f777b3          	remu	a5,a4,a5
80000fde:	0ff7f793          	zext.b	a5,a5
80000fe2:	03078793          	addi	a5,a5,48
80000fe6:	0ff7f793          	zext.b	a5,a5
80000fea:	85be                	mv	a1,a5
80000fec:	fdc42503          	lw	a0,-36(s0)
80000ff0:	3bbd                	jal	80000d6e <PutChar>
80000ff2:	872a                	mv	a4,a0
80000ff4:	fec42783          	lw	a5,-20(s0)
80000ff8:	97ba                	add	a5,a5,a4
80000ffa:	fef42623          	sw	a5,-20(s0)

    return num;
80000ffe:	fec42783          	lw	a5,-20(s0)
}
80001002:	853e                	mv	a0,a5
80001004:	50b2                	lw	ra,44(sp)
80001006:	5422                	lw	s0,40(sp)
80001008:	6145                	addi	sp,sp,48
8000100a:	8082                	ret

8000100c <PutHexa>:
    char *pStr,
    char fill,
    signed int width,
    unsigned char maj,
    unsigned int value)
{
8000100c:	7179                	addi	sp,sp,-48
8000100e:	d606                	sw	ra,44(sp)
80001010:	d422                	sw	s0,40(sp)
80001012:	1800                	addi	s0,sp,48
80001014:	fca42e23          	sw	a0,-36(s0)
80001018:	87ae                	mv	a5,a1
8000101a:	fcc42a23          	sw	a2,-44(s0)
8000101e:	fce42823          	sw	a4,-48(s0)
80001022:	fcf40da3          	sb	a5,-37(s0)
80001026:	87b6                	mv	a5,a3
80001028:	fcf40d23          	sb	a5,-38(s0)
    signed int num = 0;
8000102c:	fe042623          	sw	zero,-20(s0)

    /* Decrement width */
    width--;
80001030:	fd442783          	lw	a5,-44(s0)
80001034:	17fd                	addi	a5,a5,-1
80001036:	fcf42a23          	sw	a5,-44(s0)

    /* Recursively output upper digits */
    if ((value >> 4) > 0) {
8000103a:	fd042783          	lw	a5,-48(s0)
8000103e:	8391                	srli	a5,a5,0x4
80001040:	c3b5                	beqz	a5,800010a4 <PutHexa+0x98>

        num += PutHexa(pStr, fill, width, maj, value >> 4);
80001042:	fd042783          	lw	a5,-48(s0)
80001046:	0047d713          	srli	a4,a5,0x4
8000104a:	fda44683          	lbu	a3,-38(s0)
8000104e:	fdb44783          	lbu	a5,-37(s0)
80001052:	fd442603          	lw	a2,-44(s0)
80001056:	85be                	mv	a1,a5
80001058:	fdc42503          	lw	a0,-36(s0)
8000105c:	3f45                	jal	8000100c <PutHexa>
8000105e:	872a                	mv	a4,a0
80001060:	fec42783          	lw	a5,-20(s0)
80001064:	97ba                	add	a5,a5,a4
80001066:	fef42623          	sw	a5,-20(s0)
        pStr += num;
8000106a:	fec42783          	lw	a5,-20(s0)
8000106e:	fdc42703          	lw	a4,-36(s0)
80001072:	97ba                	add	a5,a5,a4
80001074:	fcf42e23          	sw	a5,-36(s0)
80001078:	a815                	j	800010ac <PutHexa+0xa0>
    /* Write filler chars */
    else {

        while (width > 0) {

            PutChar(pStr, fill);
8000107a:	fdb44783          	lbu	a5,-37(s0)
8000107e:	85be                	mv	a1,a5
80001080:	fdc42503          	lw	a0,-36(s0)
80001084:	31ed                	jal	80000d6e <PutChar>
            pStr++;
80001086:	fdc42783          	lw	a5,-36(s0)
8000108a:	0785                	addi	a5,a5,1
8000108c:	fcf42e23          	sw	a5,-36(s0)
            num++;
80001090:	fec42783          	lw	a5,-20(s0)
80001094:	0785                	addi	a5,a5,1
80001096:	fef42623          	sw	a5,-20(s0)
            width--;
8000109a:	fd442783          	lw	a5,-44(s0)
8000109e:	17fd                	addi	a5,a5,-1
800010a0:	fcf42a23          	sw	a5,-44(s0)
        while (width > 0) {
800010a4:	fd442783          	lw	a5,-44(s0)
800010a8:	fcf049e3          	bgtz	a5,8000107a <PutHexa+0x6e>
        }
    }

    /* Write current digit */
    if ((value & 0xF) < 10) {
800010ac:	fd042783          	lw	a5,-48(s0)
800010b0:	00f7f713          	andi	a4,a5,15
800010b4:	47a5                	li	a5,9
800010b6:	02e7e263          	bltu	a5,a4,800010da <PutHexa+0xce>

        PutChar(pStr, (value & 0xF) + '0');
800010ba:	fd042783          	lw	a5,-48(s0)
800010be:	0ff7f793          	zext.b	a5,a5
800010c2:	8bbd                	andi	a5,a5,15
800010c4:	0ff7f793          	zext.b	a5,a5
800010c8:	03078793          	addi	a5,a5,48
800010cc:	0ff7f793          	zext.b	a5,a5
800010d0:	85be                	mv	a1,a5
800010d2:	fdc42503          	lw	a0,-36(s0)
800010d6:	3961                	jal	80000d6e <PutChar>
800010d8:	a099                	j	8000111e <PutHexa+0x112>
    }
    else if (maj) {
800010da:	fda44783          	lbu	a5,-38(s0)
800010de:	c38d                	beqz	a5,80001100 <PutHexa+0xf4>

        PutChar(pStr, (value & 0xF) - 10 + 'A');
800010e0:	fd042783          	lw	a5,-48(s0)
800010e4:	0ff7f793          	zext.b	a5,a5
800010e8:	8bbd                	andi	a5,a5,15
800010ea:	0ff7f793          	zext.b	a5,a5
800010ee:	03778793          	addi	a5,a5,55
800010f2:	0ff7f793          	zext.b	a5,a5
800010f6:	85be                	mv	a1,a5
800010f8:	fdc42503          	lw	a0,-36(s0)
800010fc:	398d                	jal	80000d6e <PutChar>
800010fe:	a005                	j	8000111e <PutHexa+0x112>
    }
    else {

        PutChar(pStr, (value & 0xF) - 10 + 'a');
80001100:	fd042783          	lw	a5,-48(s0)
80001104:	0ff7f793          	zext.b	a5,a5
80001108:	8bbd                	andi	a5,a5,15
8000110a:	0ff7f793          	zext.b	a5,a5
8000110e:	05778793          	addi	a5,a5,87
80001112:	0ff7f793          	zext.b	a5,a5
80001116:	85be                	mv	a1,a5
80001118:	fdc42503          	lw	a0,-36(s0)
8000111c:	3989                	jal	80000d6e <PutChar>
    }
    num++;
8000111e:	fec42783          	lw	a5,-20(s0)
80001122:	0785                	addi	a5,a5,1
80001124:	fef42623          	sw	a5,-20(s0)

    return num;
80001128:	fec42783          	lw	a5,-20(s0)
}
8000112c:	853e                	mv	a0,a5
8000112e:	50b2                	lw	ra,44(sp)
80001130:	5422                	lw	s0,40(sp)
80001132:	6145                	addi	sp,sp,48
80001134:	8082                	ret

80001136 <vsnprintf>:
 * @param ap      Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsnprintf(char *pStr, size_t length, const char *pFormat, va_list ap)
{
80001136:	7179                	addi	sp,sp,-48
80001138:	d606                	sw	ra,44(sp)
8000113a:	d422                	sw	s0,40(sp)
8000113c:	1800                	addi	s0,sp,48
8000113e:	fca42e23          	sw	a0,-36(s0)
80001142:	fcb42c23          	sw	a1,-40(s0)
80001146:	fcc42a23          	sw	a2,-44(s0)
8000114a:	fcd42823          	sw	a3,-48(s0)
    char          fill;
    unsigned char width;
    signed int    num = 0;
8000114e:	fe042423          	sw	zero,-24(s0)
    signed int    size = 0;
80001152:	fe042223          	sw	zero,-28(s0)

    /* Clear the string */
    if (pStr) {
80001156:	fdc42783          	lw	a5,-36(s0)
8000115a:	26078163          	beqz	a5,800013bc <vsnprintf+0x286>

        *pStr = 0;
8000115e:	fdc42783          	lw	a5,-36(s0)
80001162:	00078023          	sb	zero,0(a5)
    }

    /* Phase string */
    while (*pFormat != 0 && size < length) {
80001166:	ac99                	j	800013bc <vsnprintf+0x286>

        /* Normal character */
        if (*pFormat != '%') {
80001168:	fd442783          	lw	a5,-44(s0)
8000116c:	0007c703          	lbu	a4,0(a5)
80001170:	02500793          	li	a5,37
80001174:	02f70863          	beq	a4,a5,800011a4 <vsnprintf+0x6e>

            *pStr++ = *pFormat++;
80001178:	fd442703          	lw	a4,-44(s0)
8000117c:	00170793          	addi	a5,a4,1
80001180:	fcf42a23          	sw	a5,-44(s0)
80001184:	fdc42783          	lw	a5,-36(s0)
80001188:	00178693          	addi	a3,a5,1
8000118c:	fcd42e23          	sw	a3,-36(s0)
80001190:	00074703          	lbu	a4,0(a4)
80001194:	00e78023          	sb	a4,0(a5)
            size++;
80001198:	fe442783          	lw	a5,-28(s0)
8000119c:	0785                	addi	a5,a5,1
8000119e:	fef42223          	sw	a5,-28(s0)
800011a2:	ac29                	j	800013bc <vsnprintf+0x286>
        }
        /* Escaped '%' */
        else if (*(pFormat+1) == '%') {
800011a4:	fd442783          	lw	a5,-44(s0)
800011a8:	0785                	addi	a5,a5,1
800011aa:	0007c703          	lbu	a4,0(a5)
800011ae:	02500793          	li	a5,37
800011b2:	02f71763          	bne	a4,a5,800011e0 <vsnprintf+0xaa>

            *pStr++ = '%';
800011b6:	fdc42783          	lw	a5,-36(s0)
800011ba:	00178713          	addi	a4,a5,1
800011be:	fce42e23          	sw	a4,-36(s0)
800011c2:	02500713          	li	a4,37
800011c6:	00e78023          	sb	a4,0(a5)
            pFormat += 2;
800011ca:	fd442783          	lw	a5,-44(s0)
800011ce:	0789                	addi	a5,a5,2
800011d0:	fcf42a23          	sw	a5,-44(s0)
            size++;
800011d4:	fe442783          	lw	a5,-28(s0)
800011d8:	0785                	addi	a5,a5,1
800011da:	fef42223          	sw	a5,-28(s0)
800011de:	aaf9                	j	800013bc <vsnprintf+0x286>
        }
        /* Token delimiter */
        else {

            fill = ' ';
800011e0:	02000793          	li	a5,32
800011e4:	fef407a3          	sb	a5,-17(s0)
            width = 0;
800011e8:	fe040723          	sb	zero,-18(s0)
            pFormat++;
800011ec:	fd442783          	lw	a5,-44(s0)
800011f0:	0785                	addi	a5,a5,1
800011f2:	fcf42a23          	sw	a5,-44(s0)

            /* Parse filler */
            if (*pFormat == '0') {
800011f6:	fd442783          	lw	a5,-44(s0)
800011fa:	0007c703          	lbu	a4,0(a5)
800011fe:	03000793          	li	a5,48
80001202:	04f71563          	bne	a4,a5,8000124c <vsnprintf+0x116>

                fill = '0';
80001206:	03000793          	li	a5,48
8000120a:	fef407a3          	sb	a5,-17(s0)
                pFormat++;
8000120e:	fd442783          	lw	a5,-44(s0)
80001212:	0785                	addi	a5,a5,1
80001214:	fcf42a23          	sw	a5,-44(s0)
            }

            /* Parse width */
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
80001218:	a815                	j	8000124c <vsnprintf+0x116>

                width = (width*10) + *pFormat-'0';
8000121a:	fee44783          	lbu	a5,-18(s0)
8000121e:	873e                	mv	a4,a5
80001220:	87ba                	mv	a5,a4
80001222:	078a                	slli	a5,a5,0x2
80001224:	97ba                	add	a5,a5,a4
80001226:	0786                	slli	a5,a5,0x1
80001228:	0ff7f713          	zext.b	a4,a5
8000122c:	fd442783          	lw	a5,-44(s0)
80001230:	0007c783          	lbu	a5,0(a5)
80001234:	97ba                	add	a5,a5,a4
80001236:	0ff7f793          	zext.b	a5,a5
8000123a:	fd078793          	addi	a5,a5,-48
8000123e:	fef40723          	sb	a5,-18(s0)
                pFormat++;
80001242:	fd442783          	lw	a5,-44(s0)
80001246:	0785                	addi	a5,a5,1
80001248:	fcf42a23          	sw	a5,-44(s0)
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
8000124c:	fd442783          	lw	a5,-44(s0)
80001250:	0007c703          	lbu	a4,0(a5)
80001254:	02f00793          	li	a5,47
80001258:	00e7fa63          	bgeu	a5,a4,8000126c <vsnprintf+0x136>
8000125c:	fd442783          	lw	a5,-44(s0)
80001260:	0007c703          	lbu	a4,0(a5)
80001264:	03900793          	li	a5,57
80001268:	fae7f9e3          	bgeu	a5,a4,8000121a <vsnprintf+0xe4>
            }

            /* Check if there is enough space */
            if (size + width > length) {
8000126c:	fee44703          	lbu	a4,-18(s0)
80001270:	fe442783          	lw	a5,-28(s0)
80001274:	97ba                	add	a5,a5,a4
80001276:	873e                	mv	a4,a5
80001278:	fd842783          	lw	a5,-40(s0)
8000127c:	00e7fe63          	bgeu	a5,a4,80001298 <vsnprintf+0x162>

                width = length - size;
80001280:	fd842783          	lw	a5,-40(s0)
80001284:	0ff7f713          	zext.b	a4,a5
80001288:	fe442783          	lw	a5,-28(s0)
8000128c:	0ff7f793          	zext.b	a5,a5
80001290:	40f707b3          	sub	a5,a4,a5
80001294:	fef40723          	sb	a5,-18(s0)
            }

            /* Parse type */
            switch (*pFormat) {
80001298:	fd442783          	lw	a5,-44(s0)
8000129c:	0007c783          	lbu	a5,0(a5)
800012a0:	fa878793          	addi	a5,a5,-88
800012a4:	02000713          	li	a4,32
800012a8:	0ef76563          	bltu	a4,a5,80001392 <vsnprintf+0x25c>
800012ac:	00279713          	slli	a4,a5,0x2
800012b0:	800097b7          	lui	a5,0x80009
800012b4:	a1c78793          	addi	a5,a5,-1508 # 80008a1c <__data_source_start+0xfffffbc8>
800012b8:	97ba                	add	a5,a5,a4
800012ba:	439c                	lw	a5,0(a5)
800012bc:	8782                	jr	a5
            case 'd':
            case 'i': num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int)); break;
800012be:	fee44603          	lbu	a2,-18(s0)
800012c2:	fd042783          	lw	a5,-48(s0)
800012c6:	00478713          	addi	a4,a5,4
800012ca:	fce42823          	sw	a4,-48(s0)
800012ce:	4398                	lw	a4,0(a5)
800012d0:	fef44783          	lbu	a5,-17(s0)
800012d4:	86ba                	mv	a3,a4
800012d6:	85be                	mv	a1,a5
800012d8:	fdc42503          	lw	a0,-36(s0)
800012dc:	3ee1                	jal	80000eb4 <PutSignedInt>
800012de:	fea42423          	sw	a0,-24(s0)
800012e2:	a855                	j	80001396 <vsnprintf+0x260>
            case 'u': num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned int)); break;
800012e4:	fee44603          	lbu	a2,-18(s0)
800012e8:	fd042783          	lw	a5,-48(s0)
800012ec:	00478713          	addi	a4,a5,4
800012f0:	fce42823          	sw	a4,-48(s0)
800012f4:	4398                	lw	a4,0(a5)
800012f6:	fef44783          	lbu	a5,-17(s0)
800012fa:	86ba                	mv	a3,a4
800012fc:	85be                	mv	a1,a5
800012fe:	fdc42503          	lw	a0,-36(s0)
80001302:	34dd                	jal	80000de8 <PutUnsignedInt>
80001304:	fea42423          	sw	a0,-24(s0)
80001308:	a079                	j	80001396 <vsnprintf+0x260>
            case 'x': num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int)); break;
8000130a:	fee44603          	lbu	a2,-18(s0)
8000130e:	fd042783          	lw	a5,-48(s0)
80001312:	00478713          	addi	a4,a5,4
80001316:	fce42823          	sw	a4,-48(s0)
8000131a:	4398                	lw	a4,0(a5)
8000131c:	fef44783          	lbu	a5,-17(s0)
80001320:	4681                	li	a3,0
80001322:	85be                	mv	a1,a5
80001324:	fdc42503          	lw	a0,-36(s0)
80001328:	31d5                	jal	8000100c <PutHexa>
8000132a:	fea42423          	sw	a0,-24(s0)
8000132e:	a0a5                	j	80001396 <vsnprintf+0x260>
            case 'X': num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int)); break;
80001330:	fee44603          	lbu	a2,-18(s0)
80001334:	fd042783          	lw	a5,-48(s0)
80001338:	00478713          	addi	a4,a5,4
8000133c:	fce42823          	sw	a4,-48(s0)
80001340:	4398                	lw	a4,0(a5)
80001342:	fef44783          	lbu	a5,-17(s0)
80001346:	4685                	li	a3,1
80001348:	85be                	mv	a1,a5
8000134a:	fdc42503          	lw	a0,-36(s0)
8000134e:	397d                	jal	8000100c <PutHexa>
80001350:	fea42423          	sw	a0,-24(s0)
80001354:	a089                	j	80001396 <vsnprintf+0x260>
            case 's': num = PutString(pStr, va_arg(ap, char *)); break;
80001356:	fd042783          	lw	a5,-48(s0)
8000135a:	00478713          	addi	a4,a5,4
8000135e:	fce42823          	sw	a4,-48(s0)
80001362:	439c                	lw	a5,0(a5)
80001364:	85be                	mv	a1,a5
80001366:	fdc42503          	lw	a0,-36(s0)
8000136a:	342d                	jal	80000d94 <PutString>
8000136c:	fea42423          	sw	a0,-24(s0)
80001370:	a01d                	j	80001396 <vsnprintf+0x260>
            case 'c': num = PutChar(pStr, va_arg(ap, unsigned int)); break;
80001372:	fd042783          	lw	a5,-48(s0)
80001376:	00478713          	addi	a4,a5,4
8000137a:	fce42823          	sw	a4,-48(s0)
8000137e:	439c                	lw	a5,0(a5)
80001380:	0ff7f793          	zext.b	a5,a5
80001384:	85be                	mv	a1,a5
80001386:	fdc42503          	lw	a0,-36(s0)
8000138a:	32d5                	jal	80000d6e <PutChar>
8000138c:	fea42423          	sw	a0,-24(s0)
80001390:	a019                	j	80001396 <vsnprintf+0x260>
            default:
                return EOF;
80001392:	57fd                	li	a5,-1
80001394:	a895                	j	80001408 <vsnprintf+0x2d2>
            }

            pFormat++;
80001396:	fd442783          	lw	a5,-44(s0)
8000139a:	0785                	addi	a5,a5,1
8000139c:	fcf42a23          	sw	a5,-44(s0)
            pStr += num;
800013a0:	fe842783          	lw	a5,-24(s0)
800013a4:	fdc42703          	lw	a4,-36(s0)
800013a8:	97ba                	add	a5,a5,a4
800013aa:	fcf42e23          	sw	a5,-36(s0)
            size += num;
800013ae:	fe442703          	lw	a4,-28(s0)
800013b2:	fe842783          	lw	a5,-24(s0)
800013b6:	97ba                	add	a5,a5,a4
800013b8:	fef42223          	sw	a5,-28(s0)
    while (*pFormat != 0 && size < length) {
800013bc:	fd442783          	lw	a5,-44(s0)
800013c0:	0007c783          	lbu	a5,0(a5)
800013c4:	c799                	beqz	a5,800013d2 <vsnprintf+0x29c>
800013c6:	fe442783          	lw	a5,-28(s0)
800013ca:	fd842703          	lw	a4,-40(s0)
800013ce:	d8e7ede3          	bltu	a5,a4,80001168 <vsnprintf+0x32>
        }
    }

    /* NULL-terminated (final \0 is not counted) */
    if (size < length) {
800013d2:	fe442783          	lw	a5,-28(s0)
800013d6:	fd842703          	lw	a4,-40(s0)
800013da:	00e7f763          	bgeu	a5,a4,800013e8 <vsnprintf+0x2b2>

        *pStr = 0;
800013de:	fdc42783          	lw	a5,-36(s0)
800013e2:	00078023          	sb	zero,0(a5)
800013e6:	a839                	j	80001404 <vsnprintf+0x2ce>
    }
    else {

        *(--pStr) = 0;
800013e8:	fdc42783          	lw	a5,-36(s0)
800013ec:	17fd                	addi	a5,a5,-1
800013ee:	fcf42e23          	sw	a5,-36(s0)
800013f2:	fdc42783          	lw	a5,-36(s0)
800013f6:	00078023          	sb	zero,0(a5)
        size--;
800013fa:	fe442783          	lw	a5,-28(s0)
800013fe:	17fd                	addi	a5,a5,-1
80001400:	fef42223          	sw	a5,-28(s0)
    }

    return size;
80001404:	fe442783          	lw	a5,-28(s0)
}
80001408:	853e                	mv	a0,a5
8000140a:	50b2                	lw	ra,44(sp)
8000140c:	5422                	lw	s0,40(sp)
8000140e:	6145                	addi	sp,sp,48
80001410:	8082                	ret

80001412 <snprintf>:
 * @param ...     Other arguments
 *
 * @return  The number of characters written.
 */
signed int snprintf(char *pString, size_t length, const char *pFormat, ...)
{
80001412:	715d                	addi	sp,sp,-80
80001414:	d606                	sw	ra,44(sp)
80001416:	d422                	sw	s0,40(sp)
80001418:	1800                	addi	s0,sp,48
8000141a:	fca42e23          	sw	a0,-36(s0)
8000141e:	fcb42c23          	sw	a1,-40(s0)
80001422:	fcc42a23          	sw	a2,-44(s0)
80001426:	c454                	sw	a3,12(s0)
80001428:	c818                	sw	a4,16(s0)
8000142a:	c85c                	sw	a5,20(s0)
8000142c:	01042c23          	sw	a6,24(s0)
80001430:	01142e23          	sw	a7,28(s0)
    va_list    ap;
    signed int rc;

    va_start(ap, pFormat);
80001434:	02040793          	addi	a5,s0,32
80001438:	fcf42823          	sw	a5,-48(s0)
8000143c:	fd042783          	lw	a5,-48(s0)
80001440:	17b1                	addi	a5,a5,-20
80001442:	fef42423          	sw	a5,-24(s0)
    rc = vsnprintf(pString, length, pFormat, ap);
80001446:	fe842783          	lw	a5,-24(s0)
8000144a:	86be                	mv	a3,a5
8000144c:	fd442603          	lw	a2,-44(s0)
80001450:	fd842583          	lw	a1,-40(s0)
80001454:	fdc42503          	lw	a0,-36(s0)
80001458:	39f9                	jal	80001136 <vsnprintf>
8000145a:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return rc;
8000145e:	fec42783          	lw	a5,-20(s0)
}
80001462:	853e                	mv	a0,a5
80001464:	50b2                	lw	ra,44(sp)
80001466:	5422                	lw	s0,40(sp)
80001468:	6161                	addi	sp,sp,80
8000146a:	8082                	ret

8000146c <vsprintf>:
 * @param ap       Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsprintf(char *pString, const char *pFormat, va_list ap)
{
8000146c:	1101                	addi	sp,sp,-32
8000146e:	ce06                	sw	ra,28(sp)
80001470:	cc22                	sw	s0,24(sp)
80001472:	1000                	addi	s0,sp,32
80001474:	fea42623          	sw	a0,-20(s0)
80001478:	feb42423          	sw	a1,-24(s0)
8000147c:	fec42223          	sw	a2,-28(s0)
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
80001480:	fe442683          	lw	a3,-28(s0)
80001484:	fe842603          	lw	a2,-24(s0)
80001488:	15e00593          	li	a1,350
8000148c:	fec42503          	lw	a0,-20(s0)
80001490:	315d                	jal	80001136 <vsnprintf>
80001492:	87aa                	mv	a5,a0
}
80001494:	853e                	mv	a0,a5
80001496:	40f2                	lw	ra,28(sp)
80001498:	4462                	lw	s0,24(sp)
8000149a:	6105                	addi	sp,sp,32
8000149c:	8082                	ret

8000149e <vfprintf>:
 * @param pStream  Output stream.
 * @param pFormat  Format string
 * @param ap       Argument list.
 */
signed int vfprintf(FILE *pStream, const char *pFormat, va_list ap)
{
8000149e:	7161                	addi	sp,sp,-432
800014a0:	1a112623          	sw	ra,428(sp)
800014a4:	1a812423          	sw	s0,424(sp)
800014a8:	1b00                	addi	s0,sp,432
800014aa:	e4a42e23          	sw	a0,-420(s0)
800014ae:	e4b42c23          	sw	a1,-424(s0)
800014b2:	e4c42a23          	sw	a2,-428(s0)
    char pStr[MAX_STRING_SIZE];
    char pError[] = "stdio.c: increase MAX_STRING_SIZE\n\r";
800014b6:	800097b7          	lui	a5,0x80009
800014ba:	aa078793          	addi	a5,a5,-1376 # 80008aa0 <__data_source_start+0xfffffc4c>
800014be:	0007a303          	lw	t1,0(a5)
800014c2:	0047a883          	lw	a7,4(a5)
800014c6:	0087a803          	lw	a6,8(a5)
800014ca:	47c8                	lw	a0,12(a5)
800014cc:	4b8c                	lw	a1,16(a5)
800014ce:	4bd0                	lw	a2,20(a5)
800014d0:	4f94                	lw	a3,24(a5)
800014d2:	4fd8                	lw	a4,28(a5)
800014d4:	539c                	lw	a5,32(a5)
800014d6:	e6642623          	sw	t1,-404(s0)
800014da:	e7142823          	sw	a7,-400(s0)
800014de:	e7042a23          	sw	a6,-396(s0)
800014e2:	e6a42c23          	sw	a0,-392(s0)
800014e6:	e6b42e23          	sw	a1,-388(s0)
800014ea:	e8c42023          	sw	a2,-384(s0)
800014ee:	e8d42223          	sw	a3,-380(s0)
800014f2:	e8e42423          	sw	a4,-376(s0)
800014f6:	e8f42623          	sw	a5,-372(s0)

    /* Write formatted string in buffer */
    if (vsprintf(pStr, pFormat, ap) >= MAX_STRING_SIZE) {
800014fa:	e9040793          	addi	a5,s0,-368
800014fe:	e5442603          	lw	a2,-428(s0)
80001502:	e5842583          	lw	a1,-424(s0)
80001506:	853e                	mv	a0,a5
80001508:	3795                	jal	8000146c <vsprintf>
8000150a:	872a                	mv	a4,a0
8000150c:	15d00793          	li	a5,349
80001510:	00e7dc63          	bge	a5,a4,80001528 <vfprintf+0x8a>

        fputs(pError, stderr);
80001514:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
80001518:	47d8                	lw	a4,12(a5)
8000151a:	e6c40793          	addi	a5,s0,-404
8000151e:	85ba                	mv	a1,a4
80001520:	853e                	mv	a0,a5
80001522:	22f1                	jal	800016ee <fputs>
        while (1); /* Increase MAX_STRING_SIZE */
80001524:	0001                	nop
80001526:	bffd                	j	80001524 <vfprintf+0x86>
    }

    /* Display string */
    return fputs(pStr, pStream);
80001528:	e9040793          	addi	a5,s0,-368
8000152c:	e5c42583          	lw	a1,-420(s0)
80001530:	853e                	mv	a0,a5
80001532:	2a75                	jal	800016ee <fputs>
80001534:	87aa                	mv	a5,a0
}
80001536:	853e                	mv	a0,a5
80001538:	1ac12083          	lw	ra,428(sp)
8000153c:	1a812403          	lw	s0,424(sp)
80001540:	615d                	addi	sp,sp,432
80001542:	8082                	ret

80001544 <vprintf>:
 *
 * @param pFormat  Format string.
 * @param ap  Argument list.
 */
signed int vprintf(const char *pFormat, va_list ap)
{
80001544:	1101                	addi	sp,sp,-32
80001546:	ce06                	sw	ra,28(sp)
80001548:	cc22                	sw	s0,24(sp)
8000154a:	1000                	addi	s0,sp,32
8000154c:	fea42623          	sw	a0,-20(s0)
80001550:	feb42423          	sw	a1,-24(s0)
    return vfprintf(stdout, pFormat, ap);
80001554:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
80001558:	479c                	lw	a5,8(a5)
8000155a:	fe842603          	lw	a2,-24(s0)
8000155e:	fec42583          	lw	a1,-20(s0)
80001562:	853e                	mv	a0,a5
80001564:	3f2d                	jal	8000149e <vfprintf>
80001566:	87aa                	mv	a5,a0
}
80001568:	853e                	mv	a0,a5
8000156a:	40f2                	lw	ra,28(sp)
8000156c:	4462                	lw	s0,24(sp)
8000156e:	6105                	addi	sp,sp,32
80001570:	8082                	ret

80001572 <fprintf>:
 *
 * @param pStream  Output stream.
 * @param pFormat  Format string.
 */
signed int fprintf(FILE *pStream, const char *pFormat, ...)
{
80001572:	715d                	addi	sp,sp,-80
80001574:	d606                	sw	ra,44(sp)
80001576:	d422                	sw	s0,40(sp)
80001578:	1800                	addi	s0,sp,48
8000157a:	fca42e23          	sw	a0,-36(s0)
8000157e:	fcb42c23          	sw	a1,-40(s0)
80001582:	c410                	sw	a2,8(s0)
80001584:	c454                	sw	a3,12(s0)
80001586:	c818                	sw	a4,16(s0)
80001588:	c85c                	sw	a5,20(s0)
8000158a:	01042c23          	sw	a6,24(s0)
8000158e:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    /* Forward call to vfprintf */
    va_start(ap, pFormat);
80001592:	02040793          	addi	a5,s0,32
80001596:	fcf42a23          	sw	a5,-44(s0)
8000159a:	fd442783          	lw	a5,-44(s0)
8000159e:	17a1                	addi	a5,a5,-24
800015a0:	fef42423          	sw	a5,-24(s0)
    result = vfprintf(pStream, pFormat, ap);
800015a4:	fe842783          	lw	a5,-24(s0)
800015a8:	863e                	mv	a2,a5
800015aa:	fd842583          	lw	a1,-40(s0)
800015ae:	fdc42503          	lw	a0,-36(s0)
800015b2:	35f5                	jal	8000149e <vfprintf>
800015b4:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
800015b8:	fec42783          	lw	a5,-20(s0)
}
800015bc:	853e                	mv	a0,a5
800015be:	50b2                	lw	ra,44(sp)
800015c0:	5422                	lw	s0,40(sp)
800015c2:	6161                	addi	sp,sp,80
800015c4:	8082                	ret

800015c6 <printf>:
 *         arguments.
 *
 * @param  pFormat  Format string.
 */
signed int printf(const char *pFormat, ...)
{
800015c6:	715d                	addi	sp,sp,-80
800015c8:	d606                	sw	ra,44(sp)
800015ca:	d422                	sw	s0,40(sp)
800015cc:	1800                	addi	s0,sp,48
800015ce:	fca42e23          	sw	a0,-36(s0)
800015d2:	c04c                	sw	a1,4(s0)
800015d4:	c410                	sw	a2,8(s0)
800015d6:	c454                	sw	a3,12(s0)
800015d8:	c818                	sw	a4,16(s0)
800015da:	c85c                	sw	a5,20(s0)
800015dc:	01042c23          	sw	a6,24(s0)
800015e0:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    /* Forward call to vprintf */
    va_start(ap, pFormat);
800015e4:	02040793          	addi	a5,s0,32
800015e8:	fcf42c23          	sw	a5,-40(s0)
800015ec:	fd842783          	lw	a5,-40(s0)
800015f0:	1791                	addi	a5,a5,-28
800015f2:	fef42423          	sw	a5,-24(s0)
    result = vprintf(pFormat, ap);
800015f6:	fe842783          	lw	a5,-24(s0)
800015fa:	85be                	mv	a1,a5
800015fc:	fdc42503          	lw	a0,-36(s0)
80001600:	3791                	jal	80001544 <vprintf>
80001602:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
80001606:	fec42783          	lw	a5,-20(s0)
}
8000160a:	853e                	mv	a0,a5
8000160c:	50b2                	lw	ra,44(sp)
8000160e:	5422                	lw	s0,40(sp)
80001610:	6161                	addi	sp,sp,80
80001612:	8082                	ret

80001614 <sprintf>:
 *
 * @param pStr     torage string.
 * @param pFormat  Format string.
 */
signed int sprintf(char *pStr, const char *pFormat, ...)
{
80001614:	715d                	addi	sp,sp,-80
80001616:	d606                	sw	ra,44(sp)
80001618:	d422                	sw	s0,40(sp)
8000161a:	1800                	addi	s0,sp,48
8000161c:	fca42e23          	sw	a0,-36(s0)
80001620:	fcb42c23          	sw	a1,-40(s0)
80001624:	c410                	sw	a2,8(s0)
80001626:	c454                	sw	a3,12(s0)
80001628:	c818                	sw	a4,16(s0)
8000162a:	c85c                	sw	a5,20(s0)
8000162c:	01042c23          	sw	a6,24(s0)
80001630:	01142e23          	sw	a7,28(s0)
    va_list ap;
    signed int result;

    // Forward call to vsprintf
    va_start(ap, pFormat);
80001634:	02040793          	addi	a5,s0,32
80001638:	fcf42a23          	sw	a5,-44(s0)
8000163c:	fd442783          	lw	a5,-44(s0)
80001640:	17a1                	addi	a5,a5,-24
80001642:	fef42423          	sw	a5,-24(s0)
    result = vsprintf(pStr, pFormat, ap);
80001646:	fe842783          	lw	a5,-24(s0)
8000164a:	863e                	mv	a2,a5
8000164c:	fd842583          	lw	a1,-40(s0)
80001650:	fdc42503          	lw	a0,-36(s0)
80001654:	3d21                	jal	8000146c <vsprintf>
80001656:	fea42623          	sw	a0,-20(s0)
    va_end(ap);

    return result;
8000165a:	fec42783          	lw	a5,-20(s0)
}
8000165e:	853e                	mv	a0,a5
80001660:	50b2                	lw	ra,44(sp)
80001662:	5422                	lw	s0,40(sp)
80001664:	6161                	addi	sp,sp,80
80001666:	8082                	ret

80001668 <puts>:
 * @brief  Outputs a string on stdout.
 *
 * @param pStr  String to output.
 */
signed int puts(const char *pStr)
{
80001668:	7179                	addi	sp,sp,-48
8000166a:	d606                	sw	ra,44(sp)
8000166c:	d422                	sw	s0,40(sp)
8000166e:	1800                	addi	s0,sp,48
80001670:	fca42e23          	sw	a0,-36(s0)
    signed int i = fputs(pStr, stdout);
80001674:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
80001678:	479c                	lw	a5,8(a5)
8000167a:	85be                	mv	a1,a5
8000167c:	fdc42503          	lw	a0,-36(s0)
80001680:	20bd                	jal	800016ee <fputs>
80001682:	fea42623          	sw	a0,-20(s0)
    fputc('\n', stdout);
80001686:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
8000168a:	479c                	lw	a5,8(a5)
8000168c:	85be                	mv	a1,a5
8000168e:	4529                	li	a0,10
80001690:	2809                	jal	800016a2 <fputc>

    return i+1;
80001692:	fec42783          	lw	a5,-20(s0)
80001696:	0785                	addi	a5,a5,1
}
80001698:	853e                	mv	a0,a5
8000169a:	50b2                	lw	ra,44(sp)
8000169c:	5422                	lw	s0,40(sp)
8000169e:	6145                	addi	sp,sp,48
800016a0:	8082                	ret

800016a2 <fputc>:
 * @param pStream  Output stream.
 * @param The character written if successful, or -1 if the output stream is
 *        not stdout or stderr.
 */
signed int fputc(signed int c, FILE *pStream)
{
800016a2:	1101                	addi	sp,sp,-32
800016a4:	ce06                	sw	ra,28(sp)
800016a6:	cc22                	sw	s0,24(sp)
800016a8:	1000                	addi	s0,sp,32
800016aa:	fea42623          	sw	a0,-20(s0)
800016ae:	feb42423          	sw	a1,-24(s0)
    if ((pStream == stdout) || (pStream == stderr)) {
800016b2:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
800016b6:	479c                	lw	a5,8(a5)
800016b8:	fe842703          	lw	a4,-24(s0)
800016bc:	00f70963          	beq	a4,a5,800016ce <fputc+0x2c>
800016c0:	8881a783          	lw	a5,-1912(gp) # 40000008 <_impure_ptr>
800016c4:	47dc                	lw	a5,12(a5)
800016c6:	fe842703          	lw	a4,-24(s0)
800016ca:	00f71c63          	bne	a4,a5,800016e2 <fputc+0x40>

    	PrintChar(c);
800016ce:	fec42783          	lw	a5,-20(s0)
800016d2:	0ff7f793          	zext.b	a5,a5
800016d6:	853e                	mv	a0,a5
800016d8:	e74ff0ef          	jal	ra,80000d4c <PrintChar>

        return c;
800016dc:	fec42783          	lw	a5,-20(s0)
800016e0:	a011                	j	800016e4 <fputc+0x42>
    }
    else {

        return EOF;
800016e2:	57fd                	li	a5,-1
    }
}
800016e4:	853e                	mv	a0,a5
800016e6:	40f2                	lw	ra,28(sp)
800016e8:	4462                	lw	s0,24(sp)
800016ea:	6105                	addi	sp,sp,32
800016ec:	8082                	ret

800016ee <fputs>:
 *
 * @return  Number of characters written if successful, or -1 if the output
 *          stream is not stdout or stderr.
 */
signed int fputs(const char *pStr, FILE *pStream)
{
800016ee:	7179                	addi	sp,sp,-48
800016f0:	d606                	sw	ra,44(sp)
800016f2:	d422                	sw	s0,40(sp)
800016f4:	1800                	addi	s0,sp,48
800016f6:	fca42e23          	sw	a0,-36(s0)
800016fa:	fcb42c23          	sw	a1,-40(s0)
    signed int num = 0;
800016fe:	fe042623          	sw	zero,-20(s0)

    while (*pStr != 0) {
80001702:	a80d                	j	80001734 <fputs+0x46>

        if (fputc(*pStr, pStream) == -1) {
80001704:	fdc42783          	lw	a5,-36(s0)
80001708:	0007c783          	lbu	a5,0(a5)
8000170c:	fd842583          	lw	a1,-40(s0)
80001710:	853e                	mv	a0,a5
80001712:	3f41                	jal	800016a2 <fputc>
80001714:	872a                	mv	a4,a0
80001716:	57fd                	li	a5,-1
80001718:	00f71463          	bne	a4,a5,80001720 <fputs+0x32>

            return -1;
8000171c:	57fd                	li	a5,-1
8000171e:	a015                	j	80001742 <fputs+0x54>
        }
        num++;
80001720:	fec42783          	lw	a5,-20(s0)
80001724:	0785                	addi	a5,a5,1
80001726:	fef42623          	sw	a5,-20(s0)
        pStr++;
8000172a:	fdc42783          	lw	a5,-36(s0)
8000172e:	0785                	addi	a5,a5,1
80001730:	fcf42e23          	sw	a5,-36(s0)
    while (*pStr != 0) {
80001734:	fdc42783          	lw	a5,-36(s0)
80001738:	0007c783          	lbu	a5,0(a5)
8000173c:	f7e1                	bnez	a5,80001704 <fputs+0x16>
    }

    return num;
8000173e:	fec42783          	lw	a5,-20(s0)
}
80001742:	853e                	mv	a0,a5
80001744:	50b2                	lw	ra,44(sp)
80001746:	5422                	lw	s0,40(sp)
80001748:	6145                	addi	sp,sp,48
8000174a:	8082                	ret

8000174c <retarget_init>:
#include "../Include/retarget.h"
// #include "../Include/system_k1921vg015.h"
#define SystemCoreClock_uart	SystemCoreClock
//-- Functions -----------------------------------------------------------------
void retarget_init()
{
8000174c:	1101                	addi	sp,sp,-32
8000174e:	ce22                	sw	s0,28(sp)
80001750:	1000                	addi	s0,sp,32
#if defined RETARGET
    uint32_t baud_icoef = HSECLK_VAL / (16 * RETARGET_UART_BAUD);
80001752:	47a1                	li	a5,8
80001754:	fef42423          	sw	a5,-24(s0)
    uint32_t baud_fcoef = ((HSECLK_VAL / (16.0f * RETARGET_UART_BAUD) - baud_icoef) * 64 + 0.5f);
80001758:	fe842783          	lw	a5,-24(s0)
8000175c:	d017f7d3          	fcvt.s.wu	fa5,a5
80001760:	800097b7          	lui	a5,0x80009
80001764:	ac47a707          	flw	fa4,-1340(a5) # 80008ac4 <__data_source_start+0xfffffc70>
80001768:	08f77753          	fsub.s	fa4,fa4,fa5
8000176c:	800097b7          	lui	a5,0x80009
80001770:	ac87a787          	flw	fa5,-1336(a5) # 80008ac8 <__data_source_start+0xfffffc74>
80001774:	10f77753          	fmul.s	fa4,fa4,fa5
80001778:	800097b7          	lui	a5,0x80009
8000177c:	acc7a787          	flw	fa5,-1332(a5) # 80008acc <__data_source_start+0xfffffc78>
80001780:	00f777d3          	fadd.s	fa5,fa4,fa5
80001784:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80001788:	fef42623          	sw	a5,-20(s0)

    // Настраиваем GPIO
    RCU->CGCFGAHB_bit.GPIOAEN = 1;
8000178c:	3000e7b7          	lui	a5,0x3000e
80001790:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80001794:	10076713          	ori	a4,a4,256
80001798:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOAEN = 1;
8000179c:	3000e7b7          	lui	a5,0x3000e
800017a0:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
800017a4:	10076713          	ori	a4,a4,256
800017a8:	00e79823          	sh	a4,16(a5)
    RCU->RSTDISAPB_bit.UART2EN = 1;
    #elif (RETARGET_UART_NUM == 3)
    RCU->CGCFGAPB_bit.UART3EN = 1;
    RCU->RSTDISAPB_bit.UART3EN = 1;
    #elif (RETARGET_UART_NUM == 4)
    RCU->CGCFGAPB_bit.UART4EN = 1;
800017ac:	3000e7b7          	lui	a5,0x3000e
800017b0:	4798                	lw	a4,8(a5)
800017b2:	40076713          	ori	a4,a4,1024
800017b6:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.UART4EN = 1;
800017b8:	3000e7b7          	lui	a5,0x3000e
800017bc:	4f98                	lw	a4,24(a5)
800017be:	40076713          	ori	a4,a4,1024
800017c2:	cf98                	sw	a4,24(a5)
    } else if (RETARGET_UART_PIN_TX_POS == 3) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN3 = 1;
    } else if (RETARGET_UART_PIN_TX_POS == 8) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN8 = 1;
    } else if (RETARGET_UART_PIN_TX_POS == 9) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN9 = 1;
800017c4:	280007b7          	lui	a5,0x28000
800017c8:	5fd4                	lw	a3,60(a5)
800017ca:	fff40737          	lui	a4,0xfff40
800017ce:	177d                	addi	a4,a4,-1 # fff3ffff <__data_source_start+0x7ff371ab>
800017d0:	8ef9                	and	a3,a3,a4
800017d2:	00040737          	lui	a4,0x40
800017d6:	8f55                	or	a4,a4,a3
800017d8:	dfd8                	sw	a4,60(a5)
    if (RETARGET_UART_PIN_RX_POS == 2) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN2 = 1;
    } else if (RETARGET_UART_PIN_RX_POS == 3) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN3 = 1;
    } else if (RETARGET_UART_PIN_RX_POS == 8) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN8 = 1;
800017da:	280007b7          	lui	a5,0x28000
800017de:	5fd4                	lw	a3,60(a5)
800017e0:	fffd0737          	lui	a4,0xfffd0
800017e4:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc71ab>
800017e6:	8ef9                	and	a3,a3,a4
800017e8:	6741                	lui	a4,0x10
800017ea:	8f55                	or	a4,a4,a3
800017ec:	dfd8                	sw	a4,60(a5)
    } else if (RETARGET_UART_PIN_RX_POS == 9) {
      RETARGET_UART_PORT->ALTFUNCNUM_bit.PIN9 = 1;
    }
    
    RETARGET_UART_PORT->ALTFUNCSET = (1 << RETARGET_UART_PIN_TX_POS) | (1 << RETARGET_UART_PIN_RX_POS);
800017ee:	280007b7          	lui	a5,0x28000
800017f2:	30000713          	li	a4,768
800017f6:	dbd8                	sw	a4,52(a5)

    // Настраиваем UART0 с более детальной конфигурацией
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.CLKSEL = RCU_UARTCLKCFG_CLKSEL_HSE;
800017f8:	3000e7b7          	lui	a5,0x3000e
800017fc:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
80001800:	fffd0737          	lui	a4,0xfffd0
80001804:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc71ab>
80001806:	8ef9                	and	a3,a3,a4
80001808:	6741                	lui	a4,0x10
8000180a:	8f55                	or	a4,a4,a3
8000180c:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.DIVEN = 0;
80001810:	3000e7b7          	lui	a5,0x3000e
80001814:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
80001818:	fff00737          	lui	a4,0xfff00
8000181c:	177d                	addi	a4,a4,-1 # ffefffff <__data_source_start+0x7fef71ab>
8000181e:	8f75                	and	a4,a4,a3
80001820:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.RSTDIS = 1;
80001824:	3000e7b7          	lui	a5,0x3000e
80001828:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
8000182c:	10076713          	ori	a4,a4,256
80001830:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[RETARGET_UART_NUM].UARTCLKCFG_bit.CLKEN = 1;
80001834:	3000e7b7          	lui	a5,0x3000e
80001838:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
8000183c:	00176713          	ori	a4,a4,1
80001840:	08e7a023          	sw	a4,128(a5)

    RETARGET_UART->IBRD = baud_icoef;
80001844:	3000a7b7          	lui	a5,0x3000a
80001848:	fe842703          	lw	a4,-24(s0)
8000184c:	d3d8                	sw	a4,36(a5)
    RETARGET_UART->FBRD = baud_fcoef;
8000184e:	3000a7b7          	lui	a5,0x3000a
80001852:	fec42703          	lw	a4,-20(s0)
80001856:	d798                	sw	a4,40(a5)
    RETARGET_UART->LCRH = UART_LCRH_FEN_Msk | (3 << UART_LCRH_WLEN_Pos);
80001858:	3000a7b7          	lui	a5,0x3000a
8000185c:	07000713          	li	a4,112
80001860:	d7d8                	sw	a4,44(a5)
    RETARGET_UART->IFLS = 0;  // Настройка уровня прерываний
80001862:	3000a7b7          	lui	a5,0x3000a
80001866:	0207aa23          	sw	zero,52(a5) # 3000a034 <STACK_SIZE+0x30009834>
    RETARGET_UART->CR = UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
8000186a:	3000a7b7          	lui	a5,0x3000a
8000186e:	30100713          	li	a4,769
80001872:	db98                	sw	a4,48(a5)
#endif //RETARGET
}
80001874:	0001                	nop
80001876:	4472                	lw	s0,28(sp)
80001878:	6105                	addi	sp,sp,32
8000187a:	8082                	ret

8000187c <retarget_get_char>:

int retarget_get_char()
{
8000187c:	1141                	addi	sp,sp,-16
8000187e:	c622                	sw	s0,12(sp)
80001880:	0800                	addi	s0,sp,16
#if defined RETARGET
    while (RETARGET_UART->FR_bit.RXFE) {
80001882:	0001                	nop
80001884:	3000a7b7          	lui	a5,0x3000a
80001888:	4f9c                	lw	a5,24(a5)
8000188a:	8391                	srli	a5,a5,0x4
8000188c:	8b85                	andi	a5,a5,1
8000188e:	0ff7f793          	zext.b	a5,a5
80001892:	fbed                	bnez	a5,80001884 <retarget_get_char+0x8>
    };
    return (int)RETARGET_UART->DR_bit.DATA;
80001894:	3000a7b7          	lui	a5,0x3000a
80001898:	0007c783          	lbu	a5,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
8000189c:	0ff7f793          	zext.b	a5,a5
#endif //RETARGET
    return -1;
}
800018a0:	853e                	mv	a0,a5
800018a2:	4432                	lw	s0,12(sp)
800018a4:	0141                	addi	sp,sp,16
800018a6:	8082                	ret

800018a8 <retarget_put_char>:

int retarget_put_char(int ch)
{
800018a8:	1101                	addi	sp,sp,-32
800018aa:	ce22                	sw	s0,28(sp)
800018ac:	1000                	addi	s0,sp,32
800018ae:	fea42623          	sw	a0,-20(s0)
#if defined RETARGET
    while (RETARGET_UART->FR_bit.BUSY) {
800018b2:	0001                	nop
800018b4:	3000a7b7          	lui	a5,0x3000a
800018b8:	4f9c                	lw	a5,24(a5)
800018ba:	838d                	srli	a5,a5,0x3
800018bc:	8b85                	andi	a5,a5,1
800018be:	0ff7f793          	zext.b	a5,a5
800018c2:	fbed                	bnez	a5,800018b4 <retarget_put_char+0xc>
    };
    RETARGET_UART->DR = ch;
800018c4:	3000a7b7          	lui	a5,0x3000a
800018c8:	fec42703          	lw	a4,-20(s0)
800018cc:	c398                	sw	a4,0(a5)
#endif //RETARGET
    return 0;
800018ce:	4781                	li	a5,0
}
800018d0:	853e                	mv	a0,a5
800018d2:	4472                	lw	s0,28(sp)
800018d4:	6105                	addi	sp,sp,32
800018d6:	8082                	ret

800018d8 <SystemCoreClockUpdate>:
uint32_t SystemPll1Clock; // System PLL1Clock Frequency
uint32_t USBClock; 		  // USB Clock Frequency (USB PLL Clock)

//-- Functions -----------------------------------------------------------------
void SystemCoreClockUpdate(void)
{
800018d8:	7139                	addi	sp,sp,-64
800018da:	de22                	sw	s0,60(sp)
800018dc:	0080                	addi	s0,sp,64
    uint32_t current_sysclk;
    uint32_t pll_refclk, pll_refdiv, pll_frac, pll_fbdiv, pll_pd0a, pll_pd0b, pll_pd1a, pll_pd1b = 1;
800018de:	4785                	li	a5,1
800018e0:	fef42423          	sw	a5,-24(s0)
    current_sysclk = RCU->CLKSTAT_bit.SRC;
800018e4:	3000e7b7          	lui	a5,0x3000e
800018e8:	5fdc                	lw	a5,60(a5)
800018ea:	8b8d                	andi	a5,a5,3
800018ec:	0ff7f793          	zext.b	a5,a5
800018f0:	fef42223          	sw	a5,-28(s0)
  	pll_refclk = HSECLK_VAL;
800018f4:	00f427b7          	lui	a5,0xf42
800018f8:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
800018fc:	fef42023          	sw	a5,-32(s0)
   	pll_fbdiv = RCU->PLLSYSCFG2_bit.FBDIV;
80001900:	3000e7b7          	lui	a5,0x3000e
80001904:	4fbc                	lw	a5,88(a5)
80001906:	873e                	mv	a4,a5
80001908:	6785                	lui	a5,0x1
8000190a:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
8000190c:	8ff9                	and	a5,a5,a4
8000190e:	07c2                	slli	a5,a5,0x10
80001910:	83c1                	srli	a5,a5,0x10
80001912:	fcf42e23          	sw	a5,-36(s0)
   	pll_refdiv = RCU->PLLSYSCFG0_bit.REFDIV;
80001916:	3000e7b7          	lui	a5,0x3000e
8000191a:	4bbc                	lw	a5,80(a5)
8000191c:	839d                	srli	a5,a5,0x7
8000191e:	03f7f793          	andi	a5,a5,63
80001922:	0ff7f793          	zext.b	a5,a5
80001926:	fcf42c23          	sw	a5,-40(s0)
   	pll_pd0a = RCU->PLLSYSCFG0_bit.PD0A;
8000192a:	3000e7b7          	lui	a5,0x3000e
8000192e:	4bbc                	lw	a5,80(a5)
80001930:	83b5                	srli	a5,a5,0xd
80001932:	8b9d                	andi	a5,a5,7
80001934:	0ff7f793          	zext.b	a5,a5
80001938:	fcf42a23          	sw	a5,-44(s0)
   	pll_pd0b = RCU->PLLSYSCFG0_bit.PD0B;
8000193c:	3000e7b7          	lui	a5,0x3000e
80001940:	4bbc                	lw	a5,80(a5)
80001942:	83c1                	srli	a5,a5,0x10
80001944:	03f7f793          	andi	a5,a5,63
80001948:	0ff7f793          	zext.b	a5,a5
8000194c:	fcf42823          	sw	a5,-48(s0)
   	pll_pd1a = RCU->PLLSYSCFG0_bit.PD1A;
80001950:	3000e7b7          	lui	a5,0x3000e
80001954:	4bbc                	lw	a5,80(a5)
80001956:	83d9                	srli	a5,a5,0x16
80001958:	8b9d                	andi	a5,a5,7
8000195a:	0ff7f793          	zext.b	a5,a5
8000195e:	fcf42623          	sw	a5,-52(s0)
   	pll_pd1b = RCU->PLLSYSCFG0_bit.PD1B;
80001962:	3000e7b7          	lui	a5,0x3000e
80001966:	4bbc                	lw	a5,80(a5)
80001968:	83e5                	srli	a5,a5,0x19
8000196a:	03f7f793          	andi	a5,a5,63
8000196e:	0ff7f793          	zext.b	a5,a5
80001972:	fef42423          	sw	a5,-24(s0)
   	if (RCU->PLLSYSCFG0_bit.DSMEN) pll_frac = RCU->PLLSYSCFG1_bit.FRAC;
80001976:	3000e7b7          	lui	a5,0x3000e
8000197a:	4bbc                	lw	a5,80(a5)
8000197c:	8391                	srli	a5,a5,0x4
8000197e:	8b85                	andi	a5,a5,1
80001980:	0ff7f793          	zext.b	a5,a5
80001984:	cb99                	beqz	a5,8000199a <SystemCoreClockUpdate+0xc2>
80001986:	3000e7b7          	lui	a5,0x3000e
8000198a:	4bf8                	lw	a4,84(a5)
8000198c:	010007b7          	lui	a5,0x1000
80001990:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
80001992:	8ff9                	and	a5,a5,a4
80001994:	fef42623          	sw	a5,-20(s0)
80001998:	a019                	j	8000199e <SystemCoreClockUpdate+0xc6>
   	else pll_frac = 0;
8000199a:	fe042623          	sw	zero,-20(s0)

   	SystemPll0Clock = (pll_refclk * (pll_fbdiv+pll_frac/(1 << 24))) / (pll_refdiv * (1+pll_pd0a) * (1+pll_pd0b));
8000199e:	fec42783          	lw	a5,-20(s0)
800019a2:	0187d713          	srli	a4,a5,0x18
800019a6:	fdc42783          	lw	a5,-36(s0)
800019aa:	973e                	add	a4,a4,a5
800019ac:	fe042783          	lw	a5,-32(s0)
800019b0:	02f70733          	mul	a4,a4,a5
800019b4:	fd442783          	lw	a5,-44(s0)
800019b8:	00178693          	addi	a3,a5,1
800019bc:	fd842783          	lw	a5,-40(s0)
800019c0:	02f686b3          	mul	a3,a3,a5
800019c4:	fd042783          	lw	a5,-48(s0)
800019c8:	0785                	addi	a5,a5,1
800019ca:	02f687b3          	mul	a5,a3,a5
800019ce:	02f75733          	divu	a4,a4,a5
800019d2:	e0e1ae23          	sw	a4,-484(gp) # 4000059c <SystemPll0Clock>
   	SystemPll1Clock = (pll_refclk * (pll_fbdiv+pll_frac/(1 << 24))) / (pll_refdiv * (1+pll_pd1a) * (1+pll_pd1b));
800019d6:	fec42783          	lw	a5,-20(s0)
800019da:	0187d713          	srli	a4,a5,0x18
800019de:	fdc42783          	lw	a5,-36(s0)
800019e2:	973e                	add	a4,a4,a5
800019e4:	fe042783          	lw	a5,-32(s0)
800019e8:	02f70733          	mul	a4,a4,a5
800019ec:	fcc42783          	lw	a5,-52(s0)
800019f0:	00178693          	addi	a3,a5,1
800019f4:	fd842783          	lw	a5,-40(s0)
800019f8:	02f686b3          	mul	a3,a3,a5
800019fc:	fe842783          	lw	a5,-24(s0)
80001a00:	0785                	addi	a5,a5,1
80001a02:	02f687b3          	mul	a5,a3,a5
80001a06:	02f75733          	divu	a4,a4,a5
80001a0a:	e2e1a023          	sw	a4,-480(gp) # 400005a0 <SystemPll1Clock>
    switch (current_sysclk) {
80001a0e:	fe442703          	lw	a4,-28(s0)
80001a12:	478d                	li	a5,3
80001a14:	04f70d63          	beq	a4,a5,80001a6e <SystemCoreClockUpdate+0x196>
80001a18:	fe442703          	lw	a4,-28(s0)
80001a1c:	478d                	li	a5,3
80001a1e:	04e7ec63          	bltu	a5,a4,80001a76 <SystemCoreClockUpdate+0x19e>
80001a22:	fe442703          	lw	a4,-28(s0)
80001a26:	4789                	li	a5,2
80001a28:	02f70e63          	beq	a4,a5,80001a64 <SystemCoreClockUpdate+0x18c>
80001a2c:	fe442703          	lw	a4,-28(s0)
80001a30:	4789                	li	a5,2
80001a32:	04e7e263          	bltu	a5,a4,80001a76 <SystemCoreClockUpdate+0x19e>
80001a36:	fe442783          	lw	a5,-28(s0)
80001a3a:	c799                	beqz	a5,80001a48 <SystemCoreClockUpdate+0x170>
80001a3c:	fe442703          	lw	a4,-28(s0)
80001a40:	4785                	li	a5,1
80001a42:	00f70a63          	beq	a4,a5,80001a56 <SystemCoreClockUpdate+0x17e>
    case RCU_CLKSTAT_SRC_LSICLK:
    	SystemCoreClock = LSICLK_VAL;
        break;
    }

}
80001a46:	a805                	j	80001a76 <SystemCoreClockUpdate+0x19e>
        SystemCoreClock = HSICLK_VAL;
80001a48:	000f4737          	lui	a4,0xf4
80001a4c:	24070713          	addi	a4,a4,576 # f4240 <STACK_SIZE+0xf3a40>
80001a50:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
        break;
80001a54:	a00d                	j	80001a76 <SystemCoreClockUpdate+0x19e>
        SystemCoreClock = HSECLK_VAL;
80001a56:	00f42737          	lui	a4,0xf42
80001a5a:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
80001a5e:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
        break;
80001a62:	a811                	j	80001a76 <SystemCoreClockUpdate+0x19e>
    	SystemCoreClock = SystemPll0Clock;
80001a64:	e1c1a703          	lw	a4,-484(gp) # 4000059c <SystemPll0Clock>
80001a68:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
    	break;
80001a6c:	a029                	j	80001a76 <SystemCoreClockUpdate+0x19e>
    	SystemCoreClock = LSICLK_VAL;
80001a6e:	6721                	lui	a4,0x8
80001a70:	e0e1ac23          	sw	a4,-488(gp) # 40000598 <SystemCoreClock>
        break;
80001a74:	0001                	nop
}
80001a76:	0001                	nop
80001a78:	5472                	lw	s0,60(sp)
80001a7a:	6121                	addi	sp,sp,64
80001a7c:	8082                	ret

80001a7e <ClkInit>:

void ClkInit()
{
80001a7e:	1101                	addi	sp,sp,-32
80001a80:	ce22                	sw	s0,28(sp)
80001a82:	1000                	addi	s0,sp,32
    uint32_t timeout_counter = 0;
80001a84:	fe042623          	sw	zero,-20(s0)
    uint32_t sysclk_source;

    //clockout control
    #ifndef CKO_NONE
        //C7 clockout
        RCU->CGCFGAHB_bit.GPIOCEN = 1;
80001a88:	3000e7b7          	lui	a5,0x3000e
80001a8c:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80001a90:	40076713          	ori	a4,a4,1024
80001a94:	00e79023          	sh	a4,0(a5)
        RCU->RSTDISAHB_bit.GPIOCEN = 1;
80001a98:	3000e7b7          	lui	a5,0x3000e
80001a9c:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80001aa0:	40076713          	ori	a4,a4,1024
80001aa4:	00e79823          	sh	a4,16(a5)
        GPIOC->ALTFUNCNUM_bit.PIN7 = 3;
80001aa8:	280027b7          	lui	a5,0x28002
80001aac:	5fd4                	lw	a3,60(a5)
80001aae:	6731                	lui	a4,0xc
80001ab0:	8f55                	or	a4,a4,a3
80001ab2:	dfd8                	sw	a4,60(a5)
        GPIOC->ALTFUNCSET_bit.PIN7 = 1;
80001ab4:	280027b7          	lui	a5,0x28002
80001ab8:	0347d703          	lhu	a4,52(a5) # 28002034 <STACK_SIZE+0x28001834>
80001abc:	08076713          	ori	a4,a4,128
80001ac0:	02e79a23          	sh	a4,52(a5)
        RCU->CLKOUTCFG = (RCU_CLKOUTCFG_CLKSEL_HSE << RCU_CLKOUTCFG_CLKSEL_Pos) |
				  	  	  (1 << RCU_CLKOUTCFG_DIVN_Pos) |
						  (0 << RCU_CLKOUTCFG_DIVEN_Pos) |
						  RCU_CLKOUTCFG_RSTDIS_Msk | RCU_CLKOUTCFG_CLKEN_Msk; //CKO = HSECLK
    #elif defined CKO_PLL0
        RCU->CLKOUTCFG = (RCU_CLKOUTCFG_CLKSEL_PLL0 << RCU_CLKOUTCFG_CLKSEL_Pos) |
80001ac4:	3000e7b7          	lui	a5,0x3000e
80001ac8:	6745                	lui	a4,0x11
80001aca:	12170713          	addi	a4,a4,289 # 11121 <STACK_SIZE+0x10921>
80001ace:	0ae7ae23          	sw	a4,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
	RCU->PLLSYSCFG2 = 100;         //FBDIV
#elif (HSECLK_VAL == 16000000)
// Fout0 = 50 000 000 Hz
// Fout1 = 12 500 000 Hz
	RCU->PLLSYSCFG0 =( 7 << RCU_PLLSYSCFG0_PD1B_Pos) |  //PD1B
80001ad2:	3000e7b7          	lui	a5,0x3000e
80001ad6:	0fc16737          	lui	a4,0xfc16
80001ada:	10770713          	addi	a4,a4,263 # fc16107 <STACK_SIZE+0xfc15907>
80001ade:	cbb8                	sw	a4,80(a5)
					 ( 0 << RCU_PLLSYSCFG0_FOUTEN_Pos)    |  //fouten
					 ( 0 << RCU_PLLSYSCFG0_DSMEN_Pos)     |  //dsmen
					 ( 0 << RCU_PLLSYSCFG0_DACEN_Pos)     |  //dacen
					 ( 3 << RCU_PLLSYSCFG0_BYP_Pos)       |  //bypass
					 ( 1 << RCU_PLLSYSCFG0_PLLEN_Pos);       //en
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
80001ae0:	3000e7b7          	lui	a5,0x3000e
80001ae4:	0407aa23          	sw	zero,84(a5) # 3000e054 <STACK_SIZE+0x3000d854>
	RCU->PLLSYSCFG2 = 50;         //FBDIV
80001ae8:	3000e7b7          	lui	a5,0x3000e
80001aec:	03200713          	li	a4,50
80001af0:	cfb8                	sw	a4,88(a5)
	RCU->PLLSYSCFG1 = 0;          //FRAC = 0					 
	RCU->PLLSYSCFG2 = 65;         //FBDIV
#else
#error "Please define HSECLK_VAL with correct values!"
#endif
	RCU->PLLSYSCFG0_bit.FOUTEN = 1; 	// Fout0 Enable
80001af2:	3000e7b7          	lui	a5,0x3000e
80001af6:	4bb8                	lw	a4,80(a5)
80001af8:	f9f77713          	andi	a4,a4,-97
80001afc:	02076713          	ori	a4,a4,32
80001b00:	cbb8                	sw	a4,80(a5)
	timeout_counter = 1000;
80001b02:	3e800793          	li	a5,1000
80001b06:	fef42623          	sw	a5,-20(s0)
	while(timeout_counter) timeout_counter--;
80001b0a:	a031                	j	80001b16 <ClkInit+0x98>
80001b0c:	fec42783          	lw	a5,-20(s0)
80001b10:	17fd                	addi	a5,a5,-1 # 3000dfff <STACK_SIZE+0x3000d7ff>
80001b12:	fef42623          	sw	a5,-20(s0)
80001b16:	fec42783          	lw	a5,-20(s0)
80001b1a:	fbed                	bnez	a5,80001b0c <ClkInit+0x8e>
	while((RCU->PLLSYSSTAT_bit.LOCK) != 1)
80001b1c:	0001                	nop
80001b1e:	3000e7b7          	lui	a5,0x3000e
80001b22:	53bc                	lw	a5,96(a5)
80001b24:	8b85                	andi	a5,a5,1
80001b26:	0ff7f713          	zext.b	a4,a5
80001b2a:	4785                	li	a5,1
80001b2c:	fef719e3          	bne	a4,a5,80001b1e <ClkInit+0xa0>
	{}; 								// wait lock signal
	RCU->PLLSYSCFG0_bit.BYP = 2; 		// Bypass for Fout1
80001b30:	3000e7b7          	lui	a5,0x3000e
80001b34:	4bb8                	lw	a4,80(a5)
80001b36:	9b65                	andi	a4,a4,-7
80001b38:	00476713          	ori	a4,a4,4
80001b3c:	cbb8                	sw	a4,80(a5)
	//select PLL as source system clock
	sysclk_source = RCU_SYSCLKCFG_SRC_SYSPLL0CLK;
80001b3e:	4789                	li	a5,2
80001b40:	fef42423          	sw	a5,-24(s0)
    // FLASH control settings
    FLASH->CTRL_bit.LAT = 3;
80001b44:	3000d7b7          	lui	a5,0x3000d
80001b48:	47f4                	lw	a3,76(a5)
80001b4a:	fff10737          	lui	a4,0xfff10
80001b4e:	177d                	addi	a4,a4,-1 # fff0ffff <__data_source_start+0x7ff071ab>
80001b50:	8ef9                	and	a3,a3,a4
80001b52:	00030737          	lui	a4,0x30
80001b56:	8f55                	or	a4,a4,a3
80001b58:	c7f8                	sw	a4,76(a5)
    FLASH->CTRL_bit.CEN = 1;
80001b5a:	3000d7b7          	lui	a5,0x3000d
80001b5e:	47f8                	lw	a4,76(a5)
80001b60:	00276713          	ori	a4,a4,2
80001b64:	c7f8                	sw	a4,76(a5)
#else
#error "Please define SYSCLK source (SYSCLK_PLL | SYSCLK_HSE | SYSCLK_HSI | SYSCLK_LSI)!"
#endif

    //switch sysclk
    RCU->SYSCLKCFG = (sysclk_source << RCU_SYSCLKCFG_SRC_Pos);
80001b66:	3000e7b7          	lui	a5,0x3000e
80001b6a:	fe842703          	lw	a4,-24(s0)
80001b6e:	db98                	sw	a4,48(a5)
    // Wait switching done
    timeout_counter = 0;
80001b70:	fe042623          	sw	zero,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)) //SYSCLK_SWITCH_TIMEOUT))
80001b74:	a031                	j	80001b80 <ClkInit+0x102>
        timeout_counter++;
80001b76:	fec42783          	lw	a5,-20(s0)
80001b7a:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80001b7c:	fef42623          	sw	a5,-20(s0)
    while ((RCU->CLKSTAT_bit.SRC != RCU->SYSCLKCFG_bit.SRC) && (timeout_counter < 100)) //SYSCLK_SWITCH_TIMEOUT))
80001b80:	3000e7b7          	lui	a5,0x3000e
80001b84:	5fdc                	lw	a5,60(a5)
80001b86:	8b8d                	andi	a5,a5,3
80001b88:	0ff7f713          	zext.b	a4,a5
80001b8c:	3000e7b7          	lui	a5,0x3000e
80001b90:	5b9c                	lw	a5,48(a5)
80001b92:	8b8d                	andi	a5,a5,3
80001b94:	0ff7f793          	zext.b	a5,a5
80001b98:	00f70863          	beq	a4,a5,80001ba8 <ClkInit+0x12a>
80001b9c:	fec42703          	lw	a4,-20(s0)
80001ba0:	06300793          	li	a5,99
80001ba4:	fce7f9e3          	bgeu	a5,a4,80001b76 <ClkInit+0xf8>
/*    if (timeout_counter == SYSCLK_SWITCH_TIMEOUT) //SYSCLK failed to switch
        while (1) {
        };*/

}
80001ba8:	0001                	nop
80001baa:	4472                	lw	s0,28(sp)
80001bac:	6105                	addi	sp,sp,32
80001bae:	8082                	ret

80001bb0 <InterruptEnable>:

void InterruptEnable()
{
80001bb0:	1101                	addi	sp,sp,-32
80001bb2:	ce06                	sw	ra,28(sp)
80001bb4:	cc22                	sw	s0,24(sp)
80001bb6:	1000                	addi	s0,sp,32
	//allow all interrupts in machine mode
	PLIC_SetThreshold (Plic_Mach_Target, 0); //allow all interrupts in machine mode
80001bb8:	4581                	li	a1,0
80001bba:	4501                	li	a0,0
80001bbc:	8b6ff0ef          	jal	ra,80000c72 <PLIC_SetThreshold>
    // disable timer interrupt
//    clear_csr(mie, MIE_MTIMER);
    // enable machine external interrupt
    set_csr(mie, MIE_MEXTERNAL);
80001bc0:	6785                	lui	a5,0x1
80001bc2:	80078793          	addi	a5,a5,-2048 # 800 <STACK_SIZE>
80001bc6:	fef42623          	sw	a5,-20(s0)
80001bca:	fec42783          	lw	a5,-20(s0)
80001bce:	3047a7f3          	csrrs	a5,mie,a5
80001bd2:	fef42623          	sw	a5,-20(s0)
    // enable global interrupts
    set_csr(mstatus, MSTATUS_MIE);
80001bd6:	47a1                	li	a5,8
80001bd8:	fef42423          	sw	a5,-24(s0)
80001bdc:	fe842783          	lw	a5,-24(s0)
80001be0:	3007a7f3          	csrrs	a5,mstatus,a5
80001be4:	fef42423          	sw	a5,-24(s0)
}
80001be8:	0001                	nop
80001bea:	40f2                	lw	ra,28(sp)
80001bec:	4462                	lw	s0,24(sp)
80001bee:	6105                	addi	sp,sp,32
80001bf0:	8082                	ret

80001bf2 <SystemInit>:

void SystemInit(void)
{
80001bf2:	1141                	addi	sp,sp,-16
80001bf4:	c606                	sw	ra,12(sp)
80001bf6:	c422                	sw	s0,8(sp)
80001bf8:	0800                	addi	s0,sp,16
//	clear_csr(mie, MIE_MTIMER);
	// enable machine external interrupt
//	set_csr(mie, MIE_MEXTERNAL);
	// enable global interrupts
//	set_csr(mstatus, MSTATUS_MIE);
	ClkInit();
80001bfa:	3551                	jal	80001a7e <ClkInit>
}
80001bfc:	0001                	nop
80001bfe:	40b2                	lw	ra,12(sp)
80001c00:	4422                	lw	s0,8(sp)
80001c02:	0141                	addi	sp,sp,16
80001c04:	8082                	ret

80001c06 <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80001c06:	1101                	addi	sp,sp,-32
80001c08:	ce22                	sw	s0,28(sp)
80001c0a:	1000                	addi	s0,sp,32
80001c0c:	fea42623          	sw	a0,-20(s0)
80001c10:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
80001c14:	fec42783          	lw	a5,-20(s0)
80001c18:	fe842703          	lw	a4,-24(s0)
80001c1c:	c798                	sw	a4,8(a5)
}
80001c1e:	0001                	nop
80001c20:	4472                	lw	s0,28(sp)
80001c22:	6105                	addi	sp,sp,32
80001c24:	8082                	ret

80001c26 <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80001c26:	1101                	addi	sp,sp,-32
80001c28:	ce22                	sw	s0,28(sp)
80001c2a:	1000                	addi	s0,sp,32
80001c2c:	fea42623          	sw	a0,-20(s0)
80001c30:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
80001c34:	fec42783          	lw	a5,-20(s0)
80001c38:	fe842703          	lw	a4,-24(s0)
80001c3c:	c7d8                	sw	a4,12(a5)
}
80001c3e:	0001                	nop
80001c40:	4472                	lw	s0,28(sp)
80001c42:	6105                	addi	sp,sp,32
80001c44:	8082                	ret

80001c46 <eeprom_is_busy>:
// Простейший статус для SPI-ветки (чтобы config.c мог вызывать eeprom_is_busy/eeprom_had_error)
static volatile bool g_eeprom_spi_busy  = false;
static volatile bool g_eeprom_spi_error = false;

bool eeprom_is_busy(void)
{
80001c46:	1141                	addi	sp,sp,-16
80001c48:	c622                	sw	s0,12(sp)
80001c4a:	0800                	addi	s0,sp,16
    return g_eeprom_spi_busy;
80001c4c:	e4d1c783          	lbu	a5,-435(gp) # 400005cd <g_eeprom_spi_busy>
80001c50:	0ff7f793          	zext.b	a5,a5
}
80001c54:	853e                	mv	a0,a5
80001c56:	4432                	lw	s0,12(sp)
80001c58:	0141                	addi	sp,sp,16
80001c5a:	8082                	ret

80001c5c <eeprom_had_error>:

bool eeprom_had_error(void)
{
80001c5c:	1141                	addi	sp,sp,-16
80001c5e:	c622                	sw	s0,12(sp)
80001c60:	0800                	addi	s0,sp,16
    return g_eeprom_spi_error;
80001c62:	e4e1c783          	lbu	a5,-434(gp) # 400005ce <g_eeprom_spi_error>
80001c66:	0ff7f793          	zext.b	a5,a5
}
80001c6a:	853e                	mv	a0,a5
80001c6c:	4432                	lw	s0,12(sp)
80001c6e:	0141                	addi	sp,sp,16
80001c70:	8082                	ret

80001c72 <eeprom_spi_cs_low>:

void eeprom_spi_cs_low(void)
{
80001c72:	1141                	addi	sp,sp,-16
80001c74:	c606                	sw	ra,12(sp)
80001c76:	c422                	sw	s0,8(sp)
80001c78:	0800                	addi	s0,sp,16
    GPIO_ClearBits(CS_PORT, CS_PIN);
80001c7a:	4589                	li	a1,2
80001c7c:	28001537          	lui	a0,0x28001
80001c80:	375d                	jal	80001c26 <GPIO_ClearBits>
}
80001c82:	0001                	nop
80001c84:	40b2                	lw	ra,12(sp)
80001c86:	4422                	lw	s0,8(sp)
80001c88:	0141                	addi	sp,sp,16
80001c8a:	8082                	ret

80001c8c <eeprom_spi_cs_high>:

void eeprom_spi_cs_high(void)
{
80001c8c:	1141                	addi	sp,sp,-16
80001c8e:	c606                	sw	ra,12(sp)
80001c90:	c422                	sw	s0,8(sp)
80001c92:	0800                	addi	s0,sp,16
    GPIO_SetBits(CS_PORT, CS_PIN);
80001c94:	4589                	li	a1,2
80001c96:	28001537          	lui	a0,0x28001
80001c9a:	37b5                	jal	80001c06 <GPIO_SetBits>
}
80001c9c:	0001                	nop
80001c9e:	40b2                	lw	ra,12(sp)
80001ca0:	4422                	lw	s0,8(sp)
80001ca2:	0141                	addi	sp,sp,16
80001ca4:	8082                	ret

80001ca6 <eeprom_init>:

void eeprom_init(void)
{
80001ca6:	1141                	addi	sp,sp,-16
80001ca8:	c606                	sw	ra,12(sp)
80001caa:	c422                	sw	s0,8(sp)
80001cac:	0800                	addi	s0,sp,16
    spi0_init();
80001cae:	2031                	jal	80001cba <spi0_init>
}
80001cb0:	0001                	nop
80001cb2:	40b2                	lw	ra,12(sp)
80001cb4:	4422                	lw	s0,8(sp)
80001cb6:	0141                	addi	sp,sp,16
80001cb8:	8082                	ret

80001cba <spi0_init>:

static void spi0_init(void)
{
80001cba:	1141                	addi	sp,sp,-16
80001cbc:	c606                	sw	ra,12(sp)
80001cbe:	c422                	sw	s0,8(sp)
80001cc0:	0800                	addi	s0,sp,16
    RCU->CGCFGAHB_bit.GPIOBEN = 1;                                                                                                 // Разрешение тактирования порта GPIOB
80001cc2:	3000e7b7          	lui	a5,0x3000e
80001cc6:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80001cca:	20076713          	ori	a4,a4,512
80001cce:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOBEN = 1;                                                                                                // Вывод из состояния сброса порта GPIOB
80001cd2:	3000e7b7          	lui	a5,0x3000e
80001cd6:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80001cda:	20076713          	ori	a4,a4,512
80001cde:	00e79823          	sh	a4,16(a5)
    RCU->CGCFGAHB_bit.SPI0EN = 1;                                                                                                  // Разрешение тактирования SPI0
80001ce2:	3000e7b7          	lui	a5,0x3000e
80001ce6:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80001cea:	02076713          	ori	a4,a4,32
80001cee:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.SPI0EN = 1;                                                                                                 // Вывод из состояния сброса SPI0
80001cf2:	3000e7b7          	lui	a5,0x3000e
80001cf6:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80001cfa:	02076713          	ori	a4,a4,32
80001cfe:	00e79823          	sh	a4,16(a5)
    RCU->SPICLKCFG[0].SPICLKCFG_bit.CLKSEL = RCU_SPICLKCFG_CLKSEL_HSE;                                                             // Источник сигнала внешний кварц
80001d02:	3000e7b7          	lui	a5,0x3000e
80001d06:	0947a683          	lw	a3,148(a5) # 3000e094 <STACK_SIZE+0x3000d894>
80001d0a:	fffd0737          	lui	a4,0xfffd0
80001d0e:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc71ab>
80001d10:	8ef9                	and	a3,a3,a4
80001d12:	6741                	lui	a4,0x10
80001d14:	8f55                	or	a4,a4,a3
80001d16:	08e7aa23          	sw	a4,148(a5)
    RCU->SPICLKCFG[0].SPICLKCFG_bit.CLKEN = 1;                                                                                     // Разрешение тактирования
80001d1a:	3000e7b7          	lui	a5,0x3000e
80001d1e:	0947a703          	lw	a4,148(a5) # 3000e094 <STACK_SIZE+0x3000d894>
80001d22:	00176713          	ori	a4,a4,1
80001d26:	08e7aa23          	sw	a4,148(a5)
    RCU->SPICLKCFG[0].SPICLKCFG_bit.RSTDIS = 1;                                                                                    // Вывод из сброса
80001d2a:	3000e7b7          	lui	a5,0x3000e
80001d2e:	0947a703          	lw	a4,148(a5) # 3000e094 <STACK_SIZE+0x3000d894>
80001d32:	10076713          	ori	a4,a4,256
80001d36:	08e7aa23          	sw	a4,148(a5)
    SPI0->CPSR_bit.CPSDVSR = 8;                                                                                                    // Коэффициент деления первого делителя
80001d3a:	200507b7          	lui	a5,0x20050
80001d3e:	4721                	li	a4,8
80001d40:	00e78823          	sb	a4,16(a5) # 20050010 <STACK_SIZE+0x2004f810>
    SPI0->CR0_bit.SCR = 1;                                                                                                         // Коэффициент деления второго делителя. Результирующий коэффициент SCK/((SCR+1)*CPSDVSR) 16/((1+1)*8)=1МГц
80001d44:	200507b7          	lui	a5,0x20050
80001d48:	4705                	li	a4,1
80001d4a:	00e780a3          	sb	a4,1(a5) # 20050001 <STACK_SIZE+0x2004f801>
    SPI0->CR0_bit.SPO = 0;                                                                                                         // Полярность сигнала. В режиме ожидания линия в состоянии логического нуля.
80001d4e:	200507b7          	lui	a5,0x20050
80001d52:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
80001d56:	fbf77713          	andi	a4,a4,-65
80001d5a:	00e79023          	sh	a4,0(a5)
    SPI0->CR0_bit.SPH = 0;                                                                                                         // Фаза: выборка на первом фронте (CPHA=0)
80001d5e:	200507b7          	lui	a5,0x20050
80001d62:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
80001d66:	f7f77713          	andi	a4,a4,-129
80001d6a:	00e79023          	sh	a4,0(a5)
    SPI0->CR0_bit.FRF = 0;                                                                                                         // Выбор протокола обмена информацией 0-SPI
80001d6e:	200507b7          	lui	a5,0x20050
80001d72:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
80001d76:	fcf77713          	andi	a4,a4,-49
80001d7a:	00e79023          	sh	a4,0(a5)
    SPI0->CR0_bit.DSS = 7;                                                                                                         // Размер слова данных 8 бит
80001d7e:	200507b7          	lui	a5,0x20050
80001d82:	0007d703          	lhu	a4,0(a5) # 20050000 <STACK_SIZE+0x2004f800>
80001d86:	9b41                	andi	a4,a4,-16
80001d88:	00776713          	ori	a4,a4,7
80001d8c:	00e79023          	sh	a4,0(a5)
    SPI0->CR1_bit.MS = 0;                                                                                                          // Режим работы - Мастер
80001d90:	200507b7          	lui	a5,0x20050
80001d94:	0047d703          	lhu	a4,4(a5) # 20050004 <STACK_SIZE+0x2004f804>
80001d98:	9b6d                	andi	a4,a4,-5
80001d9a:	00e79223          	sh	a4,4(a5)
    gpio_init_spi_pins();
80001d9e:	2091                	jal	80001de2 <gpio_init_spi_pins>
    SPI0->IMSC = 0x1;                                                                                                                    // Разрешаем прерывания по переполнению приемного буфера
80001da0:	200507b7          	lui	a5,0x20050
80001da4:	4705                	li	a4,1
80001da6:	cbd8                	sw	a4,20(a5)
    // Настраиваем обработчик прерывания для SPI0
    PLIC_SetIrqHandler(Plic_Mach_Target, IsrVect_IRQ_SPI0, SPI0_IRQHandler);
80001da8:	800027b7          	lui	a5,0x80002
80001dac:	0d078613          	addi	a2,a5,208 # 800020d0 <__data_source_start+0xffff927c>
80001db0:	45ad                	li	a1,11
80001db2:	4501                	li	a0,0
80001db4:	cbdfe0ef          	jal	ra,80000a70 <PLIC_SetIrqHandler>
    PLIC_SetPriority(IsrVect_IRQ_SPI0, 0x1);
80001db8:	4585                	li	a1,1
80001dba:	452d                	li	a0,11
80001dbc:	d01fe0ef          	jal	ra,80000abc <PLIC_SetPriority>
    PLIC_IntEnable(Plic_Mach_Target, IsrVect_IRQ_SPI0);
80001dc0:	45ad                	li	a1,11
80001dc2:	4501                	li	a0,0
80001dc4:	d23fe0ef          	jal	ra,80000ae6 <PLIC_IntEnable>

    SPI0->CR1_bit.SSE = 1; // Разрешение работы приемопередатчика
80001dc8:	200507b7          	lui	a5,0x20050
80001dcc:	0047d703          	lhu	a4,4(a5) # 20050004 <STACK_SIZE+0x2004f804>
80001dd0:	00276713          	ori	a4,a4,2
80001dd4:	00e79223          	sh	a4,4(a5)
}
80001dd8:	0001                	nop
80001dda:	40b2                	lw	ra,12(sp)
80001ddc:	4422                	lw	s0,8(sp)
80001dde:	0141                	addi	sp,sp,16
80001de0:	8082                	ret

80001de2 <gpio_init_spi_pins>:

static void gpio_init_spi_pins(void)
{
80001de2:	7179                	addi	sp,sp,-48
80001de4:	d606                	sw	ra,44(sp)
80001de6:	d422                	sw	s0,40(sp)
80001de8:	1800                	addi	s0,sp,48
    GPIOB->ALTFUNCSET = GPIO_ALTFUNCSET_PIN0_Msk |  // SCK
80001dea:	280017b7          	lui	a5,0x28001
80001dee:	4735                	li	a4,13
80001df0:	dbd8                	sw	a4,52(a5)
                        GPIO_ALTFUNCSET_PIN2_Msk |  // MISO (RX)
                        GPIO_ALTFUNCSET_PIN3_Msk;   // MOSI (TX)
    GPIOB->ALTFUNCNUM = (GPIO_ALTFUNCNUM_PIN0_AF1 << GPIO_ALTFUNCNUM_PIN0_Pos) |
80001df2:	280017b7          	lui	a5,0x28001
80001df6:	05100713          	li	a4,81
80001dfa:	dfd8                	sw	a4,60(a5)
                        (GPIO_ALTFUNCNUM_PIN2_AF1 << GPIO_ALTFUNCNUM_PIN2_Pos) |
                        (GPIO_ALTFUNCNUM_PIN3_AF1 << GPIO_ALTFUNCNUM_PIN3_Pos);

    // CS (PB1) как GPIO выход, держим в "1"
    GPIO_Init_TypeDef gpio;
    GPIO_StructInit(&gpio);
80001dfc:	fd040793          	addi	a5,s0,-48
80001e00:	853e                	mv	a0,a5
80001e02:	27e050ef          	jal	ra,80007080 <GPIO_StructInit>
    gpio.Out = ENABLE;
80001e06:	4785                	li	a5,1
80001e08:	fcf42a23          	sw	a5,-44(s0)
    gpio.AltFunc = DISABLE;
80001e0c:	fc042c23          	sw	zero,-40(s0)
    gpio.Pin = CS_PIN;
80001e10:	4789                	li	a5,2
80001e12:	fcf42823          	sw	a5,-48(s0)
    GPIO_Init(CS_PORT, &gpio);
80001e16:	fd040793          	addi	a5,s0,-48
80001e1a:	85be                	mv	a1,a5
80001e1c:	28001537          	lui	a0,0x28001
80001e20:	1c2050ef          	jal	ra,80006fe2 <GPIO_Init>
    GPIO_SetBits(CS_PORT, CS_PIN);
80001e24:	4589                	li	a1,2
80001e26:	28001537          	lui	a0,0x28001
80001e2a:	3bf1                	jal	80001c06 <GPIO_SetBits>
}
80001e2c:	0001                	nop
80001e2e:	50b2                	lw	ra,44(sp)
80001e30:	5422                	lw	s0,40(sp)
80001e32:	6145                	addi	sp,sp,48
80001e34:	8082                	ret

80001e36 <eeprom_spi_xfer>:

uint8_t eeprom_spi_xfer(uint8_t byte)
{
80001e36:	1101                	addi	sp,sp,-32
80001e38:	ce22                	sw	s0,28(sp)
80001e3a:	1000                	addi	s0,sp,32
80001e3c:	87aa                	mv	a5,a0
80001e3e:	fef407a3          	sb	a5,-17(s0)
    // Ждём свободное место в TX FIFO
    while (!(SPI0->SR & SPI_SR_TNF_Msk)) {
80001e42:	0001                	nop
80001e44:	200507b7          	lui	a5,0x20050
80001e48:	47dc                	lw	a5,12(a5)
80001e4a:	8b89                	andi	a5,a5,2
80001e4c:	dfe5                	beqz	a5,80001e44 <eeprom_spi_xfer+0xe>
    }
    SPI0->DR = byte;
80001e4e:	200507b7          	lui	a5,0x20050
80001e52:	fef44703          	lbu	a4,-17(s0)
80001e56:	c798                	sw	a4,8(a5)

    // Ждём байт в RX FIFO
    while (!(SPI0->SR & SPI_SR_RNE_Msk)) {
80001e58:	0001                	nop
80001e5a:	200507b7          	lui	a5,0x20050
80001e5e:	47dc                	lw	a5,12(a5)
80001e60:	8b91                	andi	a5,a5,4
80001e62:	dfe5                	beqz	a5,80001e5a <eeprom_spi_xfer+0x24>
    }
    return (uint8_t)SPI0->DR;
80001e64:	200507b7          	lui	a5,0x20050
80001e68:	479c                	lw	a5,8(a5)
80001e6a:	0ff7f793          	zext.b	a5,a5
}
80001e6e:	853e                	mv	a0,a5
80001e70:	4472                	lw	s0,28(sp)
80001e72:	6105                	addi	sp,sp,32
80001e74:	8082                	ret

80001e76 <eeprom_spi_read_status>:

uint8_t eeprom_spi_read_status(void)
{
80001e76:	1101                	addi	sp,sp,-32
80001e78:	ce06                	sw	ra,28(sp)
80001e7a:	cc22                	sw	s0,24(sp)
80001e7c:	1000                	addi	s0,sp,32
    eeprom_spi_cs_low();
80001e7e:	3bd5                	jal	80001c72 <eeprom_spi_cs_low>
    eeprom_spi_xfer(SPI_CMD_RDSR);
80001e80:	4515                	li	a0,5
80001e82:	3f55                	jal	80001e36 <eeprom_spi_xfer>
    uint8_t sr = eeprom_spi_xfer(0xFF);
80001e84:	0ff00513          	li	a0,255
80001e88:	377d                	jal	80001e36 <eeprom_spi_xfer>
80001e8a:	87aa                	mv	a5,a0
80001e8c:	fef407a3          	sb	a5,-17(s0)
    eeprom_spi_cs_high();
80001e90:	3bf5                	jal	80001c8c <eeprom_spi_cs_high>
    return sr;
80001e92:	fef44783          	lbu	a5,-17(s0)
}
80001e96:	853e                	mv	a0,a5
80001e98:	40f2                	lw	ra,28(sp)
80001e9a:	4462                	lw	s0,24(sp)
80001e9c:	6105                	addi	sp,sp,32
80001e9e:	8082                	ret

80001ea0 <eeprom_spi_wait_ready>:

bool eeprom_spi_wait_ready(uint32_t timeout_cycles)
{
80001ea0:	7179                	addi	sp,sp,-48
80001ea2:	d606                	sw	ra,44(sp)
80001ea4:	d422                	sw	s0,40(sp)
80001ea6:	1800                	addi	s0,sp,48
80001ea8:	fca42e23          	sw	a0,-36(s0)
    while (timeout_cycles--) {
80001eac:	a819                	j	80001ec2 <eeprom_spi_wait_ready+0x22>
        uint8_t sr = eeprom_spi_read_status();
80001eae:	37e1                	jal	80001e76 <eeprom_spi_read_status>
80001eb0:	87aa                	mv	a5,a0
80001eb2:	fef407a3          	sb	a5,-17(s0)
        if ((sr & SPI_STATUS_BUSY) == 0) {
80001eb6:	fef44783          	lbu	a5,-17(s0)
80001eba:	8b85                	andi	a5,a5,1
80001ebc:	e399                	bnez	a5,80001ec2 <eeprom_spi_wait_ready+0x22>
            return true;
80001ebe:	4785                	li	a5,1
80001ec0:	a809                	j	80001ed2 <eeprom_spi_wait_ready+0x32>
    while (timeout_cycles--) {
80001ec2:	fdc42783          	lw	a5,-36(s0)
80001ec6:	fff78713          	addi	a4,a5,-1 # 2004ffff <STACK_SIZE+0x2004f7ff>
80001eca:	fce42e23          	sw	a4,-36(s0)
80001ece:	f3e5                	bnez	a5,80001eae <eeprom_spi_wait_ready+0xe>
        }
    }
    return false;
80001ed0:	4781                	li	a5,0
}
80001ed2:	853e                	mv	a0,a5
80001ed4:	50b2                	lw	ra,44(sp)
80001ed6:	5422                	lw	s0,40(sp)
80001ed8:	6145                	addi	sp,sp,48
80001eda:	8082                	ret

80001edc <eeprom_spi_write_enable>:


static void eeprom_spi_write_enable(void)
{
80001edc:	1141                	addi	sp,sp,-16
80001ede:	c606                	sw	ra,12(sp)
80001ee0:	c422                	sw	s0,8(sp)
80001ee2:	0800                	addi	s0,sp,16
    eeprom_spi_cs_low();
80001ee4:	3379                	jal	80001c72 <eeprom_spi_cs_low>
    eeprom_spi_xfer(SPI_CMD_WREN);
80001ee6:	4519                	li	a0,6
80001ee8:	37b9                	jal	80001e36 <eeprom_spi_xfer>
    eeprom_spi_cs_high();
80001eea:	334d                	jal	80001c8c <eeprom_spi_cs_high>
}
80001eec:	0001                	nop
80001eee:	40b2                	lw	ra,12(sp)
80001ef0:	4422                	lw	s0,8(sp)
80001ef2:	0141                	addi	sp,sp,16
80001ef4:	8082                	ret

80001ef6 <eeprom_write_bytes>:

void eeprom_write_bytes(uint16_t addr, const uint8_t* data, size_t len)
{
80001ef6:	7179                	addi	sp,sp,-48
80001ef8:	d606                	sw	ra,44(sp)
80001efa:	d422                	sw	s0,40(sp)
80001efc:	1800                	addi	s0,sp,48
80001efe:	87aa                	mv	a5,a0
80001f00:	fcb42c23          	sw	a1,-40(s0)
80001f04:	fcc42a23          	sw	a2,-44(s0)
80001f08:	fcf41f23          	sh	a5,-34(s0)
    if (!data || !len) {
80001f0c:	fd842783          	lw	a5,-40(s0)
80001f10:	10078563          	beqz	a5,8000201a <eeprom_write_bytes+0x124>
80001f14:	fd442783          	lw	a5,-44(s0)
80001f18:	10078163          	beqz	a5,8000201a <eeprom_write_bytes+0x124>
        return;
    }

    // Не допускаем параллельных транзакций
    if (g_eeprom_spi_busy) {
80001f1c:	e4d1c783          	lbu	a5,-435(gp) # 400005cd <g_eeprom_spi_busy>
80001f20:	0ff7f793          	zext.b	a5,a5
80001f24:	0e079d63          	bnez	a5,8000201e <eeprom_write_bytes+0x128>
        return;
    }

    g_eeprom_spi_error = false;
80001f28:	e4018723          	sb	zero,-434(gp) # 400005ce <g_eeprom_spi_error>
    g_eeprom_spi_busy  = true;
80001f2c:	4705                	li	a4,1
80001f2e:	e4e186a3          	sb	a4,-435(gp) # 400005cd <g_eeprom_spi_busy>

    while (len) {
80001f32:	a8e9                	j	8000200c <eeprom_write_bytes+0x116>
        size_t page_off = addr % EEPROM_PAGE_SIZE;
80001f34:	fde45783          	lhu	a5,-34(s0)
80001f38:	03f7f793          	andi	a5,a5,63
80001f3c:	fef42223          	sw	a5,-28(s0)
        // ограничиваем запись границами страницы EEPROM
        size_t chunk = EEPROM_PAGE_SIZE - page_off;
80001f40:	04000713          	li	a4,64
80001f44:	fe442783          	lw	a5,-28(s0)
80001f48:	40f707b3          	sub	a5,a4,a5
80001f4c:	fef42623          	sw	a5,-20(s0)
        if (chunk > len) {
80001f50:	fec42703          	lw	a4,-20(s0)
80001f54:	fd442783          	lw	a5,-44(s0)
80001f58:	00e7f663          	bgeu	a5,a4,80001f64 <eeprom_write_bytes+0x6e>
            chunk = len;
80001f5c:	fd442783          	lw	a5,-44(s0)
80001f60:	fef42623          	sw	a5,-20(s0)
        }

        eeprom_spi_write_enable();
80001f64:	3fa5                	jal	80001edc <eeprom_spi_write_enable>

        eeprom_spi_cs_low();
80001f66:	3331                	jal	80001c72 <eeprom_spi_cs_low>
        eeprom_spi_xfer(SPI_CMD_WRITE);
80001f68:	4509                	li	a0,2
80001f6a:	35f1                	jal	80001e36 <eeprom_spi_xfer>
        eeprom_spi_xfer(addr >> 8);
80001f6c:	fde45783          	lhu	a5,-34(s0)
80001f70:	83a1                	srli	a5,a5,0x8
80001f72:	07c2                	slli	a5,a5,0x10
80001f74:	83c1                	srli	a5,a5,0x10
80001f76:	0ff7f793          	zext.b	a5,a5
80001f7a:	853e                	mv	a0,a5
80001f7c:	3d6d                	jal	80001e36 <eeprom_spi_xfer>
        eeprom_spi_xfer(addr & 0xFF);
80001f7e:	fde45783          	lhu	a5,-34(s0)
80001f82:	0ff7f793          	zext.b	a5,a5
80001f86:	853e                	mv	a0,a5
80001f88:	357d                	jal	80001e36 <eeprom_spi_xfer>
        for (size_t i = 0; i < chunk; ++i) {
80001f8a:	fe042423          	sw	zero,-24(s0)
80001f8e:	a839                	j	80001fac <eeprom_write_bytes+0xb6>
            eeprom_spi_xfer(data[i]);
80001f90:	fd842703          	lw	a4,-40(s0)
80001f94:	fe842783          	lw	a5,-24(s0)
80001f98:	97ba                	add	a5,a5,a4
80001f9a:	0007c783          	lbu	a5,0(a5)
80001f9e:	853e                	mv	a0,a5
80001fa0:	3d59                	jal	80001e36 <eeprom_spi_xfer>
        for (size_t i = 0; i < chunk; ++i) {
80001fa2:	fe842783          	lw	a5,-24(s0)
80001fa6:	0785                	addi	a5,a5,1
80001fa8:	fef42423          	sw	a5,-24(s0)
80001fac:	fe842703          	lw	a4,-24(s0)
80001fb0:	fec42783          	lw	a5,-20(s0)
80001fb4:	fcf76ee3          	bltu	a4,a5,80001f90 <eeprom_write_bytes+0x9a>
        }
        eeprom_spi_cs_high();
80001fb8:	39d1                	jal	80001c8c <eeprom_spi_cs_high>

        if (!eeprom_spi_wait_ready(1000000)) {
80001fba:	000f47b7          	lui	a5,0xf4
80001fbe:	24078513          	addi	a0,a5,576 # f4240 <STACK_SIZE+0xf3a40>
80001fc2:	3df9                	jal	80001ea0 <eeprom_spi_wait_ready>
80001fc4:	87aa                	mv	a5,a0
80001fc6:	0017c793          	xori	a5,a5,1
80001fca:	0ff7f793          	zext.b	a5,a5
80001fce:	c799                	beqz	a5,80001fdc <eeprom_write_bytes+0xe6>
            // не дождались — выходим, чтобы не повиснуть
            g_eeprom_spi_error = true;
80001fd0:	4705                	li	a4,1
80001fd2:	e4e18723          	sb	a4,-434(gp) # 400005ce <g_eeprom_spi_error>
            g_eeprom_spi_busy  = false;
80001fd6:	e40186a3          	sb	zero,-435(gp) # 400005cd <g_eeprom_spi_busy>
            return;
80001fda:	a099                	j	80002020 <eeprom_write_bytes+0x12a>
        }

        addr += (uint16_t)chunk;
80001fdc:	fec42783          	lw	a5,-20(s0)
80001fe0:	07c2                	slli	a5,a5,0x10
80001fe2:	83c1                	srli	a5,a5,0x10
80001fe4:	fde45703          	lhu	a4,-34(s0)
80001fe8:	97ba                	add	a5,a5,a4
80001fea:	fcf41f23          	sh	a5,-34(s0)
        data += chunk;
80001fee:	fd842703          	lw	a4,-40(s0)
80001ff2:	fec42783          	lw	a5,-20(s0)
80001ff6:	97ba                	add	a5,a5,a4
80001ff8:	fcf42c23          	sw	a5,-40(s0)
        len  -= chunk;
80001ffc:	fd442703          	lw	a4,-44(s0)
80002000:	fec42783          	lw	a5,-20(s0)
80002004:	40f707b3          	sub	a5,a4,a5
80002008:	fcf42a23          	sw	a5,-44(s0)
    while (len) {
8000200c:	fd442783          	lw	a5,-44(s0)
80002010:	f20792e3          	bnez	a5,80001f34 <eeprom_write_bytes+0x3e>
    }

    g_eeprom_spi_busy = false;
80002014:	e40186a3          	sb	zero,-435(gp) # 400005cd <g_eeprom_spi_busy>
80002018:	a021                	j	80002020 <eeprom_write_bytes+0x12a>
        return;
8000201a:	0001                	nop
8000201c:	a011                	j	80002020 <eeprom_write_bytes+0x12a>
        return;
8000201e:	0001                	nop
}
80002020:	50b2                	lw	ra,44(sp)
80002022:	5422                	lw	s0,40(sp)
80002024:	6145                	addi	sp,sp,48
80002026:	8082                	ret

80002028 <eeprom_read_bytes>:

void eeprom_read_bytes(uint16_t addr, uint8_t* data, size_t len)
{
80002028:	7179                	addi	sp,sp,-48
8000202a:	d606                	sw	ra,44(sp)
8000202c:	d422                	sw	s0,40(sp)
8000202e:	d226                	sw	s1,36(sp)
80002030:	1800                	addi	s0,sp,48
80002032:	87aa                	mv	a5,a0
80002034:	fcb42c23          	sw	a1,-40(s0)
80002038:	fcc42a23          	sw	a2,-44(s0)
8000203c:	fcf41f23          	sh	a5,-34(s0)
    if (!data || !len) {
80002040:	fd842783          	lw	a5,-40(s0)
80002044:	cfb5                	beqz	a5,800020c0 <eeprom_read_bytes+0x98>
80002046:	fd442783          	lw	a5,-44(s0)
8000204a:	cbbd                	beqz	a5,800020c0 <eeprom_read_bytes+0x98>
        return;
    }

    if (g_eeprom_spi_busy) {
8000204c:	e4d1c783          	lbu	a5,-435(gp) # 400005cd <g_eeprom_spi_busy>
80002050:	0ff7f793          	zext.b	a5,a5
80002054:	eba5                	bnez	a5,800020c4 <eeprom_read_bytes+0x9c>
        return;
    }

    g_eeprom_spi_error = false;
80002056:	e4018723          	sb	zero,-434(gp) # 400005ce <g_eeprom_spi_error>
    g_eeprom_spi_busy  = true;
8000205a:	4705                	li	a4,1
8000205c:	e4e186a3          	sb	a4,-435(gp) # 400005cd <g_eeprom_spi_busy>

    eeprom_spi_cs_low();
80002060:	3909                	jal	80001c72 <eeprom_spi_cs_low>
    eeprom_spi_xfer(SPI_CMD_READ);
80002062:	450d                	li	a0,3
80002064:	3bc9                	jal	80001e36 <eeprom_spi_xfer>
    eeprom_spi_xfer(addr >> 8);
80002066:	fde45783          	lhu	a5,-34(s0)
8000206a:	83a1                	srli	a5,a5,0x8
8000206c:	07c2                	slli	a5,a5,0x10
8000206e:	83c1                	srli	a5,a5,0x10
80002070:	0ff7f793          	zext.b	a5,a5
80002074:	853e                	mv	a0,a5
80002076:	33c1                	jal	80001e36 <eeprom_spi_xfer>
    eeprom_spi_xfer(addr & 0xFF);
80002078:	fde45783          	lhu	a5,-34(s0)
8000207c:	0ff7f793          	zext.b	a5,a5
80002080:	853e                	mv	a0,a5
80002082:	3b55                	jal	80001e36 <eeprom_spi_xfer>
    for (size_t i = 0; i < len; ++i) {
80002084:	fe042623          	sw	zero,-20(s0)
80002088:	a015                	j	800020ac <eeprom_read_bytes+0x84>
        data[i] = eeprom_spi_xfer(0xFF);
8000208a:	fd842703          	lw	a4,-40(s0)
8000208e:	fec42783          	lw	a5,-20(s0)
80002092:	00f704b3          	add	s1,a4,a5
80002096:	0ff00513          	li	a0,255
8000209a:	3b71                	jal	80001e36 <eeprom_spi_xfer>
8000209c:	87aa                	mv	a5,a0
8000209e:	00f48023          	sb	a5,0(s1)
    for (size_t i = 0; i < len; ++i) {
800020a2:	fec42783          	lw	a5,-20(s0)
800020a6:	0785                	addi	a5,a5,1
800020a8:	fef42623          	sw	a5,-20(s0)
800020ac:	fec42703          	lw	a4,-20(s0)
800020b0:	fd442783          	lw	a5,-44(s0)
800020b4:	fcf76be3          	bltu	a4,a5,8000208a <eeprom_read_bytes+0x62>
    }
    eeprom_spi_cs_high();
800020b8:	3ed1                	jal	80001c8c <eeprom_spi_cs_high>

    g_eeprom_spi_busy = false;
800020ba:	e40186a3          	sb	zero,-435(gp) # 400005cd <g_eeprom_spi_busy>
800020be:	a021                	j	800020c6 <eeprom_read_bytes+0x9e>
        return;
800020c0:	0001                	nop
800020c2:	a011                	j	800020c6 <eeprom_read_bytes+0x9e>
        return;
800020c4:	0001                	nop
}
800020c6:	50b2                	lw	ra,44(sp)
800020c8:	5422                	lw	s0,40(sp)
800020ca:	5492                	lw	s1,36(sp)
800020cc:	6145                	addi	sp,sp,48
800020ce:	8082                	ret

800020d0 <SPI0_IRQHandler>:

static void SPI0_IRQHandler(void)
{
800020d0:	1141                	addi	sp,sp,-16
800020d2:	c622                	sw	s0,12(sp)
800020d4:	0800                	addi	s0,sp,16
    SPI0->ICR = 0x3;
800020d6:	200507b7          	lui	a5,0x20050
800020da:	470d                	li	a4,3
800020dc:	d398                	sw	a4,32(a5)
}
800020de:	0001                	nop
800020e0:	4432                	lw	s0,12(sp)
800020e2:	0141                	addi	sp,sp,16
800020e4:	8082                	ret

800020e6 <GPIO_OutCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_OutCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
800020e6:	1101                	addi	sp,sp,-32
800020e8:	ce22                	sw	s0,28(sp)
800020ea:	1000                	addi	s0,sp,32
800020ec:	fea42623          	sw	a0,-20(s0)
800020f0:	feb42423          	sw	a1,-24(s0)
800020f4:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800020f8:	fe442703          	lw	a4,-28(s0)
800020fc:	4785                	li	a5,1
800020fe:	00f71863          	bne	a4,a5,8000210e <GPIO_OutCmd+0x28>
        WRITE_REG(GPIOx->OUTENSET, Pin);
80002102:	fec42783          	lw	a5,-20(s0)
80002106:	fe842703          	lw	a4,-24(s0)
8000210a:	d7d8                	sw	a4,44(a5)
    else
        WRITE_REG(GPIOx->OUTENCLR, Pin);
}
8000210c:	a031                	j	80002118 <GPIO_OutCmd+0x32>
        WRITE_REG(GPIOx->OUTENCLR, Pin);
8000210e:	fec42783          	lw	a5,-20(s0)
80002112:	fe842703          	lw	a4,-24(s0)
80002116:	db98                	sw	a4,48(a5)
}
80002118:	0001                	nop
8000211a:	4472                	lw	s0,28(sp)
8000211c:	6105                	addi	sp,sp,32
8000211e:	8082                	ret

80002120 <GPIO_AltFuncCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_AltFuncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80002120:	1101                	addi	sp,sp,-32
80002122:	ce22                	sw	s0,28(sp)
80002124:	1000                	addi	s0,sp,32
80002126:	fea42623          	sw	a0,-20(s0)
8000212a:	feb42423          	sw	a1,-24(s0)
8000212e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80002132:	fe442703          	lw	a4,-28(s0)
80002136:	4785                	li	a5,1
80002138:	00f71863          	bne	a4,a5,80002148 <GPIO_AltFuncCmd+0x28>
        WRITE_REG(GPIOx->ALTFUNCSET, Pin);
8000213c:	fec42783          	lw	a5,-20(s0)
80002140:	fe842703          	lw	a4,-24(s0)
80002144:	dbd8                	sw	a4,52(a5)
    else
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
}
80002146:	a031                	j	80002152 <GPIO_AltFuncCmd+0x32>
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
80002148:	fec42783          	lw	a5,-20(s0)
8000214c:	fe842703          	lw	a4,-24(s0)
80002150:	df98                	sw	a4,56(a5)
}
80002152:	0001                	nop
80002154:	4472                	lw	s0,28(sp)
80002156:	6105                	addi	sp,sp,32
80002158:	8082                	ret

8000215a <GPIO_ReadBit>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  State  Состояние Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
8000215a:	1101                	addi	sp,sp,-32
8000215c:	ce22                	sw	s0,28(sp)
8000215e:	1000                	addi	s0,sp,32
80002160:	fea42623          	sw	a0,-20(s0)
80002164:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
80002168:	fec42783          	lw	a5,-20(s0)
8000216c:	4398                	lw	a4,0(a5)
8000216e:	fe842783          	lw	a5,-24(s0)
80002172:	8ff9                	and	a5,a5,a4
80002174:	c399                	beqz	a5,8000217a <GPIO_ReadBit+0x20>
80002176:	4785                	li	a5,1
80002178:	a011                	j	8000217c <GPIO_ReadBit+0x22>
8000217a:	4781                	li	a5,0
}
8000217c:	853e                	mv	a0,a5
8000217e:	4472                	lw	s0,28(sp)
80002180:	6105                	addi	sp,sp,32
80002182:	8082                	ret

80002184 <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002184:	1101                	addi	sp,sp,-32
80002186:	ce22                	sw	s0,28(sp)
80002188:	1000                	addi	s0,sp,32
8000218a:	fea42623          	sw	a0,-20(s0)
8000218e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
80002192:	fec42783          	lw	a5,-20(s0)
80002196:	fe842703          	lw	a4,-24(s0)
8000219a:	c798                	sw	a4,8(a5)
}
8000219c:	0001                	nop
8000219e:	4472                	lw	s0,28(sp)
800021a0:	6105                	addi	sp,sp,32
800021a2:	8082                	ret

800021a4 <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
800021a4:	1101                	addi	sp,sp,-32
800021a6:	ce22                	sw	s0,28(sp)
800021a8:	1000                	addi	s0,sp,32
800021aa:	fea42623          	sw	a0,-20(s0)
800021ae:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
800021b2:	fec42783          	lw	a5,-20(s0)
800021b6:	fe842703          	lw	a4,-24(s0)
800021ba:	c7d8                	sw	a4,12(a5)
}
800021bc:	0001                	nop
800021be:	4472                	lw	s0,28(sp)
800021c0:	6105                	addi	sp,sp,32
800021c2:	8082                	ret

800021c4 <GPIO_QualModeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   Mode  Выбор режима
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_QualMode_TypeDef Mode)
{
800021c4:	1101                	addi	sp,sp,-32
800021c6:	ce22                	sw	s0,28(sp)
800021c8:	1000                	addi	s0,sp,32
800021ca:	fea42623          	sw	a0,-20(s0)
800021ce:	feb42423          	sw	a1,-24(s0)
800021d2:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_QUAL_MODE(Mode));

    if (Mode == GPIO_QualMode_6Sample)
800021d6:	fe442703          	lw	a4,-28(s0)
800021da:	4785                	li	a5,1
800021dc:	00f71863          	bne	a4,a5,800021ec <GPIO_QualModeConfig+0x28>
        WRITE_REG(GPIOx->QUALMODESET, Pin);
800021e0:	fec42783          	lw	a5,-20(s0)
800021e4:	fe842703          	lw	a4,-24(s0)
800021e8:	cbf8                	sw	a4,84(a5)
    else
        WRITE_REG(GPIOx->QUALMODECLR, Pin);
}
800021ea:	a031                	j	800021f6 <GPIO_QualModeConfig+0x32>
        WRITE_REG(GPIOx->QUALMODECLR, Pin);
800021ec:	fec42783          	lw	a5,-20(s0)
800021f0:	fe842703          	lw	a4,-24(s0)
800021f4:	cfb8                	sw	a4,88(a5)
}
800021f6:	0001                	nop
800021f8:	4472                	lw	s0,28(sp)
800021fa:	6105                	addi	sp,sp,32
800021fc:	8082                	ret

800021fe <GPIO_QualSampleConfig>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   SamplePerod  Количество тактов системной частоты между отсчетами фильтра
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualSampleConfig(GPIO_TypeDef* GPIOx, uint32_t SamplePerod)
{
800021fe:	1101                	addi	sp,sp,-32
80002200:	ce22                	sw	s0,28(sp)
80002202:	1000                	addi	s0,sp,32
80002204:	fea42623          	sw	a0,-20(s0)
80002208:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_QUAL_PERIOD(SamplePerod));

    WRITE_REG(GPIOx->QUALSAMPLE, SamplePerod);
8000220c:	fec42783          	lw	a5,-20(s0)
80002210:	fe842703          	lw	a4,-24(s0)
80002214:	cff8                	sw	a4,92(a5)
}
80002216:	0001                	nop
80002218:	4472                	lw	s0,28(sp)
8000221a:	6105                	addi	sp,sp,32
8000221c:	8082                	ret

8000221e <GPIO_QualCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_QualCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
8000221e:	1101                	addi	sp,sp,-32
80002220:	ce22                	sw	s0,28(sp)
80002222:	1000                	addi	s0,sp,32
80002224:	fea42623          	sw	a0,-20(s0)
80002228:	feb42423          	sw	a1,-24(s0)
8000222c:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80002230:	fe442703          	lw	a4,-28(s0)
80002234:	4785                	li	a5,1
80002236:	00f71863          	bne	a4,a5,80002246 <GPIO_QualCmd+0x28>
        WRITE_REG(GPIOx->QUALSET, Pin);
8000223a:	fec42783          	lw	a5,-20(s0)
8000223e:	fe842703          	lw	a4,-24(s0)
80002242:	c7f8                	sw	a4,76(a5)
    else
        WRITE_REG(GPIOx->QUALCLR, Pin);
}
80002244:	a031                	j	80002250 <GPIO_QualCmd+0x32>
        WRITE_REG(GPIOx->QUALCLR, Pin);
80002246:	fec42783          	lw	a5,-20(s0)
8000224a:	fe842703          	lw	a4,-24(s0)
8000224e:	cbb8                	sw	a4,80(a5)
}
80002250:	0001                	nop
80002252:	4472                	lw	s0,28(sp)
80002254:	6105                	addi	sp,sp,32
80002256:	8082                	ret

80002258 <GPIO_SyncCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_SyncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80002258:	1101                	addi	sp,sp,-32
8000225a:	ce22                	sw	s0,28(sp)
8000225c:	1000                	addi	s0,sp,32
8000225e:	fea42623          	sw	a0,-20(s0)
80002262:	feb42423          	sw	a1,-24(s0)
80002266:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000226a:	fe442703          	lw	a4,-28(s0)
8000226e:	4785                	li	a5,1
80002270:	00f71863          	bne	a4,a5,80002280 <GPIO_SyncCmd+0x28>
        WRITE_REG(GPIOx->SYNCSET, Pin);
80002274:	fec42783          	lw	a5,-20(s0)
80002278:	fe842703          	lw	a4,-24(s0)
8000227c:	c3f8                	sw	a4,68(a5)
    else
        WRITE_REG(GPIOx->SYNCCLR, Pin);
}
8000227e:	a031                	j	8000228a <GPIO_SyncCmd+0x32>
        WRITE_REG(GPIOx->SYNCCLR, Pin);
80002280:	fec42783          	lw	a5,-20(s0)
80002284:	fe842703          	lw	a4,-24(s0)
80002288:	c7b8                	sw	a4,72(a5)
}
8000228a:	0001                	nop
8000228c:	4472                	lw	s0,28(sp)
8000228e:	6105                	addi	sp,sp,32
80002290:	8082                	ret

80002292 <GPIO_ITTypeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   IntType  Выбор режима генерации
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITTypeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_IntType_TypeDef IntType)
{
80002292:	1101                	addi	sp,sp,-32
80002294:	ce22                	sw	s0,28(sp)
80002296:	1000                	addi	s0,sp,32
80002298:	fea42623          	sw	a0,-20(s0)
8000229c:	feb42423          	sw	a1,-24(s0)
800022a0:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_INT_TYPE(IntType));

    if (IntType == GPIO_IntType_Edge)
800022a4:	fe442703          	lw	a4,-28(s0)
800022a8:	4785                	li	a5,1
800022aa:	00f71863          	bne	a4,a5,800022ba <GPIO_ITTypeConfig+0x28>
        WRITE_REG(GPIOx->INTTYPESET, Pin);
800022ae:	fec42783          	lw	a5,-20(s0)
800022b2:	fe842703          	lw	a4,-24(s0)
800022b6:	d7b8                	sw	a4,104(a5)
    else
        WRITE_REG(GPIOx->INTTYPECLR, Pin);
}
800022b8:	a031                	j	800022c4 <GPIO_ITTypeConfig+0x32>
        WRITE_REG(GPIOx->INTTYPECLR, Pin);
800022ba:	fec42783          	lw	a5,-20(s0)
800022be:	fe842703          	lw	a4,-24(s0)
800022c2:	d7f8                	sw	a4,108(a5)
}
800022c4:	0001                	nop
800022c6:	4472                	lw	s0,28(sp)
800022c8:	6105                	addi	sp,sp,32
800022ca:	8082                	ret

800022cc <GPIO_ITPolConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   IntPol  Выбор полярности
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITPolConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_IntPol_TypeDef IntPol)
{
800022cc:	1101                	addi	sp,sp,-32
800022ce:	ce22                	sw	s0,28(sp)
800022d0:	1000                	addi	s0,sp,32
800022d2:	fea42623          	sw	a0,-20(s0)
800022d6:	feb42423          	sw	a1,-24(s0)
800022da:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_INT_POL(IntPol));

    if (IntPol == GPIO_IntPol_Positive)
800022de:	fe442703          	lw	a4,-28(s0)
800022e2:	4785                	li	a5,1
800022e4:	00f71863          	bne	a4,a5,800022f4 <GPIO_ITPolConfig+0x28>
        WRITE_REG(GPIOx->INTPOLSET, Pin);
800022e8:	fec42783          	lw	a5,-20(s0)
800022ec:	fe842703          	lw	a4,-24(s0)
800022f0:	dbb8                	sw	a4,112(a5)
    else
        WRITE_REG(GPIOx->INTPOLCLR, Pin);
}
800022f2:	a031                	j	800022fe <GPIO_ITPolConfig+0x32>
        WRITE_REG(GPIOx->INTPOLCLR, Pin);
800022f4:	fec42783          	lw	a5,-20(s0)
800022f8:	fe842703          	lw	a4,-24(s0)
800022fc:	dbf8                	sw	a4,116(a5)
}
800022fe:	0001                	nop
80002300:	4472                	lw	s0,28(sp)
80002302:	6105                	addi	sp,sp,32
80002304:	8082                	ret

80002306 <GPIO_ITEdgeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   IntEdge  Выбор режима
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITEdgeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_IntEdge_TypeDef IntEdge)
{
80002306:	1101                	addi	sp,sp,-32
80002308:	ce22                	sw	s0,28(sp)
8000230a:	1000                	addi	s0,sp,32
8000230c:	fea42623          	sw	a0,-20(s0)
80002310:	feb42423          	sw	a1,-24(s0)
80002314:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_INT_EDGE(IntEdge));

    if (IntEdge == GPIO_IntEdge_Any)
80002318:	fe442703          	lw	a4,-28(s0)
8000231c:	4785                	li	a5,1
8000231e:	00f71863          	bne	a4,a5,8000232e <GPIO_ITEdgeConfig+0x28>
        WRITE_REG(GPIOx->INTEDGESET, Pin);
80002322:	fec42783          	lw	a5,-20(s0)
80002326:	fe842703          	lw	a4,-24(s0)
8000232a:	dfb8                	sw	a4,120(a5)
    else
        WRITE_REG(GPIOx->INTEDGECLR, Pin);
}
8000232c:	a031                	j	80002338 <GPIO_ITEdgeConfig+0x32>
        WRITE_REG(GPIOx->INTEDGECLR, Pin);
8000232e:	fec42783          	lw	a5,-20(s0)
80002332:	fe842703          	lw	a4,-24(s0)
80002336:	dff8                	sw	a4,124(a5)
}
80002338:	0001                	nop
8000233a:	4472                	lw	s0,28(sp)
8000233c:	6105                	addi	sp,sp,32
8000233e:	8082                	ret

80002340 <GPIO_ITCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80002340:	1101                	addi	sp,sp,-32
80002342:	ce22                	sw	s0,28(sp)
80002344:	1000                	addi	s0,sp,32
80002346:	fea42623          	sw	a0,-20(s0)
8000234a:	feb42423          	sw	a1,-24(s0)
8000234e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80002352:	fe442703          	lw	a4,-28(s0)
80002356:	4785                	li	a5,1
80002358:	00f71863          	bne	a4,a5,80002368 <GPIO_ITCmd+0x28>
        WRITE_REG(GPIOx->INTENSET, Pin);
8000235c:	fec42783          	lw	a5,-20(s0)
80002360:	fe842703          	lw	a4,-24(s0)
80002364:	d3b8                	sw	a4,96(a5)
    else
        WRITE_REG(GPIOx->INTENCLR, Pin);
}
80002366:	a031                	j	80002372 <GPIO_ITCmd+0x32>
        WRITE_REG(GPIOx->INTENCLR, Pin);
80002368:	fec42783          	lw	a5,-20(s0)
8000236c:	fe842703          	lw	a4,-24(s0)
80002370:	d3f8                	sw	a4,100(a5)
}
80002372:	0001                	nop
80002374:	4472                	lw	s0,28(sp)
80002376:	6105                	addi	sp,sp,32
80002378:	8082                	ret

8000237a <GPIO_ITStatusClear>:
  * @param   GPIOx  выбор порта, где x=A|B|C    
  * @param   Pin  Выбор пинов
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITStatusClear(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
8000237a:	1101                	addi	sp,sp,-32
8000237c:	ce22                	sw	s0,28(sp)
8000237e:	1000                	addi	s0,sp,32
80002380:	fea42623          	sw	a0,-20(s0)
80002384:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->INTSTATUS, Pin);
80002388:	fec42783          	lw	a5,-20(s0)
8000238c:	fe842703          	lw	a4,-24(s0)
80002390:	08e7a023          	sw	a4,128(a5) # 20050080 <STACK_SIZE+0x2004f880>
}
80002394:	0001                	nop
80002396:	4472                	lw	s0,28(sp)
80002398:	6105                	addi	sp,sp,32
8000239a:	8082                	ret

8000239c <gpio_reset_pin>:
#include "gpio_helpers.h"
#include <stddef.h>

void gpio_reset_pin(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
8000239c:	1101                	addi	sp,sp,-32
8000239e:	ce06                	sw	ra,28(sp)
800023a0:	cc22                	sw	s0,24(sp)
800023a2:	1000                	addi	s0,sp,32
800023a4:	fea42623          	sw	a0,-20(s0)
800023a8:	feb42423          	sw	a1,-24(s0)
    // 1. Отключить выход (OUTENCLR)
    GPIO_OutCmd(GPIOx, Pin, DISABLE);
800023ac:	4601                	li	a2,0
800023ae:	fe842583          	lw	a1,-24(s0)
800023b2:	fec42503          	lw	a0,-20(s0)
800023b6:	3b05                	jal	800020e6 <GPIO_OutCmd>
    // 2. Очистить данные выхода (DATAOUTCLR)
    GPIO_ClearBits(GPIOx, Pin);
800023b8:	fe842583          	lw	a1,-24(s0)
800023bc:	fec42503          	lw	a0,-20(s0)
800023c0:	33d5                	jal	800021a4 <GPIO_ClearBits>
    // 3. Отключить альтернативную функцию (ALTFUNCCLR)
    GPIO_AltFuncCmd(GPIOx, Pin, DISABLE); 
800023c2:	4601                	li	a2,0
800023c4:	fe842583          	lw	a1,-24(s0)
800023c8:	fec42503          	lw	a0,-20(s0)
800023cc:	3b91                	jal	80002120 <GPIO_AltFuncCmd>
    // 4. Сбросить номер альтернативной функции (ALTFUNCNUM = 0)
    GPIO_AltFuncNumConfig(GPIOx, Pin, GPIO_AltFuncNum_None);
800023ce:	4601                	li	a2,0
800023d0:	fe842583          	lw	a1,-24(s0)
800023d4:	fec42503          	lw	a0,-20(s0)
800023d8:	317040ef          	jal	ra,80006eee <GPIO_AltFuncNumConfig>
    // 5. Сбросить режимы в значения по умолчанию
    GPIO_InModeConfig(GPIOx, Pin, GPIO_InMode_Disable);
800023dc:	460d                	li	a2,3
800023de:	fe842583          	lw	a1,-24(s0)
800023e2:	fec42503          	lw	a0,-20(s0)
800023e6:	24b040ef          	jal	ra,80006e30 <GPIO_InModeConfig>
    GPIO_PullModeConfig(GPIOx, Pin, GPIO_PullMode_Disable);
800023ea:	4601                	li	a2,0
800023ec:	fe842583          	lw	a1,-24(s0)
800023f0:	fec42503          	lw	a0,-20(s0)
800023f4:	26d040ef          	jal	ra,80006e60 <GPIO_PullModeConfig>
    GPIO_OutModeConfig(GPIOx, Pin, GPIO_OutMode_PP);
800023f8:	4601                	li	a2,0
800023fa:	fe842583          	lw	a1,-24(s0)
800023fe:	fec42503          	lw	a0,-20(s0)
80002402:	1fd040ef          	jal	ra,80006dfe <GPIO_OutModeConfig>
    // 6. Отключить прерывания, если были включены
    GPIO_ITCmd(GPIOx, Pin, DISABLE);
80002406:	4601                	li	a2,0
80002408:	fe842583          	lw	a1,-24(s0)
8000240c:	fec42503          	lw	a0,-20(s0)
80002410:	3f05                	jal	80002340 <GPIO_ITCmd>
    GPIO_ITStatusClear(GPIOx, Pin);
80002412:	fe842583          	lw	a1,-24(s0)
80002416:	fec42503          	lw	a0,-20(s0)
8000241a:	3785                	jal	8000237a <GPIO_ITStatusClear>
    // 7. Отключить квалификатор входа
    GPIO_QualCmd(GPIOx, Pin, DISABLE);
8000241c:	4601                	li	a2,0
8000241e:	fe842583          	lw	a1,-24(s0)
80002422:	fec42503          	lw	a0,-20(s0)
80002426:	3be5                	jal	8000221e <GPIO_QualCmd>
    GPIO_SyncCmd(GPIOx, Pin, DISABLE);
80002428:	4601                	li	a2,0
8000242a:	fe842583          	lw	a1,-24(s0)
8000242e:	fec42503          	lw	a0,-20(s0)
80002432:	351d                	jal	80002258 <GPIO_SyncCmd>
}
80002434:	0001                	nop
80002436:	40f2                	lw	ra,28(sp)
80002438:	4462                	lw	s0,24(sp)
8000243a:	6105                	addi	sp,sp,32
8000243c:	8082                	ret

8000243e <gpio_init_output>:

void gpio_init_output(GPIO_TypeDef* GPIOx, uint32_t Pin, uint8_t initial_state)
{
8000243e:	7139                	addi	sp,sp,-64
80002440:	de06                	sw	ra,60(sp)
80002442:	dc22                	sw	s0,56(sp)
80002444:	0080                	addi	s0,sp,64
80002446:	fca42623          	sw	a0,-52(s0)
8000244a:	fcb42423          	sw	a1,-56(s0)
8000244e:	87b2                	mv	a5,a2
80002450:	fcf403a3          	sb	a5,-57(s0)
    // Сначала сбрасываем состояние пина
    gpio_reset_pin(GPIOx, Pin);
80002454:	fc842583          	lw	a1,-56(s0)
80002458:	fcc42503          	lw	a0,-52(s0)
8000245c:	3781                	jal	8000239c <gpio_reset_pin>
    
    GPIO_Init_TypeDef gpio;
    GPIO_StructInit(&gpio);
8000245e:	fd040793          	addi	a5,s0,-48
80002462:	853e                	mv	a0,a5
80002464:	41d040ef          	jal	ra,80007080 <GPIO_StructInit>
    gpio.Pin = Pin;
80002468:	fc842783          	lw	a5,-56(s0)
8000246c:	fcf42823          	sw	a5,-48(s0)
    gpio.Out = ENABLE;                // включить выход
80002470:	4785                	li	a5,1
80002472:	fcf42a23          	sw	a5,-44(s0)
    gpio.AltFunc = DISABLE;           // обычный GPIO
80002476:	fc042c23          	sw	zero,-40(s0)
    gpio.AltFuncNum = GPIO_AltFuncNum_None;
8000247a:	fc042e23          	sw	zero,-36(s0)
    gpio.OutMode = GPIO_OutMode_PP;   // push-pull
8000247e:	fe042223          	sw	zero,-28(s0)
    gpio.PullMode = GPIO_PullMode_Disable;
80002482:	fe042623          	sw	zero,-20(s0)
    GPIO_Init(GPIOx, &gpio);
80002486:	fd040793          	addi	a5,s0,-48
8000248a:	85be                	mv	a1,a5
8000248c:	fcc42503          	lw	a0,-52(s0)
80002490:	353040ef          	jal	ra,80006fe2 <GPIO_Init>
    
    // Устанавливаем начальное состояние
    if (initial_state) {
80002494:	fc744783          	lbu	a5,-57(s0)
80002498:	c799                	beqz	a5,800024a6 <gpio_init_output+0x68>
      GPIO_SetBits(GPIOx, Pin);
8000249a:	fc842583          	lw	a1,-56(s0)
8000249e:	fcc42503          	lw	a0,-52(s0)
800024a2:	31cd                	jal	80002184 <GPIO_SetBits>
    } else {
      GPIO_ClearBits(GPIOx, Pin);
    }
}
800024a4:	a031                	j	800024b0 <gpio_init_output+0x72>
      GPIO_ClearBits(GPIOx, Pin);
800024a6:	fc842583          	lw	a1,-56(s0)
800024aa:	fcc42503          	lw	a0,-52(s0)
800024ae:	39dd                	jal	800021a4 <GPIO_ClearBits>
}
800024b0:	0001                	nop
800024b2:	50f2                	lw	ra,60(sp)
800024b4:	5462                	lw	s0,56(sp)
800024b6:	6121                	addi	sp,sp,64
800024b8:	8082                	ret

800024ba <gpio_init_input>:

static uint8_t gpio_qual_initialized = 0;

void gpio_init_input(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_PullMode_TypeDef pull_mode)
{
800024ba:	715d                	addi	sp,sp,-80
800024bc:	c686                	sw	ra,76(sp)
800024be:	c4a2                	sw	s0,72(sp)
800024c0:	0880                	addi	s0,sp,80
800024c2:	faa42e23          	sw	a0,-68(s0)
800024c6:	fab42c23          	sw	a1,-72(s0)
800024ca:	fac42a23          	sw	a2,-76(s0)
    // Сначала сбрасываем состояние пина
    gpio_reset_pin(GPIOx, Pin);
800024ce:	fb842583          	lw	a1,-72(s0)
800024d2:	fbc42503          	lw	a0,-68(s0)
800024d6:	35d9                	jal	8000239c <gpio_reset_pin>
    
    GPIO_Init_TypeDef gpio;
    GPIO_StructInit(&gpio);
800024d8:	fcc40793          	addi	a5,s0,-52
800024dc:	853e                	mv	a0,a5
800024de:	3a3040ef          	jal	ra,80007080 <GPIO_StructInit>
    gpio.Pin = Pin;
800024e2:	fb842783          	lw	a5,-72(s0)
800024e6:	fcf42623          	sw	a5,-52(s0)
    gpio.Out = DISABLE;               
800024ea:	fc042823          	sw	zero,-48(s0)
    gpio.AltFunc = DISABLE;
800024ee:	fc042a23          	sw	zero,-44(s0)
    gpio.AltFuncNum = GPIO_AltFuncNum_None;
800024f2:	fc042c23          	sw	zero,-40(s0)
    gpio.InMode = GPIO_InMode_Schmitt;
800024f6:	fe042223          	sw	zero,-28(s0)
    gpio.PullMode = pull_mode;
800024fa:	fb442783          	lw	a5,-76(s0)
800024fe:	fef42423          	sw	a5,-24(s0)
    GPIO_Init(GPIOx, &gpio);
80002502:	fcc40793          	addi	a5,s0,-52
80002506:	85be                	mv	a1,a5
80002508:	fbc42503          	lw	a0,-68(s0)
8000250c:	2d7040ef          	jal	ra,80006fe2 <GPIO_Init>

    // Аппаратная фильтрация дребезга: пересинхронизация + квалификатор входа
    GPIO_SyncCmd(GPIOx, Pin, ENABLE);
80002510:	4605                	li	a2,1
80002512:	fb842583          	lw	a1,-72(s0)
80002516:	fbc42503          	lw	a0,-68(s0)
8000251a:	3b3d                	jal	80002258 <GPIO_SyncCmd>
    uint8_t port_mask = 0;
8000251c:	fe0407a3          	sb	zero,-17(s0)
    
    if (!(gpio_qual_initialized & port_mask)) {
80002520:	e4f1c783          	lbu	a5,-433(gp) # 400005cf <gpio_qual_initialized>
80002524:	fef44703          	lbu	a4,-17(s0)
80002528:	8ff9                	and	a5,a5,a4
8000252a:	0ff7f793          	zext.b	a5,a5
8000252e:	ef99                	bnez	a5,8000254c <gpio_init_input+0x92>
      GPIO_QualSampleConfig(GPIOx, 1000); // период дискретизации фильтра (такты HCLK)
80002530:	3e800593          	li	a1,1000
80002534:	fbc42503          	lw	a0,-68(s0)
80002538:	31d9                	jal	800021fe <GPIO_QualSampleConfig>
      gpio_qual_initialized |= port_mask;
8000253a:	e4f1c783          	lbu	a5,-433(gp) # 400005cf <gpio_qual_initialized>
8000253e:	fef44703          	lbu	a4,-17(s0)
80002542:	8fd9                	or	a5,a5,a4
80002544:	0ff7f713          	zext.b	a4,a5
80002548:	e4e187a3          	sb	a4,-433(gp) # 400005cf <gpio_qual_initialized>
    }
    
    GPIO_QualModeConfig(GPIOx, Pin, GPIO_QualMode_6Sample); // более жесткая фильтрация
8000254c:	4605                	li	a2,1
8000254e:	fb842583          	lw	a1,-72(s0)
80002552:	fbc42503          	lw	a0,-68(s0)
80002556:	31bd                	jal	800021c4 <GPIO_QualModeConfig>
    GPIO_QualCmd(GPIOx, Pin, ENABLE);
80002558:	4605                	li	a2,1
8000255a:	fb842583          	lw	a1,-72(s0)
8000255e:	fbc42503          	lw	a0,-68(s0)
80002562:	3975                	jal	8000221e <GPIO_QualCmd>
}
80002564:	0001                	nop
80002566:	40b6                	lw	ra,76(sp)
80002568:	4426                	lw	s0,72(sp)
8000256a:	6161                	addi	sp,sp,80
8000256c:	8082                	ret

8000256e <gpio_init_input_irq>:

void gpio_init_input_irq(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_PullMode_TypeDef pull_mode, volatile uint8_t* last_state)
{
8000256e:	1101                	addi	sp,sp,-32
80002570:	ce06                	sw	ra,28(sp)
80002572:	cc22                	sw	s0,24(sp)
80002574:	1000                	addi	s0,sp,32
80002576:	fea42623          	sw	a0,-20(s0)
8000257a:	feb42423          	sw	a1,-24(s0)
8000257e:	fec42223          	sw	a2,-28(s0)
80002582:	fed42023          	sw	a3,-32(s0)
    // Сначала инициализируем как обычный вход
    gpio_init_input(GPIOx, Pin, pull_mode);
80002586:	fe442603          	lw	a2,-28(s0)
8000258a:	fe842583          	lw	a1,-24(s0)
8000258e:	fec42503          	lw	a0,-20(s0)
80002592:	3725                	jal	800024ba <gpio_init_input>
    
    // Настраиваем прерывания
    GPIO_ITTypeConfig(GPIOx, Pin, GPIO_IntType_Edge);
80002594:	4605                	li	a2,1
80002596:	fe842583          	lw	a1,-24(s0)
8000259a:	fec42503          	lw	a0,-20(s0)
8000259e:	39d5                	jal	80002292 <GPIO_ITTypeConfig>
    GPIO_ITPolConfig(GPIOx, Pin, GPIO_IntPol_Negative);
800025a0:	4601                	li	a2,0
800025a2:	fe842583          	lw	a1,-24(s0)
800025a6:	fec42503          	lw	a0,-20(s0)
800025aa:	330d                	jal	800022cc <GPIO_ITPolConfig>
    GPIO_ITEdgeConfig(GPIOx, Pin, GPIO_IntEdge_Any); // прерывание по обоим фронтам
800025ac:	4605                	li	a2,1
800025ae:	fe842583          	lw	a1,-24(s0)
800025b2:	fec42503          	lw	a0,-20(s0)
800025b6:	3b81                	jal	80002306 <GPIO_ITEdgeConfig>
    GPIO_ITStatusClear(GPIOx, Pin);
800025b8:	fe842583          	lw	a1,-24(s0)
800025bc:	fec42503          	lw	a0,-20(s0)
800025c0:	3b6d                	jal	8000237a <GPIO_ITStatusClear>
    
    // Инициализировать предыдущее состояние кнопки (отпущена = 1)
    if (last_state != NULL) {
800025c2:	fe042783          	lw	a5,-32(s0)
800025c6:	c385                	beqz	a5,800025e6 <gpio_init_input_irq+0x78>
      *last_state = GPIO_ReadBit(GPIOx, Pin) ? 1 : 0;
800025c8:	fe842583          	lw	a1,-24(s0)
800025cc:	fec42503          	lw	a0,-20(s0)
800025d0:	3669                	jal	8000215a <GPIO_ReadBit>
800025d2:	87aa                	mv	a5,a0
800025d4:	00f037b3          	snez	a5,a5
800025d8:	0ff7f793          	zext.b	a5,a5
800025dc:	873e                	mv	a4,a5
800025de:	fe042783          	lw	a5,-32(s0)
800025e2:	00e78023          	sb	a4,0(a5)
    }
    
    // Включить прерывание
    GPIO_ITCmd(GPIOx, Pin, ENABLE);
800025e6:	4605                	li	a2,1
800025e8:	fe842583          	lw	a1,-24(s0)
800025ec:	fec42503          	lw	a0,-20(s0)
800025f0:	3b81                	jal	80002340 <GPIO_ITCmd>
}
800025f2:	0001                	nop
800025f4:	40f2                	lw	ra,28(sp)
800025f6:	4462                	lw	s0,24(sp)
800025f8:	6105                	addi	sp,sp,32
800025fa:	8082                	ret

800025fc <TMR32_SetMode>:
  * @brief   Выбор режима счёта
  * @param   mode Режим счёта
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetMode(TMR32_Mode_TypeDef mode)
{
800025fc:	1101                	addi	sp,sp,-32
800025fe:	ce22                	sw	s0,28(sp)
80002600:	1000                	addi	s0,sp,32
80002602:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_MODE(mode));

    MODIFY_REG(TMR32->CTRL, TMR32_CTRL_MODE_Msk, (uint32_t) mode << TMR32_CTRL_MODE_Pos);
80002606:	300007b7          	lui	a5,0x30000
8000260a:	439c                	lw	a5,0(a5)
8000260c:	fcf7f693          	andi	a3,a5,-49
80002610:	fec42783          	lw	a5,-20(s0)
80002614:	00479713          	slli	a4,a5,0x4
80002618:	300007b7          	lui	a5,0x30000
8000261c:	8f55                	or	a4,a4,a3
8000261e:	c398                	sw	a4,0(a5)
}
80002620:	0001                	nop
80002622:	4472                	lw	s0,28(sp)
80002624:	6105                	addi	sp,sp,32
80002626:	8082                	ret

80002628 <TMR32_SetDivider>:
  * @brief   Выбор выходного делителя частоты таймера
  * @param   div Делитель частоты
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetDivider(TMR32_Div_TypeDef div)
{
80002628:	1101                	addi	sp,sp,-32
8000262a:	ce22                	sw	s0,28(sp)
8000262c:	1000                	addi	s0,sp,32
8000262e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_DIV(div));

    MODIFY_REG(TMR32->CTRL, TMR32_CTRL_DIV_Msk, (uint32_t) div << TMR32_CTRL_DIV_Pos);
80002632:	300007b7          	lui	a5,0x30000
80002636:	439c                	lw	a5,0(a5)
80002638:	f3f7f693          	andi	a3,a5,-193
8000263c:	fec42783          	lw	a5,-20(s0)
80002640:	00679713          	slli	a4,a5,0x6
80002644:	300007b7          	lui	a5,0x30000
80002648:	8f55                	or	a4,a4,a3
8000264a:	c398                	sw	a4,0(a5)
}
8000264c:	0001                	nop
8000264e:	4472                	lw	s0,28(sp)
80002650:	6105                	addi	sp,sp,32
80002652:	8082                	ret

80002654 <TMR32_SetClksel>:
  * @brief   Выбор источника тактированного сигнала
  * @param   sel Источник тактирования
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetClksel(TMR32_Clksel_TypeDef sel)
{
80002654:	1101                	addi	sp,sp,-32
80002656:	ce22                	sw	s0,28(sp)
80002658:	1000                	addi	s0,sp,32
8000265a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TMR32_CLKSEL(sel));

    MODIFY_REG(TMR32->CTRL, TMR32_CTRL_CLKSEL_Msk, (uint32_t) sel << TMR32_CTRL_CLKSEL_Pos);
8000265e:	300007b7          	lui	a5,0x30000
80002662:	439c                	lw	a5,0(a5)
80002664:	eff7f693          	andi	a3,a5,-257
80002668:	fec42783          	lw	a5,-20(s0)
8000266c:	00879713          	slli	a4,a5,0x8
80002670:	300007b7          	lui	a5,0x30000
80002674:	8f55                	or	a4,a4,a3
80002676:	c398                	sw	a4,0(a5)
}
80002678:	0001                	nop
8000267a:	4472                	lw	s0,28(sp)
8000267c:	6105                	addi	sp,sp,32
8000267e:	8082                	ret

80002680 <TMR32_SetCounter>:
  * @brief   Установка значения счетчика
  * @param   CountVal  Значение счетчика
  * @retval  void
  */
__STATIC_INLINE void TMR32_SetCounter(uint32_t CountVal)
{
80002680:	1101                	addi	sp,sp,-32
80002682:	ce22                	sw	s0,28(sp)
80002684:	1000                	addi	s0,sp,32
80002686:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(TMR32->COUNT, CountVal);
8000268a:	300007b7          	lui	a5,0x30000
8000268e:	fec42703          	lw	a4,-20(s0)
80002692:	c3d8                	sw	a4,4(a5)
}
80002694:	0001                	nop
80002696:	4472                	lw	s0,28(sp)
80002698:	6105                	addi	sp,sp,32
8000269a:	8082                	ret

8000269c <TMR32_ITCmd>:
  * @param   it Номер маскированного прерывания типа @ref TMR32_IT_TypeDef
  * @param   state Флаг для включения маскированного прерывания
  * @retval  void
  */
__STATIC_INLINE void TMR32_ITCmd(TMR32_IT_TypeDef it, FunctionalState state)
{
8000269c:	1101                	addi	sp,sp,-32
8000269e:	ce22                	sw	s0,28(sp)
800026a0:	1000                	addi	s0,sp,32
800026a2:	fea42623          	sw	a0,-20(s0)
800026a6:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_TMR32_IT(it));
    assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(TMR32->IM, it, (uint32_t) state * (uint32_t) it);
800026aa:	300007b7          	lui	a5,0x30000
800026ae:	4798                	lw	a4,8(a5)
800026b0:	fec42783          	lw	a5,-20(s0)
800026b4:	fff7c793          	not	a5,a5
800026b8:	00f776b3          	and	a3,a4,a5
800026bc:	fe842703          	lw	a4,-24(s0)
800026c0:	fec42783          	lw	a5,-20(s0)
800026c4:	02f70733          	mul	a4,a4,a5
800026c8:	300007b7          	lui	a5,0x30000
800026cc:	8f55                	or	a4,a4,a3
800026ce:	c798                	sw	a4,8(a5)
}
800026d0:	0001                	nop
800026d2:	4472                	lw	s0,28(sp)
800026d4:	6105                	addi	sp,sp,32
800026d6:	8082                	ret

800026d8 <TMR32_ITClear>:
  * @brief   Сброс прерываний
  * @param   it Маскированное прерывание прерывания типа @ref TMR32_IT_TypeDef
  * @retval  void
  */
__STATIC_INLINE void TMR32_ITClear(TMR32_IT_TypeDef it)
{
800026d8:	1101                	addi	sp,sp,-32
800026da:	ce22                	sw	s0,28(sp)
800026dc:	1000                	addi	s0,sp,32
800026de:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_TMR32_IT(it));

    SET_BIT(TMR32->IC, it);
800026e2:	300007b7          	lui	a5,0x30000
800026e6:	4bd4                	lw	a3,20(a5)
800026e8:	300007b7          	lui	a5,0x30000
800026ec:	fec42703          	lw	a4,-20(s0)
800026f0:	8f55                	or	a4,a4,a3
800026f2:	cbd8                	sw	a4,20(a5)
}
800026f4:	0001                	nop
800026f6:	4472                	lw	s0,28(sp)
800026f8:	6105                	addi	sp,sp,32
800026fa:	8082                	ret

800026fc <TMR32_CAPCOM_SetComparator>:
  * @param   capcomx номер регистра capcom @ref TMR32_CAPCOM_Num_TypeDef.
  * @param   CapComVal  Значение регистра сравнения
  * @retval  void
  */
__STATIC_INLINE void TMR32_CAPCOM_SetComparator(TMR32_CAPCOM_Num_TypeDef capcomx, uint32_t capcomVal)
{
800026fc:	1101                	addi	sp,sp,-32
800026fe:	ce22                	sw	s0,28(sp)
80002700:	1000                	addi	s0,sp,32
80002702:	fea42623          	sw	a0,-20(s0)
80002706:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_TMR32_CAPCOM(capcomx));

    WRITE_REG(TMR32->CAPCOM[capcomx].VAL, capcomVal);
8000270a:	30000737          	lui	a4,0x30000
8000270e:	fec42783          	lw	a5,-20(s0)
80002712:	0789                	addi	a5,a5,2 # 30000002 <STACK_SIZE+0x2ffff802>
80002714:	078e                	slli	a5,a5,0x3
80002716:	97ba                	add	a5,a5,a4
80002718:	fe842703          	lw	a4,-24(s0)
8000271c:	c7d8                	sw	a4,12(a5)
}
8000271e:	0001                	nop
80002720:	4472                	lw	s0,28(sp)
80002722:	6105                	addi	sp,sp,32
80002724:	8082                	ret

80002726 <GPIO_ReadBit>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  State  Состояние Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002726:	1101                	addi	sp,sp,-32
80002728:	ce22                	sw	s0,28(sp)
8000272a:	1000                	addi	s0,sp,32
8000272c:	fea42623          	sw	a0,-20(s0)
80002730:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
80002734:	fec42783          	lw	a5,-20(s0)
80002738:	4398                	lw	a4,0(a5)
8000273a:	fe842783          	lw	a5,-24(s0)
8000273e:	8ff9                	and	a5,a5,a4
80002740:	c399                	beqz	a5,80002746 <GPIO_ReadBit+0x20>
80002742:	4785                	li	a5,1
80002744:	a011                	j	80002748 <GPIO_ReadBit+0x22>
80002746:	4781                	li	a5,0
}
80002748:	853e                	mv	a0,a5
8000274a:	4472                	lw	s0,28(sp)
8000274c:	6105                	addi	sp,sp,32
8000274e:	8082                	ret

80002750 <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002750:	1101                	addi	sp,sp,-32
80002752:	ce22                	sw	s0,28(sp)
80002754:	1000                	addi	s0,sp,32
80002756:	fea42623          	sw	a0,-20(s0)
8000275a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
8000275e:	fec42783          	lw	a5,-20(s0)
80002762:	fe842703          	lw	a4,-24(s0)
80002766:	c798                	sw	a4,8(a5)
}
80002768:	0001                	nop
8000276a:	4472                	lw	s0,28(sp)
8000276c:	6105                	addi	sp,sp,32
8000276e:	8082                	ret

80002770 <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002770:	1101                	addi	sp,sp,-32
80002772:	ce22                	sw	s0,28(sp)
80002774:	1000                	addi	s0,sp,32
80002776:	fea42623          	sw	a0,-20(s0)
8000277a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
8000277e:	fec42783          	lw	a5,-20(s0)
80002782:	fe842703          	lw	a4,-24(s0)
80002786:	c7d8                	sw	a4,12(a5)
}
80002788:	0001                	nop
8000278a:	4472                	lw	s0,28(sp)
8000278c:	6105                	addi	sp,sp,32
8000278e:	8082                	ret

80002790 <GPIO_ITStatus>:
  * @param   GPIOx  выбор порта, где x=A|B|C  
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @retval  Status  Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE FlagStatus GPIO_ITStatus(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80002790:	1101                	addi	sp,sp,-32
80002792:	ce22                	sw	s0,28(sp)
80002794:	1000                	addi	s0,sp,32
80002796:	fea42623          	sw	a0,-20(s0)
8000279a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    return (FlagStatus)READ_BIT(GPIOx->INTSTATUS, Pin);
8000279e:	fec42783          	lw	a5,-20(s0)
800027a2:	0807a703          	lw	a4,128(a5)
800027a6:	fe842783          	lw	a5,-24(s0)
800027aa:	8ff9                	and	a5,a5,a4
800027ac:	c399                	beqz	a5,800027b2 <GPIO_ITStatus+0x22>
800027ae:	4785                	li	a5,1
800027b0:	a011                	j	800027b4 <GPIO_ITStatus+0x24>
800027b2:	4781                	li	a5,0
}
800027b4:	853e                	mv	a0,a5
800027b6:	4472                	lw	s0,28(sp)
800027b8:	6105                	addi	sp,sp,32
800027ba:	8082                	ret

800027bc <GPIO_ITStatusClear>:
  * @param   GPIOx  выбор порта, где x=A|B|C    
  * @param   Pin  Выбор пинов
  * @retval  void
  */
__STATIC_INLINE void GPIO_ITStatusClear(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
800027bc:	1101                	addi	sp,sp,-32
800027be:	ce22                	sw	s0,28(sp)
800027c0:	1000                	addi	s0,sp,32
800027c2:	fea42623          	sw	a0,-20(s0)
800027c6:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->INTSTATUS, Pin);
800027ca:	fec42783          	lw	a5,-20(s0)
800027ce:	fe842703          	lw	a4,-24(s0)
800027d2:	08e7a023          	sw	a4,128(a5)
}
800027d6:	0001                	nop
800027d8:	4472                	lw	s0,28(sp)
800027da:	6105                	addi	sp,sp,32
800027dc:	8082                	ret

800027de <UART4_init>:
static void tmr32_irq_handler(void);
static void cfg_store_and_report(void);
 

void UART4_init()
{
800027de:	1101                	addi	sp,sp,-32
800027e0:	ce22                	sw	s0,28(sp)
800027e2:	1000                	addi	s0,sp,32
    uint32_t baud_icoef = HSECLK_VAL / (16 * UART4_BAUD);
800027e4:	47a1                	li	a5,8
800027e6:	fef42623          	sw	a5,-20(s0)
    uint32_t baud_fcoef = ((HSECLK_VAL / (16.0f * UART4_BAUD) - baud_icoef) * 64 + 0.5f);
800027ea:	fec42783          	lw	a5,-20(s0)
800027ee:	d017f7d3          	fcvt.s.wu	fa5,a5
800027f2:	800097b7          	lui	a5,0x80009
800027f6:	b687a707          	flw	fa4,-1176(a5) # 80008b68 <__data_source_start+0xfffffd14>
800027fa:	08f77753          	fsub.s	fa4,fa4,fa5
800027fe:	800097b7          	lui	a5,0x80009
80002802:	b6c7a787          	flw	fa5,-1172(a5) # 80008b6c <__data_source_start+0xfffffd18>
80002806:	10f77753          	fmul.s	fa4,fa4,fa5
8000280a:	800097b7          	lui	a5,0x80009
8000280e:	b707a787          	flw	fa5,-1168(a5) # 80008b70 <__data_source_start+0xfffffd1c>
80002812:	00f777d3          	fadd.s	fa5,fa4,fa5
80002816:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
8000281a:	fef42423          	sw	a5,-24(s0)
    // Настраиваем GPIO
    RCU->CGCFGAHB_bit.GPIOAEN = 1;
8000281e:	3000e7b7          	lui	a5,0x3000e
80002822:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80002826:	10076713          	ori	a4,a4,256
8000282a:	00e79023          	sh	a4,0(a5)
    RCU->RSTDISAHB_bit.GPIOAEN = 1;
8000282e:	3000e7b7          	lui	a5,0x3000e
80002832:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80002836:	10076713          	ori	a4,a4,256
8000283a:	00e79823          	sh	a4,16(a5)
    RCU->CGCFGAPB_bit.UART4EN = 1;
8000283e:	3000e7b7          	lui	a5,0x3000e
80002842:	4798                	lw	a4,8(a5)
80002844:	40076713          	ori	a4,a4,1024
80002848:	c798                	sw	a4,8(a5)
    RCU->RSTDISAPB_bit.UART4EN = 1;
8000284a:	3000e7b7          	lui	a5,0x3000e
8000284e:	4f98                	lw	a4,24(a5)
80002850:	40076713          	ori	a4,a4,1024
80002854:	cf98                	sw	a4,24(a5)

    // UART4 на пинах PA8 (RX) и PA9 (TX)
    GPIOA->ALTFUNCNUM_bit.PIN8 = 1;
80002856:	280007b7          	lui	a5,0x28000
8000285a:	5fd4                	lw	a3,60(a5)
8000285c:	fffd0737          	lui	a4,0xfffd0
80002860:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc71ab>
80002862:	8ef9                	and	a3,a3,a4
80002864:	6741                	lui	a4,0x10
80002866:	8f55                	or	a4,a4,a3
80002868:	dfd8                	sw	a4,60(a5)
    GPIOA->ALTFUNCNUM_bit.PIN9 = 1;
8000286a:	280007b7          	lui	a5,0x28000
8000286e:	5fd4                	lw	a3,60(a5)
80002870:	fff40737          	lui	a4,0xfff40
80002874:	177d                	addi	a4,a4,-1 # fff3ffff <__data_source_start+0x7ff371ab>
80002876:	8ef9                	and	a3,a3,a4
80002878:	00040737          	lui	a4,0x40
8000287c:	8f55                	or	a4,a4,a3
8000287e:	dfd8                	sw	a4,60(a5)
    GPIOA->ALTFUNCSET = GPIO_ALTFUNCSET_PIN8_Msk | GPIO_ALTFUNCSET_PIN9_Msk;
80002880:	280007b7          	lui	a5,0x28000
80002884:	30000713          	li	a4,768
80002888:	dbd8                	sw	a4,52(a5)

    // Настраиваем UART4
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.CLKSEL = RCU_UARTCLKCFG_CLKSEL_HSE;
8000288a:	3000e7b7          	lui	a5,0x3000e
8000288e:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
80002892:	fffd0737          	lui	a4,0xfffd0
80002896:	177d                	addi	a4,a4,-1 # fffcffff <__data_source_start+0x7ffc71ab>
80002898:	8ef9                	and	a3,a3,a4
8000289a:	6741                	lui	a4,0x10
8000289c:	8f55                	or	a4,a4,a3
8000289e:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.DIVEN = 0;
800028a2:	3000e7b7          	lui	a5,0x3000e
800028a6:	0807a683          	lw	a3,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
800028aa:	fff00737          	lui	a4,0xfff00
800028ae:	177d                	addi	a4,a4,-1 # ffefffff <__data_source_start+0x7fef71ab>
800028b0:	8f75                	and	a4,a4,a3
800028b2:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.RSTDIS = 1;
800028b6:	3000e7b7          	lui	a5,0x3000e
800028ba:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
800028be:	10076713          	ori	a4,a4,256
800028c2:	08e7a023          	sw	a4,128(a5)
    RCU->UARTCLKCFG[4].UARTCLKCFG_bit.CLKEN = 1;
800028c6:	3000e7b7          	lui	a5,0x3000e
800028ca:	0807a703          	lw	a4,128(a5) # 3000e080 <STACK_SIZE+0x3000d880>
800028ce:	00176713          	ori	a4,a4,1
800028d2:	08e7a023          	sw	a4,128(a5)

    UART4->IBRD = baud_icoef;
800028d6:	3000a7b7          	lui	a5,0x3000a
800028da:	fec42703          	lw	a4,-20(s0)
800028de:	d3d8                	sw	a4,36(a5)
    UART4->FBRD = baud_fcoef;
800028e0:	3000a7b7          	lui	a5,0x3000a
800028e4:	fe842703          	lw	a4,-24(s0)
800028e8:	d798                	sw	a4,40(a5)
    UART4->LCRH = UART_LCRH_FEN_Msk | (3 << UART_LCRH_WLEN_Pos);
800028ea:	3000a7b7          	lui	a5,0x3000a
800028ee:	07000713          	li	a4,112
800028f2:	d7d8                	sw	a4,44(a5)
    UART4->IFLS = 0;
800028f4:	3000a7b7          	lui	a5,0x3000a
800028f8:	0207aa23          	sw	zero,52(a5) # 3000a034 <STACK_SIZE+0x30009834>
    UART4->CR = UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
800028fc:	3000a7b7          	lui	a5,0x3000a
80002900:	30100713          	li	a4,769
80002904:	db98                	sw	a4,48(a5)
}
80002906:	0001                	nop
80002908:	4472                	lw	s0,28(sp)
8000290a:	6105                	addi	sp,sp,32
8000290c:	8082                	ret

8000290e <periph_init>:



//-- Peripheral init functions -------------------------------------------------
void periph_init()
{
8000290e:	1141                	addi	sp,sp,-16
80002910:	c606                	sw	ra,12(sp)
80002912:	c422                	sw	s0,8(sp)
80002914:	0800                	addi	s0,sp,16
  SystemInit();
80002916:	adcff0ef          	jal	ra,80001bf2 <SystemInit>
  SystemCoreClockUpdate();
8000291a:	fbffe0ef          	jal	ra,800018d8 <SystemCoreClockUpdate>
  retarget_init();
8000291e:	e2ffe0ef          	jal	ra,8000174c <retarget_init>
  adcsar_init();
80002922:	c99fd0ef          	jal	ra,800005ba <adcsar_init>
  eeprom_init();
80002926:	b80ff0ef          	jal	ra,80001ca6 <eeprom_init>
  gpio_init();
8000292a:	2a39                	jal	80002a48 <gpio_init>
  tmr32_init();
8000292c:	212d                	jal	80002d56 <tmr32_init>
  uart_irq_init();
8000292e:	2069                	jal	800029b8 <uart_irq_init>
  gpio_irq_init();
80002930:	2241                	jal	80002ab0 <gpio_irq_init>
  InterruptEnable();
80002932:	a7eff0ef          	jal	ra,80001bb0 <InterruptEnable>
  osdp_init();
80002936:	461010ef          	jal	ra,80004596 <osdp_init>
  cfg_store_and_report();
8000293a:	2801                	jal	8000294a <cfg_store_and_report>
  adcsar_start();
8000293c:	e33fd0ef          	jal	ra,8000076e <adcsar_start>
}
80002940:	0001                	nop
80002942:	40b2                	lw	ra,12(sp)
80002944:	4422                	lw	s0,8(sp)
80002946:	0141                	addi	sp,sp,16
80002948:	8082                	ret

8000294a <cfg_store_and_report>:

static void cfg_store_and_report(void)
{
8000294a:	1141                	addi	sp,sp,-16
8000294c:	c606                	sw	ra,12(sp)
8000294e:	c422                	sw	s0,8(sp)
80002950:	0800                	addi	s0,sp,16
  // Пытаемся загрузить конфиг; если невалиден — пишем дефолтный и перезагружаем
  if (!config_storage_load(&g_cfg)) {
80002952:	e6818513          	addi	a0,gp,-408 # 400005e8 <g_cfg>
80002956:	f4bfd0ef          	jal	ra,800008a0 <config_storage_load>
8000295a:	87aa                	mv	a5,a0
8000295c:	0017c793          	xori	a5,a5,1
80002960:	0ff7f793          	zext.b	a5,a5
80002964:	cf99                	beqz	a5,80002982 <cfg_store_and_report+0x38>
    printf("CFG invalid, writing defaults\r\n");
80002966:	800097b7          	lui	a5,0x80009
8000296a:	ad078513          	addi	a0,a5,-1328 # 80008ad0 <__data_source_start+0xfffffc7c>
8000296e:	cfbfe0ef          	jal	ra,80001668 <puts>
    config_storage_default(&g_cfg);
80002972:	e6818513          	addi	a0,gp,-408 # 400005e8 <g_cfg>
80002976:	ec3fd0ef          	jal	ra,80000838 <config_storage_default>
    config_storage_save(&g_cfg);
8000297a:	e6818513          	addi	a0,gp,-408 # 400005e8 <g_cfg>
8000297e:	884fe0ef          	jal	ra,80000a02 <config_storage_save>
  }

  printf("CFG active: addr=%u baud=%u\r\n", g_cfg.osdp_addr, (unsigned)g_cfg.osdp_baud);
80002982:	e6818793          	addi	a5,gp,-408 # 400005e8 <g_cfg>
80002986:	0007c783          	lbu	a5,0(a5)
8000298a:	86be                	mv	a3,a5
8000298c:	e6818793          	addi	a5,gp,-408 # 400005e8 <g_cfg>
80002990:	4398                	lw	a4,0(a5)
80002992:	8321                	srli	a4,a4,0x8
80002994:	43dc                	lw	a5,4(a5)
80002996:	0ff7f793          	zext.b	a5,a5
8000299a:	07e2                	slli	a5,a5,0x18
8000299c:	8fd9                	or	a5,a5,a4
8000299e:	863e                	mv	a2,a5
800029a0:	85b6                	mv	a1,a3
800029a2:	800097b7          	lui	a5,0x80009
800029a6:	af078513          	addi	a0,a5,-1296 # 80008af0 <__data_source_start+0xfffffc9c>
800029aa:	c1dfe0ef          	jal	ra,800015c6 <printf>
}
800029ae:	0001                	nop
800029b0:	40b2                	lw	ra,12(sp)
800029b2:	4422                	lw	s0,8(sp)
800029b4:	0141                	addi	sp,sp,16
800029b6:	8082                	ret

800029b8 <uart_irq_init>:

//--- USER FUNCTIONS ----------------------------------------------------------------------

// Инициализация прерываний UART4 и регистрация обработчика в PLIC
static void uart_irq_init(void)
{
800029b8:	1141                	addi	sp,sp,-16
800029ba:	c606                	sw	ra,12(sp)
800029bc:	c422                	sw	s0,8(sp)
800029be:	0800                	addi	s0,sp,16
  // Очистить возможные висящие флаги прерываний
  RETARGET_UART->ICR = UART_ICR_RXIC_Msk |
800029c0:	3000a7b7          	lui	a5,0x3000a
800029c4:	7d000713          	li	a4,2000
800029c8:	c3f8                	sw	a4,68(a5)
                       UART_ICR_FEIC_Msk |
                       UART_ICR_PEIC_Msk |
                       UART_ICR_BEIC_Msk;

  // Включить источники прерываний по приёму и таймауту
  RETARGET_UART->IMSC |= (UART_IMSC_RXIM_Msk |
800029ca:	3000a7b7          	lui	a5,0x3000a
800029ce:	5f98                	lw	a4,56(a5)
800029d0:	3000a7b7          	lui	a5,0x3000a
800029d4:	7d076713          	ori	a4,a4,2000
800029d8:	df98                	sw	a4,56(a5)
                          UART_IMSC_FERIM_Msk |
                          UART_IMSC_PERIM_Msk |
                          UART_IMSC_BERIM_Msk);

  // Зарегистрировать обработчик в PLIC и включить линию прерываний UART4
  PLIC_SetPriority(PLIC_UART4_VECTNUM, 1);
800029da:	4585                	li	a1,1
800029dc:	4569                	li	a0,26
800029de:	8defe0ef          	jal	ra,80000abc <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_UART4_VECTNUM, uart4_irq_handler);
800029e2:	800037b7          	lui	a5,0x80003
800029e6:	a0478613          	addi	a2,a5,-1532 # 80002a04 <__data_source_start+0xffff9bb0>
800029ea:	45e9                	li	a1,26
800029ec:	4501                	li	a0,0
800029ee:	882fe0ef          	jal	ra,80000a70 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_UART4_VECTNUM);
800029f2:	45e9                	li	a1,26
800029f4:	4501                	li	a0,0
800029f6:	8f0fe0ef          	jal	ra,80000ae6 <PLIC_IntEnable>
}
800029fa:	0001                	nop
800029fc:	40b2                	lw	ra,12(sp)
800029fe:	4422                	lw	s0,8(sp)
80002a00:	0141                	addi	sp,sp,16
80002a02:	8082                	ret

80002a04 <uart4_irq_handler>:

// Обработчик прерывания UART4 (через PLIC)
static void uart4_irq_handler(void)
{
80002a04:	1101                	addi	sp,sp,-32
80002a06:	ce06                	sw	ra,28(sp)
80002a08:	cc22                	sw	s0,24(sp)
80002a0a:	1000                	addi	s0,sp,32
  while (!RETARGET_UART->FR_bit.RXFE) {
80002a0c:	a821                	j	80002a24 <uart4_irq_handler+0x20>
    uint8_t ch = (uint8_t)RETARGET_UART->DR_bit.DATA;
80002a0e:	3000a7b7          	lui	a5,0x3000a
80002a12:	0007c783          	lbu	a5,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
80002a16:	fef407a3          	sb	a5,-17(s0)
    osdp_on_rx_byte(ch);
80002a1a:	fef44783          	lbu	a5,-17(s0)
80002a1e:	853e                	mv	a0,a5
80002a20:	423010ef          	jal	ra,80004642 <osdp_on_rx_byte>
  while (!RETARGET_UART->FR_bit.RXFE) {
80002a24:	3000a7b7          	lui	a5,0x3000a
80002a28:	4f9c                	lw	a5,24(a5)
80002a2a:	8391                	srli	a5,a5,0x4
80002a2c:	8b85                	andi	a5,a5,1
80002a2e:	0ff7f793          	zext.b	a5,a5
80002a32:	dff1                	beqz	a5,80002a0e <uart4_irq_handler+0xa>
  }

  // Очистить флаги источников прерываний
  RETARGET_UART->ICR = UART_ICR_RXIC_Msk |
80002a34:	3000a7b7          	lui	a5,0x3000a
80002a38:	7d000713          	li	a4,2000
80002a3c:	c3f8                	sw	a4,68(a5)
                       UART_ICR_RTIC_Msk |
                       UART_ICR_OEIC_Msk |
                       UART_ICR_FEIC_Msk |
                       UART_ICR_PEIC_Msk |
                       UART_ICR_BEIC_Msk;
}
80002a3e:	0001                	nop
80002a40:	40f2                	lw	ra,28(sp)
80002a42:	4462                	lw	s0,24(sp)
80002a44:	6105                	addi	sp,sp,32
80002a46:	8082                	ret

80002a48 <gpio_init>:


static void gpio_init(void)
{
80002a48:	1141                	addi	sp,sp,-16
80002a4a:	c606                	sw	ra,12(sp)
80002a4c:	c422                	sw	s0,8(sp)
80002a4e:	0800                	addi	s0,sp,16
  // Включить тактирование GPIOA
  RCU->CGCFGAHB_bit.GPIOAEN = 1;
80002a50:	3000e7b7          	lui	a5,0x3000e
80002a54:	0007d703          	lhu	a4,0(a5) # 3000e000 <STACK_SIZE+0x3000d800>
80002a58:	10076713          	ori	a4,a4,256
80002a5c:	00e79023          	sh	a4,0(a5)
  RCU->RSTDISAHB_bit.GPIOAEN = 1;
80002a60:	3000e7b7          	lui	a5,0x3000e
80002a64:	0107d703          	lhu	a4,16(a5) # 3000e010 <STACK_SIZE+0x3000d810>
80002a68:	10076713          	ori	a4,a4,256
80002a6c:	00e79823          	sh	a4,16(a5)

  // LED на PA4-PA7 (начальное состояние: все выключены)
  gpio_init_output(GPIOA, GPIO_Pin_4, 0);
80002a70:	4601                	li	a2,0
80002a72:	45c1                	li	a1,16
80002a74:	28000537          	lui	a0,0x28000
80002a78:	9c7ff0ef          	jal	ra,8000243e <gpio_init_output>
  gpio_init_output(GPIOA, GPIO_Pin_5, 0);
80002a7c:	4601                	li	a2,0
80002a7e:	02000593          	li	a1,32
80002a82:	28000537          	lui	a0,0x28000
80002a86:	9b9ff0ef          	jal	ra,8000243e <gpio_init_output>
  gpio_init_output(GPIOA, GPIO_Pin_6, 0);
80002a8a:	4601                	li	a2,0
80002a8c:	04000593          	li	a1,64
80002a90:	28000537          	lui	a0,0x28000
80002a94:	9abff0ef          	jal	ra,8000243e <gpio_init_output>
  gpio_init_output(GPIOA, GPIO_Pin_7, 0);
80002a98:	4601                	li	a2,0
80002a9a:	08000593          	li	a1,128
80002a9e:	28000537          	lui	a0,0x28000
80002aa2:	99dff0ef          	jal	ra,8000243e <gpio_init_output>
}
80002aa6:	0001                	nop
80002aa8:	40b2                	lw	ra,12(sp)
80002aaa:	4422                	lw	s0,8(sp)
80002aac:	0141                	addi	sp,sp,16
80002aae:	8082                	ret

80002ab0 <gpio_irq_init>:

// Инициализация прерываний GPIO для кнопок
static void gpio_irq_init(void)
{
80002ab0:	1141                	addi	sp,sp,-16
80002ab2:	c606                	sw	ra,12(sp)
80002ab4:	c422                	sw	s0,8(sp)
80002ab6:	0800                	addi	s0,sp,16
  // Кнопки PA0-PA3
  gpio_init_input_irq(GPIOA, GPIO_Pin_0, GPIO_PullMode_PU, &g_btn_last_state[0]);
80002ab8:	88018693          	addi	a3,gp,-1920 # 40000000 <g_btn_last_state>
80002abc:	4605                	li	a2,1
80002abe:	4585                	li	a1,1
80002ac0:	28000537          	lui	a0,0x28000
80002ac4:	aabff0ef          	jal	ra,8000256e <gpio_init_input_irq>
  gpio_init_input_irq(GPIOA, GPIO_Pin_1, GPIO_PullMode_PU, &g_btn_last_state[1]);
80002ac8:	88118693          	addi	a3,gp,-1919 # 40000001 <g_btn_last_state+0x1>
80002acc:	4605                	li	a2,1
80002ace:	4589                	li	a1,2
80002ad0:	28000537          	lui	a0,0x28000
80002ad4:	a9bff0ef          	jal	ra,8000256e <gpio_init_input_irq>
  gpio_init_input_irq(GPIOA, GPIO_Pin_2, GPIO_PullMode_PU, &g_btn_last_state[2]);
80002ad8:	88218693          	addi	a3,gp,-1918 # 40000002 <g_btn_last_state+0x2>
80002adc:	4605                	li	a2,1
80002ade:	4591                	li	a1,4
80002ae0:	28000537          	lui	a0,0x28000
80002ae4:	a8bff0ef          	jal	ra,8000256e <gpio_init_input_irq>
  gpio_init_input_irq(GPIOA, GPIO_Pin_3, GPIO_PullMode_PU, &g_btn_last_state[3]);
80002ae8:	88318693          	addi	a3,gp,-1917 # 40000003 <g_btn_last_state+0x3>
80002aec:	4605                	li	a2,1
80002aee:	45a1                	li	a1,8
80002af0:	28000537          	lui	a0,0x28000
80002af4:	a7bff0ef          	jal	ra,8000256e <gpio_init_input_irq>
  
  // Зарегистрировать обработчик в PLIC и включить линию прерываний GPIO
  PLIC_SetPriority(PLIC_GPIO_VECTNUM, 1);
80002af8:	4585                	li	a1,1
80002afa:	4515                	li	a0,5
80002afc:	fc1fd0ef          	jal	ra,80000abc <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_GPIO_VECTNUM, gpio_irq_handler);
80002b00:	800037b7          	lui	a5,0x80003
80002b04:	b2278613          	addi	a2,a5,-1246 # 80002b22 <__data_source_start+0xffff9cce>
80002b08:	4595                	li	a1,5
80002b0a:	4501                	li	a0,0
80002b0c:	f65fd0ef          	jal	ra,80000a70 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_GPIO_VECTNUM);
80002b10:	4595                	li	a1,5
80002b12:	4501                	li	a0,0
80002b14:	fd3fd0ef          	jal	ra,80000ae6 <PLIC_IntEnable>
}
80002b18:	0001                	nop
80002b1a:	40b2                	lw	ra,12(sp)
80002b1c:	4422                	lw	s0,8(sp)
80002b1e:	0141                	addi	sp,sp,16
80002b20:	8082                	ret

80002b22 <gpio_irq_handler>:
// Простой самотест EEPROM: запись и чтение известного шаблона


// Обработчик прерывания GPIO (кнопки)
static void gpio_irq_handler(void)
{
80002b22:	7139                	addi	sp,sp,-64
80002b24:	de06                	sw	ra,60(sp)
80002b26:	dc22                	sw	s0,56(sp)
80002b28:	0080                	addi	s0,sp,64
  uint32_t now = ms_ticks;
80002b2a:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
80002b2e:	fef42423          	sw	a5,-24(s0)
  
  const uint32_t btn_pins[4] = {GPIO_Pin_0, GPIO_Pin_1, GPIO_Pin_2, GPIO_Pin_3};
80002b32:	800097b7          	lui	a5,0x80009
80002b36:	b3878793          	addi	a5,a5,-1224 # 80008b38 <__data_source_start+0xfffffce4>
80002b3a:	4390                	lw	a2,0(a5)
80002b3c:	43d4                	lw	a3,4(a5)
80002b3e:	4798                	lw	a4,8(a5)
80002b40:	47dc                	lw	a5,12(a5)
80002b42:	fcc42a23          	sw	a2,-44(s0)
80002b46:	fcd42c23          	sw	a3,-40(s0)
80002b4a:	fce42e23          	sw	a4,-36(s0)
80002b4e:	fef42023          	sw	a5,-32(s0)
  const uint32_t led_pins[4] = {GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7};
80002b52:	800097b7          	lui	a5,0x80009
80002b56:	b4878793          	addi	a5,a5,-1208 # 80008b48 <__data_source_start+0xfffffcf4>
80002b5a:	4390                	lw	a2,0(a5)
80002b5c:	43d4                	lw	a3,4(a5)
80002b5e:	4798                	lw	a4,8(a5)
80002b60:	47dc                	lw	a5,12(a5)
80002b62:	fcc42223          	sw	a2,-60(s0)
80002b66:	fcd42423          	sw	a3,-56(s0)
80002b6a:	fce42623          	sw	a4,-52(s0)
80002b6e:	fcf42823          	sw	a5,-48(s0)
  
  // Обработка всех 4 кнопок PA0-PA3
  for (uint8_t i = 0; i < 4; i++) {
80002b72:	fe0407a3          	sb	zero,-17(s0)
80002b76:	a2e9                	j	80002d40 <gpio_irq_handler+0x21e>
    if (GPIO_ITStatus(GPIOA, btn_pins[i]) == SET) {
80002b78:	fef44783          	lbu	a5,-17(s0)
80002b7c:	078a                	slli	a5,a5,0x2
80002b7e:	17c1                	addi	a5,a5,-16
80002b80:	97a2                	add	a5,a5,s0
80002b82:	fe47a783          	lw	a5,-28(a5)
80002b86:	85be                	mv	a1,a5
80002b88:	28000537          	lui	a0,0x28000
80002b8c:	3111                	jal	80002790 <GPIO_ITStatus>
80002b8e:	872a                	mv	a4,a0
80002b90:	4785                	li	a5,1
80002b92:	1af71263          	bne	a4,a5,80002d36 <gpio_irq_handler+0x214>
      uint8_t btn_current = GPIO_ReadBit(GPIOA, btn_pins[i]) ? 1 : 0;
80002b96:	fef44783          	lbu	a5,-17(s0)
80002b9a:	078a                	slli	a5,a5,0x2
80002b9c:	17c1                	addi	a5,a5,-16
80002b9e:	97a2                	add	a5,a5,s0
80002ba0:	fe47a783          	lw	a5,-28(a5)
80002ba4:	85be                	mv	a1,a5
80002ba6:	28000537          	lui	a0,0x28000
80002baa:	3eb5                	jal	80002726 <GPIO_ReadBit>
80002bac:	87aa                	mv	a5,a0
80002bae:	00f037b3          	snez	a5,a5
80002bb2:	0ff7f793          	zext.b	a5,a5
80002bb6:	fef403a3          	sb	a5,-25(s0)
      
      if (g_btn_last_state[i] == 1 && btn_current == 0) {
80002bba:	fef44703          	lbu	a4,-17(s0)
80002bbe:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80002bc2:	97ba                	add	a5,a5,a4
80002bc4:	0007c783          	lbu	a5,0(a5)
80002bc8:	0ff7f713          	zext.b	a4,a5
80002bcc:	4785                	li	a5,1
80002bce:	0ef71a63          	bne	a4,a5,80002cc2 <gpio_irq_handler+0x1a0>
80002bd2:	fe744783          	lbu	a5,-25(s0)
80002bd6:	0e079663          	bnez	a5,80002cc2 <gpio_irq_handler+0x1a0>
        // Кнопка нажата (переход из 1 в 0)
        if ((now - g_btn_last_ms[i]) >= g_debounce_ms) {
80002bda:	fef44783          	lbu	a5,-17(s0)
80002bde:	e5418713          	addi	a4,gp,-428 # 400005d4 <g_btn_last_ms>
80002be2:	078a                	slli	a5,a5,0x2
80002be4:	97ba                	add	a5,a5,a4
80002be6:	439c                	lw	a5,0(a5)
80002be8:	fe842703          	lw	a4,-24(s0)
80002bec:	8f1d                	sub	a4,a4,a5
80002bee:	03200793          	li	a5,50
80002bf2:	12f76763          	bltu	a4,a5,80002d20 <gpio_irq_handler+0x1fe>
          // Переключаем состояние соответствующего LED (PA4-PA7)
          led_state[i] ^= 1u;
80002bf6:	fef44703          	lbu	a4,-17(s0)
80002bfa:	e5018793          	addi	a5,gp,-432 # 400005d0 <led_state>
80002bfe:	97ba                	add	a5,a5,a4
80002c00:	0007c783          	lbu	a5,0(a5)
80002c04:	0ff7f793          	zext.b	a5,a5
80002c08:	fef44683          	lbu	a3,-17(s0)
80002c0c:	0017c793          	xori	a5,a5,1
80002c10:	0ff7f713          	zext.b	a4,a5
80002c14:	e5018793          	addi	a5,gp,-432 # 400005d0 <led_state>
80002c18:	97b6                	add	a5,a5,a3
80002c1a:	00e78023          	sb	a4,0(a5)
          if (led_state[i]) {
80002c1e:	fef44703          	lbu	a4,-17(s0)
80002c22:	e5018793          	addi	a5,gp,-432 # 400005d0 <led_state>
80002c26:	97ba                	add	a5,a5,a4
80002c28:	0007c783          	lbu	a5,0(a5)
80002c2c:	0ff7f793          	zext.b	a5,a5
80002c30:	cf85                	beqz	a5,80002c68 <gpio_irq_handler+0x146>
            GPIO_SetBits(GPIOA, led_pins[i]);
80002c32:	fef44783          	lbu	a5,-17(s0)
80002c36:	078a                	slli	a5,a5,0x2
80002c38:	17c1                	addi	a5,a5,-16
80002c3a:	97a2                	add	a5,a5,s0
80002c3c:	fd47a783          	lw	a5,-44(a5)
80002c40:	85be                	mv	a1,a5
80002c42:	28000537          	lui	a0,0x28000
80002c46:	3629                	jal	80002750 <GPIO_SetBits>
            printf("LED%d ON (PA%d)\r\n", i+1, i+4);
80002c48:	fef44783          	lbu	a5,-17(s0)
80002c4c:	00178713          	addi	a4,a5,1
80002c50:	fef44783          	lbu	a5,-17(s0)
80002c54:	0791                	addi	a5,a5,4
80002c56:	863e                	mv	a2,a5
80002c58:	85ba                	mv	a1,a4
80002c5a:	800097b7          	lui	a5,0x80009
80002c5e:	b1078513          	addi	a0,a5,-1264 # 80008b10 <__data_source_start+0xfffffcbc>
80002c62:	965fe0ef          	jal	ra,800015c6 <printf>
80002c66:	a81d                	j	80002c9c <gpio_irq_handler+0x17a>
          } else {
            GPIO_ClearBits(GPIOA, led_pins[i]);
80002c68:	fef44783          	lbu	a5,-17(s0)
80002c6c:	078a                	slli	a5,a5,0x2
80002c6e:	17c1                	addi	a5,a5,-16
80002c70:	97a2                	add	a5,a5,s0
80002c72:	fd47a783          	lw	a5,-44(a5)
80002c76:	85be                	mv	a1,a5
80002c78:	28000537          	lui	a0,0x28000
80002c7c:	3cd5                	jal	80002770 <GPIO_ClearBits>
            printf("LED%d OFF (PA%d)\r\n", i+1, i+4);
80002c7e:	fef44783          	lbu	a5,-17(s0)
80002c82:	00178713          	addi	a4,a5,1
80002c86:	fef44783          	lbu	a5,-17(s0)
80002c8a:	0791                	addi	a5,a5,4
80002c8c:	863e                	mv	a2,a5
80002c8e:	85ba                	mv	a1,a4
80002c90:	800097b7          	lui	a5,0x80009
80002c94:	b2478513          	addi	a0,a5,-1244 # 80008b24 <__data_source_start+0xfffffcd0>
80002c98:	92ffe0ef          	jal	ra,800015c6 <printf>
          }
          g_btn_last_ms[i] = now;
80002c9c:	fef44783          	lbu	a5,-17(s0)
80002ca0:	e5418713          	addi	a4,gp,-428 # 400005d4 <g_btn_last_ms>
80002ca4:	078a                	slli	a5,a5,0x2
80002ca6:	97ba                	add	a5,a5,a4
80002ca8:	fe842703          	lw	a4,-24(s0)
80002cac:	c398                	sw	a4,0(a5)
          g_btn_last_state[i] = btn_current;
80002cae:	fef44703          	lbu	a4,-17(s0)
80002cb2:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80002cb6:	97ba                	add	a5,a5,a4
80002cb8:	fe744703          	lbu	a4,-25(s0)
80002cbc:	00e78023          	sb	a4,0(a5)
        if ((now - g_btn_last_ms[i]) >= g_debounce_ms) {
80002cc0:	a085                	j	80002d20 <gpio_irq_handler+0x1fe>
        }
      } else if (g_btn_last_state[i] == 0 && btn_current == 1) {
80002cc2:	fef44703          	lbu	a4,-17(s0)
80002cc6:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80002cca:	97ba                	add	a5,a5,a4
80002ccc:	0007c783          	lbu	a5,0(a5)
80002cd0:	0ff7f793          	zext.b	a5,a5
80002cd4:	e7b1                	bnez	a5,80002d20 <gpio_irq_handler+0x1fe>
80002cd6:	fe744703          	lbu	a4,-25(s0)
80002cda:	4785                	li	a5,1
80002cdc:	04f71263          	bne	a4,a5,80002d20 <gpio_irq_handler+0x1fe>
        // Кнопка отпущена (переход из 0 в 1)
        if ((now - g_btn_last_ms[i]) >= g_debounce_ms) {
80002ce0:	fef44783          	lbu	a5,-17(s0)
80002ce4:	e5418713          	addi	a4,gp,-428 # 400005d4 <g_btn_last_ms>
80002ce8:	078a                	slli	a5,a5,0x2
80002cea:	97ba                	add	a5,a5,a4
80002cec:	439c                	lw	a5,0(a5)
80002cee:	fe842703          	lw	a4,-24(s0)
80002cf2:	8f1d                	sub	a4,a4,a5
80002cf4:	03200793          	li	a5,50
80002cf8:	02f76463          	bltu	a4,a5,80002d20 <gpio_irq_handler+0x1fe>
          g_btn_last_state[i] = btn_current;
80002cfc:	fef44703          	lbu	a4,-17(s0)
80002d00:	88018793          	addi	a5,gp,-1920 # 40000000 <g_btn_last_state>
80002d04:	97ba                	add	a5,a5,a4
80002d06:	fe744703          	lbu	a4,-25(s0)
80002d0a:	00e78023          	sb	a4,0(a5)
          g_btn_last_ms[i] = now;
80002d0e:	fef44783          	lbu	a5,-17(s0)
80002d12:	e5418713          	addi	a4,gp,-428 # 400005d4 <g_btn_last_ms>
80002d16:	078a                	slli	a5,a5,0x2
80002d18:	97ba                	add	a5,a5,a4
80002d1a:	fe842703          	lw	a4,-24(s0)
80002d1e:	c398                	sw	a4,0(a5)
        }
      }
      
      GPIO_ITStatusClear(GPIOA, btn_pins[i]);
80002d20:	fef44783          	lbu	a5,-17(s0)
80002d24:	078a                	slli	a5,a5,0x2
80002d26:	17c1                	addi	a5,a5,-16
80002d28:	97a2                	add	a5,a5,s0
80002d2a:	fe47a783          	lw	a5,-28(a5)
80002d2e:	85be                	mv	a1,a5
80002d30:	28000537          	lui	a0,0x28000
80002d34:	3461                	jal	800027bc <GPIO_ITStatusClear>
  for (uint8_t i = 0; i < 4; i++) {
80002d36:	fef44783          	lbu	a5,-17(s0)
80002d3a:	0785                	addi	a5,a5,1
80002d3c:	fef407a3          	sb	a5,-17(s0)
80002d40:	fef44703          	lbu	a4,-17(s0)
80002d44:	478d                	li	a5,3
80002d46:	e2e7f9e3          	bgeu	a5,a4,80002b78 <gpio_irq_handler+0x56>
    }
  }
}
80002d4a:	0001                	nop
80002d4c:	0001                	nop
80002d4e:	50f2                	lw	ra,60(sp)
80002d50:	5462                	lw	s0,56(sp)
80002d52:	6121                	addi	sp,sp,64
80002d54:	8082                	ret

80002d56 <tmr32_init>:

static void tmr32_init(void) 
{
80002d56:	1101                	addi	sp,sp,-32
80002d58:	ce06                	sw	ra,28(sp)
80002d5a:	cc22                	sw	s0,24(sp)
80002d5c:	1000                	addi	s0,sp,32
  // Тактирование TMR32
  RCU->CGCFGAPB_bit.TMR32EN = 1;
80002d5e:	3000e7b7          	lui	a5,0x3000e
80002d62:	4798                	lw	a4,8(a5)
80002d64:	00176713          	ori	a4,a4,1
80002d68:	c798                	sw	a4,8(a5)
  RCU->RSTDISAPB_bit.TMR32EN = 1;
80002d6a:	3000e7b7          	lui	a5,0x3000e
80002d6e:	4f98                	lw	a4,24(a5)
80002d70:	00176713          	ori	a4,a4,1
80002d74:	cf98                	sw	a4,24(a5)

  // Настройка таймера: SYSCLK / 8, режим Up до CAPCOM0, период ~1 мс
  TMR32_SetClksel(TMR32_Clksel_SysClk);
80002d76:	4501                	li	a0,0
80002d78:	38f1                	jal	80002654 <TMR32_SetClksel>
  TMR32_SetDivider(TMR32_Div_8);
80002d7a:	450d                	li	a0,3
80002d7c:	3075                	jal	80002628 <TMR32_SetDivider>
  TMR32_SetMode(TMR32_Mode_Capcom_Up);
80002d7e:	4505                	li	a0,1
80002d80:	38b5                	jal	800025fc <TMR32_SetMode>
  uint32_t cmp = (SystemCoreClock / 8u) / 1000u; // 1 мс
80002d82:	e181a703          	lw	a4,-488(gp) # 40000598 <SystemCoreClock>
80002d86:	6789                	lui	a5,0x2
80002d88:	f4078793          	addi	a5,a5,-192 # 1f40 <STACK_SIZE+0x1740>
80002d8c:	02f757b3          	divu	a5,a4,a5
80002d90:	fef42623          	sw	a5,-20(s0)
  if (cmp == 0) cmp = 1;
80002d94:	fec42783          	lw	a5,-20(s0)
80002d98:	e781                	bnez	a5,80002da0 <tmr32_init+0x4a>
80002d9a:	4785                	li	a5,1
80002d9c:	fef42623          	sw	a5,-20(s0)
  TMR32_CAPCOM_SetComparator(TMR32_CAPCOM_0, cmp);
80002da0:	fec42583          	lw	a1,-20(s0)
80002da4:	4501                	li	a0,0
80002da6:	3a99                	jal	800026fc <TMR32_CAPCOM_SetComparator>
  TMR32_SetCounter(0);
80002da8:	4501                	li	a0,0
80002daa:	38d9                	jal	80002680 <TMR32_SetCounter>

  // Прерывание по переполнению таймера (обновление)
  TMR32_ITCmd(TMR32_IT_TimerUpdate, ENABLE);
80002dac:	4585                	li	a1,1
80002dae:	4505                	li	a0,1
80002db0:	30f5                	jal	8000269c <TMR32_ITCmd>

  // Регистрация обработчика в PLIC
  PLIC_SetPriority(PLIC_TMR32_VECTNUM, 1);
80002db2:	4585                	li	a1,1
80002db4:	4519                	li	a0,6
80002db6:	d07fd0ef          	jal	ra,80000abc <PLIC_SetPriority>
  PLIC_SetIrqHandler(Plic_Mach_Target, PLIC_TMR32_VECTNUM, tmr32_irq_handler);
80002dba:	800037b7          	lui	a5,0x80003
80002dbe:	ddc78613          	addi	a2,a5,-548 # 80002ddc <__data_source_start+0xffff9f88>
80002dc2:	4599                	li	a1,6
80002dc4:	4501                	li	a0,0
80002dc6:	cabfd0ef          	jal	ra,80000a70 <PLIC_SetIrqHandler>
  PLIC_IntEnable(Plic_Mach_Target, PLIC_TMR32_VECTNUM);
80002dca:	4599                	li	a1,6
80002dcc:	4501                	li	a0,0
80002dce:	d19fd0ef          	jal	ra,80000ae6 <PLIC_IntEnable>
}
80002dd2:	0001                	nop
80002dd4:	40f2                	lw	ra,28(sp)
80002dd6:	4462                	lw	s0,24(sp)
80002dd8:	6105                	addi	sp,sp,32
80002dda:	8082                	ret

80002ddc <tmr32_irq_handler>:

static void tmr32_irq_handler(void)
{
80002ddc:	1141                	addi	sp,sp,-16
80002dde:	c606                	sw	ra,12(sp)
80002de0:	c422                	sw	s0,8(sp)
80002de2:	0800                	addi	s0,sp,16
  // Инкремент тиков, сброс флага
  ms_ticks++;
80002de4:	e281a783          	lw	a5,-472(gp) # 400005a8 <ms_ticks>
80002de8:	00178713          	addi	a4,a5,1
80002dec:	e2e1a423          	sw	a4,-472(gp) # 400005a8 <ms_ticks>
  // 1 мс тик для OSDP (временное управление LED)
  osdp_tick_1ms();
80002df0:	100010ef          	jal	ra,80003ef0 <osdp_tick_1ms>
  TMR32_ITClear(TMR32_IT_TimerUpdate);
80002df4:	4505                	li	a0,1
80002df6:	30cd                	jal	800026d8 <TMR32_ITClear>
}
80002df8:	0001                	nop
80002dfa:	40b2                	lw	ra,12(sp)
80002dfc:	4422                	lw	s0,8(sp)
80002dfe:	0141                	addi	sp,sp,16
80002e00:	8082                	ret

80002e02 <main>:



//-- Main ----------------------------------------------------------------------
int main(void)
{
80002e02:	1101                	addi	sp,sp,-32
80002e04:	ce06                	sw	ra,28(sp)
80002e06:	cc22                	sw	s0,24(sp)
80002e08:	1000                	addi	s0,sp,32
  periph_init();
80002e0a:	3611                	jal	8000290e <periph_init>
  
  while(1)
  {
    adcsar_sample_t sample;
    if (adcsar_poll(&sample)) {
80002e0c:	fe440793          	addi	a5,s0,-28
80002e10:	853e                	mv	a0,a5
80002e12:	971fd0ef          	jal	ra,80000782 <adcsar_poll>
80002e16:	87aa                	mv	a5,a0
80002e18:	c7ad                	beqz	a5,80002e82 <main+0x80>
      if (sample.state_char != g_adc_last_state) {
80002e1a:	fec44703          	lbu	a4,-20(s0)
80002e1e:	8841c783          	lbu	a5,-1916(gp) # 40000004 <g_adc_last_state>
80002e22:	04f70863          	beq	a4,a5,80002e72 <main+0x70>
        if (g_adc_candidate_state != sample.state_char) {
80002e26:	fec44703          	lbu	a4,-20(s0)
80002e2a:	8851c783          	lbu	a5,-1915(gp) # 40000005 <g_adc_candidate_state>
80002e2e:	00f70b63          	beq	a4,a5,80002e44 <main+0x42>
          g_adc_candidate_state = sample.state_char;
80002e32:	fec44703          	lbu	a4,-20(s0)
80002e36:	88e182a3          	sb	a4,-1915(gp) # 40000005 <g_adc_candidate_state>
          g_adc_candidate_ms = ms_ticks;
80002e3a:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80002e3e:	e6e1a223          	sw	a4,-412(gp) # 400005e4 <g_adc_candidate_ms>
80002e42:	a081                	j	80002e82 <main+0x80>
        } else if ((ms_ticks - g_adc_candidate_ms) >= g_adc_state_confirm_ms) {
80002e44:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80002e48:	e641a783          	lw	a5,-412(gp) # 400005e4 <g_adc_candidate_ms>
80002e4c:	8f1d                	sub	a4,a4,a5
80002e4e:	03200793          	li	a5,50
80002e52:	02f76863          	bltu	a4,a5,80002e82 <main+0x80>
          printf("ADC state: %c\r\n", sample.state_char);
80002e56:	fec44783          	lbu	a5,-20(s0)
80002e5a:	85be                	mv	a1,a5
80002e5c:	800097b7          	lui	a5,0x80009
80002e60:	b5878513          	addi	a0,a5,-1192 # 80008b58 <__data_source_start+0xfffffd04>
80002e64:	f62fe0ef          	jal	ra,800015c6 <printf>
          g_adc_last_state = sample.state_char;
80002e68:	fec44703          	lbu	a4,-20(s0)
80002e6c:	88e18223          	sb	a4,-1916(gp) # 40000004 <g_adc_last_state>
80002e70:	a809                	j	80002e82 <main+0x80>
        }
      } else {
        g_adc_candidate_state = sample.state_char;
80002e72:	fec44703          	lbu	a4,-20(s0)
80002e76:	88e182a3          	sb	a4,-1915(gp) # 40000005 <g_adc_candidate_state>
        g_adc_candidate_ms = ms_ticks;
80002e7a:	e281a703          	lw	a4,-472(gp) # 400005a8 <ms_ticks>
80002e7e:	e6e1a223          	sw	a4,-412(gp) # 400005e4 <g_adc_candidate_ms>
      }
    }
    __asm volatile("wfi");
80002e82:	10500073          	wfi
  {
80002e86:	b759                	j	80002e0c <main+0xa>

80002e88 <ccitt_crc16_update>:
0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};

uint16_t ccitt_crc16_update(uint16_t crc, uint8_t byte)
{
80002e88:	1101                	addi	sp,sp,-32
80002e8a:	ce22                	sw	s0,28(sp)
80002e8c:	1000                	addi	s0,sp,32
80002e8e:	87aa                	mv	a5,a0
80002e90:	872e                	mv	a4,a1
80002e92:	fef41723          	sh	a5,-18(s0)
80002e96:	87ba                	mv	a5,a4
80002e98:	fef406a3          	sb	a5,-19(s0)
	crc = (crc << 8) ^ crc_table[((crc >> 8) ^ byte) & 0x00FF];
80002e9c:	fee45783          	lhu	a5,-18(s0)
80002ea0:	07a2                	slli	a5,a5,0x8
80002ea2:	01079713          	slli	a4,a5,0x10
80002ea6:	8741                	srai	a4,a4,0x10
80002ea8:	fee45783          	lhu	a5,-18(s0)
80002eac:	83a1                	srli	a5,a5,0x8
80002eae:	07c2                	slli	a5,a5,0x10
80002eb0:	83c1                	srli	a5,a5,0x10
80002eb2:	86be                	mv	a3,a5
80002eb4:	fed44783          	lbu	a5,-19(s0)
80002eb8:	8fb5                	xor	a5,a5,a3
80002eba:	0ff7f793          	zext.b	a5,a5
80002ebe:	800096b7          	lui	a3,0x80009
80002ec2:	b7468693          	addi	a3,a3,-1164 # 80008b74 <__data_source_start+0xfffffd20>
80002ec6:	0786                	slli	a5,a5,0x1
80002ec8:	97b6                	add	a5,a5,a3
80002eca:	0007d783          	lhu	a5,0(a5)
80002ece:	07c2                	slli	a5,a5,0x10
80002ed0:	87c1                	srai	a5,a5,0x10
80002ed2:	8fb9                	xor	a5,a5,a4
80002ed4:	07c2                	slli	a5,a5,0x10
80002ed6:	87c1                	srai	a5,a5,0x10
80002ed8:	fef41723          	sh	a5,-18(s0)
	return crc;
80002edc:	fee45783          	lhu	a5,-18(s0)
}
80002ee0:	853e                	mv	a0,a5
80002ee2:	4472                	lw	s0,28(sp)
80002ee4:	6105                	addi	sp,sp,32
80002ee6:	8082                	ret

80002ee8 <ccitt_crc16_calc>:

uint16_t ccitt_crc16_calc(uint16_t initcrc, const uint8_t *data, uint16_t len)
{
80002ee8:	7179                	addi	sp,sp,-48
80002eea:	d622                	sw	s0,44(sp)
80002eec:	1800                	addi	s0,sp,48
80002eee:	87aa                	mv	a5,a0
80002ef0:	fcb42c23          	sw	a1,-40(s0)
80002ef4:	8732                	mv	a4,a2
80002ef6:	fcf41f23          	sh	a5,-34(s0)
80002efa:	87ba                	mv	a5,a4
80002efc:	fcf41e23          	sh	a5,-36(s0)
	uint16_t crc = initcrc;
80002f00:	fde45783          	lhu	a5,-34(s0)
80002f04:	fef41723          	sh	a5,-18(s0)
	for (uint16_t i = 0; i < len; i++) {
80002f08:	fe041623          	sh	zero,-20(s0)
80002f0c:	a899                	j	80002f62 <ccitt_crc16_calc+0x7a>
		crc = (crc << 8) ^ crc_table[((crc >> 8) ^ data[i]) & 0x00FF];
80002f0e:	fee45783          	lhu	a5,-18(s0)
80002f12:	07a2                	slli	a5,a5,0x8
80002f14:	01079713          	slli	a4,a5,0x10
80002f18:	8741                	srai	a4,a4,0x10
80002f1a:	fee45783          	lhu	a5,-18(s0)
80002f1e:	83a1                	srli	a5,a5,0x8
80002f20:	07c2                	slli	a5,a5,0x10
80002f22:	83c1                	srli	a5,a5,0x10
80002f24:	863e                	mv	a2,a5
80002f26:	fec45783          	lhu	a5,-20(s0)
80002f2a:	fd842683          	lw	a3,-40(s0)
80002f2e:	97b6                	add	a5,a5,a3
80002f30:	0007c783          	lbu	a5,0(a5)
80002f34:	8fb1                	xor	a5,a5,a2
80002f36:	0ff7f793          	zext.b	a5,a5
80002f3a:	800096b7          	lui	a3,0x80009
80002f3e:	b7468693          	addi	a3,a3,-1164 # 80008b74 <__data_source_start+0xfffffd20>
80002f42:	0786                	slli	a5,a5,0x1
80002f44:	97b6                	add	a5,a5,a3
80002f46:	0007d783          	lhu	a5,0(a5)
80002f4a:	07c2                	slli	a5,a5,0x10
80002f4c:	87c1                	srai	a5,a5,0x10
80002f4e:	8fb9                	xor	a5,a5,a4
80002f50:	07c2                	slli	a5,a5,0x10
80002f52:	87c1                	srai	a5,a5,0x10
80002f54:	fef41723          	sh	a5,-18(s0)
	for (uint16_t i = 0; i < len; i++) {
80002f58:	fec45783          	lhu	a5,-20(s0)
80002f5c:	0785                	addi	a5,a5,1
80002f5e:	fef41623          	sh	a5,-20(s0)
80002f62:	fec45703          	lhu	a4,-20(s0)
80002f66:	fdc45783          	lhu	a5,-36(s0)
80002f6a:	faf762e3          	bltu	a4,a5,80002f0e <ccitt_crc16_calc+0x26>
	}
	return crc;
80002f6e:	fee45783          	lhu	a5,-18(s0)
}
80002f72:	853e                	mv	a0,a5
80002f74:	5432                	lw	s0,44(sp)
80002f76:	6145                	addi	sp,sp,48
80002f78:	8082                	ret

80002f7a <osdp_crc_is_ok>:

int osdp_crc_is_ok(const uint8_t *data, uint16_t len)
{
80002f7a:	7179                	addi	sp,sp,-48
80002f7c:	d606                	sw	ra,44(sp)
80002f7e:	d422                	sw	s0,40(sp)
80002f80:	1800                	addi	s0,sp,48
80002f82:	fca42e23          	sw	a0,-36(s0)
80002f86:	87ae                	mv	a5,a1
80002f88:	fcf41d23          	sh	a5,-38(s0)
	if (len < 2) return 0;
80002f8c:	fda45703          	lhu	a4,-38(s0)
80002f90:	4785                	li	a5,1
80002f92:	00e7e463          	bltu	a5,a4,80002f9a <osdp_crc_is_ok+0x20>
80002f96:	4781                	li	a5,0
80002f98:	a0ad                	j	80003002 <osdp_crc_is_ok+0x88>
	uint16_t src_crc = ((uint16_t)data[len - 1] << 8) | data[len - 2];
80002f9a:	fda45783          	lhu	a5,-38(s0)
80002f9e:	17fd                	addi	a5,a5,-1
80002fa0:	fdc42703          	lw	a4,-36(s0)
80002fa4:	97ba                	add	a5,a5,a4
80002fa6:	0007c783          	lbu	a5,0(a5)
80002faa:	07a2                	slli	a5,a5,0x8
80002fac:	01079713          	slli	a4,a5,0x10
80002fb0:	8741                	srai	a4,a4,0x10
80002fb2:	fda45783          	lhu	a5,-38(s0)
80002fb6:	17f9                	addi	a5,a5,-2
80002fb8:	fdc42683          	lw	a3,-36(s0)
80002fbc:	97b6                	add	a5,a5,a3
80002fbe:	0007c783          	lbu	a5,0(a5)
80002fc2:	07c2                	slli	a5,a5,0x10
80002fc4:	87c1                	srai	a5,a5,0x10
80002fc6:	8fd9                	or	a5,a5,a4
80002fc8:	07c2                	slli	a5,a5,0x10
80002fca:	87c1                	srai	a5,a5,0x10
80002fcc:	fef41723          	sh	a5,-18(s0)
	uint16_t calc = ccitt_crc16_calc(OSDP_INIT_CRC16, data, (uint16_t)(len - 2));
80002fd0:	fda45783          	lhu	a5,-38(s0)
80002fd4:	17f9                	addi	a5,a5,-2
80002fd6:	07c2                	slli	a5,a5,0x10
80002fd8:	83c1                	srli	a5,a5,0x10
80002fda:	863e                	mv	a2,a5
80002fdc:	fdc42583          	lw	a1,-36(s0)
80002fe0:	6789                	lui	a5,0x2
80002fe2:	d0f78513          	addi	a0,a5,-753 # 1d0f <STACK_SIZE+0x150f>
80002fe6:	3709                	jal	80002ee8 <ccitt_crc16_calc>
80002fe8:	87aa                	mv	a5,a0
80002fea:	fef41623          	sh	a5,-20(s0)
	return (src_crc == calc) ? 1 : 0;
80002fee:	fee45703          	lhu	a4,-18(s0)
80002ff2:	fec45783          	lhu	a5,-20(s0)
80002ff6:	40f707b3          	sub	a5,a4,a5
80002ffa:	0017b793          	seqz	a5,a5
80002ffe:	0ff7f793          	zext.b	a5,a5
}
80003002:	853e                	mv	a0,a5
80003004:	50b2                	lw	ra,44(sp)
80003006:	5422                	lw	s0,40(sp)
80003008:	6145                	addi	sp,sp,48
8000300a:	8082                	ret

8000300c <GPIO_ReadBit>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  State  Состояние Если выбрано несколько пинов, то результат соответсвует логическому ИЛИ их состояний.
  */
__STATIC_INLINE BitState GPIO_ReadBit(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
8000300c:	1101                	addi	sp,sp,-32
8000300e:	ce22                	sw	s0,28(sp)
80003010:	1000                	addi	s0,sp,32
80003012:	fea42623          	sw	a0,-20(s0)
80003016:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GET_GPIO_PIN(Pin));

    return (BitState)READ_BIT(GPIOx->DATA, (uint32_t)Pin);
8000301a:	fec42783          	lw	a5,-20(s0)
8000301e:	4398                	lw	a4,0(a5)
80003020:	fe842783          	lw	a5,-24(s0)
80003024:	8ff9                	and	a5,a5,a4
80003026:	c399                	beqz	a5,8000302c <GPIO_ReadBit+0x20>
80003028:	4785                	li	a5,1
8000302a:	a011                	j	8000302e <GPIO_ReadBit+0x22>
8000302c:	4781                	li	a5,0
}
8000302e:	853e                	mv	a0,a5
80003030:	4472                	lw	s0,28(sp)
80003032:	6105                	addi	sp,sp,32
80003034:	8082                	ret

80003036 <GPIO_SetBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003036:	1101                	addi	sp,sp,-32
80003038:	ce22                	sw	s0,28(sp)
8000303a:	1000                	addi	s0,sp,32
8000303c:	fea42623          	sw	a0,-20(s0)
80003040:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTSET, Pin);
80003044:	fec42783          	lw	a5,-20(s0)
80003048:	fe842703          	lw	a4,-24(s0)
8000304c:	c798                	sw	a4,8(a5)
}
8000304e:	0001                	nop
80003050:	4472                	lw	s0,28(sp)
80003052:	6105                	addi	sp,sp,32
80003054:	8082                	ret

80003056 <GPIO_ClearBits>:
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @param   Pin  Выбор пина
  * @retval  void
  */
__STATIC_INLINE void GPIO_ClearBits(GPIO_TypeDef* GPIOx, uint32_t Pin)
{
80003056:	1101                	addi	sp,sp,-32
80003058:	ce22                	sw	s0,28(sp)
8000305a:	1000                	addi	s0,sp,32
8000305c:	fea42623          	sw	a0,-20(s0)
80003060:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));

    WRITE_REG(GPIOx->DATAOUTCLR, Pin);
80003064:	fec42783          	lw	a5,-20(s0)
80003068:	fe842703          	lw	a4,-24(s0)
8000306c:	c7d8                	sw	a4,12(a5)
}
8000306e:	0001                	nop
80003070:	4472                	lw	s0,28(sp)
80003072:	6105                	addi	sp,sp,32
80003074:	8082                	ret

80003076 <osdp_load_addr_baud>:
// Текущий адрес в RAM
static uint8_t g_addr;
static uint32_t g_baud;

static void osdp_load_addr_baud(void)
{
80003076:	7179                	addi	sp,sp,-48
80003078:	d606                	sw	ra,44(sp)
8000307a:	d422                	sw	s0,40(sp)
8000307c:	1800                	addi	s0,sp,48
	// Всегда задаём значения по умолчанию — иначе при неудачной загрузке
	// из EEPROM g_addr и g_baud остаются 0 и устройство не отвечает на POLL
	g_addr = 0x01;
8000307e:	4705                	li	a4,1
80003080:	e8e18023          	sb	a4,-384(gp) # 40000600 <g_addr>
	g_baud = 115200;
80003084:	6771                	lui	a4,0x1c
80003086:	20070713          	addi	a4,a4,512 # 1c200 <STACK_SIZE+0x1ba00>
8000308a:	e8e1a223          	sw	a4,-380(gp) # 40000604 <g_baud>

	config_storage_t cfg;
	if (config_storage_load(&cfg)) {
8000308e:	fd840793          	addi	a5,s0,-40
80003092:	853e                	mv	a0,a5
80003094:	80dfd0ef          	jal	ra,800008a0 <config_storage_load>
80003098:	87aa                	mv	a5,a0
8000309a:	cbad                	beqz	a5,8000310c <osdp_load_addr_baud+0x96>
		if (cfg.osdp_addr > 0 && cfg.osdp_addr <= 0x7F) {
8000309c:	fd844783          	lbu	a5,-40(s0)
800030a0:	cb99                	beqz	a5,800030b6 <osdp_load_addr_baud+0x40>
800030a2:	fd844783          	lbu	a5,-40(s0)
800030a6:	07e2                	slli	a5,a5,0x18
800030a8:	87e1                	srai	a5,a5,0x18
800030aa:	0007c663          	bltz	a5,800030b6 <osdp_load_addr_baud+0x40>
			g_addr = cfg.osdp_addr;
800030ae:	fd844703          	lbu	a4,-40(s0)
800030b2:	e8e18023          	sb	a4,-384(gp) # 40000600 <g_addr>
		}
		if (cfg.osdp_baud >= 9600 && cfg.osdp_baud <= 1000000) {
800030b6:	fd842783          	lw	a5,-40(s0)
800030ba:	83a1                	srli	a5,a5,0x8
800030bc:	fdc42703          	lw	a4,-36(s0)
800030c0:	0ff77713          	zext.b	a4,a4
800030c4:	0762                	slli	a4,a4,0x18
800030c6:	8fd9                	or	a5,a5,a4
800030c8:	873e                	mv	a4,a5
800030ca:	6789                	lui	a5,0x2
800030cc:	57f78793          	addi	a5,a5,1407 # 257f <STACK_SIZE+0x1d7f>
800030d0:	02e7fe63          	bgeu	a5,a4,8000310c <osdp_load_addr_baud+0x96>
800030d4:	fd842783          	lw	a5,-40(s0)
800030d8:	83a1                	srli	a5,a5,0x8
800030da:	fdc42703          	lw	a4,-36(s0)
800030de:	0ff77713          	zext.b	a4,a4
800030e2:	0762                	slli	a4,a4,0x18
800030e4:	8fd9                	or	a5,a5,a4
800030e6:	873e                	mv	a4,a5
800030e8:	000f47b7          	lui	a5,0xf4
800030ec:	24078793          	addi	a5,a5,576 # f4240 <STACK_SIZE+0xf3a40>
800030f0:	00e7ee63          	bltu	a5,a4,8000310c <osdp_load_addr_baud+0x96>
			g_baud = cfg.osdp_baud;
800030f4:	fd842783          	lw	a5,-40(s0)
800030f8:	83a1                	srli	a5,a5,0x8
800030fa:	fdc42703          	lw	a4,-36(s0)
800030fe:	0ff77713          	zext.b	a4,a4
80003102:	0762                	slli	a4,a4,0x18
80003104:	8fd9                	or	a5,a5,a4
80003106:	873e                	mv	a4,a5
80003108:	e8e1a223          	sw	a4,-380(gp) # 40000604 <g_baud>
		}
	}
	// ВАЖНО: здесь baud только сохраняем в RAM / cfg.
	// Реальную смену скорости UART делаем ТОЛЬКО по команде osdp_COMSET,
	// чтобы не ломать консольный вывод при старте.
}
8000310c:	0001                	nop
8000310e:	50b2                	lw	ra,44(sp)
80003110:	5422                	lw	s0,40(sp)
80003112:	6145                	addi	sp,sp,48
80003114:	8082                	ret

80003116 <osdp_send_blocking>:
static uint16_t   rx_expected_len = 0;
static uint16_t   rx_pos = 0;
static uint8_t    rx_buf[64];

static void osdp_send_blocking(const uint8_t *data, uint16_t len)
{
80003116:	7179                	addi	sp,sp,-48
80003118:	d622                	sw	s0,44(sp)
8000311a:	1800                	addi	s0,sp,48
8000311c:	fca42e23          	sw	a0,-36(s0)
80003120:	87ae                	mv	a5,a1
80003122:	fcf41d23          	sh	a5,-38(s0)
	for (uint16_t i = 0; i < len; i++) {
80003126:	fe041723          	sh	zero,-18(s0)
8000312a:	a815                	j	8000315e <osdp_send_blocking+0x48>
		while (RETARGET_UART->FR_bit.TXFF) { }
8000312c:	0001                	nop
8000312e:	3000a7b7          	lui	a5,0x3000a
80003132:	4f9c                	lw	a5,24(a5)
80003134:	8395                	srli	a5,a5,0x5
80003136:	8b85                	andi	a5,a5,1
80003138:	0ff7f793          	zext.b	a5,a5
8000313c:	fbed                	bnez	a5,8000312e <osdp_send_blocking+0x18>
		RETARGET_UART->DR_bit.DATA = data[i];
8000313e:	fee45783          	lhu	a5,-18(s0)
80003142:	fdc42703          	lw	a4,-36(s0)
80003146:	973e                	add	a4,a4,a5
80003148:	3000a7b7          	lui	a5,0x3000a
8000314c:	00074703          	lbu	a4,0(a4)
80003150:	00e78023          	sb	a4,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
	for (uint16_t i = 0; i < len; i++) {
80003154:	fee45783          	lhu	a5,-18(s0)
80003158:	0785                	addi	a5,a5,1
8000315a:	fef41723          	sh	a5,-18(s0)
8000315e:	fee45703          	lhu	a4,-18(s0)
80003162:	fda45783          	lhu	a5,-38(s0)
80003166:	fcf763e3          	bltu	a4,a5,8000312c <osdp_send_blocking+0x16>
	}
	while (!RETARGET_UART->FR_bit.TXFE) { }
8000316a:	0001                	nop
8000316c:	3000a7b7          	lui	a5,0x3000a
80003170:	4f9c                	lw	a5,24(a5)
80003172:	839d                	srli	a5,a5,0x7
80003174:	8b85                	andi	a5,a5,1
80003176:	0ff7f793          	zext.b	a5,a5
8000317a:	dbed                	beqz	a5,8000316c <osdp_send_blocking+0x56>
}
8000317c:	0001                	nop
8000317e:	0001                	nop
80003180:	5432                	lw	s0,44(sp)
80003182:	6145                	addi	sp,sp,48
80003184:	8082                	ret

80003186 <osdp_build_header>:

// Вспомогательная функция для записи заголовка ответа.
static uint16_t osdp_build_header(uint8_t *tx, uint16_t dlen, uint8_t seq)
{
80003186:	7179                	addi	sp,sp,-48
80003188:	d622                	sw	s0,44(sp)
8000318a:	1800                	addi	s0,sp,48
8000318c:	fca42e23          	sw	a0,-36(s0)
80003190:	87ae                	mv	a5,a1
80003192:	8732                	mv	a4,a2
80003194:	fcf41d23          	sh	a5,-38(s0)
80003198:	87ba                	mv	a5,a4
8000319a:	fcf40ca3          	sb	a5,-39(s0)
	uint16_t i = 0;
8000319e:	fe041723          	sh	zero,-18(s0)
	tx[i++] = OSDP_SOM;
800031a2:	fee45783          	lhu	a5,-18(s0)
800031a6:	00178713          	addi	a4,a5,1 # 3000a001 <STACK_SIZE+0x30009801>
800031aa:	fee41723          	sh	a4,-18(s0)
800031ae:	873e                	mv	a4,a5
800031b0:	fdc42783          	lw	a5,-36(s0)
800031b4:	97ba                	add	a5,a5,a4
800031b6:	05300713          	li	a4,83
800031ba:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)(g_addr | 0x80);
800031be:	e801c703          	lbu	a4,-384(gp) # 40000600 <g_addr>
800031c2:	fee45783          	lhu	a5,-18(s0)
800031c6:	00178693          	addi	a3,a5,1
800031ca:	fed41723          	sh	a3,-18(s0)
800031ce:	86be                	mv	a3,a5
800031d0:	fdc42783          	lw	a5,-36(s0)
800031d4:	97b6                	add	a5,a5,a3
800031d6:	f8076713          	ori	a4,a4,-128
800031da:	0ff77713          	zext.b	a4,a4
800031de:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)(dlen & 0xFF);
800031e2:	fee45783          	lhu	a5,-18(s0)
800031e6:	00178713          	addi	a4,a5,1
800031ea:	fee41723          	sh	a4,-18(s0)
800031ee:	873e                	mv	a4,a5
800031f0:	fdc42783          	lw	a5,-36(s0)
800031f4:	97ba                	add	a5,a5,a4
800031f6:	fda45703          	lhu	a4,-38(s0)
800031fa:	0ff77713          	zext.b	a4,a4
800031fe:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)((dlen >> 8) & 0xFF);
80003202:	fda45783          	lhu	a5,-38(s0)
80003206:	83a1                	srli	a5,a5,0x8
80003208:	01079693          	slli	a3,a5,0x10
8000320c:	82c1                	srli	a3,a3,0x10
8000320e:	fee45783          	lhu	a5,-18(s0)
80003212:	00178713          	addi	a4,a5,1
80003216:	fee41723          	sh	a4,-18(s0)
8000321a:	873e                	mv	a4,a5
8000321c:	fdc42783          	lw	a5,-36(s0)
80003220:	97ba                	add	a5,a5,a4
80003222:	0ff6f713          	zext.b	a4,a3
80003226:	00e78023          	sb	a4,0(a5)
	tx[i++] = (uint8_t)((seq & 0x03) | 0x04);
8000322a:	fd940783          	lb	a5,-39(s0)
8000322e:	8b8d                	andi	a5,a5,3
80003230:	07e2                	slli	a5,a5,0x18
80003232:	87e1                	srai	a5,a5,0x18
80003234:	0047e793          	ori	a5,a5,4
80003238:	01879693          	slli	a3,a5,0x18
8000323c:	86e1                	srai	a3,a3,0x18
8000323e:	fee45783          	lhu	a5,-18(s0)
80003242:	00178713          	addi	a4,a5,1
80003246:	fee41723          	sh	a4,-18(s0)
8000324a:	873e                	mv	a4,a5
8000324c:	fdc42783          	lw	a5,-36(s0)
80003250:	97ba                	add	a5,a5,a4
80003252:	0ff6f713          	zext.b	a4,a3
80003256:	00e78023          	sb	a4,0(a5)
	return i;
8000325a:	fee45783          	lhu	a5,-18(s0)
}
8000325e:	853e                	mv	a0,a5
80003260:	5432                	lw	s0,44(sp)
80003262:	6145                	addi	sp,sp,48
80003264:	8082                	ret

80003266 <osdp_build_crc_and_send>:

// Универсальное завершение кадра: добавить CRC и отправить
static void osdp_build_crc_and_send(uint8_t *tx, uint16_t dlen)
{
80003266:	7179                	addi	sp,sp,-48
80003268:	d606                	sw	ra,44(sp)
8000326a:	d422                	sw	s0,40(sp)
8000326c:	1800                	addi	s0,sp,48
8000326e:	fca42e23          	sw	a0,-36(s0)
80003272:	87ae                	mv	a5,a1
80003274:	fcf41d23          	sh	a5,-38(s0)
	uint16_t crc = ccitt_crc16_calc(OSDP_INIT_CRC16, tx, dlen);
80003278:	fda45783          	lhu	a5,-38(s0)
8000327c:	863e                	mv	a2,a5
8000327e:	fdc42583          	lw	a1,-36(s0)
80003282:	6789                	lui	a5,0x2
80003284:	d0f78513          	addi	a0,a5,-753 # 1d0f <STACK_SIZE+0x150f>
80003288:	c61ff0ef          	jal	ra,80002ee8 <ccitt_crc16_calc>
8000328c:	87aa                	mv	a5,a0
8000328e:	fef41723          	sh	a5,-18(s0)
	tx[dlen++] = (uint8_t)(crc & 0xFF);
80003292:	fda45783          	lhu	a5,-38(s0)
80003296:	00178713          	addi	a4,a5,1
8000329a:	fce41d23          	sh	a4,-38(s0)
8000329e:	873e                	mv	a4,a5
800032a0:	fdc42783          	lw	a5,-36(s0)
800032a4:	97ba                	add	a5,a5,a4
800032a6:	fee45703          	lhu	a4,-18(s0)
800032aa:	0ff77713          	zext.b	a4,a4
800032ae:	00e78023          	sb	a4,0(a5)
	tx[dlen++] = (uint8_t)((crc >> 8) & 0xFF);
800032b2:	fee45783          	lhu	a5,-18(s0)
800032b6:	83a1                	srli	a5,a5,0x8
800032b8:	01079693          	slli	a3,a5,0x10
800032bc:	82c1                	srli	a3,a3,0x10
800032be:	fda45783          	lhu	a5,-38(s0)
800032c2:	00178713          	addi	a4,a5,1
800032c6:	fce41d23          	sh	a4,-38(s0)
800032ca:	873e                	mv	a4,a5
800032cc:	fdc42783          	lw	a5,-36(s0)
800032d0:	97ba                	add	a5,a5,a4
800032d2:	0ff6f713          	zext.b	a4,a3
800032d6:	00e78023          	sb	a4,0(a5)
	osdp_send_blocking(tx, dlen);
800032da:	fda45783          	lhu	a5,-38(s0)
800032de:	85be                	mv	a1,a5
800032e0:	fdc42503          	lw	a0,-36(s0)
800032e4:	3d0d                	jal	80003116 <osdp_send_blocking>
}
800032e6:	0001                	nop
800032e8:	50b2                	lw	ra,44(sp)
800032ea:	5422                	lw	s0,40(sp)
800032ec:	6145                	addi	sp,sp,48
800032ee:	8082                	ret

800032f0 <osdp_build_and_send_ack>:

static void osdp_build_and_send_ack(uint8_t seq)
{
800032f0:	7139                	addi	sp,sp,-64
800032f2:	de06                	sw	ra,60(sp)
800032f4:	dc22                	sw	s0,56(sp)
800032f6:	0080                	addi	s0,sp,64
800032f8:	87aa                	mv	a5,a0
800032fa:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t dlen = OSDP_HEADER_LEN; // заголовок(5) + ответ(1) + crc(2)
800032fe:	47a1                	li	a5,8
80003300:	fef41723          	sh	a5,-18(s0)
	uint16_t i = 0;
80003304:	fe041623          	sh	zero,-20(s0)
	// Заголовок
	i = osdp_build_header(tx, dlen, seq);
80003308:	fcf44683          	lbu	a3,-49(s0)
8000330c:	fee45703          	lhu	a4,-18(s0)
80003310:	fdc40793          	addi	a5,s0,-36
80003314:	8636                	mv	a2,a3
80003316:	85ba                	mv	a1,a4
80003318:	853e                	mv	a0,a5
8000331a:	35b5                	jal	80003186 <osdp_build_header>
8000331c:	87aa                	mv	a5,a0
8000331e:	fef41623          	sh	a5,-20(s0)
	// Ответ
	tx[i++] = osdp_ACK;
80003322:	fec45783          	lhu	a5,-20(s0)
80003326:	00178713          	addi	a4,a5,1
8000332a:	fee41623          	sh	a4,-20(s0)
8000332e:	17c1                	addi	a5,a5,-16
80003330:	97a2                	add	a5,a5,s0
80003332:	04000713          	li	a4,64
80003336:	fee78623          	sb	a4,-20(a5)
	// CRC + отправка
	osdp_build_crc_and_send(tx, i);
8000333a:	fec45703          	lhu	a4,-20(s0)
8000333e:	fdc40793          	addi	a5,s0,-36
80003342:	85ba                	mv	a1,a4
80003344:	853e                	mv	a0,a5
80003346:	3705                	jal	80003266 <osdp_build_crc_and_send>
}
80003348:	0001                	nop
8000334a:	50f2                	lw	ra,60(sp)
8000334c:	5462                	lw	s0,56(sp)
8000334e:	6121                	addi	sp,sp,64
80003350:	8082                	ret

80003352 <osdp_build_and_send_nak>:

static void osdp_build_and_send_nak(uint8_t seq, uint8_t reason)
{
80003352:	7139                	addi	sp,sp,-64
80003354:	de06                	sw	ra,60(sp)
80003356:	dc22                	sw	s0,56(sp)
80003358:	0080                	addi	s0,sp,64
8000335a:	87aa                	mv	a5,a0
8000335c:	872e                	mv	a4,a1
8000335e:	fcf407a3          	sb	a5,-49(s0)
80003362:	87ba                	mv	a5,a4
80003364:	fcf40723          	sb	a5,-50(s0)
	uint8_t tx[16];
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1); // +1 байт причины
80003368:	47a5                	li	a5,9
8000336a:	fef41723          	sh	a5,-18(s0)
	uint16_t i = 0;
8000336e:	fe041623          	sh	zero,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80003372:	fcf44683          	lbu	a3,-49(s0)
80003376:	fee45703          	lhu	a4,-18(s0)
8000337a:	fdc40793          	addi	a5,s0,-36
8000337e:	8636                	mv	a2,a3
80003380:	85ba                	mv	a1,a4
80003382:	853e                	mv	a0,a5
80003384:	3509                	jal	80003186 <osdp_build_header>
80003386:	87aa                	mv	a5,a0
80003388:	fef41623          	sh	a5,-20(s0)
	tx[i++] = osdp_NAK;
8000338c:	fec45783          	lhu	a5,-20(s0)
80003390:	00178713          	addi	a4,a5,1
80003394:	fee41623          	sh	a4,-20(s0)
80003398:	17c1                	addi	a5,a5,-16
8000339a:	97a2                	add	a5,a5,s0
8000339c:	04100713          	li	a4,65
800033a0:	fee78623          	sb	a4,-20(a5)
	tx[i++] = reason; // причина NAK
800033a4:	fec45783          	lhu	a5,-20(s0)
800033a8:	00178713          	addi	a4,a5,1
800033ac:	fee41623          	sh	a4,-20(s0)
800033b0:	17c1                	addi	a5,a5,-16
800033b2:	97a2                	add	a5,a5,s0
800033b4:	fce44703          	lbu	a4,-50(s0)
800033b8:	fee78623          	sb	a4,-20(a5)
	osdp_build_crc_and_send(tx, i);
800033bc:	fec45703          	lhu	a4,-20(s0)
800033c0:	fdc40793          	addi	a5,s0,-36
800033c4:	85ba                	mv	a1,a4
800033c6:	853e                	mv	a0,a5
800033c8:	3d79                	jal	80003266 <osdp_build_crc_and_send>
}
800033ca:	0001                	nop
800033cc:	50f2                	lw	ra,60(sp)
800033ce:	5462                	lw	s0,56(sp)
800033d0:	6121                	addi	sp,sp,64
800033d2:	8082                	ret

800033d4 <osdp_build_and_send_pdid>:

static void osdp_build_and_send_pdid(uint8_t seq)
{
800033d4:	7159                	addi	sp,sp,-112
800033d6:	d686                	sw	ra,108(sp)
800033d8:	d4a2                	sw	s0,104(sp)
800033da:	1880                	addi	s0,sp,112
800033dc:	87aa                	mv	a5,a0
800033de:	f8f40fa3          	sb	a5,-97(s0)
	uint8_t tx[64];
	uint16_t i = 0;
800033e2:	fe041723          	sh	zero,-18(s0)
	uint8_t pdid[12] = {
800033e6:	014347b7          	lui	a5,0x1434
800033ea:	24178793          	addi	a5,a5,577 # 1434241 <STACK_SIZE+0x1433a41>
800033ee:	faf42023          	sw	a5,-96(s0)
800033f2:	10100793          	li	a5,257
800033f6:	faf42223          	sw	a5,-92(s0)
800033fa:	010107b7          	lui	a5,0x1010
800033fe:	10078793          	addi	a5,a5,256 # 1010100 <STACK_SIZE+0x100f900>
80003402:	faf42423          	sw	a5,-88(s0)
		1,                       // модель
		1,                       // версия
		0x01,0x00,0x00,0x00,     // серийный
		1,1,1                    
	};
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + sizeof(pdid));
80003406:	47d1                	li	a5,20
80003408:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
8000340c:	f9f44683          	lbu	a3,-97(s0)
80003410:	fec45703          	lhu	a4,-20(s0)
80003414:	fac40793          	addi	a5,s0,-84
80003418:	8636                	mv	a2,a3
8000341a:	85ba                	mv	a1,a4
8000341c:	853e                	mv	a0,a5
8000341e:	33a5                	jal	80003186 <osdp_build_header>
80003420:	87aa                	mv	a5,a0
80003422:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_PDID;
80003426:	fee45783          	lhu	a5,-18(s0)
8000342a:	00178713          	addi	a4,a5,1
8000342e:	fee41723          	sh	a4,-18(s0)
80003432:	17c1                	addi	a5,a5,-16
80003434:	97a2                	add	a5,a5,s0
80003436:	04500713          	li	a4,69
8000343a:	fae78e23          	sb	a4,-68(a5)
	memcpy(&tx[i], pdid, sizeof(pdid));             // копируем данные в буфер начиная с позиции i, т.е. после заголовка и ctrl
8000343e:	fee45783          	lhu	a5,-18(s0)
80003442:	fac40713          	addi	a4,s0,-84
80003446:	97ba                	add	a5,a5,a4
80003448:	fa044703          	lbu	a4,-96(s0)
8000344c:	8fba                	mv	t6,a4
8000344e:	fa144703          	lbu	a4,-95(s0)
80003452:	8f3a                	mv	t5,a4
80003454:	fa244703          	lbu	a4,-94(s0)
80003458:	8eba                	mv	t4,a4
8000345a:	fa344703          	lbu	a4,-93(s0)
8000345e:	8e3a                	mv	t3,a4
80003460:	fa444703          	lbu	a4,-92(s0)
80003464:	833a                	mv	t1,a4
80003466:	fa544703          	lbu	a4,-91(s0)
8000346a:	88ba                	mv	a7,a4
8000346c:	fa644703          	lbu	a4,-90(s0)
80003470:	883a                	mv	a6,a4
80003472:	fa744703          	lbu	a4,-89(s0)
80003476:	853a                	mv	a0,a4
80003478:	fa844703          	lbu	a4,-88(s0)
8000347c:	85ba                	mv	a1,a4
8000347e:	fa944703          	lbu	a4,-87(s0)
80003482:	863a                	mv	a2,a4
80003484:	faa44703          	lbu	a4,-86(s0)
80003488:	86ba                	mv	a3,a4
8000348a:	fab44703          	lbu	a4,-85(s0)
8000348e:	01f78023          	sb	t6,0(a5)
80003492:	01e780a3          	sb	t5,1(a5)
80003496:	01d78123          	sb	t4,2(a5)
8000349a:	01c781a3          	sb	t3,3(a5)
8000349e:	00678223          	sb	t1,4(a5)
800034a2:	011782a3          	sb	a7,5(a5)
800034a6:	01078323          	sb	a6,6(a5)
800034aa:	00a783a3          	sb	a0,7(a5)
800034ae:	00b78423          	sb	a1,8(a5)
800034b2:	00c784a3          	sb	a2,9(a5)
800034b6:	00d78523          	sb	a3,10(a5)
800034ba:	00e785a3          	sb	a4,11(a5)
	i += (uint16_t)sizeof(pdid);
800034be:	fee45783          	lhu	a5,-18(s0)
800034c2:	07b1                	addi	a5,a5,12
800034c4:	fef41723          	sh	a5,-18(s0)
	osdp_build_crc_and_send(tx, i);
800034c8:	fee45703          	lhu	a4,-18(s0)
800034cc:	fac40793          	addi	a5,s0,-84
800034d0:	85ba                	mv	a1,a4
800034d2:	853e                	mv	a0,a5
800034d4:	3b49                	jal	80003266 <osdp_build_crc_and_send>
}
800034d6:	0001                	nop
800034d8:	50b6                	lw	ra,108(sp)
800034da:	5426                	lw	s0,104(sp)
800034dc:	6165                	addi	sp,sp,112
800034de:	8082                	ret

800034e0 <osdp_build_and_send_pdcap>:

static void osdp_build_and_send_pdcap(uint8_t seq)
{
800034e0:	7135                	addi	sp,sp,-160
800034e2:	cf06                	sw	ra,156(sp)
800034e4:	cd22                	sw	s0,152(sp)
800034e6:	1100                	addi	s0,sp,160
800034e8:	87aa                	mv	a5,a0
800034ea:	f6f407a3          	sb	a5,-145(s0)
	uint8_t tx[64];
	uint16_t i = 0;
800034ee:	fe041723          	sh	zero,-18(s0)
	// Включены коды 0x01..0x10; неподдерживаемые помечены CL=0 и Number=0.
	uint8_t caps[] = {
800034f2:	800097b7          	lui	a5,0x80009
800034f6:	d7478793          	addi	a5,a5,-652 # 80008d74 <__data_source_start+0xffffff20>
800034fa:	0007af03          	lw	t5,0(a5)
800034fe:	0047ae83          	lw	t4,4(a5)
80003502:	0087ae03          	lw	t3,8(a5)
80003506:	00c7a303          	lw	t1,12(a5)
8000350a:	0107a883          	lw	a7,16(a5)
8000350e:	0147a803          	lw	a6,20(a5)
80003512:	4f88                	lw	a0,24(a5)
80003514:	4fcc                	lw	a1,28(a5)
80003516:	5390                	lw	a2,32(a5)
80003518:	53d4                	lw	a3,36(a5)
8000351a:	5798                	lw	a4,40(a5)
8000351c:	57dc                	lw	a5,44(a5)
8000351e:	f7e42e23          	sw	t5,-132(s0)
80003522:	f9d42023          	sw	t4,-128(s0)
80003526:	f9c42223          	sw	t3,-124(s0)
8000352a:	f8642423          	sw	t1,-120(s0)
8000352e:	f9142623          	sw	a7,-116(s0)
80003532:	f9042823          	sw	a6,-112(s0)
80003536:	f8a42a23          	sw	a0,-108(s0)
8000353a:	f8b42c23          	sw	a1,-104(s0)
8000353e:	f8c42e23          	sw	a2,-100(s0)
80003542:	fad42023          	sw	a3,-96(s0)
80003546:	fae42223          	sw	a4,-92(s0)
8000354a:	faf42423          	sw	a5,-88(s0)
		0x0D, 0x00, 0x00, // 13 Readers: none
		0x0E, 0x00, 0x00, // 14 Biometrics: none
		0x0F, 0x00, 0x00, // 15 Secure PIN entry: not supported
		0x10, 0x01, 0x00  // 16 OSDP version: IEC 60839-11-5(почему-то не отображается в утилите osdp client)
	};
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + sizeof(caps));
8000354e:	03800793          	li	a5,56
80003552:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80003556:	f6f44683          	lbu	a3,-145(s0)
8000355a:	fec45703          	lhu	a4,-20(s0)
8000355e:	fac40793          	addi	a5,s0,-84
80003562:	8636                	mv	a2,a3
80003564:	85ba                	mv	a1,a4
80003566:	853e                	mv	a0,a5
80003568:	3939                	jal	80003186 <osdp_build_header>
8000356a:	87aa                	mv	a5,a0
8000356c:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_PDCAP;
80003570:	fee45783          	lhu	a5,-18(s0)
80003574:	00178713          	addi	a4,a5,1
80003578:	fee41723          	sh	a4,-18(s0)
8000357c:	17c1                	addi	a5,a5,-16
8000357e:	97a2                	add	a5,a5,s0
80003580:	04600713          	li	a4,70
80003584:	fae78e23          	sb	a4,-68(a5)
	memcpy(&tx[i], caps, sizeof(caps));
80003588:	fee45783          	lhu	a5,-18(s0)
8000358c:	fac40713          	addi	a4,s0,-84
80003590:	97ba                	add	a5,a5,a4
80003592:	86be                	mv	a3,a5
80003594:	f7c40793          	addi	a5,s0,-132
80003598:	03000713          	li	a4,48
8000359c:	863a                	mv	a2,a4
8000359e:	85be                	mv	a1,a5
800035a0:	8536                	mv	a0,a3
800035a2:	422050ef          	jal	ra,800089c4 <memcpy>
	i += (uint16_t)sizeof(caps);
800035a6:	fee45783          	lhu	a5,-18(s0)
800035aa:	03078793          	addi	a5,a5,48
800035ae:	fef41723          	sh	a5,-18(s0)
	osdp_build_crc_and_send(tx, i);
800035b2:	fee45703          	lhu	a4,-18(s0)
800035b6:	fac40793          	addi	a5,s0,-84
800035ba:	85ba                	mv	a1,a4
800035bc:	853e                	mv	a0,a5
800035be:	3165                	jal	80003266 <osdp_build_crc_and_send>
}
800035c0:	0001                	nop
800035c2:	40fa                	lw	ra,156(sp)
800035c4:	446a                	lw	s0,152(sp)
800035c6:	610d                	addi	sp,sp,160
800035c8:	8082                	ret

800035ca <osdp_build_and_send_com>:

static void osdp_build_and_send_com(uint8_t seq, uint8_t new_addr, uint32_t new_baud)
{
800035ca:	715d                	addi	sp,sp,-80
800035cc:	c686                	sw	ra,76(sp)
800035ce:	c4a2                	sw	s0,72(sp)
800035d0:	0880                	addi	s0,sp,80
800035d2:	87aa                	mv	a5,a0
800035d4:	872e                	mv	a4,a1
800035d6:	fac42c23          	sw	a2,-72(s0)
800035da:	faf40fa3          	sb	a5,-65(s0)
800035de:	87ba                	mv	a5,a4
800035e0:	faf40f23          	sb	a5,-66(s0)
	uint8_t tx[16];
	uint16_t i = 0;
800035e4:	fe041723          	sh	zero,-18(s0)
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 5); 
800035e8:	47b5                	li	a5,13
800035ea:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
800035ee:	fbf44683          	lbu	a3,-65(s0)
800035f2:	fec45703          	lhu	a4,-20(s0)
800035f6:	fdc40793          	addi	a5,s0,-36
800035fa:	8636                	mv	a2,a3
800035fc:	85ba                	mv	a1,a4
800035fe:	853e                	mv	a0,a5
80003600:	3659                	jal	80003186 <osdp_build_header>
80003602:	87aa                	mv	a5,a0
80003604:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_COM;
80003608:	fee45783          	lhu	a5,-18(s0)
8000360c:	00178713          	addi	a4,a5,1
80003610:	fee41723          	sh	a4,-18(s0)
80003614:	17c1                	addi	a5,a5,-16
80003616:	97a2                	add	a5,a5,s0
80003618:	06500713          	li	a4,101
8000361c:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)(new_addr & 0x7F);
80003620:	fee45783          	lhu	a5,-18(s0)
80003624:	00178713          	addi	a4,a5,1
80003628:	fee41723          	sh	a4,-18(s0)
8000362c:	fbe44703          	lbu	a4,-66(s0)
80003630:	07f77713          	andi	a4,a4,127
80003634:	0ff77713          	zext.b	a4,a4
80003638:	17c1                	addi	a5,a5,-16
8000363a:	97a2                	add	a5,a5,s0
8000363c:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)(new_baud & 0xFF);
80003640:	fee45783          	lhu	a5,-18(s0)
80003644:	00178713          	addi	a4,a5,1
80003648:	fee41723          	sh	a4,-18(s0)
8000364c:	fb842703          	lw	a4,-72(s0)
80003650:	0ff77713          	zext.b	a4,a4
80003654:	17c1                	addi	a5,a5,-16
80003656:	97a2                	add	a5,a5,s0
80003658:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 8) & 0xFF);
8000365c:	fb842783          	lw	a5,-72(s0)
80003660:	0087d693          	srli	a3,a5,0x8
80003664:	fee45783          	lhu	a5,-18(s0)
80003668:	00178713          	addi	a4,a5,1
8000366c:	fee41723          	sh	a4,-18(s0)
80003670:	0ff6f713          	zext.b	a4,a3
80003674:	17c1                	addi	a5,a5,-16
80003676:	97a2                	add	a5,a5,s0
80003678:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 16) & 0xFF);
8000367c:	fb842783          	lw	a5,-72(s0)
80003680:	0107d693          	srli	a3,a5,0x10
80003684:	fee45783          	lhu	a5,-18(s0)
80003688:	00178713          	addi	a4,a5,1
8000368c:	fee41723          	sh	a4,-18(s0)
80003690:	0ff6f713          	zext.b	a4,a3
80003694:	17c1                	addi	a5,a5,-16
80003696:	97a2                	add	a5,a5,s0
80003698:	fee78623          	sb	a4,-20(a5)
	tx[i++] = (uint8_t)((new_baud >> 24) & 0xFF);
8000369c:	fb842783          	lw	a5,-72(s0)
800036a0:	0187d693          	srli	a3,a5,0x18
800036a4:	fee45783          	lhu	a5,-18(s0)
800036a8:	00178713          	addi	a4,a5,1
800036ac:	fee41723          	sh	a4,-18(s0)
800036b0:	0ff6f713          	zext.b	a4,a3
800036b4:	17c1                	addi	a5,a5,-16
800036b6:	97a2                	add	a5,a5,s0
800036b8:	fee78623          	sb	a4,-20(a5)
	osdp_build_crc_and_send(tx, i);
800036bc:	fee45703          	lhu	a4,-18(s0)
800036c0:	fdc40793          	addi	a5,s0,-36
800036c4:	85ba                	mv	a1,a4
800036c6:	853e                	mv	a0,a5
800036c8:	3e79                	jal	80003266 <osdp_build_crc_and_send>

	// Сохранить новые адрес и скорость в EEPROM
	config_storage_t cfg;
	if (!config_storage_load(&cfg)) {
800036ca:	fc440793          	addi	a5,s0,-60
800036ce:	853e                	mv	a0,a5
800036d0:	9d0fd0ef          	jal	ra,800008a0 <config_storage_load>
800036d4:	87aa                	mv	a5,a0
800036d6:	0017c793          	xori	a5,a5,1
800036da:	0ff7f793          	zext.b	a5,a5
800036de:	c791                	beqz	a5,800036ea <osdp_build_and_send_com+0x120>
		config_storage_default(&cfg);
800036e0:	fc440793          	addi	a5,s0,-60
800036e4:	853e                	mv	a0,a5
800036e6:	952fd0ef          	jal	ra,80000838 <config_storage_default>
	}
	cfg.osdp_addr = (uint8_t)(new_addr & 0x7F);
800036ea:	fbe44783          	lbu	a5,-66(s0)
800036ee:	07f7f793          	andi	a5,a5,127
800036f2:	0ff7f793          	zext.b	a5,a5
800036f6:	fcf40223          	sb	a5,-60(s0)
	cfg.osdp_baud = new_baud;
800036fa:	fb842783          	lw	a5,-72(s0)
800036fe:	0ff7f793          	zext.b	a5,a5
80003702:	fc544703          	lbu	a4,-59(s0)
80003706:	8b01                	andi	a4,a4,0
80003708:	8fd9                	or	a5,a5,a4
8000370a:	fcf402a3          	sb	a5,-59(s0)
8000370e:	fb842783          	lw	a5,-72(s0)
80003712:	83a1                	srli	a5,a5,0x8
80003714:	0ff7f793          	zext.b	a5,a5
80003718:	fc644703          	lbu	a4,-58(s0)
8000371c:	8b01                	andi	a4,a4,0
8000371e:	8fd9                	or	a5,a5,a4
80003720:	fcf40323          	sb	a5,-58(s0)
80003724:	fb842783          	lw	a5,-72(s0)
80003728:	83c1                	srli	a5,a5,0x10
8000372a:	0ff7f793          	zext.b	a5,a5
8000372e:	fc744703          	lbu	a4,-57(s0)
80003732:	8b01                	andi	a4,a4,0
80003734:	8fd9                	or	a5,a5,a4
80003736:	fcf403a3          	sb	a5,-57(s0)
8000373a:	fb842783          	lw	a5,-72(s0)
8000373e:	83e1                	srli	a5,a5,0x18
80003740:	fc844703          	lbu	a4,-56(s0)
80003744:	8b01                	andi	a4,a4,0
80003746:	8fd9                	or	a5,a5,a4
80003748:	fcf40423          	sb	a5,-56(s0)
	config_storage_save(&cfg);
8000374c:	fc440793          	addi	a5,s0,-60
80003750:	853e                	mv	a0,a5
80003752:	ab0fd0ef          	jal	ra,80000a02 <config_storage_save>

	// Обновить текущие значения в RAM
	g_addr = cfg.osdp_addr;
80003756:	fc444703          	lbu	a4,-60(s0)
8000375a:	e8e18023          	sb	a4,-384(gp) # 40000600 <g_addr>
	g_baud = cfg.osdp_baud;
8000375e:	fc442783          	lw	a5,-60(s0)
80003762:	83a1                	srli	a5,a5,0x8
80003764:	fc842703          	lw	a4,-56(s0)
80003768:	0ff77713          	zext.b	a4,a4
8000376c:	0762                	slli	a4,a4,0x18
8000376e:	8fd9                	or	a5,a5,a4
80003770:	873e                	mv	a4,a5
80003772:	e8e1a223          	sw	a4,-380(gp) # 40000604 <g_baud>
}
80003776:	0001                	nop
80003778:	40b6                	lw	ra,76(sp)
8000377a:	4426                	lw	s0,72(sp)
8000377c:	6161                	addi	sp,sp,80
8000377e:	8082                	ret

80003780 <set_led_state>:

static void set_led_state(uint8_t on)
{
80003780:	1101                	addi	sp,sp,-32
80003782:	ce06                	sw	ra,28(sp)
80003784:	cc22                	sw	s0,24(sp)
80003786:	1000                	addi	s0,sp,32
80003788:	87aa                	mv	a5,a0
8000378a:	fef407a3          	sb	a5,-17(s0)
	if (on) {
8000378e:	fef44783          	lbu	a5,-17(s0)
80003792:	c78d                	beqz	a5,800037bc <set_led_state+0x3c>
		GPIO_SetBits(GPIOA, GPIO_Pin_7);
80003794:	08000593          	li	a1,128
80003798:	28000537          	lui	a0,0x28000
8000379c:	3869                	jal	80003036 <GPIO_SetBits>
		GPIO_SetBits(GPIOA, GPIO_Pin_6);
8000379e:	04000593          	li	a1,64
800037a2:	28000537          	lui	a0,0x28000
800037a6:	3841                	jal	80003036 <GPIO_SetBits>
		GPIO_SetBits(GPIOA, GPIO_Pin_5);
800037a8:	02000593          	li	a1,32
800037ac:	28000537          	lui	a0,0x28000
800037b0:	3059                	jal	80003036 <GPIO_SetBits>
		GPIO_SetBits(GPIOA, GPIO_Pin_4);
800037b2:	45c1                	li	a1,16
800037b4:	28000537          	lui	a0,0x28000
800037b8:	38bd                	jal	80003036 <GPIO_SetBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_7);
		GPIO_ClearBits(GPIOA, GPIO_Pin_6);
		GPIO_ClearBits(GPIOA, GPIO_Pin_5);
		GPIO_ClearBits(GPIOA, GPIO_Pin_4);
	}
}
800037ba:	a025                	j	800037e2 <set_led_state+0x62>
		GPIO_ClearBits(GPIOA, GPIO_Pin_7);
800037bc:	08000593          	li	a1,128
800037c0:	28000537          	lui	a0,0x28000
800037c4:	3849                	jal	80003056 <GPIO_ClearBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_6);
800037c6:	04000593          	li	a1,64
800037ca:	28000537          	lui	a0,0x28000
800037ce:	3061                	jal	80003056 <GPIO_ClearBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_5);
800037d0:	02000593          	li	a1,32
800037d4:	28000537          	lui	a0,0x28000
800037d8:	38bd                	jal	80003056 <GPIO_ClearBits>
		GPIO_ClearBits(GPIOA, GPIO_Pin_4);
800037da:	45c1                	li	a1,16
800037dc:	28000537          	lui	a0,0x28000
800037e0:	389d                	jal	80003056 <GPIO_ClearBits>
}
800037e2:	0001                	nop
800037e4:	40f2                	lw	ra,28(sp)
800037e6:	4462                	lw	s0,24(sp)
800037e8:	6105                	addi	sp,sp,32
800037ea:	8082                	ret

800037ec <osdp_build_and_send_istat>:
} output_ctrl_t;

static output_ctrl_t output_ctrl[4]; // Состояние для 4 выходов (PA12-PA15)

static void osdp_build_and_send_istat(uint8_t seq)
{
800037ec:	7139                	addi	sp,sp,-64
800037ee:	de06                	sw	ra,60(sp)
800037f0:	dc22                	sw	s0,56(sp)
800037f2:	0080                	addi	s0,sp,64
800037f4:	87aa                	mv	a5,a0
800037f6:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t i = 0;
800037fa:	fe041723          	sh	zero,-18(s0)
	// Дополнительных данных 1 байт:
	//  - бит0 = состояние входа 0 (PA0)
	//  - бит1 = состояние входа 1 (PA1)
	//  - бит2 = состояние входа 2 (PA2)
	//  - бит3 = состояние входа 3 (PA3)
	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1);
800037fe:	47a5                	li	a5,9
80003800:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
80003804:	fcf44683          	lbu	a3,-49(s0)
80003808:	fec45703          	lhu	a4,-20(s0)
8000380c:	fd840793          	addi	a5,s0,-40
80003810:	8636                	mv	a2,a3
80003812:	85ba                	mv	a1,a4
80003814:	853e                	mv	a0,a5
80003816:	3a85                	jal	80003186 <osdp_build_header>
80003818:	87aa                	mv	a5,a0
8000381a:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_ISTATR;
8000381e:	fee45783          	lhu	a5,-18(s0)
80003822:	00178713          	addi	a4,a5,1
80003826:	fee41723          	sh	a4,-18(s0)
8000382a:	17c1                	addi	a5,a5,-16
8000382c:	97a2                	add	a5,a5,s0
8000382e:	04900713          	li	a4,73
80003832:	fee78423          	sb	a4,-24(a5)
	uint8_t inputs = 0;
80003836:	fe0405a3          	sb	zero,-21(s0)
	// Кнопки с PU активны уровнем 0 → инвертируем, чтобы 1 означало "замкнуто/нажато"
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_0) ? 0u : 1u) << 0; 
8000383a:	4585                	li	a1,1
8000383c:	28000537          	lui	a0,0x28000
80003840:	fccff0ef          	jal	ra,8000300c <GPIO_ReadBit>
80003844:	87aa                	mv	a5,a0
80003846:	0017b793          	seqz	a5,a5
8000384a:	0ff7f793          	zext.b	a5,a5
8000384e:	0ff7f793          	zext.b	a5,a5
80003852:	feb44703          	lbu	a4,-21(s0)
80003856:	8fd9                	or	a5,a5,a4
80003858:	fef405a3          	sb	a5,-21(s0)
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_1) ? 0u : 1u) << 1; 
8000385c:	4589                	li	a1,2
8000385e:	28000537          	lui	a0,0x28000
80003862:	faaff0ef          	jal	ra,8000300c <GPIO_ReadBit>
80003866:	87aa                	mv	a5,a0
80003868:	e399                	bnez	a5,8000386e <osdp_build_and_send_istat+0x82>
8000386a:	4789                	li	a5,2
8000386c:	a011                	j	80003870 <osdp_build_and_send_istat+0x84>
8000386e:	4781                	li	a5,0
80003870:	0ff7f793          	zext.b	a5,a5
80003874:	feb44703          	lbu	a4,-21(s0)
80003878:	8fd9                	or	a5,a5,a4
8000387a:	fef405a3          	sb	a5,-21(s0)
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_2) ? 0u : 1u) << 2; 
8000387e:	4591                	li	a1,4
80003880:	28000537          	lui	a0,0x28000
80003884:	f88ff0ef          	jal	ra,8000300c <GPIO_ReadBit>
80003888:	87aa                	mv	a5,a0
8000388a:	e399                	bnez	a5,80003890 <osdp_build_and_send_istat+0xa4>
8000388c:	4791                	li	a5,4
8000388e:	a011                	j	80003892 <osdp_build_and_send_istat+0xa6>
80003890:	4781                	li	a5,0
80003892:	0ff7f793          	zext.b	a5,a5
80003896:	feb44703          	lbu	a4,-21(s0)
8000389a:	8fd9                	or	a5,a5,a4
8000389c:	fef405a3          	sb	a5,-21(s0)
	inputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_3) ? 0u : 1u) << 3; 
800038a0:	45a1                	li	a1,8
800038a2:	28000537          	lui	a0,0x28000
800038a6:	f66ff0ef          	jal	ra,8000300c <GPIO_ReadBit>
800038aa:	87aa                	mv	a5,a0
800038ac:	e399                	bnez	a5,800038b2 <osdp_build_and_send_istat+0xc6>
800038ae:	47a1                	li	a5,8
800038b0:	a011                	j	800038b4 <osdp_build_and_send_istat+0xc8>
800038b2:	4781                	li	a5,0
800038b4:	0ff7f793          	zext.b	a5,a5
800038b8:	feb44703          	lbu	a4,-21(s0)
800038bc:	8fd9                	or	a5,a5,a4
800038be:	fef405a3          	sb	a5,-21(s0)
	tx[i++] = inputs;
800038c2:	fee45783          	lhu	a5,-18(s0)
800038c6:	00178713          	addi	a4,a5,1
800038ca:	fee41723          	sh	a4,-18(s0)
800038ce:	17c1                	addi	a5,a5,-16
800038d0:	97a2                	add	a5,a5,s0
800038d2:	feb44703          	lbu	a4,-21(s0)
800038d6:	fee78423          	sb	a4,-24(a5)
	osdp_build_crc_and_send(tx, i);
800038da:	fee45703          	lhu	a4,-18(s0)
800038de:	fd840793          	addi	a5,s0,-40
800038e2:	85ba                	mv	a1,a4
800038e4:	853e                	mv	a0,a5
800038e6:	3241                	jal	80003266 <osdp_build_crc_and_send>
}
800038e8:	0001                	nop
800038ea:	50f2                	lw	ra,60(sp)
800038ec:	5462                	lw	s0,56(sp)
800038ee:	6121                	addi	sp,sp,64
800038f0:	8082                	ret

800038f2 <osdp_build_and_send_ostat>:

static void osdp_build_and_send_ostat(uint8_t seq)
{
800038f2:	7139                	addi	sp,sp,-64
800038f4:	de06                	sw	ra,60(sp)
800038f6:	dc22                	sw	s0,56(sp)
800038f8:	0080                	addi	s0,sp,64
800038fa:	87aa                	mv	a5,a0
800038fc:	fcf407a3          	sb	a5,-49(s0)
	uint8_t tx[16];
	uint16_t i = 0;
80003900:	fe041723          	sh	zero,-18(s0)
	// Дополнительных данных 1 байт:

	uint16_t dlen = (uint16_t)(OSDP_HEADER_LEN + 1);
80003904:	47a5                	li	a5,9
80003906:	fef41623          	sh	a5,-20(s0)
	i = osdp_build_header(tx, dlen, seq);
8000390a:	fcf44683          	lbu	a3,-49(s0)
8000390e:	fec45703          	lhu	a4,-20(s0)
80003912:	fd840793          	addi	a5,s0,-40
80003916:	8636                	mv	a2,a3
80003918:	85ba                	mv	a1,a4
8000391a:	853e                	mv	a0,a5
8000391c:	30ad                	jal	80003186 <osdp_build_header>
8000391e:	87aa                	mv	a5,a0
80003920:	fef41723          	sh	a5,-18(s0)
	tx[i++] = osdp_OSTATR;
80003924:	fee45783          	lhu	a5,-18(s0)
80003928:	00178713          	addi	a4,a5,1
8000392c:	fee41723          	sh	a4,-18(s0)
80003930:	17c1                	addi	a5,a5,-16
80003932:	97a2                	add	a5,a5,s0
80003934:	04a00713          	li	a4,74
80003938:	fee78423          	sb	a4,-24(a5)
	uint8_t outputs = 0;
8000393c:	fe0405a3          	sb	zero,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_4) ? 1u : 0u) << 0; 
80003940:	45c1                	li	a1,16
80003942:	28000537          	lui	a0,0x28000
80003946:	ec6ff0ef          	jal	ra,8000300c <GPIO_ReadBit>
8000394a:	87aa                	mv	a5,a0
8000394c:	c399                	beqz	a5,80003952 <osdp_build_and_send_ostat+0x60>
8000394e:	4785                	li	a5,1
80003950:	a011                	j	80003954 <osdp_build_and_send_ostat+0x62>
80003952:	4781                	li	a5,0
80003954:	0ff7f793          	zext.b	a5,a5
80003958:	feb44703          	lbu	a4,-21(s0)
8000395c:	8fd9                	or	a5,a5,a4
8000395e:	fef405a3          	sb	a5,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_5) ? 1u : 0u) << 1; 
80003962:	02000593          	li	a1,32
80003966:	28000537          	lui	a0,0x28000
8000396a:	ea2ff0ef          	jal	ra,8000300c <GPIO_ReadBit>
8000396e:	87aa                	mv	a5,a0
80003970:	c399                	beqz	a5,80003976 <osdp_build_and_send_ostat+0x84>
80003972:	4789                	li	a5,2
80003974:	a011                	j	80003978 <osdp_build_and_send_ostat+0x86>
80003976:	4781                	li	a5,0
80003978:	0ff7f793          	zext.b	a5,a5
8000397c:	feb44703          	lbu	a4,-21(s0)
80003980:	8fd9                	or	a5,a5,a4
80003982:	fef405a3          	sb	a5,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_6) ? 1u : 0u) << 2; 
80003986:	04000593          	li	a1,64
8000398a:	28000537          	lui	a0,0x28000
8000398e:	e7eff0ef          	jal	ra,8000300c <GPIO_ReadBit>
80003992:	87aa                	mv	a5,a0
80003994:	c399                	beqz	a5,8000399a <osdp_build_and_send_ostat+0xa8>
80003996:	4791                	li	a5,4
80003998:	a011                	j	8000399c <osdp_build_and_send_ostat+0xaa>
8000399a:	4781                	li	a5,0
8000399c:	0ff7f793          	zext.b	a5,a5
800039a0:	feb44703          	lbu	a4,-21(s0)
800039a4:	8fd9                	or	a5,a5,a4
800039a6:	fef405a3          	sb	a5,-21(s0)
	outputs |= (GPIO_ReadBit(GPIOA, GPIO_Pin_7) ? 1u : 0u) << 3; 
800039aa:	08000593          	li	a1,128
800039ae:	28000537          	lui	a0,0x28000
800039b2:	e5aff0ef          	jal	ra,8000300c <GPIO_ReadBit>
800039b6:	87aa                	mv	a5,a0
800039b8:	c399                	beqz	a5,800039be <osdp_build_and_send_ostat+0xcc>
800039ba:	47a1                	li	a5,8
800039bc:	a011                	j	800039c0 <osdp_build_and_send_ostat+0xce>
800039be:	4781                	li	a5,0
800039c0:	0ff7f793          	zext.b	a5,a5
800039c4:	feb44703          	lbu	a4,-21(s0)
800039c8:	8fd9                	or	a5,a5,a4
800039ca:	fef405a3          	sb	a5,-21(s0)
	tx[i++] = outputs;
800039ce:	fee45783          	lhu	a5,-18(s0)
800039d2:	00178713          	addi	a4,a5,1
800039d6:	fee41723          	sh	a4,-18(s0)
800039da:	17c1                	addi	a5,a5,-16
800039dc:	97a2                	add	a5,a5,s0
800039de:	feb44703          	lbu	a4,-21(s0)
800039e2:	fee78423          	sb	a4,-24(a5)
	osdp_build_crc_and_send(tx, i);
800039e6:	fee45703          	lhu	a4,-18(s0)
800039ea:	fd840793          	addi	a5,s0,-40
800039ee:	85ba                	mv	a1,a4
800039f0:	853e                	mv	a0,a5
800039f2:	3895                	jal	80003266 <osdp_build_crc_and_send>
}
800039f4:	0001                	nop
800039f6:	50f2                	lw	ra,60(sp)
800039f8:	5462                	lw	s0,56(sp)
800039fa:	6121                	addi	sp,sp,64
800039fc:	8082                	ret

800039fe <handle_osdp_out>:
//   0x03: set the permanent state to OFF, allow timed operation to complete
//   0x04: set the permanent state to ON, allow timed operation to complete
//   0x05: set the temporary state to ON, resume permanent state on timeout
//   0x06: set the temporary state to OFF, resume permanent state on timeout
static void handle_osdp_out(uint8_t *data, uint16_t data_len)
{
800039fe:	7139                	addi	sp,sp,-64
80003a00:	de06                	sw	ra,60(sp)
80003a02:	dc22                	sw	s0,56(sp)
80003a04:	0080                	addi	s0,sp,64
80003a06:	fca42623          	sw	a0,-52(s0)
80003a0a:	87ae                	mv	a5,a1
80003a0c:	fcf41523          	sh	a5,-54(s0)
	// Массив пинов для выходов: PA4, PA5, PA6, PA7
	const uint32_t output_pins[4] = {GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7};
80003a10:	800097b7          	lui	a5,0x80009
80003a14:	da478793          	addi	a5,a5,-604 # 80008da4 <__data_source_start+0xffffff50>
80003a18:	4390                	lw	a2,0(a5)
80003a1a:	43d4                	lw	a3,4(a5)
80003a1c:	4798                	lw	a4,8(a5)
80003a1e:	47dc                	lw	a5,12(a5)
80003a20:	fcc42823          	sw	a2,-48(s0)
80003a24:	fcd42a23          	sw	a3,-44(s0)
80003a28:	fce42c23          	sw	a4,-40(s0)
80003a2c:	fcf42e23          	sw	a5,-36(s0)
	
	// Проверяем, что длина данных кратна 4 (стандартный формат OSDP)
	if ((data_len % 4) != 0 || data_len < 4) {
80003a30:	fca45783          	lhu	a5,-54(s0)
80003a34:	8b8d                	andi	a5,a5,3
80003a36:	07c2                	slli	a5,a5,0x10
80003a38:	83c1                	srli	a5,a5,0x10
80003a3a:	38079f63          	bnez	a5,80003dd8 <handle_osdp_out+0x3da>
80003a3e:	fca45703          	lhu	a4,-54(s0)
80003a42:	478d                	li	a5,3
80003a44:	38e7fa63          	bgeu	a5,a4,80003dd8 <handle_osdp_out+0x3da>
		// Неправильный формат - игнорируем
		return;
	}
	
	// Обрабатываем данные по 4 байта на каждый выход
	uint16_t count = (uint16_t)(data_len / 4u);
80003a48:	fca45783          	lhu	a5,-54(s0)
80003a4c:	8389                	srli	a5,a5,0x2
80003a4e:	fef41623          	sh	a5,-20(s0)
	for (uint16_t i = 0; i < count; i++) {
80003a52:	fe041723          	sh	zero,-18(s0)
80003a56:	ae95                	j	80003dca <handle_osdp_out+0x3cc>
		uint8_t *p = &data[i * 4u];
80003a58:	fee45783          	lhu	a5,-18(s0)
80003a5c:	078a                	slli	a5,a5,0x2
80003a5e:	fcc42703          	lw	a4,-52(s0)
80003a62:	97ba                	add	a5,a5,a4
80003a64:	fef42423          	sw	a5,-24(s0)
		uint8_t output_num = p[0];
80003a68:	fe842783          	lw	a5,-24(s0)
80003a6c:	0007c783          	lbu	a5,0(a5)
80003a70:	fef403a3          	sb	a5,-25(s0)
		uint8_t control_code = p[1];
80003a74:	fe842783          	lw	a5,-24(s0)
80003a78:	0017c783          	lbu	a5,1(a5)
80003a7c:	fef40323          	sb	a5,-26(s0)
		uint16_t timer_100ms = (uint16_t)p[2] | ((uint16_t)p[3] << 8);
80003a80:	fe842783          	lw	a5,-24(s0)
80003a84:	0789                	addi	a5,a5,2
80003a86:	0007c783          	lbu	a5,0(a5)
80003a8a:	01079713          	slli	a4,a5,0x10
80003a8e:	8741                	srai	a4,a4,0x10
80003a90:	fe842783          	lw	a5,-24(s0)
80003a94:	078d                	addi	a5,a5,3
80003a96:	0007c783          	lbu	a5,0(a5)
80003a9a:	07a2                	slli	a5,a5,0x8
80003a9c:	07c2                	slli	a5,a5,0x10
80003a9e:	87c1                	srai	a5,a5,0x10
80003aa0:	8fd9                	or	a5,a5,a4
80003aa2:	07c2                	slli	a5,a5,0x10
80003aa4:	87c1                	srai	a5,a5,0x10
80003aa6:	fef41223          	sh	a5,-28(s0)
		
		// Проверяем, что номер выхода в допустимом диапазоне (0-3)
		if (output_num >= 4) continue;
80003aaa:	fe744703          	lbu	a4,-25(s0)
80003aae:	478d                	li	a5,3
80003ab0:	2ee7ef63          	bltu	a5,a4,80003dae <handle_osdp_out+0x3b0>
		
		uint32_t pin = output_pins[output_num];
80003ab4:	fe744783          	lbu	a5,-25(s0)
80003ab8:	078a                	slli	a5,a5,0x2
80003aba:	17c1                	addi	a5,a5,-16
80003abc:	97a2                	add	a5,a5,s0
80003abe:	fe07a783          	lw	a5,-32(a5)
80003ac2:	fef42023          	sw	a5,-32(s0)
		
		// Обработка команд управления выходом согласно стандарту OSDP Table 14
		switch (control_code) {
80003ac6:	fe644783          	lbu	a5,-26(s0)
80003aca:	4719                	li	a4,6
80003acc:	2ef76363          	bltu	a4,a5,80003db2 <handle_osdp_out+0x3b4>
80003ad0:	00279713          	slli	a4,a5,0x2
80003ad4:	800097b7          	lui	a5,0x80009
80003ad8:	db478793          	addi	a5,a5,-588 # 80008db4 <__data_source_start+0xffffff60>
80003adc:	97ba                	add	a5,a5,a4
80003ade:	439c                	lw	a5,0(a5)
80003ae0:	8782                	jr	a5
		case 0x00: // NOP – do not alter this output
			break;
			
		case 0x01: // set the permanent state to OFF, abort timed operation (if any)
			output_ctrl[output_num].permanent_state = 0;
80003ae2:	fe744703          	lbu	a4,-25(s0)
80003ae6:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003aea:	87ba                	mv	a5,a4
80003aec:	0786                	slli	a5,a5,0x1
80003aee:	97ba                	add	a5,a5,a4
80003af0:	078a                	slli	a5,a5,0x2
80003af2:	97b6                	add	a5,a5,a3
80003af4:	00078023          	sb	zero,0(a5)
			output_ctrl[output_num].temp_active = 0; // Прервать временную операцию
80003af8:	fe744703          	lbu	a4,-25(s0)
80003afc:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003b00:	87ba                	mv	a5,a4
80003b02:	0786                	slli	a5,a5,0x1
80003b04:	97ba                	add	a5,a5,a4
80003b06:	078a                	slli	a5,a5,0x2
80003b08:	97b6                	add	a5,a5,a3
80003b0a:	000780a3          	sb	zero,1(a5)
			output_ctrl[output_num].timer_ms_left = 0;
80003b0e:	fe744703          	lbu	a4,-25(s0)
80003b12:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003b16:	87ba                	mv	a5,a4
80003b18:	0786                	slli	a5,a5,0x1
80003b1a:	97ba                	add	a5,a5,a4
80003b1c:	078a                	slli	a5,a5,0x2
80003b1e:	97b6                	add	a5,a5,a3
80003b20:	0007a223          	sw	zero,4(a5)
			GPIO_ClearBits(GPIOA, pin);
80003b24:	fe042583          	lw	a1,-32(s0)
80003b28:	28000537          	lui	a0,0x28000
80003b2c:	d2aff0ef          	jal	ra,80003056 <GPIO_ClearBits>
			break;
80003b30:	ac41                	j	80003dc0 <handle_osdp_out+0x3c2>
			
		case 0x02: // set the permanent state to ON, abort timed operation (if any)
			output_ctrl[output_num].permanent_state = 1;
80003b32:	fe744703          	lbu	a4,-25(s0)
80003b36:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003b3a:	87ba                	mv	a5,a4
80003b3c:	0786                	slli	a5,a5,0x1
80003b3e:	97ba                	add	a5,a5,a4
80003b40:	078a                	slli	a5,a5,0x2
80003b42:	97b6                	add	a5,a5,a3
80003b44:	4705                	li	a4,1
80003b46:	00e78023          	sb	a4,0(a5)
			output_ctrl[output_num].temp_active = 0; // Прервать временную операцию
80003b4a:	fe744703          	lbu	a4,-25(s0)
80003b4e:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003b52:	87ba                	mv	a5,a4
80003b54:	0786                	slli	a5,a5,0x1
80003b56:	97ba                	add	a5,a5,a4
80003b58:	078a                	slli	a5,a5,0x2
80003b5a:	97b6                	add	a5,a5,a3
80003b5c:	000780a3          	sb	zero,1(a5)
			output_ctrl[output_num].timer_ms_left = 0;
80003b60:	fe744703          	lbu	a4,-25(s0)
80003b64:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003b68:	87ba                	mv	a5,a4
80003b6a:	0786                	slli	a5,a5,0x1
80003b6c:	97ba                	add	a5,a5,a4
80003b6e:	078a                	slli	a5,a5,0x2
80003b70:	97b6                	add	a5,a5,a3
80003b72:	0007a223          	sw	zero,4(a5)
			GPIO_SetBits(GPIOA, pin);
80003b76:	fe042583          	lw	a1,-32(s0)
80003b7a:	28000537          	lui	a0,0x28000
80003b7e:	cb8ff0ef          	jal	ra,80003036 <GPIO_SetBits>
			break;
80003b82:	ac3d                	j	80003dc0 <handle_osdp_out+0x3c2>
			
		case 0x03: // set the permanent state to OFF, allow timed operation to complete
			output_ctrl[output_num].permanent_state = 0;
80003b84:	fe744703          	lbu	a4,-25(s0)
80003b88:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003b8c:	87ba                	mv	a5,a4
80003b8e:	0786                	slli	a5,a5,0x1
80003b90:	97ba                	add	a5,a5,a4
80003b92:	078a                	slli	a5,a5,0x2
80003b94:	97b6                	add	a5,a5,a3
80003b96:	00078023          	sb	zero,0(a5)
			output_ctrl[output_num].allow_completion = 1; // Разрешить завершение временной операции
80003b9a:	fe744703          	lbu	a4,-25(s0)
80003b9e:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003ba2:	87ba                	mv	a5,a4
80003ba4:	0786                	slli	a5,a5,0x1
80003ba6:	97ba                	add	a5,a5,a4
80003ba8:	078a                	slli	a5,a5,0x2
80003baa:	97b6                	add	a5,a5,a3
80003bac:	4705                	li	a4,1
80003bae:	00e78423          	sb	a4,8(a5)
			// Если временная операция не активна, сразу установить постоянное состояние
			if (!output_ctrl[output_num].temp_active) {
80003bb2:	fe744703          	lbu	a4,-25(s0)
80003bb6:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003bba:	87ba                	mv	a5,a4
80003bbc:	0786                	slli	a5,a5,0x1
80003bbe:	97ba                	add	a5,a5,a4
80003bc0:	078a                	slli	a5,a5,0x2
80003bc2:	97b6                	add	a5,a5,a3
80003bc4:	0017c783          	lbu	a5,1(a5)
80003bc8:	1e079963          	bnez	a5,80003dba <handle_osdp_out+0x3bc>
				GPIO_ClearBits(GPIOA, pin);
80003bcc:	fe042583          	lw	a1,-32(s0)
80003bd0:	28000537          	lui	a0,0x28000
80003bd4:	c82ff0ef          	jal	ra,80003056 <GPIO_ClearBits>
			}
			break;
80003bd8:	a2cd                	j	80003dba <handle_osdp_out+0x3bc>
			
		case 0x04: // set the permanent state to ON, allow timed operation to complete
			output_ctrl[output_num].permanent_state = 1;
80003bda:	fe744703          	lbu	a4,-25(s0)
80003bde:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003be2:	87ba                	mv	a5,a4
80003be4:	0786                	slli	a5,a5,0x1
80003be6:	97ba                	add	a5,a5,a4
80003be8:	078a                	slli	a5,a5,0x2
80003bea:	97b6                	add	a5,a5,a3
80003bec:	4705                	li	a4,1
80003bee:	00e78023          	sb	a4,0(a5)
			output_ctrl[output_num].allow_completion = 1; // Разрешить завершение временной операции
80003bf2:	fe744703          	lbu	a4,-25(s0)
80003bf6:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003bfa:	87ba                	mv	a5,a4
80003bfc:	0786                	slli	a5,a5,0x1
80003bfe:	97ba                	add	a5,a5,a4
80003c00:	078a                	slli	a5,a5,0x2
80003c02:	97b6                	add	a5,a5,a3
80003c04:	4705                	li	a4,1
80003c06:	00e78423          	sb	a4,8(a5)
			// Если временная операция не активна, сразу установить постоянное состояние
			if (!output_ctrl[output_num].temp_active) {
80003c0a:	fe744703          	lbu	a4,-25(s0)
80003c0e:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003c12:	87ba                	mv	a5,a4
80003c14:	0786                	slli	a5,a5,0x1
80003c16:	97ba                	add	a5,a5,a4
80003c18:	078a                	slli	a5,a5,0x2
80003c1a:	97b6                	add	a5,a5,a3
80003c1c:	0017c783          	lbu	a5,1(a5)
80003c20:	18079f63          	bnez	a5,80003dbe <handle_osdp_out+0x3c0>
				GPIO_SetBits(GPIOA, pin);
80003c24:	fe042583          	lw	a1,-32(s0)
80003c28:	28000537          	lui	a0,0x28000
80003c2c:	c0aff0ef          	jal	ra,80003036 <GPIO_SetBits>
			}
			break;
80003c30:	a279                	j	80003dbe <handle_osdp_out+0x3c0>
			
		case 0x05: // set the temporary state to ON, resume permanent state on timeout
			output_ctrl[output_num].temp_active = 1;
80003c32:	fe744703          	lbu	a4,-25(s0)
80003c36:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003c3a:	87ba                	mv	a5,a4
80003c3c:	0786                	slli	a5,a5,0x1
80003c3e:	97ba                	add	a5,a5,a4
80003c40:	078a                	slli	a5,a5,0x2
80003c42:	97b6                	add	a5,a5,a3
80003c44:	4705                	li	a4,1
80003c46:	00e780a3          	sb	a4,1(a5)
			output_ctrl[output_num].temp_state = 1;
80003c4a:	fe744703          	lbu	a4,-25(s0)
80003c4e:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003c52:	87ba                	mv	a5,a4
80003c54:	0786                	slli	a5,a5,0x1
80003c56:	97ba                	add	a5,a5,a4
80003c58:	078a                	slli	a5,a5,0x2
80003c5a:	97b6                	add	a5,a5,a3
80003c5c:	4705                	li	a4,1
80003c5e:	00e78123          	sb	a4,2(a5)
			output_ctrl[output_num].allow_completion = 0;
80003c62:	fe744703          	lbu	a4,-25(s0)
80003c66:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003c6a:	87ba                	mv	a5,a4
80003c6c:	0786                	slli	a5,a5,0x1
80003c6e:	97ba                	add	a5,a5,a4
80003c70:	078a                	slli	a5,a5,0x2
80003c72:	97b6                	add	a5,a5,a3
80003c74:	00078423          	sb	zero,8(a5)
			if (timer_100ms == 0) {
80003c78:	fe445783          	lhu	a5,-28(s0)
80003c7c:	e7a1                	bnez	a5,80003cc4 <handle_osdp_out+0x2c6>
				// Таймер = 0 означает "навсегда" - устанавливаем как постоянное состояние
				output_ctrl[output_num].permanent_state = 1;
80003c7e:	fe744703          	lbu	a4,-25(s0)
80003c82:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003c86:	87ba                	mv	a5,a4
80003c88:	0786                	slli	a5,a5,0x1
80003c8a:	97ba                	add	a5,a5,a4
80003c8c:	078a                	slli	a5,a5,0x2
80003c8e:	97b6                	add	a5,a5,a3
80003c90:	4705                	li	a4,1
80003c92:	00e78023          	sb	a4,0(a5)
				output_ctrl[output_num].temp_active = 0;
80003c96:	fe744703          	lbu	a4,-25(s0)
80003c9a:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003c9e:	87ba                	mv	a5,a4
80003ca0:	0786                	slli	a5,a5,0x1
80003ca2:	97ba                	add	a5,a5,a4
80003ca4:	078a                	slli	a5,a5,0x2
80003ca6:	97b6                	add	a5,a5,a3
80003ca8:	000780a3          	sb	zero,1(a5)
				output_ctrl[output_num].timer_ms_left = 0;
80003cac:	fe744703          	lbu	a4,-25(s0)
80003cb0:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003cb4:	87ba                	mv	a5,a4
80003cb6:	0786                	slli	a5,a5,0x1
80003cb8:	97ba                	add	a5,a5,a4
80003cba:	078a                	slli	a5,a5,0x2
80003cbc:	97b6                	add	a5,a5,a3
80003cbe:	0007a223          	sw	zero,4(a5)
80003cc2:	a00d                	j	80003ce4 <handle_osdp_out+0x2e6>
			} else {
				output_ctrl[output_num].timer_ms_left = (uint32_t)timer_100ms * 100u; // Конвертируем в миллисекунды
80003cc4:	fe445683          	lhu	a3,-28(s0)
80003cc8:	fe744703          	lbu	a4,-25(s0)
80003ccc:	06400793          	li	a5,100
80003cd0:	02f686b3          	mul	a3,a3,a5
80003cd4:	ed018613          	addi	a2,gp,-304 # 40000650 <output_ctrl>
80003cd8:	87ba                	mv	a5,a4
80003cda:	0786                	slli	a5,a5,0x1
80003cdc:	97ba                	add	a5,a5,a4
80003cde:	078a                	slli	a5,a5,0x2
80003ce0:	97b2                	add	a5,a5,a2
80003ce2:	c3d4                	sw	a3,4(a5)
			}
			GPIO_SetBits(GPIOA, pin);
80003ce4:	fe042583          	lw	a1,-32(s0)
80003ce8:	28000537          	lui	a0,0x28000
80003cec:	b4aff0ef          	jal	ra,80003036 <GPIO_SetBits>
			break;
80003cf0:	a8c1                	j	80003dc0 <handle_osdp_out+0x3c2>
			
		case 0x06: // set the temporary state to OFF, resume permanent state on timeout
			output_ctrl[output_num].temp_active = 1;
80003cf2:	fe744703          	lbu	a4,-25(s0)
80003cf6:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003cfa:	87ba                	mv	a5,a4
80003cfc:	0786                	slli	a5,a5,0x1
80003cfe:	97ba                	add	a5,a5,a4
80003d00:	078a                	slli	a5,a5,0x2
80003d02:	97b6                	add	a5,a5,a3
80003d04:	4705                	li	a4,1
80003d06:	00e780a3          	sb	a4,1(a5)
			output_ctrl[output_num].temp_state = 0;
80003d0a:	fe744703          	lbu	a4,-25(s0)
80003d0e:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003d12:	87ba                	mv	a5,a4
80003d14:	0786                	slli	a5,a5,0x1
80003d16:	97ba                	add	a5,a5,a4
80003d18:	078a                	slli	a5,a5,0x2
80003d1a:	97b6                	add	a5,a5,a3
80003d1c:	00078123          	sb	zero,2(a5)
			output_ctrl[output_num].allow_completion = 0;
80003d20:	fe744703          	lbu	a4,-25(s0)
80003d24:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003d28:	87ba                	mv	a5,a4
80003d2a:	0786                	slli	a5,a5,0x1
80003d2c:	97ba                	add	a5,a5,a4
80003d2e:	078a                	slli	a5,a5,0x2
80003d30:	97b6                	add	a5,a5,a3
80003d32:	00078423          	sb	zero,8(a5)
			if (timer_100ms == 0) {
80003d36:	fe445783          	lhu	a5,-28(s0)
80003d3a:	e3b9                	bnez	a5,80003d80 <handle_osdp_out+0x382>
				// Таймер = 0 означает "навсегда" - устанавливаем как постоянное состояние
				output_ctrl[output_num].permanent_state = 0;
80003d3c:	fe744703          	lbu	a4,-25(s0)
80003d40:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003d44:	87ba                	mv	a5,a4
80003d46:	0786                	slli	a5,a5,0x1
80003d48:	97ba                	add	a5,a5,a4
80003d4a:	078a                	slli	a5,a5,0x2
80003d4c:	97b6                	add	a5,a5,a3
80003d4e:	00078023          	sb	zero,0(a5)
				output_ctrl[output_num].temp_active = 0;
80003d52:	fe744703          	lbu	a4,-25(s0)
80003d56:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003d5a:	87ba                	mv	a5,a4
80003d5c:	0786                	slli	a5,a5,0x1
80003d5e:	97ba                	add	a5,a5,a4
80003d60:	078a                	slli	a5,a5,0x2
80003d62:	97b6                	add	a5,a5,a3
80003d64:	000780a3          	sb	zero,1(a5)
				output_ctrl[output_num].timer_ms_left = 0;
80003d68:	fe744703          	lbu	a4,-25(s0)
80003d6c:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003d70:	87ba                	mv	a5,a4
80003d72:	0786                	slli	a5,a5,0x1
80003d74:	97ba                	add	a5,a5,a4
80003d76:	078a                	slli	a5,a5,0x2
80003d78:	97b6                	add	a5,a5,a3
80003d7a:	0007a223          	sw	zero,4(a5)
80003d7e:	a00d                	j	80003da0 <handle_osdp_out+0x3a2>
			} else {
				output_ctrl[output_num].timer_ms_left = (uint32_t)timer_100ms * 100u; // Конвертируем в миллисекунды
80003d80:	fe445683          	lhu	a3,-28(s0)
80003d84:	fe744703          	lbu	a4,-25(s0)
80003d88:	06400793          	li	a5,100
80003d8c:	02f686b3          	mul	a3,a3,a5
80003d90:	ed018613          	addi	a2,gp,-304 # 40000650 <output_ctrl>
80003d94:	87ba                	mv	a5,a4
80003d96:	0786                	slli	a5,a5,0x1
80003d98:	97ba                	add	a5,a5,a4
80003d9a:	078a                	slli	a5,a5,0x2
80003d9c:	97b2                	add	a5,a5,a2
80003d9e:	c3d4                	sw	a3,4(a5)
			}
			GPIO_ClearBits(GPIOA, pin);
80003da0:	fe042583          	lw	a1,-32(s0)
80003da4:	28000537          	lui	a0,0x28000
80003da8:	aaeff0ef          	jal	ra,80003056 <GPIO_ClearBits>
			break;
80003dac:	a811                	j	80003dc0 <handle_osdp_out+0x3c2>
		if (output_num >= 4) continue;
80003dae:	0001                	nop
80003db0:	a801                	j	80003dc0 <handle_osdp_out+0x3c2>
			
		default:
			// Неизвестный код управления - игнорируем согласно стандарту
			break;
80003db2:	0001                	nop
80003db4:	a031                	j	80003dc0 <handle_osdp_out+0x3c2>
			break;
80003db6:	0001                	nop
80003db8:	a021                	j	80003dc0 <handle_osdp_out+0x3c2>
			break;
80003dba:	0001                	nop
80003dbc:	a011                	j	80003dc0 <handle_osdp_out+0x3c2>
			break;
80003dbe:	0001                	nop
	for (uint16_t i = 0; i < count; i++) {
80003dc0:	fee45783          	lhu	a5,-18(s0)
80003dc4:	0785                	addi	a5,a5,1
80003dc6:	fef41723          	sh	a5,-18(s0)
80003dca:	fee45703          	lhu	a4,-18(s0)
80003dce:	fec45783          	lhu	a5,-20(s0)
80003dd2:	c8f763e3          	bltu	a4,a5,80003a58 <handle_osdp_out+0x5a>
80003dd6:	a011                	j	80003dda <handle_osdp_out+0x3dc>
		return;
80003dd8:	0001                	nop
		}
	}
}
80003dda:	50f2                	lw	ra,60(sp)
80003ddc:	5462                	lw	s0,56(sp)
80003dde:	6121                	addi	sp,sp,64
80003de0:	8082                	ret

80003de2 <set_uart_baud>:

static void set_uart_baud(uint32_t baud)
{
80003de2:	7139                	addi	sp,sp,-64
80003de4:	de22                	sw	s0,60(sp)
80003de6:	0080                	addi	s0,sp,64
80003de8:	fca42623          	sw	a0,-52(s0)
	// Настроить делители UART4 по формуле из UART4_init()
	// Предполагаем источник тактирования HSE, как в init
	uint32_t baud_icoef = HSECLK_VAL / (16u * baud);
80003dec:	fcc42783          	lw	a5,-52(s0)
80003df0:	0792                	slli	a5,a5,0x4
80003df2:	00f42737          	lui	a4,0xf42
80003df6:	40070713          	addi	a4,a4,1024 # f42400 <STACK_SIZE+0xf41c00>
80003dfa:	02f757b3          	divu	a5,a4,a5
80003dfe:	fef42623          	sw	a5,-20(s0)
	float    f = (float)HSECLK_VAL / (16.0f * (float)baud) - (float)baud_icoef;
80003e02:	fcc42783          	lw	a5,-52(s0)
80003e06:	d017f753          	fcvt.s.wu	fa4,a5
80003e0a:	800097b7          	lui	a5,0x80009
80003e0e:	e207a787          	flw	fa5,-480(a5) # 80008e20 <__data_source_start+0xffffffcc>
80003e12:	10f777d3          	fmul.s	fa5,fa4,fa5
80003e16:	800097b7          	lui	a5,0x80009
80003e1a:	e247a707          	flw	fa4,-476(a5) # 80008e24 <__data_source_start+0xffffffd0>
80003e1e:	18f77753          	fdiv.s	fa4,fa4,fa5
80003e22:	fec42783          	lw	a5,-20(s0)
80003e26:	d017f7d3          	fcvt.s.wu	fa5,a5
80003e2a:	08f777d3          	fsub.s	fa5,fa4,fa5
80003e2e:	fef42427          	fsw	fa5,-24(s0)
	uint32_t baud_fcoef = (uint32_t)(f * 64.0f + 0.5f);
80003e32:	fe842707          	flw	fa4,-24(s0)
80003e36:	800097b7          	lui	a5,0x80009
80003e3a:	e287a787          	flw	fa5,-472(a5) # 80008e28 <__data_source_start+0xffffffd4>
80003e3e:	10f77753          	fmul.s	fa4,fa4,fa5
80003e42:	800097b7          	lui	a5,0x80009
80003e46:	e2c7a787          	flw	fa5,-468(a5) # 80008e2c <__data_source_start+0xffffffd8>
80003e4a:	00f777d3          	fadd.s	fa5,fa4,fa5
80003e4e:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80003e52:	fef42223          	sw	a5,-28(s0)
	uint32_t cr_saved   = UART4->CR;
80003e56:	3000a7b7          	lui	a5,0x3000a
80003e5a:	5b9c                	lw	a5,48(a5)
80003e5c:	fef42023          	sw	a5,-32(s0)
	uint32_t lcrh_saved = UART4->LCRH;
80003e60:	3000a7b7          	lui	a5,0x3000a
80003e64:	57dc                	lw	a5,44(a5)
80003e66:	fcf42e23          	sw	a5,-36(s0)
	uint32_t imsc_saved = UART4->IMSC;
80003e6a:	3000a7b7          	lui	a5,0x3000a
80003e6e:	5f9c                	lw	a5,56(a5)
80003e70:	fcf42c23          	sw	a5,-40(s0)
	// Дождаться окончания текущей передачи/приёма, чтобы не обрывать ответ
	while (UART4->FR_bit.BUSY) { }
80003e74:	0001                	nop
80003e76:	3000a7b7          	lui	a5,0x3000a
80003e7a:	4f9c                	lw	a5,24(a5)
80003e7c:	838d                	srli	a5,a5,0x3
80003e7e:	8b85                	andi	a5,a5,1
80003e80:	0ff7f793          	zext.b	a5,a5
80003e84:	fbed                	bnez	a5,80003e76 <set_uart_baud+0x94>
	// Остановить UART
	UART4->CR = 0;
80003e86:	3000a7b7          	lui	a5,0x3000a
80003e8a:	0207a823          	sw	zero,48(a5) # 3000a030 <STACK_SIZE+0x30009830>
	UART4->IBRD = baud_icoef;
80003e8e:	3000a7b7          	lui	a5,0x3000a
80003e92:	fec42703          	lw	a4,-20(s0)
80003e96:	d3d8                	sw	a4,36(a5)
	UART4->FBRD = baud_fcoef;
80003e98:	3000a7b7          	lui	a5,0x3000a
80003e9c:	fe442703          	lw	a4,-28(s0)
80003ea0:	d798                	sw	a4,40(a5)
	// Перезаписать формат кадра и включить FIFO как в init (8N1, FIFO EN)
	UART4->LCRH = UART_LCRH_FEN_Msk | (3u << UART_LCRH_WLEN_Pos);
80003ea2:	3000a7b7          	lui	a5,0x3000a
80003ea6:	07000713          	li	a4,112
80003eaa:	d7d8                	sw	a4,44(a5)
	// Очистить все флаги прерываний
	UART4->ICR = 0x7FF;
80003eac:	3000a7b7          	lui	a5,0x3000a
80003eb0:	7ff00713          	li	a4,2047
80003eb4:	c3f8                	sw	a4,68(a5)
	while (!UART4->FR_bit.RXFE) { (void)UART4->DR_bit.DATA; }
80003eb6:	a029                	j	80003ec0 <set_uart_baud+0xde>
80003eb8:	3000a7b7          	lui	a5,0x3000a
80003ebc:	0007c783          	lbu	a5,0(a5) # 3000a000 <STACK_SIZE+0x30009800>
80003ec0:	3000a7b7          	lui	a5,0x3000a
80003ec4:	4f9c                	lw	a5,24(a5)
80003ec6:	8391                	srli	a5,a5,0x4
80003ec8:	8b85                	andi	a5,a5,1
80003eca:	0ff7f793          	zext.b	a5,a5
80003ece:	d7ed                	beqz	a5,80003eb8 <set_uart_baud+0xd6>
	// Восстановить маску прерываний (на случай, если аппаратно сбросилась)
	UART4->IMSC = imsc_saved;
80003ed0:	3000a7b7          	lui	a5,0x3000a
80003ed4:	fd842703          	lw	a4,-40(s0)
80003ed8:	df98                	sw	a4,56(a5)
	// Включить обратно (TX, RX, UARTEN)
	UART4->CR = cr_saved | UART_CR_TXE_Msk | UART_CR_RXE_Msk | UART_CR_UARTEN_Msk;
80003eda:	3000a7b7          	lui	a5,0x3000a
80003ede:	fe042703          	lw	a4,-32(s0)
80003ee2:	30176713          	ori	a4,a4,769
80003ee6:	db98                	sw	a4,48(a5)
}
80003ee8:	0001                	nop
80003eea:	5472                	lw	s0,60(sp)
80003eec:	6121                	addi	sp,sp,64
80003eee:	8082                	ret

80003ef0 <osdp_tick_1ms>:
} led_ctrl_t;

static led_ctrl_t led_ctrl;

void osdp_tick_1ms(void) // вызывается каждую мс из main.c
{
80003ef0:	7179                	addi	sp,sp,-48
80003ef2:	d606                	sw	ra,44(sp)
80003ef4:	d422                	sw	s0,40(sp)
80003ef6:	1800                	addi	s0,sp,48
	// Обработка таймеров выходов OSDP
	const uint32_t output_pins[4] = {GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7};
80003ef8:	800097b7          	lui	a5,0x80009
80003efc:	da478793          	addi	a5,a5,-604 # 80008da4 <__data_source_start+0xffffff50>
80003f00:	4390                	lw	a2,0(a5)
80003f02:	43d4                	lw	a3,4(a5)
80003f04:	4798                	lw	a4,8(a5)
80003f06:	47dc                	lw	a5,12(a5)
80003f08:	fcc42e23          	sw	a2,-36(s0)
80003f0c:	fed42023          	sw	a3,-32(s0)
80003f10:	fee42223          	sw	a4,-28(s0)
80003f14:	fef42423          	sw	a5,-24(s0)
	for (uint8_t i = 0; i < 4; i++) {
80003f18:	fe0407a3          	sb	zero,-17(s0)
80003f1c:	a8e1                	j	80003ff4 <osdp_tick_1ms+0x104>
		if (output_ctrl[i].temp_active && output_ctrl[i].timer_ms_left > 0) {
80003f1e:	fef44703          	lbu	a4,-17(s0)
80003f22:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003f26:	87ba                	mv	a5,a4
80003f28:	0786                	slli	a5,a5,0x1
80003f2a:	97ba                	add	a5,a5,a4
80003f2c:	078a                	slli	a5,a5,0x2
80003f2e:	97b6                	add	a5,a5,a3
80003f30:	0017c783          	lbu	a5,1(a5)
80003f34:	cbdd                	beqz	a5,80003fea <osdp_tick_1ms+0xfa>
80003f36:	fef44703          	lbu	a4,-17(s0)
80003f3a:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003f3e:	87ba                	mv	a5,a4
80003f40:	0786                	slli	a5,a5,0x1
80003f42:	97ba                	add	a5,a5,a4
80003f44:	078a                	slli	a5,a5,0x2
80003f46:	97b6                	add	a5,a5,a3
80003f48:	43dc                	lw	a5,4(a5)
80003f4a:	c3c5                	beqz	a5,80003fea <osdp_tick_1ms+0xfa>
			--output_ctrl[i].timer_ms_left;
80003f4c:	fef44703          	lbu	a4,-17(s0)
80003f50:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003f54:	87ba                	mv	a5,a4
80003f56:	0786                	slli	a5,a5,0x1
80003f58:	97ba                	add	a5,a5,a4
80003f5a:	078a                	slli	a5,a5,0x2
80003f5c:	97b6                	add	a5,a5,a3
80003f5e:	43dc                	lw	a5,4(a5)
80003f60:	fff78693          	addi	a3,a5,-1
80003f64:	ed018613          	addi	a2,gp,-304 # 40000650 <output_ctrl>
80003f68:	87ba                	mv	a5,a4
80003f6a:	0786                	slli	a5,a5,0x1
80003f6c:	97ba                	add	a5,a5,a4
80003f6e:	078a                	slli	a5,a5,0x2
80003f70:	97b2                	add	a5,a5,a2
80003f72:	c3d4                	sw	a3,4(a5)
			if (output_ctrl[i].timer_ms_left == 0) {
80003f74:	fef44703          	lbu	a4,-17(s0)
80003f78:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003f7c:	87ba                	mv	a5,a4
80003f7e:	0786                	slli	a5,a5,0x1
80003f80:	97ba                	add	a5,a5,a4
80003f82:	078a                	slli	a5,a5,0x2
80003f84:	97b6                	add	a5,a5,a3
80003f86:	43dc                	lw	a5,4(a5)
80003f88:	e3ad                	bnez	a5,80003fea <osdp_tick_1ms+0xfa>
				// Таймер истек - возвращаем постоянное состояние
				output_ctrl[i].temp_active = 0;
80003f8a:	fef44703          	lbu	a4,-17(s0)
80003f8e:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003f92:	87ba                	mv	a5,a4
80003f94:	0786                	slli	a5,a5,0x1
80003f96:	97ba                	add	a5,a5,a4
80003f98:	078a                	slli	a5,a5,0x2
80003f9a:	97b6                	add	a5,a5,a3
80003f9c:	000780a3          	sb	zero,1(a5)
				if (output_ctrl[i].permanent_state) {
80003fa0:	fef44703          	lbu	a4,-17(s0)
80003fa4:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80003fa8:	87ba                	mv	a5,a4
80003faa:	0786                	slli	a5,a5,0x1
80003fac:	97ba                	add	a5,a5,a4
80003fae:	078a                	slli	a5,a5,0x2
80003fb0:	97b6                	add	a5,a5,a3
80003fb2:	0007c783          	lbu	a5,0(a5)
80003fb6:	cf91                	beqz	a5,80003fd2 <osdp_tick_1ms+0xe2>
					GPIO_SetBits(GPIOA, output_pins[i]);
80003fb8:	fef44783          	lbu	a5,-17(s0)
80003fbc:	078a                	slli	a5,a5,0x2
80003fbe:	17c1                	addi	a5,a5,-16
80003fc0:	97a2                	add	a5,a5,s0
80003fc2:	fec7a783          	lw	a5,-20(a5)
80003fc6:	85be                	mv	a1,a5
80003fc8:	28000537          	lui	a0,0x28000
80003fcc:	86aff0ef          	jal	ra,80003036 <GPIO_SetBits>
80003fd0:	a829                	j	80003fea <osdp_tick_1ms+0xfa>
				} else {
					GPIO_ClearBits(GPIOA, output_pins[i]);
80003fd2:	fef44783          	lbu	a5,-17(s0)
80003fd6:	078a                	slli	a5,a5,0x2
80003fd8:	17c1                	addi	a5,a5,-16
80003fda:	97a2                	add	a5,a5,s0
80003fdc:	fec7a783          	lw	a5,-20(a5)
80003fe0:	85be                	mv	a1,a5
80003fe2:	28000537          	lui	a0,0x28000
80003fe6:	870ff0ef          	jal	ra,80003056 <GPIO_ClearBits>
	for (uint8_t i = 0; i < 4; i++) {
80003fea:	fef44783          	lbu	a5,-17(s0)
80003fee:	0785                	addi	a5,a5,1
80003ff0:	fef407a3          	sb	a5,-17(s0)
80003ff4:	fef44703          	lbu	a4,-17(s0)
80003ff8:	478d                	li	a5,3
80003ffa:	f2e7f2e3          	bgeu	a5,a4,80003f1e <osdp_tick_1ms+0x2e>
			}
		}
	}
	
	// Обработка таймеров LED
	if (led_ctrl.phase_ms_left > 0) {
80003ffe:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004002:	4b9c                	lw	a5,16(a5)
80004004:	cb91                	beqz	a5,80004018 <osdp_tick_1ms+0x128>
		--led_ctrl.phase_ms_left;
80004006:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000400a:	4b9c                	lw	a5,16(a5)
8000400c:	fff78713          	addi	a4,a5,-1
80004010:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004014:	cb98                	sw	a4,16(a5)
80004016:	aa85                	j	80004186 <osdp_tick_1ms+0x296>
		return;
	}

	if (led_ctrl.temp_active) {  // проверка на профиль temp/perm
80004018:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000401c:	0007c783          	lbu	a5,0(a5)
80004020:	0e078a63          	beqz	a5,80004114 <osdp_tick_1ms+0x224>
		// Управление temp профилем
		if (led_ctrl.current_state) {
80004024:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004028:	0027c783          	lbu	a5,2(a5)
8000402c:	c79d                	beqz	a5,8000405a <osdp_tick_1ms+0x16a>
			// ON -> OFF
			led_ctrl.current_state = 0;
8000402e:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004032:	00078123          	sb	zero,2(a5)
			set_led_state(led_ctrl.temp_off_color_is_on ? 1 : 0);
80004036:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000403a:	01d7c783          	lbu	a5,29(a5)
8000403e:	00f037b3          	snez	a5,a5
80004042:	0ff7f793          	zext.b	a5,a5
80004046:	853e                	mv	a0,a5
80004048:	f38ff0ef          	jal	ra,80003780 <set_led_state>
			led_ctrl.phase_ms_left = (led_ctrl.off_ms > 0) ? led_ctrl.off_ms : 0;
8000404c:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004050:	4798                	lw	a4,8(a5)
80004052:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004056:	cb98                	sw	a4,16(a5)
80004058:	a23d                	j	80004186 <osdp_tick_1ms+0x296>
		} else {
			// OFF -> ON
			led_ctrl.current_state = 1;
8000405a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000405e:	4705                	li	a4,1
80004060:	00e78123          	sb	a4,2(a5)
			set_led_state(led_ctrl.temp_on_color_is_on ? 1 : 0);
80004064:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004068:	01c7c783          	lbu	a5,28(a5)
8000406c:	00f037b3          	snez	a5,a5
80004070:	0ff7f793          	zext.b	a5,a5
80004074:	853e                	mv	a0,a5
80004076:	f0aff0ef          	jal	ra,80003780 <set_led_state>
			led_ctrl.phase_ms_left = (led_ctrl.on_ms > 0) ? led_ctrl.on_ms : 0;
8000407a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000407e:	43d8                	lw	a4,4(a5)
80004080:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004084:	cb98                	sw	a4,16(a5)
			// Считаем циклы по фронту включения
			if (led_ctrl.cycles_left > 0) {
80004086:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000408a:	00c7d783          	lhu	a5,12(a5)
8000408e:	0e078c63          	beqz	a5,80004186 <osdp_tick_1ms+0x296>
				--led_ctrl.cycles_left;
80004092:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004096:	00c7d783          	lhu	a5,12(a5)
8000409a:	17fd                	addi	a5,a5,-1
8000409c:	01079713          	slli	a4,a5,0x10
800040a0:	8341                	srli	a4,a4,0x10
800040a2:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040a6:	00e79623          	sh	a4,12(a5)
				if (led_ctrl.cycles_left == 0) {
800040aa:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040ae:	00c7d783          	lhu	a5,12(a5)
800040b2:	0c079a63          	bnez	a5,80004186 <osdp_tick_1ms+0x296>
					// Конец временного режима – восстановить постоянный
					led_ctrl.temp_active = 0;
800040b6:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040ba:	00078023          	sb	zero,0(a5)
					// Запустить постоянный профиль
					if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
800040be:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040c2:	4bdc                	lw	a5,20(a5)
800040c4:	cf85                	beqz	a5,800040fc <osdp_tick_1ms+0x20c>
800040c6:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040ca:	4f9c                	lw	a5,24(a5)
800040cc:	cb85                	beqz	a5,800040fc <osdp_tick_1ms+0x20c>
						led_ctrl.current_state = 1;
800040ce:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040d2:	4705                	li	a4,1
800040d4:	00e78123          	sb	a4,2(a5)
						set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
800040d8:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040dc:	01e7c783          	lbu	a5,30(a5)
800040e0:	00f037b3          	snez	a5,a5
800040e4:	0ff7f793          	zext.b	a5,a5
800040e8:	853e                	mv	a0,a5
800040ea:	e96ff0ef          	jal	ra,80003780 <set_led_state>
						led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
800040ee:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040f2:	4bd8                	lw	a4,20(a5)
800040f4:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800040f8:	cb98                	sw	a4,16(a5)
800040fa:	a071                	j	80004186 <osdp_tick_1ms+0x296>
					} else {
						set_led_state(led_ctrl.perm_state);
800040fc:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004100:	0017c783          	lbu	a5,1(a5)
80004104:	853e                	mv	a0,a5
80004106:	e7aff0ef          	jal	ra,80003780 <set_led_state>
						led_ctrl.phase_ms_left = 0;
8000410a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000410e:	0007a823          	sw	zero,16(a5)
80004112:	a895                	j	80004186 <osdp_tick_1ms+0x296>
				}
			}
		}
	} else {
		// Постоянный профиль: мигание, если задано perm_on/off
		if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
80004114:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004118:	4bdc                	lw	a5,20(a5)
8000411a:	c7b5                	beqz	a5,80004186 <osdp_tick_1ms+0x296>
8000411c:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004120:	4f9c                	lw	a5,24(a5)
80004122:	c3b5                	beqz	a5,80004186 <osdp_tick_1ms+0x296>
			if (led_ctrl.current_state) {
80004124:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004128:	0027c783          	lbu	a5,2(a5)
8000412c:	c79d                	beqz	a5,8000415a <osdp_tick_1ms+0x26a>
				led_ctrl.current_state = 0;
8000412e:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004132:	00078123          	sb	zero,2(a5)
				set_led_state(led_ctrl.perm_off_color_is_on ? 1 : 0);
80004136:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000413a:	01f7c783          	lbu	a5,31(a5)
8000413e:	00f037b3          	snez	a5,a5
80004142:	0ff7f793          	zext.b	a5,a5
80004146:	853e                	mv	a0,a5
80004148:	e38ff0ef          	jal	ra,80003780 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_off_ms;
8000414c:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004150:	4f98                	lw	a4,24(a5)
80004152:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004156:	cb98                	sw	a4,16(a5)
80004158:	a03d                	j	80004186 <osdp_tick_1ms+0x296>
			} else {
				led_ctrl.current_state = 1;
8000415a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000415e:	4705                	li	a4,1
80004160:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
80004164:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004168:	01e7c783          	lbu	a5,30(a5)
8000416c:	00f037b3          	snez	a5,a5
80004170:	0ff7f793          	zext.b	a5,a5
80004174:	853e                	mv	a0,a5
80004176:	e0aff0ef          	jal	ra,80003780 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
8000417a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000417e:	4bd8                	lw	a4,20(a5)
80004180:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004184:	cb98                	sw	a4,16(a5)
			}
		}
	}
}
80004186:	50b2                	lw	ra,44(sp)
80004188:	5422                	lw	s0,40(sp)
8000418a:	6145                	addi	sp,sp,48
8000418c:	8082                	ret

8000418e <handle_osdp_led>:

static void handle_osdp_led(uint8_t *data, uint16_t data_len)
{
8000418e:	711d                	addi	sp,sp,-96
80004190:	ce86                	sw	ra,92(sp)
80004192:	cca2                	sw	s0,88(sp)
80004194:	1080                	addi	s0,sp,96
80004196:	faa42623          	sw	a0,-84(s0)
8000419a:	87ae                	mv	a5,a1
8000419c:	faf41523          	sh	a5,-86(s0)
	// Стандартный формат: 14 байт на одну запись (Temporary+Permanent)
	// Temporary: code, on, off, on_color, off_color, timerLSB, timerMSB
	// Permanent: code, on, off, on_color, off_color
	if (data_len < 14) return;
800041a0:	faa45703          	lhu	a4,-86(s0)
800041a4:	47b5                	li	a5,13
800041a6:	3ee7f363          	bgeu	a5,a4,8000458c <handle_osdp_led+0x3fe>
	uint16_t count = (uint16_t)(data_len / 14u);
800041aa:	faa45703          	lhu	a4,-86(s0)
800041ae:	47b9                	li	a5,14
800041b0:	02f757b3          	divu	a5,a4,a5
800041b4:	fef41123          	sh	a5,-30(s0)
	for (uint16_t rec = 0; rec < count; rec++) {     // rec - запись
800041b8:	fe041723          	sh	zero,-18(s0)
800041bc:	a6c9                	j	8000457e <handle_osdp_led+0x3f0>
		uint8_t *p = &data[rec * 14u];
800041be:	fee45703          	lhu	a4,-18(s0)
800041c2:	87ba                	mv	a5,a4
800041c4:	078e                	slli	a5,a5,0x3
800041c6:	8f99                	sub	a5,a5,a4
800041c8:	0786                	slli	a5,a5,0x1
800041ca:	873e                	mv	a4,a5
800041cc:	fac42783          	lw	a5,-84(s0)
800041d0:	97ba                	add	a5,a5,a4
800041d2:	fcf42e23          	sw	a5,-36(s0)
		uint8_t reader = p[0];
800041d6:	fdc42783          	lw	a5,-36(s0)
800041da:	0007c783          	lbu	a5,0(a5)
800041de:	fcf40da3          	sb	a5,-37(s0)
		uint8_t lednum  = p[1];
800041e2:	fdc42783          	lw	a5,-36(s0)
800041e6:	0017c783          	lbu	a5,1(a5)
800041ea:	fcf40d23          	sb	a5,-38(s0)
		if (!(reader == 0 && lednum == 0)) continue; // у нас пока один LED: reader0, led0
800041ee:	fdb44783          	lbu	a5,-37(s0)
800041f2:	38079063          	bnez	a5,80004572 <handle_osdp_led+0x3e4>
800041f6:	fda44783          	lbu	a5,-38(s0)
800041fa:	36079c63          	bnez	a5,80004572 <handle_osdp_led+0x3e4>

		uint8_t tcode  = p[2];  // 0 - NOP, 1 - cancel, 2 - start now
800041fe:	fdc42783          	lw	a5,-36(s0)
80004202:	0027c783          	lbu	a5,2(a5)
80004206:	fcf40ca3          	sb	a5,-39(s0)
		uint8_t tOn100ms = p[3];
8000420a:	fdc42783          	lw	a5,-36(s0)
8000420e:	0037c783          	lbu	a5,3(a5)
80004212:	fcf40c23          	sb	a5,-40(s0)
		uint8_t tOff100ms = p[4];
80004216:	fdc42783          	lw	a5,-36(s0)
8000421a:	0047c783          	lbu	a5,4(a5)
8000421e:	fcf40ba3          	sb	a5,-41(s0)
		uint8_t tOnColor  = p[5];
80004222:	fdc42783          	lw	a5,-36(s0)
80004226:	0057c783          	lbu	a5,5(a5)
8000422a:	fcf40b23          	sb	a5,-42(s0)
		uint8_t tOffColor = p[6];
8000422e:	fdc42783          	lw	a5,-36(s0)
80004232:	0067c783          	lbu	a5,6(a5)
80004236:	fcf40aa3          	sb	a5,-43(s0)
		uint16_t timer100ms = (uint16_t)p[7] | ((uint16_t)p[8] << 8);
8000423a:	fdc42783          	lw	a5,-36(s0)
8000423e:	079d                	addi	a5,a5,7
80004240:	0007c783          	lbu	a5,0(a5)
80004244:	01079713          	slli	a4,a5,0x10
80004248:	8741                	srai	a4,a4,0x10
8000424a:	fdc42783          	lw	a5,-36(s0)
8000424e:	07a1                	addi	a5,a5,8
80004250:	0007c783          	lbu	a5,0(a5)
80004254:	07a2                	slli	a5,a5,0x8
80004256:	07c2                	slli	a5,a5,0x10
80004258:	87c1                	srai	a5,a5,0x10
8000425a:	8fd9                	or	a5,a5,a4
8000425c:	07c2                	slli	a5,a5,0x10
8000425e:	87c1                	srai	a5,a5,0x10
80004260:	fcf41923          	sh	a5,-46(s0)

		uint8_t pcode  = p[9];  // 0 - NOP, 1 - start now
80004264:	fdc42783          	lw	a5,-36(s0)
80004268:	0097c783          	lbu	a5,9(a5)
8000426c:	fcf408a3          	sb	a5,-47(s0)
		uint8_t pOn100ms = p[10];
80004270:	fdc42783          	lw	a5,-36(s0)
80004274:	00a7c783          	lbu	a5,10(a5)
80004278:	fcf40823          	sb	a5,-48(s0)
		uint8_t pOff100ms= p[11];
8000427c:	fdc42783          	lw	a5,-36(s0)
80004280:	00b7c783          	lbu	a5,11(a5)
80004284:	fcf407a3          	sb	a5,-49(s0)
		uint8_t pOnColor  = p[12];
80004288:	fdc42783          	lw	a5,-36(s0)
8000428c:	00c7c783          	lbu	a5,12(a5)
80004290:	fcf40723          	sb	a5,-50(s0)
		uint8_t pOffColor = p[13];
80004294:	fdc42783          	lw	a5,-36(s0)
80004298:	00d7c783          	lbu	a5,13(a5)
8000429c:	fcf406a3          	sb	a5,-51(s0)

		// Обновим постоянный профиль, если требуется
		if (pcode == 0x01) {
800042a0:	fd144703          	lbu	a4,-47(s0)
800042a4:	4785                	li	a5,1
800042a6:	0ef71d63          	bne	a4,a5,800043a0 <handle_osdp_led+0x212>
			uint32_t pOn_ms  = (uint32_t)pOn100ms  * 100u;
800042aa:	fd044703          	lbu	a4,-48(s0)
800042ae:	06400793          	li	a5,100
800042b2:	02f707b3          	mul	a5,a4,a5
800042b6:	fcf42423          	sw	a5,-56(s0)
			uint32_t pOff_ms = (uint32_t)pOff100ms * 100u;
800042ba:	fcf44703          	lbu	a4,-49(s0)
800042be:	06400793          	li	a5,100
800042c2:	02f707b3          	mul	a5,a4,a5
800042c6:	fcf42223          	sw	a5,-60(s0)
			led_ctrl.perm_on_ms  = pOn_ms;
800042ca:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800042ce:	fc842703          	lw	a4,-56(s0)
800042d2:	cbd8                	sw	a4,20(a5)
			led_ctrl.perm_off_ms = pOff_ms;
800042d4:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800042d8:	fc442703          	lw	a4,-60(s0)
800042dc:	cf98                	sw	a4,24(a5)
			led_ctrl.perm_on_color_is_on  = (pOnColor  != 0);
800042de:	fce44783          	lbu	a5,-50(s0)
800042e2:	00f037b3          	snez	a5,a5
800042e6:	0ff7f793          	zext.b	a5,a5
800042ea:	873e                	mv	a4,a5
800042ec:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800042f0:	00e78f23          	sb	a4,30(a5)
			led_ctrl.perm_off_color_is_on = (pOffColor != 0);
800042f4:	fcd44783          	lbu	a5,-51(s0)
800042f8:	00f037b3          	snez	a5,a5
800042fc:	0ff7f793          	zext.b	a5,a5
80004300:	873e                	mv	a4,a5
80004302:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004306:	00e78fa3          	sb	a4,31(a5)
			if (pOn_ms > 0 && pOff_ms == 0) {
8000430a:	fc842783          	lw	a5,-56(s0)
8000430e:	c385                	beqz	a5,8000432e <handle_osdp_led+0x1a0>
80004310:	fc442783          	lw	a5,-60(s0)
80004314:	ef89                	bnez	a5,8000432e <handle_osdp_led+0x1a0>
				led_ctrl.perm_state = (pOnColor != 0) ? 1 : 0; // цветом управляем "включённостью"
80004316:	fce44783          	lbu	a5,-50(s0)
8000431a:	00f037b3          	snez	a5,a5
8000431e:	0ff7f793          	zext.b	a5,a5
80004322:	873e                	mv	a4,a5
80004324:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004328:	00e780a3          	sb	a4,1(a5)
8000432c:	a015                	j	80004350 <handle_osdp_led+0x1c2>
			} else if (pOn_ms == 0 && pOff_ms > 0) {
8000432e:	fc842783          	lw	a5,-56(s0)
80004332:	ef99                	bnez	a5,80004350 <handle_osdp_led+0x1c2>
80004334:	fc442783          	lw	a5,-60(s0)
80004338:	cf81                	beqz	a5,80004350 <handle_osdp_led+0x1c2>
				led_ctrl.perm_state = (pOffColor != 0) ? 1 : 0;
8000433a:	fcd44783          	lbu	a5,-51(s0)
8000433e:	00f037b3          	snez	a5,a5
80004342:	0ff7f793          	zext.b	a5,a5
80004346:	873e                	mv	a4,a5
80004348:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000434c:	00e780a3          	sb	a4,1(a5)
			}
			// Если temp режима нет – применим сразу
			if (!led_ctrl.temp_active) {
80004350:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004354:	0007c783          	lbu	a5,0(a5)
80004358:	e7a1                	bnez	a5,800043a0 <handle_osdp_led+0x212>
				if (pOn_ms > 0 && pOff_ms > 0) {
8000435a:	fc842783          	lw	a5,-56(s0)
8000435e:	cb95                	beqz	a5,80004392 <handle_osdp_led+0x204>
80004360:	fc442783          	lw	a5,-60(s0)
80004364:	c79d                	beqz	a5,80004392 <handle_osdp_led+0x204>
					led_ctrl.current_state = 1;
80004366:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000436a:	4705                	li	a4,1
8000436c:	00e78123          	sb	a4,2(a5)
					set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
80004370:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004374:	01e7c783          	lbu	a5,30(a5)
80004378:	00f037b3          	snez	a5,a5
8000437c:	0ff7f793          	zext.b	a5,a5
80004380:	853e                	mv	a0,a5
80004382:	bfeff0ef          	jal	ra,80003780 <set_led_state>
					led_ctrl.phase_ms_left = pOn_ms;
80004386:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000438a:	fc842703          	lw	a4,-56(s0)
8000438e:	cb98                	sw	a4,16(a5)
80004390:	a801                	j	800043a0 <handle_osdp_led+0x212>
				} else {
					set_led_state(led_ctrl.perm_state);
80004392:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004396:	0017c783          	lbu	a5,1(a5)
8000439a:	853e                	mv	a0,a5
8000439c:	be4ff0ef          	jal	ra,80003780 <set_led_state>
		} else if (pcode == 0x00) {
			// Not use: NOP по стандарту — не изменяем постоянные настройки
		}

		// Temporary в соответствии со стандартом
		if (tcode == 0x00) {
800043a0:	fd944783          	lbu	a5,-39(s0)
800043a4:	1c078863          	beqz	a5,80004574 <handle_osdp_led+0x3e6>
			// NOP – не изменяем текущий временный режим
		} else if (tcode == 0x01) {
800043a8:	fd944703          	lbu	a4,-39(s0)
800043ac:	4785                	li	a5,1
800043ae:	06f71963          	bne	a4,a5,80004420 <handle_osdp_led+0x292>
			// выключить temp и показать permanent немедленно
			led_ctrl.temp_active = 0;
800043b2:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043b6:	00078023          	sb	zero,0(a5)
			if (led_ctrl.perm_on_ms > 0 && led_ctrl.perm_off_ms > 0) {
800043ba:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043be:	4bdc                	lw	a5,20(a5)
800043c0:	cf85                	beqz	a5,800043f8 <handle_osdp_led+0x26a>
800043c2:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043c6:	4f9c                	lw	a5,24(a5)
800043c8:	cb85                	beqz	a5,800043f8 <handle_osdp_led+0x26a>
				led_ctrl.current_state = 1;
800043ca:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043ce:	4705                	li	a4,1
800043d0:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_on_color_is_on ? 1 : 0);
800043d4:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043d8:	01e7c783          	lbu	a5,30(a5)
800043dc:	00f037b3          	snez	a5,a5
800043e0:	0ff7f793          	zext.b	a5,a5
800043e4:	853e                	mv	a0,a5
800043e6:	b9aff0ef          	jal	ra,80003780 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.perm_on_ms;
800043ea:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043ee:	4bd8                	lw	a4,20(a5)
800043f0:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043f4:	cb98                	sw	a4,16(a5)
800043f6:	aabd                	j	80004574 <handle_osdp_led+0x3e6>
			} else {
				led_ctrl.current_state = led_ctrl.perm_state;
800043f8:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800043fc:	0017c703          	lbu	a4,1(a5)
80004400:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004404:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.perm_state);
80004408:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000440c:	0017c783          	lbu	a5,1(a5)
80004410:	853e                	mv	a0,a5
80004412:	b6eff0ef          	jal	ra,80003780 <set_led_state>
				led_ctrl.phase_ms_left = 0;
80004416:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000441a:	0007a823          	sw	zero,16(a5)
8000441e:	aa99                	j	80004574 <handle_osdp_led+0x3e6>
			}
		} else if (tcode == 0x02) {
80004420:	fd944703          	lbu	a4,-39(s0)
80004424:	4789                	li	a5,2
80004426:	14f71763          	bne	a4,a5,80004574 <handle_osdp_led+0x3e6>
			// Установить временный режим немедленно и запустить таймер
			uint32_t on_ms  = (uint32_t)tOn100ms  * 100u;
8000442a:	fd844703          	lbu	a4,-40(s0)
8000442e:	06400793          	li	a5,100
80004432:	02f707b3          	mul	a5,a4,a5
80004436:	fcf42023          	sw	a5,-64(s0)
			uint32_t off_ms = (uint32_t)tOff100ms  * 100u;
8000443a:	fd744703          	lbu	a4,-41(s0)
8000443e:	06400793          	li	a5,100
80004442:	02f707b3          	mul	a5,a4,a5
80004446:	faf42e23          	sw	a5,-68(s0)
			led_ctrl.on_ms  = (on_ms  > 0) ? on_ms  : 0; //защита от отрицательных значений
8000444a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000444e:	fc042703          	lw	a4,-64(s0)
80004452:	c3d8                	sw	a4,4(a5)
			led_ctrl.off_ms = (off_ms > 0) ? off_ms : 0; 
80004454:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004458:	fbc42703          	lw	a4,-68(s0)
8000445c:	c798                	sw	a4,8(a5)
			led_ctrl.temp_on_color_is_on  = (tOnColor  != 0);
8000445e:	fd644783          	lbu	a5,-42(s0)
80004462:	00f037b3          	snez	a5,a5
80004466:	0ff7f793          	zext.b	a5,a5
8000446a:	873e                	mv	a4,a5
8000446c:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004470:	00e78e23          	sb	a4,28(a5)
			led_ctrl.temp_off_color_is_on = (tOffColor != 0);
80004474:	fd544783          	lbu	a5,-43(s0)
80004478:	00f037b3          	snez	a5,a5
8000447c:	0ff7f793          	zext.b	a5,a5
80004480:	873e                	mv	a4,a5
80004482:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004486:	00e78ea3          	sb	a4,29(a5)
			// Рассчитать количество циклов из таймера, если задан
			if (timer100ms == 0) {
8000448a:	fd245783          	lhu	a5,-46(s0)
8000448e:	e791                	bnez	a5,8000449a <handle_osdp_led+0x30c>
				led_ctrl.cycles_left = 0; // бесконечно
80004490:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004494:	00079623          	sh	zero,12(a5)
80004498:	a0bd                	j	80004506 <handle_osdp_led+0x378>
			} else {
				uint32_t period = (led_ctrl.on_ms + led_ctrl.off_ms);
8000449a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000449e:	43d8                	lw	a4,4(a5)
800044a0:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
800044a4:	479c                	lw	a5,8(a5)
800044a6:	97ba                	add	a5,a5,a4
800044a8:	fef42423          	sw	a5,-24(s0)
				if (period == 0) period = 100; // защита от деления на 0
800044ac:	fe842783          	lw	a5,-24(s0)
800044b0:	e789                	bnez	a5,800044ba <handle_osdp_led+0x32c>
800044b2:	06400793          	li	a5,100
800044b6:	fef42423          	sw	a5,-24(s0)
				uint32_t total_ms = (uint32_t)timer100ms * 100u;
800044ba:	fd245703          	lhu	a4,-46(s0)
800044be:	06400793          	li	a5,100
800044c2:	02f707b3          	mul	a5,a4,a5
800044c6:	faf42c23          	sw	a5,-72(s0)
				uint32_t cycles = total_ms / period;
800044ca:	fb842703          	lw	a4,-72(s0)
800044ce:	fe842783          	lw	a5,-24(s0)
800044d2:	02f757b3          	divu	a5,a4,a5
800044d6:	fef42223          	sw	a5,-28(s0)
				if (cycles == 0) cycles = 1;
800044da:	fe442783          	lw	a5,-28(s0)
800044de:	e781                	bnez	a5,800044e6 <handle_osdp_led+0x358>
800044e0:	4785                	li	a5,1
800044e2:	fef42223          	sw	a5,-28(s0)
				led_ctrl.cycles_left = (uint16_t)((cycles > 0xFFFFu) ? 0xFFFFu : cycles);
800044e6:	fe442703          	lw	a4,-28(s0)
800044ea:	67c1                	lui	a5,0x10
800044ec:	00f77763          	bgeu	a4,a5,800044fa <handle_osdp_led+0x36c>
800044f0:	fe442783          	lw	a5,-28(s0)
800044f4:	07c2                	slli	a5,a5,0x10
800044f6:	83c1                	srli	a5,a5,0x10
800044f8:	a019                	j	800044fe <handle_osdp_led+0x370>
800044fa:	67c1                	lui	a5,0x10
800044fc:	17fd                	addi	a5,a5,-1 # ffff <STACK_SIZE+0xf7ff>
800044fe:	f0018713          	addi	a4,gp,-256 # 40000680 <led_ctrl>
80004502:	00f71623          	sh	a5,12(a4)
			}
			// Стартовая фаза – включение, если on_ms > 0, иначе – выключение
			if (led_ctrl.on_ms > 0) {
80004506:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000450a:	43dc                	lw	a5,4(a5)
8000450c:	cb85                	beqz	a5,8000453c <handle_osdp_led+0x3ae>
				led_ctrl.current_state = 1;
8000450e:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004512:	4705                	li	a4,1
80004514:	00e78123          	sb	a4,2(a5)
				set_led_state(led_ctrl.temp_on_color_is_on ? 1 : 0);
80004518:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000451c:	01c7c783          	lbu	a5,28(a5)
80004520:	00f037b3          	snez	a5,a5
80004524:	0ff7f793          	zext.b	a5,a5
80004528:	853e                	mv	a0,a5
8000452a:	a56ff0ef          	jal	ra,80003780 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.on_ms;
8000452e:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004532:	43d8                	lw	a4,4(a5)
80004534:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004538:	cb98                	sw	a4,16(a5)
8000453a:	a035                	j	80004566 <handle_osdp_led+0x3d8>
			} else {
				led_ctrl.current_state = 0;
8000453c:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004540:	00078123          	sb	zero,2(a5)
				set_led_state(led_ctrl.temp_off_color_is_on ? 1 : 0);
80004544:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004548:	01d7c783          	lbu	a5,29(a5)
8000454c:	00f037b3          	snez	a5,a5
80004550:	0ff7f793          	zext.b	a5,a5
80004554:	853e                	mv	a0,a5
80004556:	a2aff0ef          	jal	ra,80003780 <set_led_state>
				led_ctrl.phase_ms_left = led_ctrl.off_ms;
8000455a:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000455e:	4798                	lw	a4,8(a5)
80004560:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
80004564:	cb98                	sw	a4,16(a5)
			}
			led_ctrl.temp_active = 1;
80004566:	f0018793          	addi	a5,gp,-256 # 40000680 <led_ctrl>
8000456a:	4705                	li	a4,1
8000456c:	00e78023          	sb	a4,0(a5)
80004570:	a011                	j	80004574 <handle_osdp_led+0x3e6>
		if (!(reader == 0 && lednum == 0)) continue; // у нас пока один LED: reader0, led0
80004572:	0001                	nop
	for (uint16_t rec = 0; rec < count; rec++) {     // rec - запись
80004574:	fee45783          	lhu	a5,-18(s0)
80004578:	0785                	addi	a5,a5,1
8000457a:	fef41723          	sh	a5,-18(s0)
8000457e:	fee45703          	lhu	a4,-18(s0)
80004582:	fe245783          	lhu	a5,-30(s0)
80004586:	c2f76ce3          	bltu	a4,a5,800041be <handle_osdp_led+0x30>
8000458a:	a011                	j	8000458e <handle_osdp_led+0x400>
	if (data_len < 14) return;
8000458c:	0001                	nop
		}
	}
}
8000458e:	40f6                	lw	ra,92(sp)
80004590:	4466                	lw	s0,88(sp)
80004592:	6125                	addi	sp,sp,96
80004594:	8082                	ret

80004596 <osdp_init>:


void osdp_init(void)
{
80004596:	1101                	addi	sp,sp,-32
80004598:	ce06                	sw	ra,28(sp)
8000459a:	cc22                	sw	s0,24(sp)
8000459c:	1000                	addi	s0,sp,32
	osdp_load_addr_baud();
8000459e:	ad9fe0ef          	jal	ra,80003076 <osdp_load_addr_baud>
	rx_state = st_wait_som;
800045a2:	e801a423          	sw	zero,-376(gp) # 40000608 <rx_state>
	rx_expected_len = 0;
800045a6:	e8019623          	sh	zero,-372(gp) # 4000060c <rx_expected_len>
	rx_pos = 0;
800045aa:	e8019723          	sh	zero,-370(gp) # 4000060e <rx_pos>
	
	// Инициализация состояния выходов
	for (uint8_t i = 0; i < 4; i++) {
800045ae:	fe0407a3          	sb	zero,-17(s0)
800045b2:	a8ad                	j	8000462c <osdp_init+0x96>
		output_ctrl[i].permanent_state = 0; // По умолчанию все выходы выключены
800045b4:	fef44703          	lbu	a4,-17(s0)
800045b8:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
800045bc:	87ba                	mv	a5,a4
800045be:	0786                	slli	a5,a5,0x1
800045c0:	97ba                	add	a5,a5,a4
800045c2:	078a                	slli	a5,a5,0x2
800045c4:	97b6                	add	a5,a5,a3
800045c6:	00078023          	sb	zero,0(a5)
		output_ctrl[i].temp_active = 0;
800045ca:	fef44703          	lbu	a4,-17(s0)
800045ce:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
800045d2:	87ba                	mv	a5,a4
800045d4:	0786                	slli	a5,a5,0x1
800045d6:	97ba                	add	a5,a5,a4
800045d8:	078a                	slli	a5,a5,0x2
800045da:	97b6                	add	a5,a5,a3
800045dc:	000780a3          	sb	zero,1(a5)
		output_ctrl[i].temp_state = 0;
800045e0:	fef44703          	lbu	a4,-17(s0)
800045e4:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
800045e8:	87ba                	mv	a5,a4
800045ea:	0786                	slli	a5,a5,0x1
800045ec:	97ba                	add	a5,a5,a4
800045ee:	078a                	slli	a5,a5,0x2
800045f0:	97b6                	add	a5,a5,a3
800045f2:	00078123          	sb	zero,2(a5)
		output_ctrl[i].timer_ms_left = 0;
800045f6:	fef44703          	lbu	a4,-17(s0)
800045fa:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
800045fe:	87ba                	mv	a5,a4
80004600:	0786                	slli	a5,a5,0x1
80004602:	97ba                	add	a5,a5,a4
80004604:	078a                	slli	a5,a5,0x2
80004606:	97b6                	add	a5,a5,a3
80004608:	0007a223          	sw	zero,4(a5)
		output_ctrl[i].allow_completion = 0;
8000460c:	fef44703          	lbu	a4,-17(s0)
80004610:	ed018693          	addi	a3,gp,-304 # 40000650 <output_ctrl>
80004614:	87ba                	mv	a5,a4
80004616:	0786                	slli	a5,a5,0x1
80004618:	97ba                	add	a5,a5,a4
8000461a:	078a                	slli	a5,a5,0x2
8000461c:	97b6                	add	a5,a5,a3
8000461e:	00078423          	sb	zero,8(a5)
	for (uint8_t i = 0; i < 4; i++) {
80004622:	fef44783          	lbu	a5,-17(s0)
80004626:	0785                	addi	a5,a5,1
80004628:	fef407a3          	sb	a5,-17(s0)
8000462c:	fef44703          	lbu	a4,-17(s0)
80004630:	478d                	li	a5,3
80004632:	f8e7f1e3          	bgeu	a5,a4,800045b4 <osdp_init+0x1e>
	}
}
80004636:	0001                	nop
80004638:	0001                	nop
8000463a:	40f2                	lw	ra,28(sp)
8000463c:	4462                	lw	s0,24(sp)
8000463e:	6105                	addi	sp,sp,32
80004640:	8082                	ret

80004642 <osdp_on_rx_byte>:

void osdp_on_rx_byte(uint8_t byte) // парсер входящих байтов
{
80004642:	715d                	addi	sp,sp,-80
80004644:	c686                	sw	ra,76(sp)
80004646:	c4a2                	sw	s0,72(sp)
80004648:	0880                	addi	s0,sp,80
8000464a:	87aa                	mv	a5,a0
8000464c:	faf40fa3          	sb	a5,-65(s0)
	switch (rx_state) {
80004650:	e881a783          	lw	a5,-376(gp) # 40000608 <rx_state>
80004654:	4711                	li	a4,4
80004656:	3ef76363          	bltu	a4,a5,80004a3c <osdp_on_rx_byte+0x3fa>
8000465a:	00279713          	slli	a4,a5,0x2
8000465e:	800097b7          	lui	a5,0x80009
80004662:	dd078793          	addi	a5,a5,-560 # 80008dd0 <__data_source_start+0xffffff7c>
80004666:	97ba                	add	a5,a5,a4
80004668:	439c                	lw	a5,0(a5)
8000466a:	8782                	jr	a5
	case st_wait_som:
		if (byte == OSDP_SOM) {
8000466c:	fbf44703          	lbu	a4,-65(s0)
80004670:	05300793          	li	a5,83
80004674:	3cf71763          	bne	a4,a5,80004a42 <osdp_on_rx_byte+0x400>
			rx_pos = 0;
80004678:	e8019723          	sh	zero,-370(gp) # 4000060e <rx_pos>
			rx_buf[rx_pos++] = byte;
8000467c:	e8e1d783          	lhu	a5,-370(gp) # 4000060e <rx_pos>
80004680:	00178713          	addi	a4,a5,1
80004684:	01071693          	slli	a3,a4,0x10
80004688:	82c1                	srli	a3,a3,0x10
8000468a:	e8d19723          	sh	a3,-370(gp) # 4000060e <rx_pos>
8000468e:	873e                	mv	a4,a5
80004690:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
80004694:	97ba                	add	a5,a5,a4
80004696:	fbf44703          	lbu	a4,-65(s0)
8000469a:	00e78023          	sb	a4,0(a5)
			rx_state = st_wait_addr;
8000469e:	4705                	li	a4,1
800046a0:	e8e1a423          	sw	a4,-376(gp) # 40000608 <rx_state>
		}
		break;
800046a4:	ae79                	j	80004a42 <osdp_on_rx_byte+0x400>
	case st_wait_addr:
		rx_buf[rx_pos++] = byte;
800046a6:	e8e1d783          	lhu	a5,-370(gp) # 4000060e <rx_pos>
800046aa:	00178713          	addi	a4,a5,1
800046ae:	01071693          	slli	a3,a4,0x10
800046b2:	82c1                	srli	a3,a3,0x10
800046b4:	e8d19723          	sh	a3,-370(gp) # 4000060e <rx_pos>
800046b8:	873e                	mv	a4,a5
800046ba:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
800046be:	97ba                	add	a5,a5,a4
800046c0:	fbf44703          	lbu	a4,-65(s0)
800046c4:	00e78023          	sb	a4,0(a5)
		rx_state = st_wait_len_l;
800046c8:	4709                	li	a4,2
800046ca:	e8e1a423          	sw	a4,-376(gp) # 40000608 <rx_state>
		break;
800046ce:	aead                	j	80004a48 <osdp_on_rx_byte+0x406>
	case st_wait_len_l:
		rx_buf[rx_pos++] = byte;
800046d0:	e8e1d783          	lhu	a5,-370(gp) # 4000060e <rx_pos>
800046d4:	00178713          	addi	a4,a5,1
800046d8:	01071693          	slli	a3,a4,0x10
800046dc:	82c1                	srli	a3,a3,0x10
800046de:	e8d19723          	sh	a3,-370(gp) # 4000060e <rx_pos>
800046e2:	873e                	mv	a4,a5
800046e4:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
800046e8:	97ba                	add	a5,a5,a4
800046ea:	fbf44703          	lbu	a4,-65(s0)
800046ee:	00e78023          	sb	a4,0(a5)
		rx_expected_len = byte;
800046f2:	fbf44783          	lbu	a5,-65(s0)
800046f6:	01079713          	slli	a4,a5,0x10
800046fa:	8341                	srli	a4,a4,0x10
800046fc:	e8e19623          	sh	a4,-372(gp) # 4000060c <rx_expected_len>
		rx_state = st_wait_len_m;
80004700:	470d                	li	a4,3
80004702:	e8e1a423          	sw	a4,-376(gp) # 40000608 <rx_state>
		break;
80004706:	a689                	j	80004a48 <osdp_on_rx_byte+0x406>
	case st_wait_len_m:
		rx_buf[rx_pos++] = byte;
80004708:	e8e1d783          	lhu	a5,-370(gp) # 4000060e <rx_pos>
8000470c:	00178713          	addi	a4,a5,1
80004710:	01071693          	slli	a3,a4,0x10
80004714:	82c1                	srli	a3,a3,0x10
80004716:	e8d19723          	sh	a3,-370(gp) # 4000060e <rx_pos>
8000471a:	873e                	mv	a4,a5
8000471c:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
80004720:	97ba                	add	a5,a5,a4
80004722:	fbf44703          	lbu	a4,-65(s0)
80004726:	00e78023          	sb	a4,0(a5)
		rx_expected_len |= ((uint16_t)byte << 8);
8000472a:	fbf44783          	lbu	a5,-65(s0)
8000472e:	07a2                	slli	a5,a5,0x8
80004730:	01079713          	slli	a4,a5,0x10
80004734:	8741                	srai	a4,a4,0x10
80004736:	e8c1d783          	lhu	a5,-372(gp) # 4000060c <rx_expected_len>
8000473a:	07c2                	slli	a5,a5,0x10
8000473c:	87c1                	srai	a5,a5,0x10
8000473e:	8fd9                	or	a5,a5,a4
80004740:	07c2                	slli	a5,a5,0x10
80004742:	87c1                	srai	a5,a5,0x10
80004744:	01079713          	slli	a4,a5,0x10
80004748:	8341                	srli	a4,a4,0x10
8000474a:	e8e19623          	sh	a4,-372(gp) # 4000060c <rx_expected_len>
		if (rx_expected_len < 8 || rx_expected_len > sizeof(rx_buf)) {
8000474e:	e8c1d703          	lhu	a4,-372(gp) # 4000060c <rx_expected_len>
80004752:	479d                	li	a5,7
80004754:	00e7f863          	bgeu	a5,a4,80004764 <osdp_on_rx_byte+0x122>
80004758:	e8c1d703          	lhu	a4,-372(gp) # 4000060c <rx_expected_len>
8000475c:	04000793          	li	a5,64
80004760:	00e7f563          	bgeu	a5,a4,8000476a <osdp_on_rx_byte+0x128>
			// некорректная длина — сброс
			rx_state = st_wait_som;
80004764:	e801a423          	sw	zero,-376(gp) # 40000608 <rx_state>
			break;
80004768:	a4c5                	j	80004a48 <osdp_on_rx_byte+0x406>
		}
		rx_state = st_receive_bytes;
8000476a:	4711                	li	a4,4
8000476c:	e8e1a423          	sw	a4,-376(gp) # 40000608 <rx_state>
		break;
80004770:	ace1                	j	80004a48 <osdp_on_rx_byte+0x406>
	case st_receive_bytes:
		rx_buf[rx_pos++] = byte;
80004772:	e8e1d783          	lhu	a5,-370(gp) # 4000060e <rx_pos>
80004776:	00178713          	addi	a4,a5,1
8000477a:	01071693          	slli	a3,a4,0x10
8000477e:	82c1                	srli	a3,a3,0x10
80004780:	e8d19723          	sh	a3,-370(gp) # 4000060e <rx_pos>
80004784:	873e                	mv	a4,a5
80004786:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
8000478a:	97ba                	add	a5,a5,a4
8000478c:	fbf44703          	lbu	a4,-65(s0)
80004790:	00e78023          	sb	a4,0(a5)
		if (rx_pos >= rx_expected_len) {
80004794:	e8e1d703          	lhu	a4,-370(gp) # 4000060e <rx_pos>
80004798:	e8c1d783          	lhu	a5,-372(gp) # 4000060c <rx_expected_len>
8000479c:	2af76563          	bltu	a4,a5,80004a46 <osdp_on_rx_byte+0x404>
			// Проверка CRC
			if (osdp_crc_is_ok(rx_buf, rx_expected_len)) {
800047a0:	e8c1d783          	lhu	a5,-372(gp) # 4000060c <rx_expected_len>
800047a4:	85be                	mv	a1,a5
800047a6:	e9018513          	addi	a0,gp,-368 # 40000610 <rx_buf>
800047aa:	fd0fe0ef          	jal	ra,80002f7a <osdp_crc_is_ok>
800047ae:	87aa                	mv	a5,a0
800047b0:	22078263          	beqz	a5,800049d4 <osdp_on_rx_byte+0x392>
				uint8_t addr = (uint8_t)(rx_buf[1] & 0x7F);
800047b4:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
800047b8:	0017c783          	lbu	a5,1(a5)
800047bc:	07f7f793          	andi	a5,a5,127
800047c0:	fef40623          	sb	a5,-20(s0)
				if (addr == g_addr || addr == 0x7F || addr == 0x00) {
800047c4:	e801c783          	lbu	a5,-384(gp) # 40000600 <g_addr>
800047c8:	fec44703          	lbu	a4,-20(s0)
800047cc:	00f70c63          	beq	a4,a5,800047e4 <osdp_on_rx_byte+0x1a2>
800047d0:	fec44703          	lbu	a4,-20(s0)
800047d4:	07f00793          	li	a5,127
800047d8:	00f70663          	beq	a4,a5,800047e4 <osdp_on_rx_byte+0x1a2>
800047dc:	fec44783          	lbu	a5,-20(s0)
800047e0:	24079b63          	bnez	a5,80004a36 <osdp_on_rx_byte+0x3f4>
					uint8_t ctrl = rx_buf[4];
800047e4:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
800047e8:	0047c783          	lbu	a5,4(a5)
800047ec:	fef405a3          	sb	a5,-21(s0)
					uint8_t seq = (uint8_t)(ctrl & 0x03);
800047f0:	feb44783          	lbu	a5,-21(s0)
800047f4:	8b8d                	andi	a5,a5,3
800047f6:	fef40523          	sb	a5,-22(s0)
					uint8_t cmd = rx_buf[5];
800047fa:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
800047fe:	0057c783          	lbu	a5,5(a5)
80004802:	fef404a3          	sb	a5,-23(s0)
					// На широковещательный (0x7F) отвечать нельзя
					char should_reply = (addr != 0x7F);
80004806:	fec44783          	lbu	a5,-20(s0)
8000480a:	f8178793          	addi	a5,a5,-127
8000480e:	00f037b3          	snez	a5,a5
80004812:	0ff7f793          	zext.b	a5,a5
80004816:	fef40423          	sb	a5,-24(s0)
					switch (cmd) {
8000481a:	fe944783          	lbu	a5,-23(s0)
8000481e:	fa078793          	addi	a5,a5,-96
80004822:	4739                	li	a4,14
80004824:	18f76e63          	bltu	a4,a5,800049c0 <osdp_on_rx_byte+0x37e>
80004828:	00279713          	slli	a4,a5,0x2
8000482c:	800097b7          	lui	a5,0x80009
80004830:	de478793          	addi	a5,a5,-540 # 80008de4 <__data_source_start+0xffffff90>
80004834:	97ba                	add	a5,a5,a4
80004836:	439c                	lw	a5,0(a5)
80004838:	8782                	jr	a5
					case osdp_POLL:
						if (should_reply) osdp_build_and_send_ack(seq);
8000483a:	fe844783          	lbu	a5,-24(s0)
8000483e:	1c078b63          	beqz	a5,80004a14 <osdp_on_rx_byte+0x3d2>
80004842:	fea44783          	lbu	a5,-22(s0)
80004846:	853e                	mv	a0,a5
80004848:	aa9fe0ef          	jal	ra,800032f0 <osdp_build_and_send_ack>
						break;
8000484c:	a2e1                	j	80004a14 <osdp_on_rx_byte+0x3d2>
					case osdp_ID:
						if (should_reply) osdp_build_and_send_pdid(seq);
8000484e:	fe844783          	lbu	a5,-24(s0)
80004852:	1c078363          	beqz	a5,80004a18 <osdp_on_rx_byte+0x3d6>
80004856:	fea44783          	lbu	a5,-22(s0)
8000485a:	853e                	mv	a0,a5
8000485c:	b79fe0ef          	jal	ra,800033d4 <osdp_build_and_send_pdid>
						break;
80004860:	aa65                	j	80004a18 <osdp_on_rx_byte+0x3d6>
					case osdp_CAP:
						if (should_reply) osdp_build_and_send_pdcap(seq);
80004862:	fe844783          	lbu	a5,-24(s0)
80004866:	1a078b63          	beqz	a5,80004a1c <osdp_on_rx_byte+0x3da>
8000486a:	fea44783          	lbu	a5,-22(s0)
8000486e:	853e                	mv	a0,a5
80004870:	c71fe0ef          	jal	ra,800034e0 <osdp_build_and_send_pdcap>
						break;
80004874:	a265                	j	80004a1c <osdp_on_rx_byte+0x3da>
					case osdp_ISTAT:
						if (should_reply) osdp_build_and_send_istat(seq);
80004876:	fe844783          	lbu	a5,-24(s0)
8000487a:	1a078363          	beqz	a5,80004a20 <osdp_on_rx_byte+0x3de>
8000487e:	fea44783          	lbu	a5,-22(s0)
80004882:	853e                	mv	a0,a5
80004884:	f69fe0ef          	jal	ra,800037ec <osdp_build_and_send_istat>
						break;
80004888:	aa61                	j	80004a20 <osdp_on_rx_byte+0x3de>
					case osdp_OSTAT:
						if (should_reply) osdp_build_and_send_ostat(seq);
8000488a:	fe844783          	lbu	a5,-24(s0)
8000488e:	18078b63          	beqz	a5,80004a24 <osdp_on_rx_byte+0x3e2>
80004892:	fea44783          	lbu	a5,-22(s0)
80004896:	853e                	mv	a0,a5
80004898:	85aff0ef          	jal	ra,800038f2 <osdp_build_and_send_ostat>
						break;
8000489c:	a261                	j	80004a24 <osdp_on_rx_byte+0x3e2>
					case osdp_COMSET: {
						// Ожидаем 5 байт данных: [addr][baud L][baud H][baud HH][baud HHH]
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
8000489e:	e8c1d783          	lhu	a5,-372(gp) # 4000060c <rx_expected_len>
800048a2:	17e1                	addi	a5,a5,-8
800048a4:	fef41323          	sh	a5,-26(s0)
						if (data_len == 5) {
800048a8:	fe645703          	lhu	a4,-26(s0)
800048ac:	4795                	li	a5,5
800048ae:	08f71d63          	bne	a4,a5,80004948 <osdp_on_rx_byte+0x306>
							uint8_t *data = &rx_buf[6];
800048b2:	e9618793          	addi	a5,gp,-362 # 40000616 <rx_buf+0x6>
800048b6:	fef42023          	sw	a5,-32(s0)
							uint8_t new_addr = (uint8_t)(data[0] & 0x7F);
800048ba:	fe042783          	lw	a5,-32(s0)
800048be:	0007c783          	lbu	a5,0(a5)
800048c2:	07f7f793          	andi	a5,a5,127
800048c6:	fcf40fa3          	sb	a5,-33(s0)
							uint32_t new_baud = (uint32_t)data[1] |
800048ca:	fe042783          	lw	a5,-32(s0)
800048ce:	0785                	addi	a5,a5,1
800048d0:	0007c783          	lbu	a5,0(a5)
800048d4:	873e                	mv	a4,a5
							                    ((uint32_t)data[2] << 8) |
800048d6:	fe042783          	lw	a5,-32(s0)
800048da:	0789                	addi	a5,a5,2
800048dc:	0007c783          	lbu	a5,0(a5)
800048e0:	07a2                	slli	a5,a5,0x8
							uint32_t new_baud = (uint32_t)data[1] |
800048e2:	8f5d                	or	a4,a4,a5
							                    ((uint32_t)data[3] << 16) |
800048e4:	fe042783          	lw	a5,-32(s0)
800048e8:	078d                	addi	a5,a5,3
800048ea:	0007c783          	lbu	a5,0(a5)
800048ee:	07c2                	slli	a5,a5,0x10
							                    ((uint32_t)data[2] << 8) |
800048f0:	8f5d                	or	a4,a4,a5
							                    ((uint32_t)data[4] << 24);
800048f2:	fe042783          	lw	a5,-32(s0)
800048f6:	0791                	addi	a5,a5,4
800048f8:	0007c783          	lbu	a5,0(a5)
800048fc:	07e2                	slli	a5,a5,0x18
							uint32_t new_baud = (uint32_t)data[1] |
800048fe:	8fd9                	or	a5,a5,a4
80004900:	fcf42c23          	sw	a5,-40(s0)
							// Отправим ответ osdp_COM с теми же параметрами
							if (should_reply) osdp_build_and_send_com(seq, new_addr, new_baud);
80004904:	fe844783          	lbu	a5,-24(s0)
80004908:	cb99                	beqz	a5,8000491e <osdp_on_rx_byte+0x2dc>
8000490a:	fdf44703          	lbu	a4,-33(s0)
8000490e:	fea44783          	lbu	a5,-22(s0)
80004912:	fd842603          	lw	a2,-40(s0)
80004916:	85ba                	mv	a1,a4
80004918:	853e                	mv	a0,a5
8000491a:	cb1fe0ef          	jal	ra,800035ca <osdp_build_and_send_com>
							// Применим локально: адрес и скорость UART
							g_addr = new_addr;
8000491e:	fdf44703          	lbu	a4,-33(s0)
80004922:	e8e18023          	sb	a4,-384(gp) # 40000600 <g_addr>
							if (new_baud >= 1200 && new_baud <= 921600) {
80004926:	fd842703          	lw	a4,-40(s0)
8000492a:	4af00793          	li	a5,1199
8000492e:	0ee7fd63          	bgeu	a5,a4,80004a28 <osdp_on_rx_byte+0x3e6>
80004932:	fd842703          	lw	a4,-40(s0)
80004936:	000e17b7          	lui	a5,0xe1
8000493a:	0ee7e763          	bltu	a5,a4,80004a28 <osdp_on_rx_byte+0x3e6>
								set_uart_baud(new_baud);
8000493e:	fd842503          	lw	a0,-40(s0)
80004942:	ca0ff0ef          	jal	ra,80003de2 <set_uart_baud>
							}
						} else {
							// Неправильная длина — NAK (reason 0x02: invalid length)
							if (should_reply) osdp_build_and_send_nak(seq, 0x02);
						}
						break;
80004946:	a0cd                	j	80004a28 <osdp_on_rx_byte+0x3e6>
							if (should_reply) osdp_build_and_send_nak(seq, 0x02);
80004948:	fe844783          	lbu	a5,-24(s0)
8000494c:	0c078e63          	beqz	a5,80004a28 <osdp_on_rx_byte+0x3e6>
80004950:	fea44783          	lbu	a5,-22(s0)
80004954:	4589                	li	a1,2
80004956:	853e                	mv	a0,a5
80004958:	9fbfe0ef          	jal	ra,80003352 <osdp_build_and_send_nak>
						break;
8000495c:	a0f1                	j	80004a28 <osdp_on_rx_byte+0x3e6>
					}
					case osdp_LED: {
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
8000495e:	e8c1d783          	lhu	a5,-372(gp) # 4000060c <rx_expected_len>
80004962:	17e1                	addi	a5,a5,-8 # e0ff8 <STACK_SIZE+0xe07f8>
80004964:	fcf41b23          	sh	a5,-42(s0)
						uint8_t *data = &rx_buf[6];
80004968:	e9618793          	addi	a5,gp,-362 # 40000616 <rx_buf+0x6>
8000496c:	fcf42823          	sw	a5,-48(s0)
						handle_osdp_led(data, data_len);
80004970:	fd645783          	lhu	a5,-42(s0)
80004974:	85be                	mv	a1,a5
80004976:	fd042503          	lw	a0,-48(s0)
8000497a:	3811                	jal	8000418e <handle_osdp_led>
						if (should_reply) osdp_build_and_send_ack(seq);
8000497c:	fe844783          	lbu	a5,-24(s0)
80004980:	c7d5                	beqz	a5,80004a2c <osdp_on_rx_byte+0x3ea>
80004982:	fea44783          	lbu	a5,-22(s0)
80004986:	853e                	mv	a0,a5
80004988:	969fe0ef          	jal	ra,800032f0 <osdp_build_and_send_ack>
						break;
8000498c:	a045                	j	80004a2c <osdp_on_rx_byte+0x3ea>
					}
					case osdp_OUT: {
						uint16_t data_len = (uint16_t)(rx_expected_len - 8);
8000498e:	e8c1d783          	lhu	a5,-372(gp) # 4000060c <rx_expected_len>
80004992:	17e1                	addi	a5,a5,-8
80004994:	fcf41723          	sh	a5,-50(s0)
						uint8_t *data = &rx_buf[6];
80004998:	e9618793          	addi	a5,gp,-362 # 40000616 <rx_buf+0x6>
8000499c:	fcf42423          	sw	a5,-56(s0)
						handle_osdp_out(data, data_len);
800049a0:	fce45783          	lhu	a5,-50(s0)
800049a4:	85be                	mv	a1,a5
800049a6:	fc842503          	lw	a0,-56(s0)
800049aa:	854ff0ef          	jal	ra,800039fe <handle_osdp_out>
						if (should_reply) osdp_build_and_send_ack(seq);
800049ae:	fe844783          	lbu	a5,-24(s0)
800049b2:	cfbd                	beqz	a5,80004a30 <osdp_on_rx_byte+0x3ee>
800049b4:	fea44783          	lbu	a5,-22(s0)
800049b8:	853e                	mv	a0,a5
800049ba:	937fe0ef          	jal	ra,800032f0 <osdp_build_and_send_ack>
						break;
800049be:	a88d                	j	80004a30 <osdp_on_rx_byte+0x3ee>
					}
					default:
						// Неизвестная команда — NAK (reason 0x03: unknown command)
						if (should_reply) osdp_build_and_send_nak(seq, 0x03);
800049c0:	fe844783          	lbu	a5,-24(s0)
800049c4:	cba5                	beqz	a5,80004a34 <osdp_on_rx_byte+0x3f2>
800049c6:	fea44783          	lbu	a5,-22(s0)
800049ca:	458d                	li	a1,3
800049cc:	853e                	mv	a0,a5
800049ce:	985fe0ef          	jal	ra,80003352 <osdp_build_and_send_nak>
						break;
800049d2:	a08d                	j	80004a34 <osdp_on_rx_byte+0x3f2>
					}
				}
			} else {
				// Плохая CRC — NAK (reason 0x01), если это не широковещательный адрес
				uint8_t addr = (uint8_t)(rx_buf[1] & 0x7F);
800049d4:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
800049d8:	0017c783          	lbu	a5,1(a5)
800049dc:	07f7f793          	andi	a5,a5,127
800049e0:	fef407a3          	sb	a5,-17(s0)
				if (addr != 0x7F) {
800049e4:	fef44703          	lbu	a4,-17(s0)
800049e8:	07f00793          	li	a5,127
800049ec:	04f70563          	beq	a4,a5,80004a36 <osdp_on_rx_byte+0x3f4>
					uint8_t ctrl = rx_buf[4];
800049f0:	e9018793          	addi	a5,gp,-368 # 40000610 <rx_buf>
800049f4:	0047c783          	lbu	a5,4(a5)
800049f8:	fef40723          	sb	a5,-18(s0)
					uint8_t seq = (uint8_t)(ctrl & 0x03);
800049fc:	fee44783          	lbu	a5,-18(s0)
80004a00:	8b8d                	andi	a5,a5,3
80004a02:	fef406a3          	sb	a5,-19(s0)
					osdp_build_and_send_nak(seq, 0x01);
80004a06:	fed44783          	lbu	a5,-19(s0)
80004a0a:	4585                	li	a1,1
80004a0c:	853e                	mv	a0,a5
80004a0e:	945fe0ef          	jal	ra,80003352 <osdp_build_and_send_nak>
80004a12:	a015                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a14:	0001                	nop
80004a16:	a005                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a18:	0001                	nop
80004a1a:	a831                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a1c:	0001                	nop
80004a1e:	a821                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a20:	0001                	nop
80004a22:	a811                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a24:	0001                	nop
80004a26:	a801                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a28:	0001                	nop
80004a2a:	a031                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a2c:	0001                	nop
80004a2e:	a021                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a30:	0001                	nop
80004a32:	a011                	j	80004a36 <osdp_on_rx_byte+0x3f4>
						break;
80004a34:	0001                	nop
				}
			}
			// Готовы к следующему пакету
			rx_state = st_wait_som;
80004a36:	e801a423          	sw	zero,-376(gp) # 40000608 <rx_state>
		}
		break;
80004a3a:	a031                	j	80004a46 <osdp_on_rx_byte+0x404>
	default:
		rx_state = st_wait_som;
80004a3c:	e801a423          	sw	zero,-376(gp) # 40000608 <rx_state>
		break;
80004a40:	a021                	j	80004a48 <osdp_on_rx_byte+0x406>
		break;
80004a42:	0001                	nop
80004a44:	a011                	j	80004a48 <osdp_on_rx_byte+0x406>
		break;
80004a46:	0001                	nop
	}
}
80004a48:	0001                	nop
80004a4a:	40b6                	lw	ra,76(sp)
80004a4c:	4426                	lw	s0,72(sp)
80004a4e:	6161                	addi	sp,sp,80
80004a50:	8082                	ret

80004a52 <RCU_ADCSARRstCmd>:
  * @brief   Cнятие сброса АЦП
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void RCU_ADCSARRstCmd(FunctionalState State)
{
80004a52:	1101                	addi	sp,sp,-32
80004a54:	ce22                	sw	s0,28(sp)
80004a56:	1000                	addi	s0,sp,32
80004a58:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(RCU->ADCSARCLKCFG_bit.RSTDIS, State);
80004a5c:	3000e7b7          	lui	a5,0x3000e
80004a60:	fec42703          	lw	a4,-20(s0)
80004a64:	8b05                	andi	a4,a4,1
80004a66:	0ff77713          	zext.b	a4,a4
80004a6a:	8b05                	andi	a4,a4,1
80004a6c:	0722                	slli	a4,a4,0x8
80004a6e:	0b07a683          	lw	a3,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80004a72:	eff6f693          	andi	a3,a3,-257
80004a76:	8f55                	or	a4,a4,a3
80004a78:	0ae7a823          	sw	a4,176(a5)
}
80004a7c:	0001                	nop
80004a7e:	4472                	lw	s0,28(sp)
80004a80:	6105                	addi	sp,sp,32
80004a82:	8082                	ret

80004a84 <ADCSAR_SEQ_SwStartEnCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SwStartEnCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80004a84:	1101                	addi	sp,sp,-32
80004a86:	ce22                	sw	s0,28(sp)
80004a88:	1000                	addi	s0,sp,32
80004a8a:	fea42623          	sw	a0,-20(s0)
80004a8e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQSYNC, 1 << (uint32_t)SEQ_Num, State << (uint32_t)SEQ_Num);
80004a92:	300107b7          	lui	a5,0x30010
80004a96:	43dc                	lw	a5,4(a5)
80004a98:	fec42703          	lw	a4,-20(s0)
80004a9c:	4685                	li	a3,1
80004a9e:	00e69733          	sll	a4,a3,a4
80004aa2:	fff74713          	not	a4,a4
80004aa6:	00e7f6b3          	and	a3,a5,a4
80004aaa:	fec42783          	lw	a5,-20(s0)
80004aae:	fe842703          	lw	a4,-24(s0)
80004ab2:	00f71733          	sll	a4,a4,a5
80004ab6:	300107b7          	lui	a5,0x30010
80004aba:	8f55                	or	a4,a4,a3
80004abc:	c3d8                	sw	a4,4(a5)
}
80004abe:	0001                	nop
80004ac0:	4472                	lw	s0,28(sp)
80004ac2:	6105                	addi	sp,sp,32
80004ac4:	8082                	ret

80004ac6 <ADCSAR_SEQ_StartEventConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   StartEvent  Выбор события
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_StartEventConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_StartEvent_TypeDef StartEvent)
{
80004ac6:	1101                	addi	sp,sp,-32
80004ac8:	ce22                	sw	s0,28(sp)
80004aca:	1000                	addi	s0,sp,32
80004acc:	fea42623          	sw	a0,-20(s0)
80004ad0:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));

    MODIFY_REG(ADCSAR->EMUX, 0xF << ((uint32_t)SEQ_Num * 4), StartEvent << ((uint32_t)SEQ_Num * 4));
80004ad4:	300107b7          	lui	a5,0x30010
80004ad8:	4fdc                	lw	a5,28(a5)
80004ada:	fec42703          	lw	a4,-20(s0)
80004ade:	070a                	slli	a4,a4,0x2
80004ae0:	46bd                	li	a3,15
80004ae2:	00e69733          	sll	a4,a3,a4
80004ae6:	fff74713          	not	a4,a4
80004aea:	00e7f6b3          	and	a3,a5,a4
80004aee:	fec42783          	lw	a5,-20(s0)
80004af2:	078a                	slli	a5,a5,0x2
80004af4:	fe842703          	lw	a4,-24(s0)
80004af8:	00f71733          	sll	a4,a4,a5
80004afc:	300107b7          	lui	a5,0x30010
80004b00:	8f55                	or	a4,a4,a3
80004b02:	cfd8                	sw	a4,28(a5)
}
80004b04:	0001                	nop
80004b06:	4472                	lw	s0,28(sp)
80004b08:	6105                	addi	sp,sp,32
80004b0a:	8082                	ret

80004b0c <ADCSAR_SEQ_ReqMaxConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   ReqNumMax  Номер последнего запроса
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqMaxConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_ReqNum_TypeDef ReqNumMax)
{
80004b0c:	1101                	addi	sp,sp,-32
80004b0e:	ce22                	sw	s0,28(sp)
80004b10:	1000                	addi	s0,sp,32
80004b12:	fea42623          	sw	a0,-20(s0)
80004b16:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_REQ_NUM(ReqNumMax));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.RQMAX, ReqNumMax);
80004b1a:	300106b7          	lui	a3,0x30010
80004b1e:	fe842783          	lw	a5,-24(s0)
80004b22:	8b9d                	andi	a5,a5,7
80004b24:	0ff7f713          	zext.b	a4,a5
80004b28:	fec42783          	lw	a5,-20(s0)
80004b2c:	079a                	slli	a5,a5,0x6
80004b2e:	97b6                	add	a5,a5,a3
80004b30:	8b1d                	andi	a4,a4,7
80004b32:	0587d683          	lhu	a3,88(a5) # 30010058 <STACK_SIZE+0x3000f858>
80004b36:	9ae1                	andi	a3,a3,-8
80004b38:	8f55                	or	a4,a4,a3
80004b3a:	04e79c23          	sh	a4,88(a5)
}
80004b3e:	0001                	nop
80004b40:	4472                	lw	s0,28(sp)
80004b42:	6105                	addi	sp,sp,32
80004b44:	8082                	ret

80004b46 <ADCSAR_SEQ_ReqAverageConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   Average  Выбор режима усреднения
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqAverageConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_Average_TypeDef Average)
{
80004b46:	1101                	addi	sp,sp,-32
80004b48:	ce22                	sw	s0,28(sp)
80004b4a:	1000                	addi	s0,sp,32
80004b4c:	fea42623          	sw	a0,-20(s0)
80004b50:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_AVERAGE(Average));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.QAVGVAL, Average);
80004b54:	300106b7          	lui	a3,0x30010
80004b58:	fe842783          	lw	a5,-24(s0)
80004b5c:	8b9d                	andi	a5,a5,7
80004b5e:	0ff7f713          	zext.b	a4,a5
80004b62:	fec42783          	lw	a5,-20(s0)
80004b66:	079a                	slli	a5,a5,0x6
80004b68:	97b6                	add	a5,a5,a3
80004b6a:	8b1d                	andi	a4,a4,7
80004b6c:	00971613          	slli	a2,a4,0x9
80004b70:	0587d703          	lhu	a4,88(a5)
80004b74:	86ba                	mv	a3,a4
80004b76:	777d                	lui	a4,0xfffff
80004b78:	1ff70713          	addi	a4,a4,511 # fffff1ff <__data_source_start+0x7fff63ab>
80004b7c:	8f75                	and	a4,a4,a3
80004b7e:	86ba                	mv	a3,a4
80004b80:	8732                	mv	a4,a2
80004b82:	8f55                	or	a4,a4,a3
80004b84:	04e79c23          	sh	a4,88(a5)
}
80004b88:	0001                	nop
80004b8a:	4472                	lw	s0,28(sp)
80004b8c:	6105                	addi	sp,sp,32
80004b8e:	8082                	ret

80004b90 <ADCSAR_SEQ_ReqAverageCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_ReqAverageCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80004b90:	1101                	addi	sp,sp,-32
80004b92:	ce22                	sw	s0,28(sp)
80004b94:	1000                	addi	s0,sp,32
80004b96:	fea42623          	sw	a0,-20(s0)
80004b9a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRQCTL_bit.QAVGEN, State);
80004b9e:	300106b7          	lui	a3,0x30010
80004ba2:	fe842783          	lw	a5,-24(s0)
80004ba6:	8b85                	andi	a5,a5,1
80004ba8:	0ff7f713          	zext.b	a4,a5
80004bac:	fec42783          	lw	a5,-20(s0)
80004bb0:	079a                	slli	a5,a5,0x6
80004bb2:	97b6                	add	a5,a5,a3
80004bb4:	8b05                	andi	a4,a4,1
80004bb6:	0722                	slli	a4,a4,0x8
80004bb8:	0587d683          	lhu	a3,88(a5)
80004bbc:	eff6f693          	andi	a3,a3,-257
80004bc0:	8f55                	or	a4,a4,a3
80004bc2:	04e79c23          	sh	a4,88(a5)
}
80004bc6:	0001                	nop
80004bc8:	4472                	lw	s0,28(sp)
80004bca:	6105                	addi	sp,sp,32
80004bcc:	8082                	ret

80004bce <ADCSAR_SEQ_DMAConfig>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   DMAFIFOLevel  Выбор уровня заполнения буфера для генерации запросов DMA
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DMAConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_DMAFIFOLevel_TypeDef DMAFIFOLevel)
{
80004bce:	1101                	addi	sp,sp,-32
80004bd0:	ce22                	sw	s0,28(sp)
80004bd2:	1000                	addi	s0,sp,32
80004bd4:	fea42623          	sw	a0,-20(s0)
80004bd8:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_DMA_FIFO_LEVEL(DMAFIFOLevel));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SDMACTL_bit.WMARK, DMAFIFOLevel);
80004bdc:	300106b7          	lui	a3,0x30010
80004be0:	fe842783          	lw	a5,-24(s0)
80004be4:	8b9d                	andi	a5,a5,7
80004be6:	0ff7f713          	zext.b	a4,a5
80004bea:	fec42783          	lw	a5,-20(s0)
80004bee:	079a                	slli	a5,a5,0x6
80004bf0:	97b6                	add	a5,a5,a3
80004bf2:	8b1d                	andi	a4,a4,7
80004bf4:	0722                	slli	a4,a4,0x8
80004bf6:	0607d683          	lhu	a3,96(a5)
80004bfa:	8ff6f693          	andi	a3,a3,-1793
80004bfe:	8f55                	or	a4,a4,a3
80004c00:	06e79023          	sh	a4,96(a5)
}
80004c04:	0001                	nop
80004c06:	4472                	lw	s0,28(sp)
80004c08:	6105                	addi	sp,sp,32
80004c0a:	8082                	ret

80004c0c <ADCSAR_SEQ_DMACmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DMACmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80004c0c:	1101                	addi	sp,sp,-32
80004c0e:	ce22                	sw	s0,28(sp)
80004c10:	1000                	addi	s0,sp,32
80004c12:	fea42623          	sw	a0,-20(s0)
80004c16:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SDMACTL_bit.DMAEN, State);
80004c1a:	300106b7          	lui	a3,0x30010
80004c1e:	fe842783          	lw	a5,-24(s0)
80004c22:	8b85                	andi	a5,a5,1
80004c24:	0ff7f713          	zext.b	a4,a5
80004c28:	fec42783          	lw	a5,-20(s0)
80004c2c:	079a                	slli	a5,a5,0x6
80004c2e:	97b6                	add	a5,a5,a3
80004c30:	8b05                	andi	a4,a4,1
80004c32:	0607d683          	lhu	a3,96(a5)
80004c36:	9af9                	andi	a3,a3,-2
80004c38:	8f55                	or	a4,a4,a3
80004c3a:	06e79023          	sh	a4,96(a5)
}
80004c3e:	0001                	nop
80004c40:	4472                	lw	s0,28(sp)
80004c42:	6105                	addi	sp,sp,32
80004c44:	8082                	ret

80004c46 <ADCSAR_SEQ_RestartConfig>:
  * @param   RestartVal  Количество. 0x00 - без перезапусков,
  *                      0x01 - 1 перезапуск, 0xFF - 255 перезапусков.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_RestartConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t RestartVal)
{
80004c46:	1101                	addi	sp,sp,-32
80004c48:	ce22                	sw	s0,28(sp)
80004c4a:	1000                	addi	s0,sp,32
80004c4c:	fea42623          	sw	a0,-20(s0)
80004c50:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_RESTART_VAL(RestartVal));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.RCNT, RestartVal);
80004c54:	300106b7          	lui	a3,0x30010
80004c58:	fe842783          	lw	a5,-24(s0)
80004c5c:	0ff7f713          	zext.b	a4,a5
80004c60:	fec42783          	lw	a5,-20(s0)
80004c64:	079a                	slli	a5,a5,0x6
80004c66:	97b6                	add	a5,a5,a3
80004c68:	06e78223          	sb	a4,100(a5)
}
80004c6c:	0001                	nop
80004c6e:	4472                	lw	s0,28(sp)
80004c70:	6105                	addi	sp,sp,32
80004c72:	8082                	ret

80004c74 <ADCSAR_SEQ_RestartAverageCmd>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_RestartAverageCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, FunctionalState State)
{
80004c74:	1101                	addi	sp,sp,-32
80004c76:	ce22                	sw	s0,28(sp)
80004c78:	1000                	addi	s0,sp,32
80004c7a:	fea42623          	sw	a0,-20(s0)
80004c7e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SCCTL_bit.RAVGEN, State);
80004c82:	300106b7          	lui	a3,0x30010
80004c86:	fe842783          	lw	a5,-24(s0)
80004c8a:	8b85                	andi	a5,a5,1
80004c8c:	0ff7f713          	zext.b	a4,a5
80004c90:	fec42783          	lw	a5,-20(s0)
80004c94:	079a                	slli	a5,a5,0x6
80004c96:	97b6                	add	a5,a5,a3
80004c98:	8b05                	andi	a4,a4,1
80004c9a:	0722                	slli	a4,a4,0x8
80004c9c:	53f4                	lw	a3,100(a5)
80004c9e:	eff6f693          	andi	a3,a3,-257
80004ca2:	8f55                	or	a4,a4,a3
80004ca4:	d3f8                	sw	a4,100(a5)
}
80004ca6:	0001                	nop
80004ca8:	4472                	lw	s0,28(sp)
80004caa:	6105                	addi	sp,sp,32
80004cac:	8082                	ret

80004cae <ADCSAR_SEQ_DCEnableCmd>:
  * @param   DC_Num  Выбор компаратора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_DCEnableCmd(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_DC_Num_TypeDef DC_Num, FunctionalState State)
{
80004cae:	1101                	addi	sp,sp,-32
80004cb0:	ce22                	sw	s0,28(sp)
80004cb2:	1000                	addi	s0,sp,32
80004cb4:	fea42623          	sw	a0,-20(s0)
80004cb8:	feb42423          	sw	a1,-24(s0)
80004cbc:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SDC, 1 << ((uint32_t)DC_Num), State << ((uint32_t)DC_Num));
80004cc0:	30010737          	lui	a4,0x30010
80004cc4:	fec42783          	lw	a5,-20(s0)
80004cc8:	079a                	slli	a5,a5,0x6
80004cca:	97ba                	add	a5,a5,a4
80004ccc:	57fc                	lw	a5,108(a5)
80004cce:	fe842703          	lw	a4,-24(s0)
80004cd2:	4685                	li	a3,1
80004cd4:	00e69733          	sll	a4,a3,a4
80004cd8:	fff74713          	not	a4,a4
80004cdc:	8f7d                	and	a4,a4,a5
80004cde:	fe842783          	lw	a5,-24(s0)
80004ce2:	fe442683          	lw	a3,-28(s0)
80004ce6:	00f697b3          	sll	a5,a3,a5
80004cea:	300106b7          	lui	a3,0x30010
80004cee:	8f5d                	or	a4,a4,a5
80004cf0:	fec42783          	lw	a5,-20(s0)
80004cf4:	079a                	slli	a5,a5,0x6
80004cf6:	97b6                	add	a5,a5,a3
80004cf8:	d7f8                	sw	a4,108(a5)
}
80004cfa:	0001                	nop
80004cfc:	4472                	lw	s0,28(sp)
80004cfe:	6105                	addi	sp,sp,32
80004d00:	8082                	ret

80004d02 <ADCSAR_SEQ_SetRestartTimer>:
  * @param   SEQ_Num  Выбор секвенсора
  * @param   TimerVal  Значение. 0 - означает отсутствие задержки и немедленный перезапуск (если активен).
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_SEQ_SetRestartTimer(ADCSAR_SEQ_Num_TypeDef SEQ_Num, uint32_t TimerVal)
{
80004d02:	1101                	addi	sp,sp,-32
80004d04:	ce22                	sw	s0,28(sp)
80004d06:	1000                	addi	s0,sp,32
80004d08:	fea42623          	sw	a0,-20(s0)
80004d0c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_RESTART_TIMER_VAL(TimerVal));

    WRITE_REG(ADCSAR->SEQ[SEQ_Num].SRTMR_bit.VAL, TimerVal);
80004d10:	30010737          	lui	a4,0x30010
80004d14:	fe842683          	lw	a3,-24(s0)
80004d18:	010007b7          	lui	a5,0x1000
80004d1c:	17fd                	addi	a5,a5,-1 # ffffff <STACK_SIZE+0xfff7ff>
80004d1e:	8efd                	and	a3,a3,a5
80004d20:	fec42783          	lw	a5,-20(s0)
80004d24:	079a                	slli	a5,a5,0x6
80004d26:	97ba                	add	a5,a5,a4
80004d28:	01000737          	lui	a4,0x1000
80004d2c:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80004d2e:	8f75                	and	a4,a4,a3
80004d30:	5bb0                	lw	a2,112(a5)
80004d32:	ff0006b7          	lui	a3,0xff000
80004d36:	8ef1                	and	a3,a3,a2
80004d38:	8f55                	or	a4,a4,a3
80004d3a:	dbb8                	sw	a4,112(a5)
}
80004d3c:	0001                	nop
80004d3e:	4472                	lw	s0,28(sp)
80004d40:	6105                	addi	sp,sp,32
80004d42:	8082                	ret

80004d44 <ADCSAR_DC_OutputCmd>:
  * @param   DC_Num  Выбор компаратора
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_OutputCmd(ADCSAR_DC_Num_TypeDef DC_Num, FunctionalState State)
{
80004d44:	1101                	addi	sp,sp,-32
80004d46:	ce22                	sw	s0,28(sp)
80004d48:	1000                	addi	s0,sp,32
80004d4a:	fea42623          	sw	a0,-20(s0)
80004d4e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.CTE, State);
80004d52:	30010637          	lui	a2,0x30010
80004d56:	fe842783          	lw	a5,-24(s0)
80004d5a:	8b85                	andi	a5,a5,1
80004d5c:	0ff7f693          	zext.b	a3,a5
80004d60:	fec42703          	lw	a4,-20(s0)
80004d64:	87ba                	mv	a5,a4
80004d66:	0786                	slli	a5,a5,0x1
80004d68:	97ba                	add	a5,a5,a4
80004d6a:	078a                	slli	a5,a5,0x2
80004d6c:	97b2                	add	a5,a5,a2
80004d6e:	0016f713          	andi	a4,a3,1
80004d72:	0732                	slli	a4,a4,0xc
80004d74:	4007a603          	lw	a2,1024(a5)
80004d78:	76fd                	lui	a3,0xfffff
80004d7a:	16fd                	addi	a3,a3,-1 # ffffefff <__data_source_start+0x7fff61ab>
80004d7c:	8ef1                	and	a3,a3,a2
80004d7e:	8f55                	or	a4,a4,a3
80004d80:	40e7a023          	sw	a4,1024(a5)
}
80004d84:	0001                	nop
80004d86:	4472                	lw	s0,28(sp)
80004d88:	6105                	addi	sp,sp,32
80004d8a:	8082                	ret

80004d8c <ADCSAR_DC_SourceConfig>:
  * @param   DC_Num  Выбор компаратора
  * @param   Source  Выбор источника
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SourceConfig(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Source_TypeDef Source)
{
80004d8c:	1101                	addi	sp,sp,-32
80004d8e:	ce22                	sw	s0,28(sp)
80004d90:	1000                	addi	s0,sp,32
80004d92:	fea42623          	sw	a0,-20(s0)
80004d96:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_SOURCE(Source));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.SRC, Source);
80004d9a:	30010637          	lui	a2,0x30010
80004d9e:	fe842783          	lw	a5,-24(s0)
80004da2:	8b85                	andi	a5,a5,1
80004da4:	0ff7f693          	zext.b	a3,a5
80004da8:	fec42703          	lw	a4,-20(s0)
80004dac:	87ba                	mv	a5,a4
80004dae:	0786                	slli	a5,a5,0x1
80004db0:	97ba                	add	a5,a5,a4
80004db2:	078a                	slli	a5,a5,0x2
80004db4:	97b2                	add	a5,a5,a2
80004db6:	0016f713          	andi	a4,a3,1
80004dba:	0762                	slli	a4,a4,0x18
80004dbc:	4007a603          	lw	a2,1024(a5)
80004dc0:	ff0006b7          	lui	a3,0xff000
80004dc4:	16fd                	addi	a3,a3,-1 # feffffff <__data_source_start+0x7eff71ab>
80004dc6:	8ef1                	and	a3,a3,a2
80004dc8:	8f55                	or	a4,a4,a3
80004dca:	40e7a023          	sw	a4,1024(a5)
}
80004dce:	0001                	nop
80004dd0:	4472                	lw	s0,28(sp)
80004dd2:	6105                	addi	sp,sp,32
80004dd4:	8082                	ret

80004dd6 <ADCSAR_DC_ChannelConfig>:
  * @param   DC_Num  Выбор компаратора
  * @param   Source  Выбор источника
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_ChannelConfig(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_CH_Num_TypeDef Channel_Num)
{
80004dd6:	1101                	addi	sp,sp,-32
80004dd8:	ce22                	sw	s0,28(sp)
80004dda:	1000                	addi	s0,sp,32
80004ddc:	fea42623          	sw	a0,-20(s0)
80004de0:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_CH_NUM(Channel_Num));

    WRITE_REG(ADCSAR->DC[DC_Num].DCTL_bit.CHNL, Channel_Num);
80004de4:	30010637          	lui	a2,0x30010
80004de8:	fe842783          	lw	a5,-24(s0)
80004dec:	8b9d                	andi	a5,a5,7
80004dee:	0ff7f693          	zext.b	a3,a5
80004df2:	fec42703          	lw	a4,-20(s0)
80004df6:	87ba                	mv	a5,a4
80004df8:	0786                	slli	a5,a5,0x1
80004dfa:	97ba                	add	a5,a5,a4
80004dfc:	078a                	slli	a5,a5,0x2
80004dfe:	97b2                	add	a5,a5,a2
80004e00:	0076f713          	andi	a4,a3,7
80004e04:	0742                	slli	a4,a4,0x10
80004e06:	4007a603          	lw	a2,1024(a5)
80004e0a:	fff906b7          	lui	a3,0xfff90
80004e0e:	16fd                	addi	a3,a3,-1 # fff8ffff <__data_source_start+0x7ff871ab>
80004e10:	8ef1                	and	a3,a3,a2
80004e12:	8f55                	or	a4,a4,a3
80004e14:	40e7a023          	sw	a4,1024(a5)
}
80004e18:	0001                	nop
80004e1a:	4472                	lw	s0,28(sp)
80004e1c:	6105                	addi	sp,sp,32
80004e1e:	8082                	ret

80004e20 <ADCSAR_DC_Config>:
  * @param   Mode  Выбор режима
  * @param   Condition  Выбор условия
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_Config(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Mode_TypeDef Mode, ADCSAR_DC_Condition_TypeDef Condition)
{
80004e20:	1101                	addi	sp,sp,-32
80004e22:	ce22                	sw	s0,28(sp)
80004e24:	1000                	addi	s0,sp,32
80004e26:	fea42623          	sw	a0,-20(s0)
80004e2a:	feb42423          	sw	a1,-24(s0)
80004e2e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_MODE(Mode));
    assert_param(IS_ADCSAR_DC_CONDITION(Condition));

    MODIFY_REG(ADCSAR->DC[DC_Num].DCTL, ADCSAR_DC_DCTL_CTC_Msk | ADCSAR_DC_DCTL_CTM_Msk,
80004e32:	300106b7          	lui	a3,0x30010
80004e36:	fec42703          	lw	a4,-20(s0)
80004e3a:	87ba                	mv	a5,a4
80004e3c:	0786                	slli	a5,a5,0x1
80004e3e:	97ba                	add	a5,a5,a4
80004e40:	078a                	slli	a5,a5,0x2
80004e42:	97b6                	add	a5,a5,a3
80004e44:	4007a703          	lw	a4,1024(a5)
80004e48:	77fd                	lui	a5,0xfffff
80004e4a:	0ff78793          	addi	a5,a5,255 # fffff0ff <__data_source_start+0x7fff62ab>
80004e4e:	8f7d                	and	a4,a4,a5
80004e50:	fe842783          	lw	a5,-24(s0)
80004e54:	00879693          	slli	a3,a5,0x8
80004e58:	fe442783          	lw	a5,-28(s0)
80004e5c:	07aa                	slli	a5,a5,0xa
80004e5e:	8fd5                	or	a5,a5,a3
80004e60:	30010637          	lui	a2,0x30010
80004e64:	00f766b3          	or	a3,a4,a5
80004e68:	fec42703          	lw	a4,-20(s0)
80004e6c:	87ba                	mv	a5,a4
80004e6e:	0786                	slli	a5,a5,0x1
80004e70:	97ba                	add	a5,a5,a4
80004e72:	078a                	slli	a5,a5,0x2
80004e74:	97b2                	add	a5,a5,a2
80004e76:	40d7a023          	sw	a3,1024(a5)
               ((Mode << ADCSAR_DC_DCTL_CTM_Pos) |
                (Condition << ADCSAR_DC_DCTL_CTC_Pos)));
}
80004e7a:	0001                	nop
80004e7c:	4472                	lw	s0,28(sp)
80004e7e:	6105                	addi	sp,sp,32
80004e80:	8082                	ret

80004e82 <ADCSAR_DC_SetThresholdLow>:
  * @param   DC_Num  Выбор компаратора
  * @param   Val  Значение. Диапазон 0-0xFFF.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SetThresholdLow(ADCSAR_DC_Num_TypeDef DC_Num, uint32_t Val)
{
80004e82:	1101                	addi	sp,sp,-32
80004e84:	ce22                	sw	s0,28(sp)
80004e86:	1000                	addi	s0,sp,32
80004e88:	fea42623          	sw	a0,-20(s0)
80004e8c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_THRESHOLD(Val));

    WRITE_REG(ADCSAR->DC[DC_Num].DCMP_bit.CMPL, Val);
80004e90:	30010637          	lui	a2,0x30010
80004e94:	fe842783          	lw	a5,-24(s0)
80004e98:	873e                	mv	a4,a5
80004e9a:	6785                	lui	a5,0x1
80004e9c:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80004e9e:	8ff9                	and	a5,a5,a4
80004ea0:	01079693          	slli	a3,a5,0x10
80004ea4:	82c1                	srli	a3,a3,0x10
80004ea6:	fec42703          	lw	a4,-20(s0)
80004eaa:	87ba                	mv	a5,a4
80004eac:	0786                	slli	a5,a5,0x1
80004eae:	97ba                	add	a5,a5,a4
80004eb0:	078a                	slli	a5,a5,0x2
80004eb2:	97b2                	add	a5,a5,a2
80004eb4:	6705                	lui	a4,0x1
80004eb6:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80004eb8:	8f75                	and	a4,a4,a3
80004eba:	4047a603          	lw	a2,1028(a5)
80004ebe:	76fd                	lui	a3,0xfffff
80004ec0:	8ef1                	and	a3,a3,a2
80004ec2:	8f55                	or	a4,a4,a3
80004ec4:	40e7a223          	sw	a4,1028(a5)
}
80004ec8:	0001                	nop
80004eca:	4472                	lw	s0,28(sp)
80004ecc:	6105                	addi	sp,sp,32
80004ece:	8082                	ret

80004ed0 <ADCSAR_DC_SetThresholdHigh>:
  * @param   DC_Num  Выбор компаратора
  * @param   Val  Значение. Диапазон 0-0xFFF.
  * @retval  void
  */
__STATIC_INLINE void ADCSAR_DC_SetThresholdHigh(ADCSAR_DC_Num_TypeDef DC_Num, uint32_t Val)
{
80004ed0:	1101                	addi	sp,sp,-32
80004ed2:	ce22                	sw	s0,28(sp)
80004ed4:	1000                	addi	s0,sp,32
80004ed6:	fea42623          	sw	a0,-20(s0)
80004eda:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_ADCSAR_DC_NUM(DC_Num));
    assert_param(IS_ADCSAR_DC_THRESHOLD(Val));

    WRITE_REG(ADCSAR->DC[DC_Num].DCMP_bit.CMPH, Val);
80004ede:	30010637          	lui	a2,0x30010
80004ee2:	fe842783          	lw	a5,-24(s0)
80004ee6:	873e                	mv	a4,a5
80004ee8:	6785                	lui	a5,0x1
80004eea:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80004eec:	8ff9                	and	a5,a5,a4
80004eee:	01079693          	slli	a3,a5,0x10
80004ef2:	82c1                	srli	a3,a3,0x10
80004ef4:	fec42703          	lw	a4,-20(s0)
80004ef8:	87ba                	mv	a5,a4
80004efa:	0786                	slli	a5,a5,0x1
80004efc:	97ba                	add	a5,a5,a4
80004efe:	078a                	slli	a5,a5,0x2
80004f00:	97b2                	add	a5,a5,a2
80004f02:	6705                	lui	a4,0x1
80004f04:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80004f06:	8f75                	and	a4,a4,a3
80004f08:	0742                	slli	a4,a4,0x10
80004f0a:	4047a603          	lw	a2,1028(a5)
80004f0e:	f00106b7          	lui	a3,0xf0010
80004f12:	16fd                	addi	a3,a3,-1 # f000ffff <__data_source_start+0x700071ab>
80004f14:	8ef1                	and	a3,a3,a2
80004f16:	8f55                	or	a4,a4,a3
80004f18:	40e7a223          	sw	a4,1028(a5)
}
80004f1c:	0001                	nop
80004f1e:	4472                	lw	s0,28(sp)
80004f20:	6105                	addi	sp,sp,32
80004f22:	8082                	ret

80004f24 <ADCSAR_SEQ_ReqConfig>:
  * @param   ReqNum  Выбор запроса
  * @param   Channel_Num  Выбор канала
  * @retval  void
  */
void ADCSAR_SEQ_ReqConfig(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_ReqNum_TypeDef ReqNum, ADCSAR_CH_Num_TypeDef Channel_Num)
{
80004f24:	7179                	addi	sp,sp,-48
80004f26:	d622                	sw	s0,44(sp)
80004f28:	1800                	addi	s0,sp,48
80004f2a:	fca42e23          	sw	a0,-36(s0)
80004f2e:	fcb42c23          	sw	a1,-40(s0)
80004f32:	fcc42a23          	sw	a2,-44(s0)

    assert_param(IS_ADCSAR_SEQ_NUM(SEQ_Num));
    assert_param(IS_ADCSAR_SEQ_REQ_NUM(ReqNum));
    assert_param(IS_ADCSAR_CH_NUM(Channel_Num));

    req_pos = ((uint32_t)ReqNum % 4) * 8;
80004f36:	fd842783          	lw	a5,-40(s0)
80004f3a:	8b8d                	andi	a5,a5,3
80004f3c:	078e                	slli	a5,a5,0x3
80004f3e:	fef42623          	sw	a5,-20(s0)

    if (ReqNum > ADCSAR_SEQ_ReqNum_7)
80004f42:	fd842703          	lw	a4,-40(s0)
80004f46:	479d                	li	a5,7
80004f48:	04e7f363          	bgeu	a5,a4,80004f8e <ADCSAR_SEQ_ReqConfig+0x6a>
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel2
80004f4c:	30010737          	lui	a4,0x30010
80004f50:	fdc42783          	lw	a5,-36(s0)
80004f54:	0785                	addi	a5,a5,1
80004f56:	079a                	slli	a5,a5,0x6
80004f58:	97ba                	add	a5,a5,a4
80004f5a:	439c                	lw	a5,0(a5)
80004f5c:	fec42703          	lw	a4,-20(s0)
80004f60:	03f00693          	li	a3,63
80004f64:	00e69733          	sll	a4,a3,a4
80004f68:	fff74713          	not	a4,a4
80004f6c:	8f7d                	and	a4,a4,a5
80004f6e:	fec42783          	lw	a5,-20(s0)
80004f72:	fd442683          	lw	a3,-44(s0)
80004f76:	00f697b3          	sll	a5,a3,a5
80004f7a:	300106b7          	lui	a3,0x30010
80004f7e:	8f5d                	or	a4,a4,a5
80004f80:	fdc42783          	lw	a5,-36(s0)
80004f84:	0785                	addi	a5,a5,1
80004f86:	079a                	slli	a5,a5,0x6
80004f88:	97b6                	add	a5,a5,a3
80004f8a:	c398                	sw	a4,0(a5)
    else if (ReqNum > ADCSAR_SEQ_ReqNum_3)
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel1
    else
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel0
}
80004f8c:	a079                	j	8000501a <ADCSAR_SEQ_ReqConfig+0xf6>
    else if (ReqNum > ADCSAR_SEQ_ReqNum_3)
80004f8e:	fd842703          	lw	a4,-40(s0)
80004f92:	478d                	li	a5,3
80004f94:	04e7f363          	bgeu	a5,a4,80004fda <ADCSAR_SEQ_ReqConfig+0xb6>
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel1
80004f98:	30010737          	lui	a4,0x30010
80004f9c:	fdc42783          	lw	a5,-36(s0)
80004fa0:	0785                	addi	a5,a5,1
80004fa2:	079a                	slli	a5,a5,0x6
80004fa4:	97ba                	add	a5,a5,a4
80004fa6:	439c                	lw	a5,0(a5)
80004fa8:	fec42703          	lw	a4,-20(s0)
80004fac:	03f00693          	li	a3,63
80004fb0:	00e69733          	sll	a4,a3,a4
80004fb4:	fff74713          	not	a4,a4
80004fb8:	8f7d                	and	a4,a4,a5
80004fba:	fec42783          	lw	a5,-20(s0)
80004fbe:	fd442683          	lw	a3,-44(s0)
80004fc2:	00f697b3          	sll	a5,a3,a5
80004fc6:	300106b7          	lui	a3,0x30010
80004fca:	8f5d                	or	a4,a4,a5
80004fcc:	fdc42783          	lw	a5,-36(s0)
80004fd0:	0785                	addi	a5,a5,1
80004fd2:	079a                	slli	a5,a5,0x6
80004fd4:	97b6                	add	a5,a5,a3
80004fd6:	c398                	sw	a4,0(a5)
}
80004fd8:	a089                	j	8000501a <ADCSAR_SEQ_ReqConfig+0xf6>
        MODIFY_REG(ADCSAR->SEQ[SEQ_Num].SRQSEL, 0x3F << req_pos, Channel_Num << req_pos); // srqsel0
80004fda:	30010737          	lui	a4,0x30010
80004fde:	fdc42783          	lw	a5,-36(s0)
80004fe2:	0785                	addi	a5,a5,1
80004fe4:	079a                	slli	a5,a5,0x6
80004fe6:	97ba                	add	a5,a5,a4
80004fe8:	439c                	lw	a5,0(a5)
80004fea:	fec42703          	lw	a4,-20(s0)
80004fee:	03f00693          	li	a3,63
80004ff2:	00e69733          	sll	a4,a3,a4
80004ff6:	fff74713          	not	a4,a4
80004ffa:	8f7d                	and	a4,a4,a5
80004ffc:	fec42783          	lw	a5,-20(s0)
80005000:	fd442683          	lw	a3,-44(s0)
80005004:	00f697b3          	sll	a5,a3,a5
80005008:	300106b7          	lui	a3,0x30010
8000500c:	8f5d                	or	a4,a4,a5
8000500e:	fdc42783          	lw	a5,-36(s0)
80005012:	0785                	addi	a5,a5,1
80005014:	079a                	slli	a5,a5,0x6
80005016:	97b6                	add	a5,a5,a3
80005018:	c398                	sw	a4,0(a5)
}
8000501a:	0001                	nop
8000501c:	5432                	lw	s0,44(sp)
8000501e:	6145                	addi	sp,sp,48
80005020:	8082                	ret

80005022 <ADCSAR_DeInit>:
/**
  * @brief   Устанавливает все регистры ADCSAR значениями по умолчанию
  * @retval  void
  */
void ADCSAR_DeInit()
{
80005022:	1141                	addi	sp,sp,-16
80005024:	c606                	sw	ra,12(sp)
80005026:	c422                	sw	s0,8(sp)
80005028:	0800                	addi	s0,sp,16
    RCU_ADCSARRstCmd(DISABLE);
8000502a:	4501                	li	a0,0
8000502c:	341d                	jal	80004a52 <RCU_ADCSARRstCmd>
    RCU_ADCSARRstCmd(ENABLE);
8000502e:	4505                	li	a0,1
80005030:	340d                	jal	80004a52 <RCU_ADCSARRstCmd>
}
80005032:	0001                	nop
80005034:	40b2                	lw	ra,12(sp)
80005036:	4422                	lw	s0,8(sp)
80005038:	0141                	addi	sp,sp,16
8000503a:	8082                	ret

8000503c <ADCSAR_SEQ_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_SEQ_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSAR_SEQ_Init(ADCSAR_SEQ_Num_TypeDef SEQ_Num, ADCSAR_SEQ_Init_TypeDef* InitStruct)
{
8000503c:	7179                	addi	sp,sp,-48
8000503e:	d606                	sw	ra,44(sp)
80005040:	d422                	sw	s0,40(sp)
80005042:	1800                	addi	s0,sp,48
80005044:	fca42e23          	sw	a0,-36(s0)
80005048:	fcb42c23          	sw	a1,-40(s0)
    ADCSAR_SEQ_StartEventConfig(SEQ_Num, InitStruct->StartEvent);
8000504c:	fd842783          	lw	a5,-40(s0)
80005050:	439c                	lw	a5,0(a5)
80005052:	85be                	mv	a1,a5
80005054:	fdc42503          	lw	a0,-36(s0)
80005058:	34bd                	jal	80004ac6 <ADCSAR_SEQ_StartEventConfig>
    ADCSAR_SEQ_SwStartEnCmd(SEQ_Num, InitStruct->SWStartEn);
8000505a:	fd842783          	lw	a5,-40(s0)
8000505e:	43dc                	lw	a5,4(a5)
80005060:	85be                	mv	a1,a5
80005062:	fdc42503          	lw	a0,-36(s0)
80005066:	3c39                	jal	80004a84 <ADCSAR_SEQ_SwStartEnCmd>
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80005068:	fe042623          	sw	zero,-20(s0)
8000506c:	a01d                	j	80005092 <ADCSAR_SEQ_Init+0x56>
        ADCSAR_SEQ_ReqConfig(SEQ_Num, (ADCSAR_SEQ_ReqNum_TypeDef)i, InitStruct->Req[i]);
8000506e:	fd842703          	lw	a4,-40(s0)
80005072:	fec42783          	lw	a5,-20(s0)
80005076:	078a                	slli	a5,a5,0x2
80005078:	97ba                	add	a5,a5,a4
8000507a:	479c                	lw	a5,8(a5)
8000507c:	863e                	mv	a2,a5
8000507e:	fec42583          	lw	a1,-20(s0)
80005082:	fdc42503          	lw	a0,-36(s0)
80005086:	3d79                	jal	80004f24 <ADCSAR_SEQ_ReqConfig>
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80005088:	fec42783          	lw	a5,-20(s0)
8000508c:	0785                	addi	a5,a5,1
8000508e:	fef42623          	sw	a5,-20(s0)
80005092:	fec42703          	lw	a4,-20(s0)
80005096:	479d                	li	a5,7
80005098:	fce7fbe3          	bgeu	a5,a4,8000506e <ADCSAR_SEQ_Init+0x32>
    }
    ADCSAR_SEQ_ReqMaxConfig(SEQ_Num, InitStruct->ReqMax);
8000509c:	fd842783          	lw	a5,-40(s0)
800050a0:	579c                	lw	a5,40(a5)
800050a2:	85be                	mv	a1,a5
800050a4:	fdc42503          	lw	a0,-36(s0)
800050a8:	3495                	jal	80004b0c <ADCSAR_SEQ_ReqMaxConfig>
    ADCSAR_SEQ_ReqAverageConfig(SEQ_Num, InitStruct->ReqAverage);
800050aa:	fd842783          	lw	a5,-40(s0)
800050ae:	57dc                	lw	a5,44(a5)
800050b0:	85be                	mv	a1,a5
800050b2:	fdc42503          	lw	a0,-36(s0)
800050b6:	3c41                	jal	80004b46 <ADCSAR_SEQ_ReqAverageConfig>
    ADCSAR_SEQ_ReqAverageCmd(SEQ_Num, InitStruct->ReqAverageEn);
800050b8:	fd842783          	lw	a5,-40(s0)
800050bc:	5b9c                	lw	a5,48(a5)
800050be:	85be                	mv	a1,a5
800050c0:	fdc42503          	lw	a0,-36(s0)
800050c4:	34f1                	jal	80004b90 <ADCSAR_SEQ_ReqAverageCmd>
    ADCSAR_SEQ_RestartConfig(SEQ_Num, InitStruct->RestartCount);
800050c6:	fd842783          	lw	a5,-40(s0)
800050ca:	5bdc                	lw	a5,52(a5)
800050cc:	85be                	mv	a1,a5
800050ce:	fdc42503          	lw	a0,-36(s0)
800050d2:	3e95                	jal	80004c46 <ADCSAR_SEQ_RestartConfig>
    ADCSAR_SEQ_RestartAverageCmd(SEQ_Num, InitStruct->RestartAverageEn);
800050d4:	fd842783          	lw	a5,-40(s0)
800050d8:	5f9c                	lw	a5,56(a5)
800050da:	85be                	mv	a1,a5
800050dc:	fdc42503          	lw	a0,-36(s0)
800050e0:	3e51                	jal	80004c74 <ADCSAR_SEQ_RestartAverageCmd>
    ADCSAR_SEQ_SetRestartTimer(SEQ_Num, InitStruct->RestartTimer);
800050e2:	fd842783          	lw	a5,-40(s0)
800050e6:	5fdc                	lw	a5,60(a5)
800050e8:	85be                	mv	a1,a5
800050ea:	fdc42503          	lw	a0,-36(s0)
800050ee:	3911                	jal	80004d02 <ADCSAR_SEQ_SetRestartTimer>
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
800050f0:	fe042423          	sw	zero,-24(s0)
800050f4:	a025                	j	8000511c <ADCSAR_SEQ_Init+0xe0>
        ADCSAR_SEQ_DCEnableCmd(SEQ_Num, (ADCSAR_DC_Num_TypeDef)i, InitStruct->DCEn[i]);
800050f6:	fd842703          	lw	a4,-40(s0)
800050fa:	fe842783          	lw	a5,-24(s0)
800050fe:	07c1                	addi	a5,a5,16
80005100:	078a                	slli	a5,a5,0x2
80005102:	97ba                	add	a5,a5,a4
80005104:	439c                	lw	a5,0(a5)
80005106:	863e                	mv	a2,a5
80005108:	fe842583          	lw	a1,-24(s0)
8000510c:	fdc42503          	lw	a0,-36(s0)
80005110:	3e79                	jal	80004cae <ADCSAR_SEQ_DCEnableCmd>
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
80005112:	fe842783          	lw	a5,-24(s0)
80005116:	0785                	addi	a5,a5,1
80005118:	fef42423          	sw	a5,-24(s0)
8000511c:	fe842703          	lw	a4,-24(s0)
80005120:	479d                	li	a5,7
80005122:	fce7fae3          	bgeu	a5,a4,800050f6 <ADCSAR_SEQ_Init+0xba>
    }
    ADCSAR_SEQ_DMAConfig(SEQ_Num, InitStruct->DMAFIFOLevel);
80005126:	fd842783          	lw	a5,-40(s0)
8000512a:	53bc                	lw	a5,96(a5)
8000512c:	85be                	mv	a1,a5
8000512e:	fdc42503          	lw	a0,-36(s0)
80005132:	3c71                	jal	80004bce <ADCSAR_SEQ_DMAConfig>
    ADCSAR_SEQ_DMACmd(SEQ_Num, InitStruct->DMAEn);
80005134:	fd842783          	lw	a5,-40(s0)
80005138:	53fc                	lw	a5,100(a5)
8000513a:	85be                	mv	a1,a5
8000513c:	fdc42503          	lw	a0,-36(s0)
80005140:	34f1                	jal	80004c0c <ADCSAR_SEQ_DMACmd>
}
80005142:	0001                	nop
80005144:	50b2                	lw	ra,44(sp)
80005146:	5422                	lw	s0,40(sp)
80005148:	6145                	addi	sp,sp,48
8000514a:	8082                	ret

8000514c <ADCSAR_SEQ_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_SEQ_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSAR_SEQ_StructInit(ADCSAR_SEQ_Init_TypeDef* InitStruct)
{
8000514c:	7179                	addi	sp,sp,-48
8000514e:	d622                	sw	s0,44(sp)
80005150:	1800                	addi	s0,sp,48
80005152:	fca42e23          	sw	a0,-36(s0)
    InitStruct->StartEvent = ADCSAR_SEQ_StartEvent_SwReq;
80005156:	fdc42783          	lw	a5,-36(s0)
8000515a:	0007a023          	sw	zero,0(a5)
    InitStruct->SWStartEn = DISABLE;
8000515e:	fdc42783          	lw	a5,-36(s0)
80005162:	0007a223          	sw	zero,4(a5)
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
80005166:	fe042623          	sw	zero,-20(s0)
8000516a:	a831                	j	80005186 <ADCSAR_SEQ_StructInit+0x3a>
        InitStruct->Req[i] = ADCSAR_CH_Num_0;
8000516c:	fdc42703          	lw	a4,-36(s0)
80005170:	fec42783          	lw	a5,-20(s0)
80005174:	078a                	slli	a5,a5,0x2
80005176:	97ba                	add	a5,a5,a4
80005178:	0007a423          	sw	zero,8(a5)
    for (uint32_t i = 0; i < ADCSAR_SEQ_Req_Total; i++) {
8000517c:	fec42783          	lw	a5,-20(s0)
80005180:	0785                	addi	a5,a5,1
80005182:	fef42623          	sw	a5,-20(s0)
80005186:	fec42703          	lw	a4,-20(s0)
8000518a:	479d                	li	a5,7
8000518c:	fee7f0e3          	bgeu	a5,a4,8000516c <ADCSAR_SEQ_StructInit+0x20>
    }
    InitStruct->ReqMax = ADCSAR_SEQ_ReqNum_0;
80005190:	fdc42783          	lw	a5,-36(s0)
80005194:	0207a423          	sw	zero,40(a5)
    InitStruct->ReqAverage = ADCSAR_SEQ_Average_2;
80005198:	fdc42783          	lw	a5,-36(s0)
8000519c:	4705                	li	a4,1
8000519e:	d7d8                	sw	a4,44(a5)
    InitStruct->ReqAverageEn = DISABLE;
800051a0:	fdc42783          	lw	a5,-36(s0)
800051a4:	0207a823          	sw	zero,48(a5)
    InitStruct->RestartCount = 0;
800051a8:	fdc42783          	lw	a5,-36(s0)
800051ac:	0207aa23          	sw	zero,52(a5)
    InitStruct->RestartAverageEn = DISABLE;
800051b0:	fdc42783          	lw	a5,-36(s0)
800051b4:	0207ac23          	sw	zero,56(a5)
    InitStruct->RestartTimer = 0;
800051b8:	fdc42783          	lw	a5,-36(s0)
800051bc:	0207ae23          	sw	zero,60(a5)
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
800051c0:	fe042423          	sw	zero,-24(s0)
800051c4:	a839                	j	800051e2 <ADCSAR_SEQ_StructInit+0x96>
        InitStruct->DCEn[i] = DISABLE;
800051c6:	fdc42703          	lw	a4,-36(s0)
800051ca:	fe842783          	lw	a5,-24(s0)
800051ce:	07c1                	addi	a5,a5,16
800051d0:	078a                	slli	a5,a5,0x2
800051d2:	97ba                	add	a5,a5,a4
800051d4:	0007a023          	sw	zero,0(a5)
    for (uint32_t i = 0; i < ADCSAR_DC_Total; i++) {
800051d8:	fe842783          	lw	a5,-24(s0)
800051dc:	0785                	addi	a5,a5,1
800051de:	fef42423          	sw	a5,-24(s0)
800051e2:	fe842703          	lw	a4,-24(s0)
800051e6:	479d                	li	a5,7
800051e8:	fce7ffe3          	bgeu	a5,a4,800051c6 <ADCSAR_SEQ_StructInit+0x7a>
    }
    InitStruct->DMAFIFOLevel = ADCSAR_SEQ_DMAFIFOLevel_1;
800051ec:	fdc42783          	lw	a5,-36(s0)
800051f0:	4705                	li	a4,1
800051f2:	d3b8                	sw	a4,96(a5)
    InitStruct->DMAEn = DISABLE;
800051f4:	fdc42783          	lw	a5,-36(s0)
800051f8:	0607a223          	sw	zero,100(a5)
}
800051fc:	0001                	nop
800051fe:	5432                	lw	s0,44(sp)
80005200:	6145                	addi	sp,sp,48
80005202:	8082                	ret

80005204 <ADCSAR_DC_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_DC_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSAR_DC_Init(ADCSAR_DC_Num_TypeDef DC_Num, ADCSAR_DC_Init_TypeDef* InitStruct)
{
80005204:	1101                	addi	sp,sp,-32
80005206:	ce06                	sw	ra,28(sp)
80005208:	cc22                	sw	s0,24(sp)
8000520a:	1000                	addi	s0,sp,32
8000520c:	fea42623          	sw	a0,-20(s0)
80005210:	feb42423          	sw	a1,-24(s0)
    ADCSAR_DC_OutputCmd(DC_Num, InitStruct->DCOutput);
80005214:	fe842783          	lw	a5,-24(s0)
80005218:	439c                	lw	a5,0(a5)
8000521a:	85be                	mv	a1,a5
8000521c:	fec42503          	lw	a0,-20(s0)
80005220:	3615                	jal	80004d44 <ADCSAR_DC_OutputCmd>
    ADCSAR_DC_SetThresholdLow(DC_Num, InitStruct->ThresholdLow);
80005222:	fe842783          	lw	a5,-24(s0)
80005226:	43dc                	lw	a5,4(a5)
80005228:	85be                	mv	a1,a5
8000522a:	fec42503          	lw	a0,-20(s0)
8000522e:	3991                	jal	80004e82 <ADCSAR_DC_SetThresholdLow>
    ADCSAR_DC_SetThresholdHigh(DC_Num, InitStruct->ThresholdHigh);
80005230:	fe842783          	lw	a5,-24(s0)
80005234:	479c                	lw	a5,8(a5)
80005236:	85be                	mv	a1,a5
80005238:	fec42503          	lw	a0,-20(s0)
8000523c:	3951                	jal	80004ed0 <ADCSAR_DC_SetThresholdHigh>
    ADCSAR_DC_SourceConfig(DC_Num, InitStruct->Source);
8000523e:	fe842783          	lw	a5,-24(s0)
80005242:	47dc                	lw	a5,12(a5)
80005244:	85be                	mv	a1,a5
80005246:	fec42503          	lw	a0,-20(s0)
8000524a:	3689                	jal	80004d8c <ADCSAR_DC_SourceConfig>
    ADCSAR_DC_ChannelConfig(DC_Num, InitStruct->Channel);
8000524c:	fe842783          	lw	a5,-24(s0)
80005250:	4b9c                	lw	a5,16(a5)
80005252:	85be                	mv	a1,a5
80005254:	fec42503          	lw	a0,-20(s0)
80005258:	3ebd                	jal	80004dd6 <ADCSAR_DC_ChannelConfig>
    ADCSAR_DC_Config(DC_Num, InitStruct->Mode, InitStruct->Condition);
8000525a:	fe842783          	lw	a5,-24(s0)
8000525e:	4bd8                	lw	a4,20(a5)
80005260:	fe842783          	lw	a5,-24(s0)
80005264:	4f9c                	lw	a5,24(a5)
80005266:	863e                	mv	a2,a5
80005268:	85ba                	mv	a1,a4
8000526a:	fec42503          	lw	a0,-20(s0)
8000526e:	3e4d                	jal	80004e20 <ADCSAR_DC_Config>
}
80005270:	0001                	nop
80005272:	40f2                	lw	ra,28(sp)
80005274:	4462                	lw	s0,24(sp)
80005276:	6105                	addi	sp,sp,32
80005278:	8082                	ret

8000527a <ADCSAR_DC_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSAR_DC_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSAR_DC_StructInit(ADCSAR_DC_Init_TypeDef* InitStruct)
{
8000527a:	1101                	addi	sp,sp,-32
8000527c:	ce22                	sw	s0,28(sp)
8000527e:	1000                	addi	s0,sp,32
80005280:	fea42623          	sw	a0,-20(s0)
    InitStruct->DCOutput = DISABLE;
80005284:	fec42783          	lw	a5,-20(s0)
80005288:	0007a023          	sw	zero,0(a5)
    InitStruct->ThresholdLow = 0;
8000528c:	fec42783          	lw	a5,-20(s0)
80005290:	0007a223          	sw	zero,4(a5)
    InitStruct->ThresholdHigh = 0;
80005294:	fec42783          	lw	a5,-20(s0)
80005298:	0007a423          	sw	zero,8(a5)
    InitStruct->Source = ADCSAR_DC_Source_EOC;
8000529c:	fec42783          	lw	a5,-20(s0)
800052a0:	0007a623          	sw	zero,12(a5)
    InitStruct->Channel = ADCSAR_CH_Num_0;
800052a4:	fec42783          	lw	a5,-20(s0)
800052a8:	0007a823          	sw	zero,16(a5)
    InitStruct->Mode = ADCSAR_DC_Mode_Multiple;
800052ac:	fec42783          	lw	a5,-20(s0)
800052b0:	0007aa23          	sw	zero,20(a5)
    InitStruct->Condition = ADCSAR_DC_Condition_Low;
800052b4:	fec42783          	lw	a5,-20(s0)
800052b8:	0007ac23          	sw	zero,24(a5)
}
800052bc:	0001                	nop
800052be:	4472                	lw	s0,28(sp)
800052c0:	6105                	addi	sp,sp,32
800052c2:	8082                	ret

800052c4 <RCU_ADCSDRstCmd>:
  * @brief   Cнятие сброса АЦП сигма-дельта
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void RCU_ADCSDRstCmd(FunctionalState State)
{
800052c4:	1101                	addi	sp,sp,-32
800052c6:	ce22                	sw	s0,28(sp)
800052c8:	1000                	addi	s0,sp,32
800052ca:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(RCU->ADCSDCLKCFG_bit.RSTDIS, State);
800052ce:	3000e7b7          	lui	a5,0x3000e
800052d2:	fec42703          	lw	a4,-20(s0)
800052d6:	8b05                	andi	a4,a4,1
800052d8:	0ff77713          	zext.b	a4,a4
800052dc:	8b05                	andi	a4,a4,1
800052de:	0722                	slli	a4,a4,0x8
800052e0:	0b47a683          	lw	a3,180(a5) # 3000e0b4 <STACK_SIZE+0x3000d8b4>
800052e4:	eff6f693          	andi	a3,a3,-257
800052e8:	8f55                	or	a4,a4,a3
800052ea:	0ae7aa23          	sw	a4,180(a5)
}
800052ee:	0001                	nop
800052f0:	4472                	lw	s0,28(sp)
800052f2:	6105                	addi	sp,sp,32
800052f4:	8082                	ret

800052f6 <ADCSD_WaitCycleCmd>:
  * @brief   Выбор количества тактов ожидания АЦП сигма-дельта
  * @param   waitClkAmount Количество тактов ожидания
  * @retval  void
  */
__STATIC_INLINE void ADCSD_WaitCycleCmd(uint32_t WaitCycle)
{
800052f6:	1101                	addi	sp,sp,-32
800052f8:	ce22                	sw	s0,28(sp)
800052fa:	1000                	addi	s0,sp,32
800052fc:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_WTCYC(WaitCycle));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_WTCYC_Msk, WaitCycle << ADCSD_CTRL_WTCYC_Pos);
80005300:	300127b7          	lui	a5,0x30012
80005304:	4398                	lw	a4,0(a5)
80005306:	fff907b7          	lui	a5,0xfff90
8000530a:	17fd                	addi	a5,a5,-1 # fff8ffff <__data_source_start+0x7ff871ab>
8000530c:	00f776b3          	and	a3,a4,a5
80005310:	fec42783          	lw	a5,-20(s0)
80005314:	01079713          	slli	a4,a5,0x10
80005318:	300127b7          	lui	a5,0x30012
8000531c:	8f55                	or	a4,a4,a3
8000531e:	c398                	sw	a4,0(a5)
}
80005320:	0001                	nop
80005322:	4472                	lw	s0,28(sp)
80005324:	6105                	addi	sp,sp,32
80005326:	8082                	ret

80005328 <ADCSD_MainDivCmd>:
  * @brief   Выбор основного делителя частоты АЦП сигма-дельта
  * @param   mainDiv Значение основного делителя частоты
  * @retval  void
  */
__STATIC_INLINE void ADCSD_MainDivCmd(uint32_t mainDiv)
{
80005328:	1101                	addi	sp,sp,-32
8000532a:	ce22                	sw	s0,28(sp)
8000532c:	1000                	addi	s0,sp,32
8000532e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_MDC(mainDiv));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_MDC_Msk, mainDiv << ADCSD_CTRL_MDC_Pos);
80005332:	300127b7          	lui	a5,0x30012
80005336:	4398                	lw	a4,0(a5)
80005338:	77e5                	lui	a5,0xffff9
8000533a:	17fd                	addi	a5,a5,-1 # ffff8fff <__data_source_start+0x7fff01ab>
8000533c:	00f776b3          	and	a3,a4,a5
80005340:	fec42783          	lw	a5,-20(s0)
80005344:	00c79713          	slli	a4,a5,0xc
80005348:	300127b7          	lui	a5,0x30012
8000534c:	8f55                	or	a4,a4,a3
8000534e:	c398                	sw	a4,0(a5)
}
80005350:	0001                	nop
80005352:	4472                	lw	s0,28(sp)
80005354:	6105                	addi	sp,sp,32
80005356:	8082                	ret

80005358 <ADCSD_SampleDivCmd>:
  * @brief   Выбор делителя коэффициента прореживания АЦП сигма-дельта
  * @param   sampleDiv Значение делителя коэффициента прореживания
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SampleDivCmd(uint32_t sampleDiv)
{
80005358:	1101                	addi	sp,sp,-32
8000535a:	ce22                	sw	s0,28(sp)
8000535c:	1000                	addi	s0,sp,32
8000535e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_ADCSD_DR(sampleDiv));

	MODIFY_REG(ADCSD->CTRL, ADCSD_CTRL_DR_Msk, sampleDiv << ADCSD_CTRL_DR_Pos);
80005362:	300127b7          	lui	a5,0x30012
80005366:	439c                	lw	a5,0(a5)
80005368:	cff7f693          	andi	a3,a5,-769
8000536c:	fec42783          	lw	a5,-20(s0)
80005370:	00879713          	slli	a4,a5,0x8
80005374:	300127b7          	lui	a5,0x30012
80005378:	8f55                	or	a4,a4,a3
8000537a:	c398                	sw	a4,0(a5)
}
8000537c:	0001                	nop
8000537e:	4472                	lw	s0,28(sp)
80005380:	6105                	addi	sp,sp,32
80005382:	8082                	ret

80005384 <ADCSD_SetMode>:
  * @param   ch_num Выбор канала АЦП
  * @param   mode Выбор режима
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SetMode(ADCSD_CH_Num_TypeDef ch_num, ADCSD_MODE_TypeDef mode)
{
80005384:	1101                	addi	sp,sp,-32
80005386:	ce22                	sw	s0,28(sp)
80005388:	1000                	addi	s0,sp,32
8000538a:	fea42623          	sw	a0,-20(s0)
8000538e:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_ADCSD_CH_NUM(ch_num));
	assert_param(IS_ADCSD_MODE(mode));

	MODIFY_REG(ADCSD->MODE, ADCSD_MODE_CH0_Msk << ((uint32_t)ch_num << 2), mode << ((uint32_t)ch_num << 2));
80005392:	300127b7          	lui	a5,0x30012
80005396:	43d8                	lw	a4,4(a5)
80005398:	fec42783          	lw	a5,-20(s0)
8000539c:	078a                	slli	a5,a5,0x2
8000539e:	468d                	li	a3,3
800053a0:	00f697b3          	sll	a5,a3,a5
800053a4:	fff7c793          	not	a5,a5
800053a8:	00f776b3          	and	a3,a4,a5
800053ac:	fec42783          	lw	a5,-20(s0)
800053b0:	078a                	slli	a5,a5,0x2
800053b2:	fe842703          	lw	a4,-24(s0)
800053b6:	00f71733          	sll	a4,a4,a5
800053ba:	300127b7          	lui	a5,0x30012
800053be:	8f55                	or	a4,a4,a3
800053c0:	c3d8                	sw	a4,4(a5)
}
800053c2:	0001                	nop
800053c4:	4472                	lw	s0,28(sp)
800053c6:	6105                	addi	sp,sp,32
800053c8:	8082                	ret

800053ca <ADCSD_SetAmplification>:
  * @param   ch_num Выбор канала АЦП сигма-дельта
  * @param 	 ampl Выбор усиления канала
  * @retval  void
  */
__STATIC_INLINE void ADCSD_SetAmplification(ADCSD_CH_Num_TypeDef ch_num, ADCSD_AMPL_TypeDef ampl)
{
800053ca:	1101                	addi	sp,sp,-32
800053cc:	ce22                	sw	s0,28(sp)
800053ce:	1000                	addi	s0,sp,32
800053d0:	fea42623          	sw	a0,-20(s0)
800053d4:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_ADCSD_CH_NUM(ch_num));
	assert_param(IS_ADCSD_AMPL(ampl));

	MODIFY_REG(ADCSD->AMPL, ADCSD_AMPL_CH0_Msk << ((uint32_t)ch_num << 2), (uint32_t)ampl << ((uint32_t)ch_num << 2));
800053d8:	300127b7          	lui	a5,0x30012
800053dc:	4798                	lw	a4,8(a5)
800053de:	fec42783          	lw	a5,-20(s0)
800053e2:	078a                	slli	a5,a5,0x2
800053e4:	469d                	li	a3,7
800053e6:	00f697b3          	sll	a5,a3,a5
800053ea:	fff7c793          	not	a5,a5
800053ee:	00f776b3          	and	a3,a4,a5
800053f2:	fec42783          	lw	a5,-20(s0)
800053f6:	078a                	slli	a5,a5,0x2
800053f8:	fe842703          	lw	a4,-24(s0)
800053fc:	00f71733          	sll	a4,a4,a5
80005400:	300127b7          	lui	a5,0x30012
80005404:	8f55                	or	a4,a4,a3
80005406:	c798                	sw	a4,8(a5)
}
80005408:	0001                	nop
8000540a:	4472                	lw	s0,28(sp)
8000540c:	6105                	addi	sp,sp,32
8000540e:	8082                	ret

80005410 <ADCSD_DeInit>:
/**
  * @brief   Устанавливает все регистры ADCSD значениями по умолчанию
  * @retval  void
  */
void ADCSD_DeInit(void)
{
80005410:	1141                	addi	sp,sp,-16
80005412:	c606                	sw	ra,12(sp)
80005414:	c422                	sw	s0,8(sp)
80005416:	0800                	addi	s0,sp,16
    RCU_ADCSDRstCmd(DISABLE);
80005418:	4501                	li	a0,0
8000541a:	356d                	jal	800052c4 <RCU_ADCSDRstCmd>
    RCU_ADCSDRstCmd(ENABLE);
8000541c:	4505                	li	a0,1
8000541e:	355d                	jal	800052c4 <RCU_ADCSDRstCmd>
}
80005420:	0001                	nop
80005422:	40b2                	lw	ra,12(sp)
80005424:	4422                	lw	s0,8(sp)
80005426:	0141                	addi	sp,sp,16
80005428:	8082                	ret

8000542a <ADCSD_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSD_Init(ADCSD_Init_TypeDef* InitStruct)
{
8000542a:	1101                	addi	sp,sp,-32
8000542c:	ce06                	sw	ra,28(sp)
8000542e:	cc22                	sw	s0,24(sp)
80005430:	1000                	addi	s0,sp,32
80005432:	fea42623          	sw	a0,-20(s0)
	ADCSD_WaitCycleCmd(InitStruct->WaitCycle);
80005436:	fec42783          	lw	a5,-20(s0)
8000543a:	439c                	lw	a5,0(a5)
8000543c:	853e                	mv	a0,a5
8000543e:	3d65                	jal	800052f6 <ADCSD_WaitCycleCmd>
	ADCSD_MainDivCmd(InitStruct->MainDiv);
80005440:	fec42783          	lw	a5,-20(s0)
80005444:	43dc                	lw	a5,4(a5)
80005446:	853e                	mv	a0,a5
80005448:	35c5                	jal	80005328 <ADCSD_MainDivCmd>
	ADCSD_SampleDivCmd(InitStruct->SampleDiv);
8000544a:	fec42783          	lw	a5,-20(s0)
8000544e:	479c                	lw	a5,8(a5)
80005450:	853e                	mv	a0,a5
80005452:	3719                	jal	80005358 <ADCSD_SampleDivCmd>
}
80005454:	0001                	nop
80005456:	40f2                	lw	ra,28(sp)
80005458:	4462                	lw	s0,24(sp)
8000545a:	6105                	addi	sp,sp,32
8000545c:	8082                	ret

8000545e <ADCSD_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSD_StructInit(ADCSD_Init_TypeDef* InitStruct)
{
8000545e:	1101                	addi	sp,sp,-32
80005460:	ce22                	sw	s0,28(sp)
80005462:	1000                	addi	s0,sp,32
80005464:	fea42623          	sw	a0,-20(s0)
	InitStruct->MainDiv = 0x0;
80005468:	fec42783          	lw	a5,-20(s0)
8000546c:	0007a223          	sw	zero,4(a5) # 30012004 <STACK_SIZE+0x30011804>
	InitStruct->SampleDiv = 0x0;
80005470:	fec42783          	lw	a5,-20(s0)
80005474:	0007a423          	sw	zero,8(a5)
	InitStruct->WaitCycle = 0x0;
80005478:	fec42783          	lw	a5,-20(s0)
8000547c:	0007a023          	sw	zero,0(a5)
}
80005480:	0001                	nop
80005482:	4472                	lw	s0,28(sp)
80005484:	6105                	addi	sp,sp,32
80005486:	8082                	ret

80005488 <ADCSD_CH_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_CH_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void ADCSD_CH_Init(ADCSD_CH_Num_TypeDef ch_num, ADCSD_CH_Init_TypeDef* InitStruct)
{
80005488:	1101                	addi	sp,sp,-32
8000548a:	ce06                	sw	ra,28(sp)
8000548c:	cc22                	sw	s0,24(sp)
8000548e:	1000                	addi	s0,sp,32
80005490:	fea42623          	sw	a0,-20(s0)
80005494:	feb42423          	sw	a1,-24(s0)
	ADCSD_SetMode(ch_num, InitStruct->Mode);
80005498:	fe842783          	lw	a5,-24(s0)
8000549c:	439c                	lw	a5,0(a5)
8000549e:	85be                	mv	a1,a5
800054a0:	fec42503          	lw	a0,-20(s0)
800054a4:	35c5                	jal	80005384 <ADCSD_SetMode>
	ADCSD_SetAmplification(ch_num, InitStruct->Amplifier);
800054a6:	fe842783          	lw	a5,-24(s0)
800054aa:	43dc                	lw	a5,4(a5)
800054ac:	85be                	mv	a1,a5
800054ae:	fec42503          	lw	a0,-20(s0)
800054b2:	3f21                	jal	800053ca <ADCSD_SetAmplification>
}
800054b4:	0001                	nop
800054b6:	40f2                	lw	ra,28(sp)
800054b8:	4462                	lw	s0,24(sp)
800054ba:	6105                	addi	sp,sp,32
800054bc:	8082                	ret

800054be <ADCSD_CH_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref ADCSD_CH_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void ADCSD_CH_StructInit(ADCSD_CH_Init_TypeDef* InitStruct)
{
800054be:	1101                	addi	sp,sp,-32
800054c0:	ce22                	sw	s0,28(sp)
800054c2:	1000                	addi	s0,sp,32
800054c4:	fea42623          	sw	a0,-20(s0)
	InitStruct->Amplifier = 0x0;
800054c8:	fec42783          	lw	a5,-20(s0)
800054cc:	0007a223          	sw	zero,4(a5)
	InitStruct->Mode = 0x1;
800054d0:	fec42783          	lw	a5,-20(s0)
800054d4:	4705                	li	a4,1
800054d6:	c398                	sw	a4,0(a5)
}
800054d8:	0001                	nop
800054da:	4472                	lw	s0,28(sp)
800054dc:	6105                	addi	sp,sp,32
800054de:	8082                	ret

800054e0 <RCU_AHBRstCmd>:
{
800054e0:	1101                	addi	sp,sp,-32
800054e2:	ce22                	sw	s0,28(sp)
800054e4:	1000                	addi	s0,sp,32
800054e6:	fea42623          	sw	a0,-20(s0)
800054ea:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
800054ee:	3000e7b7          	lui	a5,0x3000e
800054f2:	4b98                	lw	a4,16(a5)
800054f4:	fec42783          	lw	a5,-20(s0)
800054f8:	fff7c793          	not	a5,a5
800054fc:	00f776b3          	and	a3,a4,a5
80005500:	fe842783          	lw	a5,-24(s0)
80005504:	c781                	beqz	a5,8000550c <RCU_AHBRstCmd+0x2c>
80005506:	fec42783          	lw	a5,-20(s0)
8000550a:	a011                	j	8000550e <RCU_AHBRstCmd+0x2e>
8000550c:	4781                	li	a5,0
8000550e:	3000e737          	lui	a4,0x3000e
80005512:	8fd5                	or	a5,a5,a3
80005514:	cb1c                	sw	a5,16(a4)
}
80005516:	0001                	nop
80005518:	4472                	lw	s0,28(sp)
8000551a:	6105                	addi	sp,sp,32
8000551c:	8082                	ret

8000551e <CRC_ResetCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   state Бит сброса
  * @retval  void
  */
__STATIC_INLINE void CRC_ResetCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
8000551e:	1101                	addi	sp,sp,-32
80005520:	ce22                	sw	s0,28(sp)
80005522:	1000                	addi	s0,sp,32
80005524:	fea42623          	sw	a0,-20(s0)
80005528:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_RESET_Msk, state << CRC_CR_RESET_Pos);
8000552c:	fec42783          	lw	a5,-20(s0)
80005530:	47dc                	lw	a5,12(a5)
80005532:	ffe7f713          	andi	a4,a5,-2
80005536:	fe842783          	lw	a5,-24(s0)
8000553a:	8f5d                	or	a4,a4,a5
8000553c:	fec42783          	lw	a5,-20(s0)
80005540:	c7d8                	sw	a4,12(a5)
}
80005542:	0001                	nop
80005544:	4472                	lw	s0,28(sp)
80005546:	6105                	addi	sp,sp,32
80005548:	8082                	ret

8000554a <CRC_ModeCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   state Выбор режима
  * @retval  void
  */
__STATIC_INLINE void CRC_ModeCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
8000554a:	1101                	addi	sp,sp,-32
8000554c:	ce22                	sw	s0,28(sp)
8000554e:	1000                	addi	s0,sp,32
80005550:	fea42623          	sw	a0,-20(s0)
80005554:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_MODE_Msk, state << CRC_CR_MODE_Pos);
80005558:	fec42783          	lw	a5,-20(s0)
8000555c:	47dc                	lw	a5,12(a5)
8000555e:	ffd7f713          	andi	a4,a5,-3
80005562:	fe842783          	lw	a5,-24(s0)
80005566:	0786                	slli	a5,a5,0x1
80005568:	8f5d                	or	a4,a4,a5
8000556a:	fec42783          	lw	a5,-20(s0)
8000556e:	c7d8                	sw	a4,12(a5)
}
80005570:	0001                	nop
80005572:	4472                	lw	s0,28(sp)
80005574:	6105                	addi	sp,sp,32
80005576:	8082                	ret

80005578 <CRC_XOROutCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   state Выбор режима
  * @retval  void
  */
__STATIC_INLINE void CRC_XOROutCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
80005578:	1101                	addi	sp,sp,-32
8000557a:	ce22                	sw	s0,28(sp)
8000557c:	1000                	addi	s0,sp,32
8000557e:	fea42623          	sw	a0,-20(s0)
80005582:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_XOROUT_Msk, state << CRC_CR_XOROUT_Pos);
80005586:	fec42783          	lw	a5,-20(s0)
8000558a:	47dc                	lw	a5,12(a5)
8000558c:	ffb7f713          	andi	a4,a5,-5
80005590:	fe842783          	lw	a5,-24(s0)
80005594:	078a                	slli	a5,a5,0x2
80005596:	8f5d                	or	a4,a4,a5
80005598:	fec42783          	lw	a5,-20(s0)
8000559c:	c7d8                	sw	a4,12(a5)
}
8000559e:	0001                	nop
800055a0:	4472                	lw	s0,28(sp)
800055a2:	6105                	addi	sp,sp,32
800055a4:	8082                	ret

800055a6 <CRC_SetPolysize>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   polysize размер порождающего полинома
  * @retval  void
  */
__STATIC_INLINE void CRC_SetPolysize(CRC_TypeDef* CRCx, CRC_POLYSIZE_TypeDef polysize)
{
800055a6:	1101                	addi	sp,sp,-32
800055a8:	ce22                	sw	s0,28(sp)
800055aa:	1000                	addi	s0,sp,32
800055ac:	fea42623          	sw	a0,-20(s0)
800055b0:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_CRC_POLYSIZE(polysize));

	MODIFY_REG(CRCx->CR, CRC_CR_POLYSIZE_Msk, polysize << CRC_CR_POLYSIZE_Pos);
800055b4:	fec42783          	lw	a5,-20(s0)
800055b8:	47dc                	lw	a5,12(a5)
800055ba:	fe77f713          	andi	a4,a5,-25
800055be:	fe842783          	lw	a5,-24(s0)
800055c2:	078e                	slli	a5,a5,0x3
800055c4:	8f5d                	or	a4,a4,a5
800055c6:	fec42783          	lw	a5,-20(s0)
800055ca:	c7d8                	sw	a4,12(a5)
}
800055cc:	0001                	nop
800055ce:	4472                	lw	s0,28(sp)
800055d0:	6105                	addi	sp,sp,32
800055d2:	8082                	ret

800055d4 <CRC_SetRevIn>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   revin Обращение входных данных
  * @retval  void
  */
__STATIC_INLINE void CRC_SetRevIn(CRC_TypeDef* CRCx, CRC_REV_IN_TypeDef revin)
{
800055d4:	1101                	addi	sp,sp,-32
800055d6:	ce22                	sw	s0,28(sp)
800055d8:	1000                	addi	s0,sp,32
800055da:	fea42623          	sw	a0,-20(s0)
800055de:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_CRC_REV_IN(revin));

	MODIFY_REG(CRCx->CR, CRC_CR_REV_IN_Msk, revin << CRC_CR_REV_IN_Pos);
800055e2:	fec42783          	lw	a5,-20(s0)
800055e6:	47dc                	lw	a5,12(a5)
800055e8:	f9f7f713          	andi	a4,a5,-97
800055ec:	fe842783          	lw	a5,-24(s0)
800055f0:	0796                	slli	a5,a5,0x5
800055f2:	8f5d                	or	a4,a4,a5
800055f4:	fec42783          	lw	a5,-20(s0)
800055f8:	c7d8                	sw	a4,12(a5)
}
800055fa:	0001                	nop
800055fc:	4472                	lw	s0,28(sp)
800055fe:	6105                	addi	sp,sp,32
80005600:	8082                	ret

80005602 <CRC_RevOutCmd>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param	 state бит обращения выходных данных
  * @retval  void
  */
__STATIC_INLINE void CRC_RevOutCmd(CRC_TypeDef* CRCx, FunctionalState state)
{
80005602:	1101                	addi	sp,sp,-32
80005604:	ce22                	sw	s0,28(sp)
80005606:	1000                	addi	s0,sp,32
80005608:	fea42623          	sw	a0,-20(s0)
8000560c:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(CRCx->CR, CRC_CR_REV_OUT_Msk, state << CRC_CR_REV_OUT_Pos);
80005610:	fec42783          	lw	a5,-20(s0)
80005614:	47dc                	lw	a5,12(a5)
80005616:	f7f7f713          	andi	a4,a5,-129
8000561a:	fe842783          	lw	a5,-24(s0)
8000561e:	079e                	slli	a5,a5,0x7
80005620:	8f5d                	or	a4,a4,a5
80005622:	fec42783          	lw	a5,-20(s0)
80005626:	c7d8                	sw	a4,12(a5)
}
80005628:	0001                	nop
8000562a:	4472                	lw	s0,28(sp)
8000562c:	6105                	addi	sp,sp,32
8000562e:	8082                	ret

80005630 <CRC_SetInit>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   val Начальное значение блока
  * @retval  void
  */
__STATIC_INLINE void CRC_SetInit(CRC_TypeDef* CRCx, uint32_t val)
{
80005630:	1101                	addi	sp,sp,-32
80005632:	ce22                	sw	s0,28(sp)
80005634:	1000                	addi	s0,sp,32
80005636:	fea42623          	sw	a0,-20(s0)
8000563a:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	WRITE_REG(CRCx->INIT, val);
8000563e:	fec42783          	lw	a5,-20(s0)
80005642:	fe842703          	lw	a4,-24(s0)
80005646:	cb98                	sw	a4,16(a5)
}
80005648:	0001                	nop
8000564a:	4472                	lw	s0,28(sp)
8000564c:	6105                	addi	sp,sp,32
8000564e:	8082                	ret

80005650 <CRC_SetPol>:
  * @param	 CRCx Выбор модуля CRC, где x = 0 | 1
  * @param   val Значение коэффициентов порождающего полинома
  * @retval  void
  */
__STATIC_INLINE void CRC_SetPol(CRC_TypeDef* CRCx, uint32_t val)
{
80005650:	1101                	addi	sp,sp,-32
80005652:	ce22                	sw	s0,28(sp)
80005654:	1000                	addi	s0,sp,32
80005656:	fea42623          	sw	a0,-20(s0)
8000565a:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	WRITE_REG(CRCx->POL, val);
8000565e:	fec42783          	lw	a5,-20(s0)
80005662:	fe842703          	lw	a4,-24(s0)
80005666:	cbd8                	sw	a4,20(a5)
}
80005668:	0001                	nop
8000566a:	4472                	lw	s0,28(sp)
8000566c:	6105                	addi	sp,sp,32
8000566e:	8082                	ret

80005670 <CRC_DeInit>:
/**
  * @brief   Устанавливает все регистры CRC значениями по умолчанию
  * @retval  void
  */
void CRC_DeInit(CRC_TypeDef* CRCx)
{
80005670:	7179                	addi	sp,sp,-48
80005672:	d606                	sw	ra,44(sp)
80005674:	d422                	sw	s0,40(sp)
80005676:	1800                	addi	s0,sp,48
80005678:	fca42e23          	sw	a0,-36(s0)
	assert_param(IS_CRC_PERIPH(CRCx));

	CRC_ResetCmd(CRCx, ENABLE);
8000567c:	4585                	li	a1,1
8000567e:	fdc42503          	lw	a0,-36(s0)
80005682:	3d71                	jal	8000551e <CRC_ResetCmd>
	CRC_ResetCmd(CRCx, DISABLE);
80005684:	4581                	li	a1,0
80005686:	fdc42503          	lw	a0,-36(s0)
8000568a:	3d51                	jal	8000551e <CRC_ResetCmd>
	uint32_t CRC_num = (CRCx == CRC0) ? RCU_AHBRst_CRC0 : RCU_AHBRst_CRC1;
8000568c:	fdc42703          	lw	a4,-36(s0)
80005690:	200307b7          	lui	a5,0x20030
80005694:	00f71463          	bne	a4,a5,8000569c <CRC_DeInit+0x2c>
80005698:	6785                	lui	a5,0x1
8000569a:	a011                	j	8000569e <CRC_DeInit+0x2e>
8000569c:	6789                	lui	a5,0x2
8000569e:	fef42623          	sw	a5,-20(s0)
    RCU_AHBRstCmd(CRC_num, DISABLE);
800056a2:	4581                	li	a1,0
800056a4:	fec42503          	lw	a0,-20(s0)
800056a8:	3d25                	jal	800054e0 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(CRC_num, ENABLE);
800056aa:	4585                	li	a1,1
800056ac:	fec42503          	lw	a0,-20(s0)
800056b0:	3d05                	jal	800054e0 <RCU_AHBRstCmd>
}
800056b2:	0001                	nop
800056b4:	50b2                	lw	ra,44(sp)
800056b6:	5422                	lw	s0,40(sp)
800056b8:	6145                	addi	sp,sp,48
800056ba:	8082                	ret

800056bc <CRC_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref CRC_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void CRC_Init(CRC_TypeDef* CRCx, CRC_Init_TypeDef* InitStruct)
{
800056bc:	1101                	addi	sp,sp,-32
800056be:	ce06                	sw	ra,28(sp)
800056c0:	cc22                	sw	s0,24(sp)
800056c2:	1000                	addi	s0,sp,32
800056c4:	fea42623          	sw	a0,-20(s0)
800056c8:	feb42423          	sw	a1,-24(s0)
	CRC_SetInit(CRCx, InitStruct->Init);
800056cc:	fe842783          	lw	a5,-24(s0)
800056d0:	439c                	lw	a5,0(a5)
800056d2:	85be                	mv	a1,a5
800056d4:	fec42503          	lw	a0,-20(s0)
800056d8:	3fa1                	jal	80005630 <CRC_SetInit>
	CRC_SetRevIn(CRCx, InitStruct->RevIn);
800056da:	fe842783          	lw	a5,-24(s0)
800056de:	43dc                	lw	a5,4(a5)
800056e0:	85be                	mv	a1,a5
800056e2:	fec42503          	lw	a0,-20(s0)
800056e6:	35fd                	jal	800055d4 <CRC_SetRevIn>
	CRC_RevOutCmd(CRCx, InitStruct->RevOut);
800056e8:	fe842783          	lw	a5,-24(s0)
800056ec:	479c                	lw	a5,8(a5)
800056ee:	85be                	mv	a1,a5
800056f0:	fec42503          	lw	a0,-20(s0)
800056f4:	3739                	jal	80005602 <CRC_RevOutCmd>
	CRC_ModeCmd(CRCx, InitStruct->Mode);
800056f6:	fe842783          	lw	a5,-24(s0)
800056fa:	47dc                	lw	a5,12(a5)
800056fc:	85be                	mv	a1,a5
800056fe:	fec42503          	lw	a0,-20(s0)
80005702:	35a1                	jal	8000554a <CRC_ModeCmd>
	CRC_XOROutCmd(CRCx, InitStruct->XorOut);
80005704:	fe842783          	lw	a5,-24(s0)
80005708:	4b9c                	lw	a5,16(a5)
8000570a:	85be                	mv	a1,a5
8000570c:	fec42503          	lw	a0,-20(s0)
80005710:	35a5                	jal	80005578 <CRC_XOROutCmd>
	CRC_SetPolysize(CRCx, InitStruct->Polysize);
80005712:	fe842783          	lw	a5,-24(s0)
80005716:	4bdc                	lw	a5,20(a5)
80005718:	85be                	mv	a1,a5
8000571a:	fec42503          	lw	a0,-20(s0)
8000571e:	3561                	jal	800055a6 <CRC_SetPolysize>
	CRC_SetPol(CRCx, InitStruct->Pol);
80005720:	fe842783          	lw	a5,-24(s0)
80005724:	4f9c                	lw	a5,24(a5)
80005726:	85be                	mv	a1,a5
80005728:	fec42503          	lw	a0,-20(s0)
8000572c:	3715                	jal	80005650 <CRC_SetPol>
}
8000572e:	0001                	nop
80005730:	40f2                	lw	ra,28(sp)
80005732:	4462                	lw	s0,24(sp)
80005734:	6105                	addi	sp,sp,32
80005736:	8082                	ret

80005738 <CRC_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref CRC_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void CRC_StructInit(CRC_Init_TypeDef* InitStruct)
{
80005738:	1101                	addi	sp,sp,-32
8000573a:	ce22                	sw	s0,28(sp)
8000573c:	1000                	addi	s0,sp,32
8000573e:	fea42623          	sw	a0,-20(s0)
	InitStruct->Init = 0x0;
80005742:	fec42783          	lw	a5,-20(s0)
80005746:	0007a023          	sw	zero,0(a5) # 2000 <STACK_SIZE+0x1800>
	InitStruct->RevIn = 0x0;
8000574a:	fec42783          	lw	a5,-20(s0)
8000574e:	0007a223          	sw	zero,4(a5)
	InitStruct->RevOut = 0x0;
80005752:	fec42783          	lw	a5,-20(s0)
80005756:	0007a423          	sw	zero,8(a5)
	InitStruct->Mode = 0x0;
8000575a:	fec42783          	lw	a5,-20(s0)
8000575e:	0007a623          	sw	zero,12(a5)
	InitStruct->XorOut = 0x0;
80005762:	fec42783          	lw	a5,-20(s0)
80005766:	0007a823          	sw	zero,16(a5)
	InitStruct->Polysize = 0x0;
8000576a:	fec42783          	lw	a5,-20(s0)
8000576e:	0007aa23          	sw	zero,20(a5)
	InitStruct->Pol = 0x4C11DB7;	// CRC-32 (Ethernet)
80005772:	fec42783          	lw	a5,-20(s0)
80005776:	04c12737          	lui	a4,0x4c12
8000577a:	db770713          	addi	a4,a4,-585 # 4c11db7 <STACK_SIZE+0x4c115b7>
8000577e:	cf98                	sw	a4,24(a5)
}
80005780:	0001                	nop
80005782:	4472                	lw	s0,28(sp)
80005784:	6105                	addi	sp,sp,32
80005786:	8082                	ret

80005788 <RCU_AHBRstCmd>:
{
80005788:	1101                	addi	sp,sp,-32
8000578a:	ce22                	sw	s0,28(sp)
8000578c:	1000                	addi	s0,sp,32
8000578e:	fea42623          	sw	a0,-20(s0)
80005792:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80005796:	3000e7b7          	lui	a5,0x3000e
8000579a:	4b98                	lw	a4,16(a5)
8000579c:	fec42783          	lw	a5,-20(s0)
800057a0:	fff7c793          	not	a5,a5
800057a4:	00f776b3          	and	a3,a4,a5
800057a8:	fe842783          	lw	a5,-24(s0)
800057ac:	c781                	beqz	a5,800057b4 <RCU_AHBRstCmd+0x2c>
800057ae:	fec42783          	lw	a5,-20(s0)
800057b2:	a011                	j	800057b6 <RCU_AHBRstCmd+0x2e>
800057b4:	4781                	li	a5,0
800057b6:	3000e737          	lui	a4,0x3000e
800057ba:	8fd5                	or	a5,a5,a3
800057bc:	cb1c                	sw	a5,16(a4)
}
800057be:	0001                	nop
800057c0:	4472                	lw	s0,28(sp)
800057c2:	6105                	addi	sp,sp,32
800057c4:	8082                	ret

800057c6 <CRYPTO_UpdateKeyCmd>:
  * 		 или регистров KEY_0...KEY_3 для алгоритма AES-128
  * @pararm  state флаг обновления ключа
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_UpdateKeyCmd(FunctionalState state)
{
800057c6:	1101                	addi	sp,sp,-32
800057c8:	ce22                	sw	s0,28(sp)
800057ca:	1000                	addi	s0,sp,32
800057cc:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_UPDATE_KEY_Msk, state << CRYPTO_CONTROL_UPDATE_KEY_Pos);
800057d0:	200207b7          	lui	a5,0x20020
800057d4:	43fc                	lw	a5,68(a5)
800057d6:	ffe7f693          	andi	a3,a5,-2
800057da:	200207b7          	lui	a5,0x20020
800057de:	fec42703          	lw	a4,-20(s0)
800057e2:	8f55                	or	a4,a4,a3
800057e4:	c3f8                	sw	a4,68(a5)
}
800057e6:	0001                	nop
800057e8:	4472                	lw	s0,28(sp)
800057ea:	6105                	addi	sp,sp,32
800057ec:	8082                	ret

800057ee <CRYPTO_StartCmd>:
  * @brief   Запрос на выполнение криптографической операции.
  * 		 Непосредственный старт может быть отложен до завершения обновления ключей.
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_StartCmd()
{
800057ee:	1141                	addi	sp,sp,-16
800057f0:	c622                	sw	s0,12(sp)
800057f2:	0800                	addi	s0,sp,16
	SET_BIT(CRYPTO->CONTROL, CRYPTO_CONTROL_START_Msk);
800057f4:	200207b7          	lui	a5,0x20020
800057f8:	43f8                	lw	a4,68(a5)
800057fa:	200207b7          	lui	a5,0x20020
800057fe:	00276713          	ori	a4,a4,2
80005802:	c3f8                	sw	a4,68(a5)
}
80005804:	0001                	nop
80005806:	4432                	lw	s0,12(sp)
80005808:	0141                	addi	sp,sp,16
8000580a:	8082                	ret

8000580c <CRYPTO_DirectionConfig>:
  * @brief   Выбор направления криптографической операции
  * @param   dir Направление криптографической операции 0 - кодирование, 1 - декодирование
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DirectionConfig(CRYPTO_Dir_TypeDef dir)
{
8000580c:	1101                	addi	sp,sp,-32
8000580e:	ce22                	sw	s0,28(sp)
80005810:	1000                	addi	s0,sp,32
80005812:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_DIR(dir));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_DIRECTION_Msk, dir << CRYPTO_CONTROL_DIRECTION_Pos);
80005816:	200207b7          	lui	a5,0x20020
8000581a:	43fc                	lw	a5,68(a5)
8000581c:	ffb7f693          	andi	a3,a5,-5
80005820:	fec42783          	lw	a5,-20(s0)
80005824:	00279713          	slli	a4,a5,0x2
80005828:	200207b7          	lui	a5,0x20020
8000582c:	8f55                	or	a4,a4,a3
8000582e:	c3f8                	sw	a4,68(a5)
}
80005830:	0001                	nop
80005832:	4472                	lw	s0,28(sp)
80005834:	6105                	addi	sp,sp,32
80005836:	8082                	ret

80005838 <CRYPTO_AlgoConfig>:
  * @brief   Выбор криптографической алгоритма операции
  * @param   algo алгоритм криптографической операции
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_AlgoConfig(CRYPTO_Algo_TypeDef algo)
{
80005838:	1101                	addi	sp,sp,-32
8000583a:	ce22                	sw	s0,28(sp)
8000583c:	1000                	addi	s0,sp,32
8000583e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_ALGO(algo));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_ALGORITHM_Msk, algo << CRYPTO_CONTROL_ALGORITHM_Pos);
80005842:	200207b7          	lui	a5,0x20020
80005846:	43fc                	lw	a5,68(a5)
80005848:	fe77f693          	andi	a3,a5,-25
8000584c:	fec42783          	lw	a5,-20(s0)
80005850:	00379713          	slli	a4,a5,0x3
80005854:	200207b7          	lui	a5,0x20020
80005858:	8f55                	or	a4,a4,a3
8000585a:	c3f8                	sw	a4,68(a5)
}
8000585c:	0001                	nop
8000585e:	4472                	lw	s0,28(sp)
80005860:	6105                	addi	sp,sp,32
80005862:	8082                	ret

80005864 <CRYPTO_ModeConfig>:
  * @brief   Выбор режима выполнения криптографической операции
  * @param   mode режим выполнения криптографической операции
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_ModeConfig(CRYPTO_Mode_TypeDef mode)
{
80005864:	1101                	addi	sp,sp,-32
80005866:	ce22                	sw	s0,28(sp)
80005868:	1000                	addi	s0,sp,32
8000586a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_MODE(mode));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_MODE_Msk, mode << CRYPTO_CONTROL_MODE_Pos);
8000586e:	200207b7          	lui	a5,0x20020
80005872:	43fc                	lw	a5,68(a5)
80005874:	f9f7f693          	andi	a3,a5,-97
80005878:	fec42783          	lw	a5,-20(s0)
8000587c:	00579713          	slli	a4,a5,0x5
80005880:	200207b7          	lui	a5,0x20020
80005884:	8f55                	or	a4,a4,a3
80005886:	c3f8                	sw	a4,68(a5)
}
80005888:	0001                	nop
8000588a:	4472                	lw	s0,28(sp)
8000588c:	6105                	addi	sp,sp,32
8000588e:	8082                	ret

80005890 <CRYPTO_GCMPhaseConfig>:
  * @brief   Выбор режима выполнения криптографической операции
  * @param   phase установка фазы обработки пакета только для режима GCM
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_TypeDef phase)
{
80005890:	1101                	addi	sp,sp,-32
80005892:	ce22                	sw	s0,28(sp)
80005894:	1000                	addi	s0,sp,32
80005896:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_GCM_PHASE(phase));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_GCM_PHASE_Msk, phase << CRYPTO_CONTROL_GCM_PHASE_Pos);
8000589a:	200207b7          	lui	a5,0x20020
8000589e:	43fc                	lw	a5,68(a5)
800058a0:	9ff7f693          	andi	a3,a5,-1537
800058a4:	fec42783          	lw	a5,-20(s0)
800058a8:	00979713          	slli	a4,a5,0x9
800058ac:	200207b7          	lui	a5,0x20020
800058b0:	8f55                	or	a4,a4,a3
800058b2:	c3f8                	sw	a4,68(a5)
}
800058b4:	0001                	nop
800058b6:	4472                	lw	s0,28(sp)
800058b8:	6105                	addi	sp,sp,32
800058ba:	8082                	ret

800058bc <CRYPTO_InitVectorAutoUpdateCmd>:
  * @brief   Разрешение автоматического обновления регистров IV_* при завершении криптографической операции
  * @param   state флаг разрешения
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_InitVectorAutoUpdateCmd(FunctionalState state)
{
800058bc:	1101                	addi	sp,sp,-32
800058be:	ce22                	sw	s0,28(sp)
800058c0:	1000                	addi	s0,sp,32
800058c2:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->CONTROL, CRYPTO_CONTROL_SELF_UPDATE_Msk, state << CRYPTO_CONTROL_SELF_UPDATE_Pos);
800058c6:	200207b7          	lui	a5,0x20020
800058ca:	43fc                	lw	a5,68(a5)
800058cc:	eff7f693          	andi	a3,a5,-257
800058d0:	fec42783          	lw	a5,-20(s0)
800058d4:	00879713          	slli	a4,a5,0x8
800058d8:	200207b7          	lui	a5,0x20020
800058dc:	8f55                	or	a4,a4,a3
800058de:	c3f8                	sw	a4,68(a5)
}
800058e0:	0001                	nop
800058e2:	4472                	lw	s0,28(sp)
800058e4:	6105                	addi	sp,sp,32
800058e6:	8082                	ret

800058e8 <CRYPTO_SetInitVector>:
  * @param   idx индекс в массиве вектора инициализации
  * @param   val значение части вектора инициализации
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_SetInitVector(uint32_t idx, uint32_t val)
{
800058e8:	1101                	addi	sp,sp,-32
800058ea:	ce22                	sw	s0,28(sp)
800058ec:	1000                	addi	s0,sp,32
800058ee:	fea42623          	sw	a0,-20(s0)
800058f2:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRYPTO_IV(idx));

	WRITE_REG(CRYPTO->IV[idx], val);
800058f6:	20020737          	lui	a4,0x20020
800058fa:	fec42783          	lw	a5,-20(s0)
800058fe:	078a                	slli	a5,a5,0x2
80005900:	97ba                	add	a5,a5,a4
80005902:	fe842703          	lw	a4,-24(s0)
80005906:	c398                	sw	a4,0(a5)
}
80005908:	0001                	nop
8000590a:	4472                	lw	s0,28(sp)
8000590c:	6105                	addi	sp,sp,32
8000590e:	8082                	ret

80005910 <CRYPTO_SetTextInput>:
  * @param   idx индекс в массиве входного текста
  * @param   val значение входного текста
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_SetTextInput(uint32_t idx, uint32_t val)
{
80005910:	1101                	addi	sp,sp,-32
80005912:	ce22                	sw	s0,28(sp)
80005914:	1000                	addi	s0,sp,32
80005916:	fea42623          	sw	a0,-20(s0)
8000591a:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRYPTO_TEXT_IN(idx));

	WRITE_REG(CRYPTO->TEXT_IN[idx], val);
8000591e:	20020737          	lui	a4,0x20020
80005922:	fec42783          	lw	a5,-20(s0)
80005926:	0791                	addi	a5,a5,4 # 20020004 <STACK_SIZE+0x2001f804>
80005928:	078a                	slli	a5,a5,0x2
8000592a:	97ba                	add	a5,a5,a4
8000592c:	fe842703          	lw	a4,-24(s0)
80005930:	c398                	sw	a4,0(a5)
}
80005932:	0001                	nop
80005934:	4472                	lw	s0,28(sp)
80005936:	6105                	addi	sp,sp,32
80005938:	8082                	ret

8000593a <CRYPTO_SetKeyInReg>:
  * @param   idx индекс в массиве раундовых ключей
  * @param   val значение элемента раундового ключа
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_SetKeyInReg(uint32_t idx, uint32_t val)
{
8000593a:	1101                	addi	sp,sp,-32
8000593c:	ce22                	sw	s0,28(sp)
8000593e:	1000                	addi	s0,sp,32
80005940:	fea42623          	sw	a0,-20(s0)
80005944:	feb42423          	sw	a1,-24(s0)
	assert_param(IS_CRYPTO_KEY(idx));

	WRITE_REG(CRYPTO->KEY[idx], val);
80005948:	20020737          	lui	a4,0x20020
8000594c:	fec42783          	lw	a5,-20(s0)
80005950:	07a1                	addi	a5,a5,8
80005952:	078a                	slli	a5,a5,0x2
80005954:	97ba                	add	a5,a5,a4
80005956:	fe842703          	lw	a4,-24(s0)
8000595a:	c398                	sw	a4,0(a5)
}
8000595c:	0001                	nop
8000595e:	4472                	lw	s0,28(sp)
80005960:	6105                	addi	sp,sp,32
80005962:	8082                	ret

80005964 <CRYPTO_GetTextOutput>:
  * @brief   Получение значения выходного регистра
  * @param   idx индекс в массиве [0; 3]
  * @retval  void
  */
__STATIC_INLINE uint32_t CRYPTO_GetTextOutput(uint32_t idx)
{
80005964:	1101                	addi	sp,sp,-32
80005966:	ce22                	sw	s0,28(sp)
80005968:	1000                	addi	s0,sp,32
8000596a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_TEXT_OUT(idx));

	return (uint32_t) READ_REG(CRYPTO->TEXT_OUT[idx]);
8000596e:	20020737          	lui	a4,0x20020
80005972:	fec42783          	lw	a5,-20(s0)
80005976:	07f1                	addi	a5,a5,28
80005978:	078a                	slli	a5,a5,0x2
8000597a:	97ba                	add	a5,a5,a4
8000597c:	439c                	lw	a5,0(a5)
}
8000597e:	853e                	mv	a0,a5
80005980:	4472                	lw	s0,28(sp)
80005982:	6105                	addi	sp,sp,32
80005984:	8082                	ret

80005986 <CRYPTO_GetGCMTag>:
  * @brief   Получение значения регистра, содержащего аутентификационный тэг GCM
  * @param   idx индекс в массиве [0; 3]
  * @retval  void
  */
__STATIC_INLINE uint32_t CRYPTO_GetGCMTag(uint32_t idx)
{
80005986:	1101                	addi	sp,sp,-32
80005988:	ce22                	sw	s0,28(sp)
8000598a:	1000                	addi	s0,sp,32
8000598c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_CRYPTO_GCM_TAG(idx));

	return (uint32_t) READ_REG(CRYPTO->GCM_TAG[idx]);
80005990:	20020737          	lui	a4,0x20020
80005994:	fec42783          	lw	a5,-20(s0)
80005998:	02878793          	addi	a5,a5,40
8000599c:	078a                	slli	a5,a5,0x2
8000599e:	97ba                	add	a5,a5,a4
800059a0:	439c                	lw	a5,0(a5)
}
800059a2:	853e                	mv	a0,a5
800059a4:	4472                	lw	s0,28(sp)
800059a6:	6105                	addi	sp,sp,32
800059a8:	8082                	ret

800059aa <CRYPTO_ReadyStatus>:
/**
  * @brief   Получение флага о готовности модуля выполнять очередную криптографическую операцию и/или обновлять раундовые ключи шифрования
  * @retval  state флаг готовности модуля
  */
__STATIC_INLINE FunctionalState CRYPTO_ReadyStatus()
{
800059aa:	1141                	addi	sp,sp,-16
800059ac:	c622                	sw	s0,12(sp)
800059ae:	0800                	addi	s0,sp,16
	return (FunctionalState) READ_BIT(CRYPTO->STATUS, CRYPTO_STATUS_READY_Msk);
800059b0:	200207b7          	lui	a5,0x20020
800059b4:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
800059b8:	8b85                	andi	a5,a5,1
}
800059ba:	853e                	mv	a0,a5
800059bc:	4432                	lw	s0,12(sp)
800059be:	0141                	addi	sp,sp,16
800059c0:	8082                	ret

800059c2 <CRYPTO_DMA_SetBaseDescriptor>:
  * @brief   Устанаваливает базовый дескриптор для DMA
  * @param   address адрес базового дескриптора, являющийся структурой типа @ref CRYPTO_DMA_DesciptorAddress_TypeDef
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_SetBaseDescriptor(uint32_t address)
{
800059c2:	1101                	addi	sp,sp,-32
800059c4:	ce22                	sw	s0,28(sp)
800059c6:	1000                	addi	s0,sp,32
800059c8:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(CRYPTO->BASE_DESCRIPTOR, address);
800059cc:	200207b7          	lui	a5,0x20020
800059d0:	fec42703          	lw	a4,-20(s0)
800059d4:	c7b8                	sw	a4,72(a5)
}
800059d6:	0001                	nop
800059d8:	4472                	lw	s0,28(sp)
800059da:	6105                	addi	sp,sp,32
800059dc:	8082                	ret

800059de <CRYPTO_DMA_StartCmd>:
/**
  * @brief   Запускает последовательность операций в режиме DMA
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_StartCmd()
{
800059de:	1141                	addi	sp,sp,-16
800059e0:	c622                	sw	s0,12(sp)
800059e2:	0800                	addi	s0,sp,16
	SET_BIT(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_START_Msk);
800059e4:	200207b7          	lui	a5,0x20020
800059e8:	47f8                	lw	a4,76(a5)
800059ea:	200207b7          	lui	a5,0x20020
800059ee:	00176713          	ori	a4,a4,1
800059f2:	c7f8                	sw	a4,76(a5)
}
800059f4:	0001                	nop
800059f6:	4432                	lw	s0,12(sp)
800059f8:	0141                	addi	sp,sp,16
800059fa:	8082                	ret

800059fc <CRYPTO_DMA_ByteSwapCmd>:
  * @brief   Инвертирование порядка байт припосылке на шину AHB
  * @param   state флаг инвертирования
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_ByteSwapCmd(FunctionalState state)
{
800059fc:	1101                	addi	sp,sp,-32
800059fe:	ce22                	sw	s0,28(sp)
80005a00:	1000                	addi	s0,sp,32
80005a02:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_BYTES_SWAP_Msk, state << CRYPTO_DMA_CONTROL_BYTES_SWAP_Pos);
80005a06:	200207b7          	lui	a5,0x20020
80005a0a:	47fc                	lw	a5,76(a5)
80005a0c:	ffd7f693          	andi	a3,a5,-3
80005a10:	fec42783          	lw	a5,-20(s0)
80005a14:	00179713          	slli	a4,a5,0x1
80005a18:	200207b7          	lui	a5,0x20020
80005a1c:	8f55                	or	a4,a4,a3
80005a1e:	c7f8                	sw	a4,76(a5)
}
80005a20:	0001                	nop
80005a22:	4472                	lw	s0,28(sp)
80005a24:	6105                	addi	sp,sp,32
80005a26:	8082                	ret

80005a28 <CRYPTO_DMA_WordSwapCmd>:
  * @brief   Инвертирование порядка слов припосылке на шину AHB
  * @param   state флаг инвертирования
  * @retval  void
  */
__STATIC_INLINE void CRYPTO_DMA_WordSwapCmd(FunctionalState state)
{
80005a28:	1101                	addi	sp,sp,-32
80005a2a:	ce22                	sw	s0,28(sp)
80005a2c:	1000                	addi	s0,sp,32
80005a2e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

    MODIFY_REG(CRYPTO->DMA_CONTROL, CRYPTO_DMA_CONTROL_WORDS_SWAP_Msk, state << CRYPTO_DMA_CONTROL_WORDS_SWAP_Pos);
80005a32:	200207b7          	lui	a5,0x20020
80005a36:	47fc                	lw	a5,76(a5)
80005a38:	ffb7f693          	andi	a3,a5,-5
80005a3c:	fec42783          	lw	a5,-20(s0)
80005a40:	00279713          	slli	a4,a5,0x2
80005a44:	200207b7          	lui	a5,0x20020
80005a48:	8f55                	or	a4,a4,a3
80005a4a:	c7f8                	sw	a4,76(a5)
}
80005a4c:	0001                	nop
80005a4e:	4472                	lw	s0,28(sp)
80005a50:	6105                	addi	sp,sp,32
80005a52:	8082                	ret

80005a54 <CRYPTO_DMA_ActiveStatus>:
/**
  * @brief   Получение флага о занятости DMA выполнением дескриптора
  * @retval  state флаг занятости DMA
  */
__STATIC_INLINE FunctionalState CRYPTO_DMA_ActiveStatus()
{
80005a54:	1141                	addi	sp,sp,-16
80005a56:	c622                	sw	s0,12(sp)
80005a58:	0800                	addi	s0,sp,16
	return (FunctionalState) READ_BIT(CRYPTO->STATUS, CRYPTO_STATUS_DMA_ACTIVE_Msk);
80005a5a:	200207b7          	lui	a5,0x20020
80005a5e:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
80005a62:	1007f793          	andi	a5,a5,256
80005a66:	c399                	beqz	a5,80005a6c <CRYPTO_DMA_ActiveStatus+0x18>
80005a68:	4785                	li	a5,1
80005a6a:	a011                	j	80005a6e <CRYPTO_DMA_ActiveStatus+0x1a>
80005a6c:	4781                	li	a5,0
}
80005a6e:	853e                	mv	a0,a5
80005a70:	4432                	lw	s0,12(sp)
80005a72:	0141                	addi	sp,sp,16
80005a74:	8082                	ret

80005a76 <CRYPTO_DeInit>:
/**
  * @brief   Устанавливает все регистры CRYPTO значениями по умолчанию
  * @retval  void
  */
void CRYPTO_DeInit()
{
80005a76:	1141                	addi	sp,sp,-16
80005a78:	c606                	sw	ra,12(sp)
80005a7a:	c422                	sw	s0,8(sp)
80005a7c:	0800                	addi	s0,sp,16
	RCU_AHBRstCmd(RCU_AHBRst_CRYPTO, DISABLE);
80005a7e:	4581                	li	a1,0
80005a80:	4511                	li	a0,4
80005a82:	3319                	jal	80005788 <RCU_AHBRstCmd>
	RCU_AHBRstCmd(RCU_AHBRst_CRYPTO, ENABLE);
80005a84:	4585                	li	a1,1
80005a86:	4511                	li	a0,4
80005a88:	3301                	jal	80005788 <RCU_AHBRstCmd>
}
80005a8a:	0001                	nop
80005a8c:	40b2                	lw	ra,12(sp)
80005a8e:	4422                	lw	s0,8(sp)
80005a90:	0141                	addi	sp,sp,16
80005a92:	8082                	ret

80005a94 <CRYPTO_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref CRYPTO_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void CRYPTO_Init(CRYPTO_Init_TypeDef* InitStruct)
{
80005a94:	1101                	addi	sp,sp,-32
80005a96:	ce06                	sw	ra,28(sp)
80005a98:	cc22                	sw	s0,24(sp)
80005a9a:	1000                	addi	s0,sp,32
80005a9c:	fea42623          	sw	a0,-20(s0)
	CRYPTO_DirectionConfig(InitStruct->Direction);
80005aa0:	fec42783          	lw	a5,-20(s0)
80005aa4:	439c                	lw	a5,0(a5)
80005aa6:	853e                	mv	a0,a5
80005aa8:	3395                	jal	8000580c <CRYPTO_DirectionConfig>
	CRYPTO_AlgoConfig(InitStruct->Algorithm);
80005aaa:	fec42783          	lw	a5,-20(s0)
80005aae:	43dc                	lw	a5,4(a5)
80005ab0:	853e                	mv	a0,a5
80005ab2:	3359                	jal	80005838 <CRYPTO_AlgoConfig>
	CRYPTO_ModeConfig(InitStruct->Mode);
80005ab4:	fec42783          	lw	a5,-20(s0)
80005ab8:	479c                	lw	a5,8(a5)
80005aba:	853e                	mv	a0,a5
80005abc:	3365                	jal	80005864 <CRYPTO_ModeConfig>
	CRYPTO_InitVectorAutoUpdateCmd(InitStruct->InitVectorAutoUpdate);
80005abe:	fec42783          	lw	a5,-20(s0)
80005ac2:	47dc                	lw	a5,12(a5)
80005ac4:	853e                	mv	a0,a5
80005ac6:	3bdd                	jal	800058bc <CRYPTO_InitVectorAutoUpdateCmd>
	CRYPTO_UpdateKeyCmd(InitStruct->UpdateKey);
80005ac8:	fec42783          	lw	a5,-20(s0)
80005acc:	4b9c                	lw	a5,16(a5)
80005ace:	853e                	mv	a0,a5
80005ad0:	39dd                	jal	800057c6 <CRYPTO_UpdateKeyCmd>
	CRYPTO_GCMPhaseConfig(InitStruct->GCMPhase);
80005ad2:	fec42783          	lw	a5,-20(s0)
80005ad6:	4bdc                	lw	a5,20(a5)
80005ad8:	853e                	mv	a0,a5
80005ada:	3b5d                	jal	80005890 <CRYPTO_GCMPhaseConfig>
}
80005adc:	0001                	nop
80005ade:	40f2                	lw	ra,28(sp)
80005ae0:	4462                	lw	s0,24(sp)
80005ae2:	6105                	addi	sp,sp,32
80005ae4:	8082                	ret

80005ae6 <CRYPTO_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref CRYPTO_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void CRYPTO_StructInit(CRYPTO_Init_TypeDef* InitStruct)
{
80005ae6:	1101                	addi	sp,sp,-32
80005ae8:	ce22                	sw	s0,28(sp)
80005aea:	1000                	addi	s0,sp,32
80005aec:	fea42623          	sw	a0,-20(s0)
	InitStruct->Direction = CRYPTO_Dir_Encrypt;
80005af0:	fec42783          	lw	a5,-20(s0)
80005af4:	0007a023          	sw	zero,0(a5)
	InitStruct->Algorithm = CRYPTO_Algo_AES_256;
80005af8:	fec42783          	lw	a5,-20(s0)
80005afc:	4705                	li	a4,1
80005afe:	c3d8                	sw	a4,4(a5)
	InitStruct->Mode = CRYPTO_Mode_GCM;
80005b00:	fec42783          	lw	a5,-20(s0)
80005b04:	470d                	li	a4,3
80005b06:	c798                	sw	a4,8(a5)
	InitStruct->InitVectorAutoUpdate = ENABLE;
80005b08:	fec42783          	lw	a5,-20(s0)
80005b0c:	4705                	li	a4,1
80005b0e:	c7d8                	sw	a4,12(a5)
	InitStruct->UpdateKey = ENABLE;
80005b10:	fec42783          	lw	a5,-20(s0)
80005b14:	4705                	li	a4,1
80005b16:	cb98                	sw	a4,16(a5)
	InitStruct->GCMPhase = CRYPTO_GCM_PHASE_INIT;
80005b18:	fec42783          	lw	a5,-20(s0)
80005b1c:	0007aa23          	sw	zero,20(a5)
}
80005b20:	0001                	nop
80005b22:	4472                	lw	s0,28(sp)
80005b24:	6105                	addi	sp,sp,32
80005b26:	8082                	ret

80005b28 <CRYPTO_DMAStructInit>:
  * @param   CryptoStruct Указатель на стуктуру типа @ref CRYPTO_Init_TypeDef,
  * 					  которая содержит параметры шифрования
  * @retval  void
  */
void CRYPTO_DMAStructInit(CRYPTO_DMAInit_TypeDef* DMAStruct, CRYPTO_Init_TypeDef* CryptoStruct)
{
80005b28:	1101                	addi	sp,sp,-32
80005b2a:	ce22                	sw	s0,28(sp)
80005b2c:	1000                	addi	s0,sp,32
80005b2e:	fea42623          	sw	a0,-20(s0)
80005b32:	feb42423          	sw	a1,-24(s0)
	DMAStruct->ByteSwap = DISABLE;
80005b36:	fec42783          	lw	a5,-20(s0)
80005b3a:	0007a023          	sw	zero,0(a5)
	DMAStruct->WordSwap = DISABLE;
80005b3e:	fec42783          	lw	a5,-20(s0)
80005b42:	0007a223          	sw	zero,4(a5)

	DMAStruct->CryptoSettings = CryptoStruct;
80005b46:	fec42783          	lw	a5,-20(s0)
80005b4a:	fe842703          	lw	a4,-24(s0)
80005b4e:	cbd8                	sw	a4,20(a5)
	DMAStruct->LastDescriptor = ENABLE;
80005b50:	fec42783          	lw	a5,-20(s0)
80005b54:	4705                	li	a4,1
80005b56:	c798                	sw	a4,8(a5)
	DMAStruct->ITEnable = DISABLE;
80005b58:	fec42783          	lw	a5,-20(s0)
80005b5c:	0007a623          	sw	zero,12(a5)
	DMAStruct->BlocksCount = 0;
80005b60:	fec42783          	lw	a5,-20(s0)
80005b64:	0007a823          	sw	zero,16(a5)

	DMAStruct->SourceAddress = 0;
80005b68:	fec42783          	lw	a5,-20(s0)
80005b6c:	0007ae23          	sw	zero,28(a5)
	DMAStruct->DestinationAddress = 0;
80005b70:	fec42783          	lw	a5,-20(s0)
80005b74:	0207a023          	sw	zero,32(a5)
//	DMAStruct->DescriptorPtr->NEXT_DESCR = 0x80;
//	DMAStruct->DescriptorPtr = 0x80;
}
80005b78:	0001                	nop
80005b7a:	4472                	lw	s0,28(sp)
80005b7c:	6105                	addi	sp,sp,32
80005b7e:	8082                	ret

80005b80 <CRYPTO_InitDMADescriptor>:
  * @param   DMAStruct  Указатель на структуру типа @ref CRYPTO_DMAInit_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
uint32_t CRYPTO_InitDMADescriptor(CRYPTO_DMAInit_TypeDef* DMAStruct)
{
80005b80:	1101                	addi	sp,sp,-32
80005b82:	ce06                	sw	ra,28(sp)
80005b84:	cc22                	sw	s0,24(sp)
80005b86:	1000                	addi	s0,sp,32
80005b88:	fea42623          	sw	a0,-20(s0)
	/* CRYPTO DMA operation control word */
	DMAStruct->DescriptorPtr->CONTROL_bit.UPDATE_KEY = DMAStruct->CryptoSettings->UpdateKey;
80005b8c:	fec42783          	lw	a5,-20(s0)
80005b90:	4bdc                	lw	a5,20(a5)
80005b92:	4b98                	lw	a4,16(a5)
80005b94:	fec42783          	lw	a5,-20(s0)
80005b98:	53dc                	lw	a5,36(a5)
80005b9a:	8b05                	andi	a4,a4,1
80005b9c:	0ff77713          	zext.b	a4,a4
80005ba0:	8b05                	andi	a4,a4,1
80005ba2:	4394                	lw	a3,0(a5)
80005ba4:	9af9                	andi	a3,a3,-2
80005ba6:	8f55                	or	a4,a4,a3
80005ba8:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.LAST_DESCRIPTOR = DMAStruct->LastDescriptor;
80005baa:	fec42783          	lw	a5,-20(s0)
80005bae:	4798                	lw	a4,8(a5)
80005bb0:	fec42783          	lw	a5,-20(s0)
80005bb4:	53dc                	lw	a5,36(a5)
80005bb6:	8b05                	andi	a4,a4,1
80005bb8:	0ff77713          	zext.b	a4,a4
80005bbc:	8b05                	andi	a4,a4,1
80005bbe:	0706                	slli	a4,a4,0x1
80005bc0:	4394                	lw	a3,0(a5)
80005bc2:	9af5                	andi	a3,a3,-3
80005bc4:	8f55                	or	a4,a4,a3
80005bc6:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.DIRECTION = DMAStruct->CryptoSettings->Direction;
80005bc8:	fec42783          	lw	a5,-20(s0)
80005bcc:	4bdc                	lw	a5,20(a5)
80005bce:	4398                	lw	a4,0(a5)
80005bd0:	fec42783          	lw	a5,-20(s0)
80005bd4:	53dc                	lw	a5,36(a5)
80005bd6:	8b05                	andi	a4,a4,1
80005bd8:	0ff77713          	zext.b	a4,a4
80005bdc:	8b05                	andi	a4,a4,1
80005bde:	070a                	slli	a4,a4,0x2
80005be0:	4394                	lw	a3,0(a5)
80005be2:	9aed                	andi	a3,a3,-5
80005be4:	8f55                	or	a4,a4,a3
80005be6:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.ALGORITHM = DMAStruct->CryptoSettings->Algorithm;
80005be8:	fec42783          	lw	a5,-20(s0)
80005bec:	4bdc                	lw	a5,20(a5)
80005bee:	43d8                	lw	a4,4(a5)
80005bf0:	fec42783          	lw	a5,-20(s0)
80005bf4:	53dc                	lw	a5,36(a5)
80005bf6:	8b0d                	andi	a4,a4,3
80005bf8:	0ff77713          	zext.b	a4,a4
80005bfc:	8b0d                	andi	a4,a4,3
80005bfe:	070e                	slli	a4,a4,0x3
80005c00:	4394                	lw	a3,0(a5)
80005c02:	9a9d                	andi	a3,a3,-25
80005c04:	8f55                	or	a4,a4,a3
80005c06:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.MODE = DMAStruct->CryptoSettings->Mode;
80005c08:	fec42783          	lw	a5,-20(s0)
80005c0c:	4bdc                	lw	a5,20(a5)
80005c0e:	4798                	lw	a4,8(a5)
80005c10:	fec42783          	lw	a5,-20(s0)
80005c14:	53dc                	lw	a5,36(a5)
80005c16:	8b0d                	andi	a4,a4,3
80005c18:	0ff77713          	zext.b	a4,a4
80005c1c:	8b0d                	andi	a4,a4,3
80005c1e:	0716                	slli	a4,a4,0x5
80005c20:	4394                	lw	a3,0(a5)
80005c22:	f9f6f693          	andi	a3,a3,-97
80005c26:	8f55                	or	a4,a4,a3
80005c28:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.GCM_PHASE = DMAStruct->CryptoSettings->GCMPhase;
80005c2a:	fec42783          	lw	a5,-20(s0)
80005c2e:	4bdc                	lw	a5,20(a5)
80005c30:	4bd8                	lw	a4,20(a5)
80005c32:	fec42783          	lw	a5,-20(s0)
80005c36:	53dc                	lw	a5,36(a5)
80005c38:	8b0d                	andi	a4,a4,3
80005c3a:	0ff77713          	zext.b	a4,a4
80005c3e:	8b0d                	andi	a4,a4,3
80005c40:	0736                	slli	a4,a4,0xd
80005c42:	4390                	lw	a2,0(a5)
80005c44:	76e9                	lui	a3,0xffffa
80005c46:	16fd                	addi	a3,a3,-1 # ffff9fff <__data_source_start+0x7fff11ab>
80005c48:	8ef1                	and	a3,a3,a2
80005c4a:	8f55                	or	a4,a4,a3
80005c4c:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.INTERRUPT_ENABLE = DMAStruct->ITEnable;
80005c4e:	fec42783          	lw	a5,-20(s0)
80005c52:	47d8                	lw	a4,12(a5)
80005c54:	fec42783          	lw	a5,-20(s0)
80005c58:	53dc                	lw	a5,36(a5)
80005c5a:	8b05                	andi	a4,a4,1
80005c5c:	0ff77713          	zext.b	a4,a4
80005c60:	8b05                	andi	a4,a4,1
80005c62:	073e                	slli	a4,a4,0xf
80005c64:	4390                	lw	a2,0(a5)
80005c66:	76e1                	lui	a3,0xffff8
80005c68:	16fd                	addi	a3,a3,-1 # ffff7fff <__data_source_start+0x7ffef1ab>
80005c6a:	8ef1                	and	a3,a3,a2
80005c6c:	8f55                	or	a4,a4,a3
80005c6e:	c398                	sw	a4,0(a5)
	DMAStruct->DescriptorPtr->CONTROL_bit.BLOCKS_COUNT = DMAStruct->BlocksCount;
80005c70:	fec42783          	lw	a5,-20(s0)
80005c74:	4b98                	lw	a4,16(a5)
80005c76:	fec42783          	lw	a5,-20(s0)
80005c7a:	53dc                	lw	a5,36(a5)
80005c7c:	86ba                	mv	a3,a4
80005c7e:	6705                	lui	a4,0x1
80005c80:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80005c82:	8f75                	and	a4,a4,a3
80005c84:	01071693          	slli	a3,a4,0x10
80005c88:	82c1                	srli	a3,a3,0x10
80005c8a:	6705                	lui	a4,0x1
80005c8c:	177d                	addi	a4,a4,-1 # fff <STACK_SIZE+0x7ff>
80005c8e:	8f75                	and	a4,a4,a3
80005c90:	0742                	slli	a4,a4,0x10
80005c92:	4390                	lw	a2,0(a5)
80005c94:	f00106b7          	lui	a3,0xf0010
80005c98:	16fd                	addi	a3,a3,-1 # f000ffff <__data_source_start+0x700071ab>
80005c9a:	8ef1                	and	a3,a3,a2
80005c9c:	8f55                	or	a4,a4,a3
80005c9e:	c398                	sw	a4,0(a5)

	DMAStruct->DescriptorPtr->SRC_ADDR = (uint32_t) DMAStruct->SourceAddress;
80005ca0:	fec42783          	lw	a5,-20(s0)
80005ca4:	4fd8                	lw	a4,28(a5)
80005ca6:	fec42783          	lw	a5,-20(s0)
80005caa:	53dc                	lw	a5,36(a5)
80005cac:	c3d8                	sw	a4,4(a5)
	DMAStruct->DescriptorPtr->DST_ADDR = (uint32_t) DMAStruct->DestinationAddress;
80005cae:	fec42783          	lw	a5,-20(s0)
80005cb2:	5398                	lw	a4,32(a5)
80005cb4:	fec42783          	lw	a5,-20(s0)
80005cb8:	53dc                	lw	a5,36(a5)
80005cba:	c798                	sw	a4,8(a5)
	DMAStruct->DescriptorPtr->NEXT_DESCR = (uint32_t) DMAStruct->LastDescriptor ? 0 : CRYPTO_InitDMADescriptor((CRYPTO_DMAInit_TypeDef*) DMAStruct->NextDescriptor);
80005cbc:	fec42783          	lw	a5,-20(s0)
80005cc0:	479c                	lw	a5,8(a5)
80005cc2:	eb81                	bnez	a5,80005cd2 <CRYPTO_InitDMADescriptor+0x152>
80005cc4:	fec42783          	lw	a5,-20(s0)
80005cc8:	4f9c                	lw	a5,24(a5)
80005cca:	853e                	mv	a0,a5
80005ccc:	3d55                	jal	80005b80 <CRYPTO_InitDMADescriptor>
80005cce:	872a                	mv	a4,a0
80005cd0:	a011                	j	80005cd4 <CRYPTO_InitDMADescriptor+0x154>
80005cd2:	4701                	li	a4,0
80005cd4:	fec42783          	lw	a5,-20(s0)
80005cd8:	53dc                	lw	a5,36(a5)
80005cda:	c7d8                	sw	a4,12(a5)

	return (uint32_t) DMAStruct->DescriptorPtr;
80005cdc:	fec42783          	lw	a5,-20(s0)
80005ce0:	53dc                	lw	a5,36(a5)
}
80005ce2:	853e                	mv	a0,a5
80005ce4:	40f2                	lw	ra,28(sp)
80005ce6:	4462                	lw	s0,24(sp)
80005ce8:	6105                	addi	sp,sp,32
80005cea:	8082                	ret

80005cec <CRPYTO_ProcessData>:
  * @param   DMAStruct  Указатель на структуру типа @ref CRYPTO_DMAInit_TypeDef,
  *                      которая будет исполнена как дескриптор DMA
  * @retval  void
  */
void CRPYTO_ProcessData(CRYPTO_DMAInit_TypeDef* DMAStruct)
{
80005cec:	1101                	addi	sp,sp,-32
80005cee:	ce06                	sw	ra,28(sp)
80005cf0:	cc22                	sw	s0,24(sp)
80005cf2:	1000                	addi	s0,sp,32
80005cf4:	fea42623          	sw	a0,-20(s0)
	CRYPTO_DMA_ByteSwapCmd(DMAStruct->ByteSwap);
80005cf8:	fec42783          	lw	a5,-20(s0)
80005cfc:	439c                	lw	a5,0(a5)
80005cfe:	853e                	mv	a0,a5
80005d00:	39f5                	jal	800059fc <CRYPTO_DMA_ByteSwapCmd>
	CRYPTO_DMA_WordSwapCmd(DMAStruct->WordSwap);
80005d02:	fec42783          	lw	a5,-20(s0)
80005d06:	43dc                	lw	a5,4(a5)
80005d08:	853e                	mv	a0,a5
80005d0a:	3b39                	jal	80005a28 <CRYPTO_DMA_WordSwapCmd>
	CRYPTO_DMA_SetBaseDescriptor(CRYPTO_InitDMADescriptor(DMAStruct));
80005d0c:	fec42503          	lw	a0,-20(s0)
80005d10:	3d85                	jal	80005b80 <CRYPTO_InitDMADescriptor>
80005d12:	87aa                	mv	a5,a0
80005d14:	853e                	mv	a0,a5
80005d16:	3175                	jal	800059c2 <CRYPTO_DMA_SetBaseDescriptor>
	CRYPTO_DMA_StartCmd();
80005d18:	31d9                	jal	800059de <CRYPTO_DMA_StartCmd>
}
80005d1a:	0001                	nop
80005d1c:	40f2                	lw	ra,28(sp)
80005d1e:	4462                	lw	s0,24(sp)
80005d20:	6105                	addi	sp,sp,32
80005d22:	8082                	ret

80005d24 <CRYPTO_SetKey>:
  * @brief   Устанавливает значение ключа, максимум 256 бит, для AES-128 128 бит
  * @param   key Массив слов, который формирует ключ шифрования
  * @retval  void
  */
void CRYPTO_SetKey(uint32_t* key, uint32_t len)
{
80005d24:	7179                	addi	sp,sp,-48
80005d26:	d606                	sw	ra,44(sp)
80005d28:	d422                	sw	s0,40(sp)
80005d2a:	1800                	addi	s0,sp,48
80005d2c:	fca42e23          	sw	a0,-36(s0)
80005d30:	fcb42c23          	sw	a1,-40(s0)
	uint32_t idx = 0;
80005d34:	fe042623          	sw	zero,-20(s0)
	while(idx < len)
80005d38:	a00d                	j	80005d5a <CRYPTO_SetKey+0x36>
	{
		CRYPTO_SetKeyInReg(idx++, *key++);
80005d3a:	fec42703          	lw	a4,-20(s0)
80005d3e:	00170793          	addi	a5,a4,1
80005d42:	fef42623          	sw	a5,-20(s0)
80005d46:	fdc42783          	lw	a5,-36(s0)
80005d4a:	00478693          	addi	a3,a5,4
80005d4e:	fcd42e23          	sw	a3,-36(s0)
80005d52:	439c                	lw	a5,0(a5)
80005d54:	85be                	mv	a1,a5
80005d56:	853a                	mv	a0,a4
80005d58:	36cd                	jal	8000593a <CRYPTO_SetKeyInReg>
	while(idx < len)
80005d5a:	fec42703          	lw	a4,-20(s0)
80005d5e:	fd842783          	lw	a5,-40(s0)
80005d62:	fcf76ce3          	bltu	a4,a5,80005d3a <CRYPTO_SetKey+0x16>
	}
}
80005d66:	0001                	nop
80005d68:	0001                	nop
80005d6a:	50b2                	lw	ra,44(sp)
80005d6c:	5422                	lw	s0,40(sp)
80005d6e:	6145                	addi	sp,sp,48
80005d70:	8082                	ret

80005d72 <CRYPTO_SetDataInBytes>:
  * @param   data_in  Входящие данные
  * @param   block_size Размерность данных блочного шифра
  * @retval  void
  */
static void CRYPTO_SetDataInBytes(const unsigned char *data_in, uint32_t block_size)
{
80005d72:	7179                	addi	sp,sp,-48
80005d74:	d606                	sw	ra,44(sp)
80005d76:	d422                	sw	s0,40(sp)
80005d78:	1800                	addi	s0,sp,48
80005d7a:	fca42e23          	sw	a0,-36(s0)
80005d7e:	fcb42c23          	sw	a1,-40(s0)
	for(uint32_t i = 0; i < block_size; i++)
80005d82:	fe042623          	sw	zero,-20(s0)
80005d86:	a889                	j	80005dd8 <CRYPTO_SetDataInBytes+0x66>
	{
		CRYPTO_SetTextInput(i, data_in[3] + (data_in[2] << 8) + (data_in[1] << 16) + (data_in[0] << 24));
80005d88:	fdc42783          	lw	a5,-36(s0)
80005d8c:	078d                	addi	a5,a5,3
80005d8e:	0007c783          	lbu	a5,0(a5)
80005d92:	873e                	mv	a4,a5
80005d94:	fdc42783          	lw	a5,-36(s0)
80005d98:	0789                	addi	a5,a5,2
80005d9a:	0007c783          	lbu	a5,0(a5)
80005d9e:	07a2                	slli	a5,a5,0x8
80005da0:	973e                	add	a4,a4,a5
80005da2:	fdc42783          	lw	a5,-36(s0)
80005da6:	0785                	addi	a5,a5,1
80005da8:	0007c783          	lbu	a5,0(a5)
80005dac:	07c2                	slli	a5,a5,0x10
80005dae:	973e                	add	a4,a4,a5
80005db0:	fdc42783          	lw	a5,-36(s0)
80005db4:	0007c783          	lbu	a5,0(a5)
80005db8:	07e2                	slli	a5,a5,0x18
80005dba:	97ba                	add	a5,a5,a4
80005dbc:	85be                	mv	a1,a5
80005dbe:	fec42503          	lw	a0,-20(s0)
80005dc2:	36b9                	jal	80005910 <CRYPTO_SetTextInput>
		data_in += sizeof(uint32_t);
80005dc4:	fdc42783          	lw	a5,-36(s0)
80005dc8:	0791                	addi	a5,a5,4
80005dca:	fcf42e23          	sw	a5,-36(s0)
	for(uint32_t i = 0; i < block_size; i++)
80005dce:	fec42783          	lw	a5,-20(s0)
80005dd2:	0785                	addi	a5,a5,1
80005dd4:	fef42623          	sw	a5,-20(s0)
80005dd8:	fec42703          	lw	a4,-20(s0)
80005ddc:	fd842783          	lw	a5,-40(s0)
80005de0:	faf764e3          	bltu	a4,a5,80005d88 <CRYPTO_SetDataInBytes+0x16>
	}
}
80005de4:	0001                	nop
80005de6:	0001                	nop
80005de8:	50b2                	lw	ra,44(sp)
80005dea:	5422                	lw	s0,40(sp)
80005dec:	6145                	addi	sp,sp,48
80005dee:	8082                	ret

80005df0 <CRYPTO_SetKeyBytes>:
  * @param   key Байтовый массив ключа, должен иметь достаточную длину для
  * 			выбранного в crypto структуре алгоритма
  * @retval  void
  */
void CRYPTO_SetKeyBytes(CRYPTO_Init_TypeDef* crypto, const unsigned char* key)
{
80005df0:	7179                	addi	sp,sp,-48
80005df2:	d606                	sw	ra,44(sp)
80005df4:	d422                	sw	s0,40(sp)
80005df6:	1800                	addi	s0,sp,48
80005df8:	fca42e23          	sw	a0,-36(s0)
80005dfc:	fcb42c23          	sw	a1,-40(s0)
	uint32_t key_size = (crypto->Algorithm == CRYPTO_Algo_AES_128) ? 4 : 8;
80005e00:	fdc42783          	lw	a5,-36(s0)
80005e04:	43dc                	lw	a5,4(a5)
80005e06:	e399                	bnez	a5,80005e0c <CRYPTO_SetKeyBytes+0x1c>
80005e08:	4791                	li	a5,4
80005e0a:	a011                	j	80005e0e <CRYPTO_SetKeyBytes+0x1e>
80005e0c:	47a1                	li	a5,8
80005e0e:	fef42423          	sw	a5,-24(s0)
	for(uint32_t i = 0; i < key_size; i++)
80005e12:	fe042623          	sw	zero,-20(s0)
80005e16:	a8a1                	j	80005e6e <CRYPTO_SetKeyBytes+0x7e>
	{
		uint32_t key_word = key[3] + (key[2] << 8) + (key[1] << 16) + (key[0] << 24);
80005e18:	fd842783          	lw	a5,-40(s0)
80005e1c:	078d                	addi	a5,a5,3
80005e1e:	0007c783          	lbu	a5,0(a5)
80005e22:	873e                	mv	a4,a5
80005e24:	fd842783          	lw	a5,-40(s0)
80005e28:	0789                	addi	a5,a5,2
80005e2a:	0007c783          	lbu	a5,0(a5)
80005e2e:	07a2                	slli	a5,a5,0x8
80005e30:	973e                	add	a4,a4,a5
80005e32:	fd842783          	lw	a5,-40(s0)
80005e36:	0785                	addi	a5,a5,1
80005e38:	0007c783          	lbu	a5,0(a5)
80005e3c:	07c2                	slli	a5,a5,0x10
80005e3e:	973e                	add	a4,a4,a5
80005e40:	fd842783          	lw	a5,-40(s0)
80005e44:	0007c783          	lbu	a5,0(a5)
80005e48:	07e2                	slli	a5,a5,0x18
80005e4a:	97ba                	add	a5,a5,a4
80005e4c:	fef42223          	sw	a5,-28(s0)
		CRYPTO_SetKeyInReg(i, key_word);
80005e50:	fe442583          	lw	a1,-28(s0)
80005e54:	fec42503          	lw	a0,-20(s0)
80005e58:	34cd                	jal	8000593a <CRYPTO_SetKeyInReg>
		key += sizeof(uint32_t);
80005e5a:	fd842783          	lw	a5,-40(s0)
80005e5e:	0791                	addi	a5,a5,4
80005e60:	fcf42c23          	sw	a5,-40(s0)
	for(uint32_t i = 0; i < key_size; i++)
80005e64:	fec42783          	lw	a5,-20(s0)
80005e68:	0785                	addi	a5,a5,1
80005e6a:	fef42623          	sw	a5,-20(s0)
80005e6e:	fec42703          	lw	a4,-20(s0)
80005e72:	fe842783          	lw	a5,-24(s0)
80005e76:	faf761e3          	bltu	a4,a5,80005e18 <CRYPTO_SetKeyBytes+0x28>
	}
}
80005e7a:	0001                	nop
80005e7c:	0001                	nop
80005e7e:	50b2                	lw	ra,44(sp)
80005e80:	5422                	lw	s0,40(sp)
80005e82:	6145                	addi	sp,sp,48
80005e84:	8082                	ret

80005e86 <CRYPTO_SinglePerform>:
  *			  вектор был уже установлен
  *	@param 	data_out Массив выходящих данных
  * @retval void
  */
void CRYPTO_SinglePerform(CRYPTO_Init_TypeDef* crypto, const unsigned char *key, const unsigned char *data_in, const unsigned char* iv, unsigned char *data_out)
{
80005e86:	7139                	addi	sp,sp,-64
80005e88:	de06                	sw	ra,60(sp)
80005e8a:	dc22                	sw	s0,56(sp)
80005e8c:	0080                	addi	s0,sp,64
80005e8e:	fca42e23          	sw	a0,-36(s0)
80005e92:	fcb42c23          	sw	a1,-40(s0)
80005e96:	fcc42a23          	sw	a2,-44(s0)
80005e9a:	fcd42823          	sw	a3,-48(s0)
80005e9e:	fce42623          	sw	a4,-52(s0)
	CRYPTO_Init(crypto);
80005ea2:	fdc42503          	lw	a0,-36(s0)
80005ea6:	36fd                	jal	80005a94 <CRYPTO_Init>
	if (key != NULL) // if null then key is already set
80005ea8:	fd842783          	lw	a5,-40(s0)
80005eac:	c791                	beqz	a5,80005eb8 <CRYPTO_SinglePerform+0x32>
		CRYPTO_SetKeyBytes(crypto, key);
80005eae:	fd842583          	lw	a1,-40(s0)
80005eb2:	fdc42503          	lw	a0,-36(s0)
80005eb6:	3f2d                	jal	80005df0 <CRYPTO_SetKeyBytes>
	if (iv != NULL) // if null then iv is already set or there is no need in it (e.g. ECB mode)
80005eb8:	fd042783          	lw	a5,-48(s0)
80005ebc:	c781                	beqz	a5,80005ec4 <CRYPTO_SinglePerform+0x3e>
		CRYPTO_SetIVBytes(iv);
80005ebe:	fd042503          	lw	a0,-48(s0)
80005ec2:	2405                	jal	800060e2 <CRYPTO_SetIVBytes>

	uint32_t block_size = (crypto->Algorithm == CRYPTO_Algo_MAGMA) ? 2 : 4;
80005ec4:	fdc42783          	lw	a5,-36(s0)
80005ec8:	43d8                	lw	a4,4(a5)
80005eca:	4789                	li	a5,2
80005ecc:	00f71463          	bne	a4,a5,80005ed4 <CRYPTO_SinglePerform+0x4e>
80005ed0:	4789                	li	a5,2
80005ed2:	a011                	j	80005ed6 <CRYPTO_SinglePerform+0x50>
80005ed4:	4791                	li	a5,4
80005ed6:	fef42223          	sw	a5,-28(s0)
	CRYPTO_SetDataInBytes(data_in, block_size);
80005eda:	fe442583          	lw	a1,-28(s0)
80005ede:	fd442503          	lw	a0,-44(s0)
80005ee2:	3d41                	jal	80005d72 <CRYPTO_SetDataInBytes>

	while (!CRYPTO_ReadyStatus()) {}
80005ee4:	0001                	nop
80005ee6:	34d1                	jal	800059aa <CRYPTO_ReadyStatus>
80005ee8:	87aa                	mv	a5,a0
80005eea:	dff5                	beqz	a5,80005ee6 <CRYPTO_SinglePerform+0x60>

	CRYPTO_StartCmd();
80005eec:	3209                	jal	800057ee <CRYPTO_StartCmd>

	while (!(CRYPTO->STATUS & CRYPTO_STATUS_KEYS_READY_Msk)) {}
80005eee:	0001                	nop
80005ef0:	200207b7          	lui	a5,0x20020
80005ef4:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
80005ef8:	8b89                	andi	a5,a5,2
80005efa:	dbfd                	beqz	a5,80005ef0 <CRYPTO_SinglePerform+0x6a>
	while (!(CRYPTO->STATUS & CRYPTO_STATUS_READY_Msk)) {}
80005efc:	0001                	nop
80005efe:	200207b7          	lui	a5,0x20020
80005f02:	0807a783          	lw	a5,128(a5) # 20020080 <STACK_SIZE+0x2001f880>
80005f06:	8b85                	andi	a5,a5,1
80005f08:	dbfd                	beqz	a5,80005efe <CRYPTO_SinglePerform+0x78>

	if (crypto->Mode == CRYPTO_Mode_CBC && crypto->Direction == CRYPTO_Dir_Decrypt)
80005f0a:	fdc42783          	lw	a5,-36(s0)
80005f0e:	4798                	lw	a4,8(a5)
80005f10:	4785                	li	a5,1
80005f12:	00f71c63          	bne	a4,a5,80005f2a <CRYPTO_SinglePerform+0xa4>
80005f16:	fdc42783          	lw	a5,-36(s0)
80005f1a:	4398                	lw	a4,0(a5)
80005f1c:	4785                	li	a5,1
80005f1e:	00f71663          	bne	a4,a5,80005f2a <CRYPTO_SinglePerform+0xa4>
	{
		CRYPTO_DirectionConfig(CRYPTO_Dir_Encrypt);
80005f22:	4501                	li	a0,0
80005f24:	30e5                	jal	8000580c <CRYPTO_DirectionConfig>
		CRYPTO_ModeConfig(CRYPTO_Mode_ECB);
80005f26:	4501                	li	a0,0
80005f28:	3a35                	jal	80005864 <CRYPTO_ModeConfig>
	}

	for (uint32_t i = 0; i < block_size; i++)
80005f2a:	fe042623          	sw	zero,-20(s0)
80005f2e:	a0c9                	j	80005ff0 <CRYPTO_SinglePerform+0x16a>
	{
		uint32_t out_word = CRYPTO_GetTextOutput(i);
80005f30:	fec42503          	lw	a0,-20(s0)
80005f34:	3c05                	jal	80005964 <CRYPTO_GetTextOutput>
80005f36:	fea42423          	sw	a0,-24(s0)
		out_word = (out_word >> 24) + ((out_word >> 8) & 0xFF00) + ((out_word << 8) & 0xFF0000) + (out_word << 24);
80005f3a:	fe842783          	lw	a5,-24(s0)
80005f3e:	0187d713          	srli	a4,a5,0x18
80005f42:	fe842783          	lw	a5,-24(s0)
80005f46:	0087d693          	srli	a3,a5,0x8
80005f4a:	67c1                	lui	a5,0x10
80005f4c:	f0078793          	addi	a5,a5,-256 # ff00 <STACK_SIZE+0xf700>
80005f50:	8ff5                	and	a5,a5,a3
80005f52:	973e                	add	a4,a4,a5
80005f54:	fe842783          	lw	a5,-24(s0)
80005f58:	00879693          	slli	a3,a5,0x8
80005f5c:	00ff07b7          	lui	a5,0xff0
80005f60:	8ff5                	and	a5,a5,a3
80005f62:	973e                	add	a4,a4,a5
80005f64:	fe842783          	lw	a5,-24(s0)
80005f68:	07e2                	slli	a5,a5,0x18
80005f6a:	97ba                	add	a5,a5,a4
80005f6c:	fef42423          	sw	a5,-24(s0)
		if (crypto->Mode == CRYPTO_Mode_CBC && crypto->Direction == CRYPTO_Dir_Decrypt)
80005f70:	fdc42783          	lw	a5,-36(s0)
80005f74:	4798                	lw	a4,8(a5)
80005f76:	4785                	li	a5,1
80005f78:	04f71d63          	bne	a4,a5,80005fd2 <CRYPTO_SinglePerform+0x14c>
80005f7c:	fdc42783          	lw	a5,-36(s0)
80005f80:	4398                	lw	a4,0(a5)
80005f82:	4785                	li	a5,1
80005f84:	04f71763          	bne	a4,a5,80005fd2 <CRYPTO_SinglePerform+0x14c>
		{
			out_word ^= (iv[3] + (iv[2] << 8) + (iv[1] << 16) + (iv[0] << 24));
80005f88:	fd042783          	lw	a5,-48(s0)
80005f8c:	078d                	addi	a5,a5,3 # ff0003 <STACK_SIZE+0xfef803>
80005f8e:	0007c783          	lbu	a5,0(a5)
80005f92:	873e                	mv	a4,a5
80005f94:	fd042783          	lw	a5,-48(s0)
80005f98:	0789                	addi	a5,a5,2
80005f9a:	0007c783          	lbu	a5,0(a5)
80005f9e:	07a2                	slli	a5,a5,0x8
80005fa0:	973e                	add	a4,a4,a5
80005fa2:	fd042783          	lw	a5,-48(s0)
80005fa6:	0785                	addi	a5,a5,1
80005fa8:	0007c783          	lbu	a5,0(a5)
80005fac:	07c2                	slli	a5,a5,0x10
80005fae:	973e                	add	a4,a4,a5
80005fb0:	fd042783          	lw	a5,-48(s0)
80005fb4:	0007c783          	lbu	a5,0(a5)
80005fb8:	07e2                	slli	a5,a5,0x18
80005fba:	97ba                	add	a5,a5,a4
80005fbc:	873e                	mv	a4,a5
80005fbe:	fe842783          	lw	a5,-24(s0)
80005fc2:	8fb9                	xor	a5,a5,a4
80005fc4:	fef42423          	sw	a5,-24(s0)
			iv += sizeof(uint32_t);
80005fc8:	fd042783          	lw	a5,-48(s0)
80005fcc:	0791                	addi	a5,a5,4
80005fce:	fcf42823          	sw	a5,-48(s0)
		}
		*((uint32_t *) data_out) = out_word;
80005fd2:	fcc42783          	lw	a5,-52(s0)
80005fd6:	fe842703          	lw	a4,-24(s0)
80005fda:	c398                	sw	a4,0(a5)
		data_out += sizeof(uint32_t);
80005fdc:	fcc42783          	lw	a5,-52(s0)
80005fe0:	0791                	addi	a5,a5,4
80005fe2:	fcf42623          	sw	a5,-52(s0)
	for (uint32_t i = 0; i < block_size; i++)
80005fe6:	fec42783          	lw	a5,-20(s0)
80005fea:	0785                	addi	a5,a5,1
80005fec:	fef42623          	sw	a5,-20(s0)
80005ff0:	fec42703          	lw	a4,-20(s0)
80005ff4:	fe442783          	lw	a5,-28(s0)
80005ff8:	f2f76ce3          	bltu	a4,a5,80005f30 <CRYPTO_SinglePerform+0xaa>
	}
}
80005ffc:	0001                	nop
80005ffe:	0001                	nop
80006000:	50f2                	lw	ra,60(sp)
80006002:	5462                	lw	s0,56(sp)
80006004:	6121                	addi	sp,sp,64
80006006:	8082                	ret

80006008 <CRYPTO_CryptWithDMA>:
  *			  вектор был уже установлен
  *	@param 	data_out Массив выходящих данных
  * @retval void
  */
void CRYPTO_CryptWithDMA(CRYPTO_Init_TypeDef* crypto, const unsigned char *key, const unsigned char *data_in, uint32_t data_in_size, const unsigned char* iv, unsigned char *data_out)
{
80006008:	7151                	addi	sp,sp,-240
8000600a:	d786                	sw	ra,236(sp)
8000600c:	d5a2                	sw	s0,232(sp)
8000600e:	d3a6                	sw	s1,228(sp)
80006010:	1980                	addi	s0,sp,240
80006012:	f2a42623          	sw	a0,-212(s0)
80006016:	f2b42423          	sw	a1,-216(s0)
8000601a:	f2c42223          	sw	a2,-220(s0)
8000601e:	f2d42023          	sw	a3,-224(s0)
80006022:	f0e42e23          	sw	a4,-228(s0)
80006026:	f0f42c23          	sw	a5,-232(s0)
8000602a:	ff040793          	addi	a5,s0,-16
8000602e:	f0f42a23          	sw	a5,-236(s0)
80006032:	f1442783          	lw	a5,-236(s0)
80006036:	f4078793          	addi	a5,a5,-192
8000603a:	07f78793          	addi	a5,a5,127
8000603e:	839d                	srli	a5,a5,0x7
80006040:	00779493          	slli	s1,a5,0x7
	CRYPTO_DMA_DESCR_TypeDef DMA_CTRLDATA __attribute__((aligned (0x80)));
	DMA_CTRLDATA.CONTROL = 0;
80006044:	0004a023          	sw	zero,0(s1)

	CRYPTO_DMAInit_TypeDef dma_init;

	if (key != NULL)
80006048:	f2842783          	lw	a5,-216(s0)
8000604c:	c791                	beqz	a5,80006058 <CRYPTO_CryptWithDMA+0x50>
		CRYPTO_SetKeyBytes(crypto, key);
8000604e:	f2842583          	lw	a1,-216(s0)
80006052:	f2c42503          	lw	a0,-212(s0)
80006056:	3b69                	jal	80005df0 <CRYPTO_SetKeyBytes>
	if (iv != NULL)
80006058:	f1c42783          	lw	a5,-228(s0)
8000605c:	c781                	beqz	a5,80006064 <CRYPTO_CryptWithDMA+0x5c>
		CRYPTO_SetIVBytes(iv);
8000605e:	f1c42503          	lw	a0,-228(s0)
80006062:	2041                	jal	800060e2 <CRYPTO_SetIVBytes>

	CRYPTO_DMAStructInit(&dma_init, crypto);
80006064:	fc840793          	addi	a5,s0,-56
80006068:	f2c42583          	lw	a1,-212(s0)
8000606c:	853e                	mv	a0,a5
8000606e:	3c6d                	jal	80005b28 <CRYPTO_DMAStructInit>
	dma_init.BlocksCount = data_in_size >> 3;
80006070:	f2042783          	lw	a5,-224(s0)
80006074:	838d                	srli	a5,a5,0x3
80006076:	fcf42c23          	sw	a5,-40(s0)
	if (crypto->Algorithm != CRYPTO_Algo_MAGMA)
8000607a:	f2c42783          	lw	a5,-212(s0)
8000607e:	43d8                	lw	a4,4(a5)
80006080:	4789                	li	a5,2
80006082:	00f70763          	beq	a4,a5,80006090 <CRYPTO_CryptWithDMA+0x88>
		dma_init.BlocksCount >>= 1;
80006086:	fd842783          	lw	a5,-40(s0)
8000608a:	8385                	srli	a5,a5,0x1
8000608c:	fcf42c23          	sw	a5,-40(s0)
	--dma_init.BlocksCount; // n - 1 DMA
80006090:	fd842783          	lw	a5,-40(s0)
80006094:	17fd                	addi	a5,a5,-1
80006096:	fcf42c23          	sw	a5,-40(s0)

	dma_init.ByteSwap = ENABLE;
8000609a:	4785                	li	a5,1
8000609c:	fcf42423          	sw	a5,-56(s0)
	dma_init.DescriptorPtr = &DMA_CTRLDATA;
800060a0:	fe942623          	sw	s1,-20(s0)
	dma_init.SourceAddress = (void*) data_in;
800060a4:	f2442783          	lw	a5,-220(s0)
800060a8:	fef42223          	sw	a5,-28(s0)
	dma_init.DestinationAddress = (void*) data_out;
800060ac:	f1842783          	lw	a5,-232(s0)
800060b0:	fef42423          	sw	a5,-24(s0)

	while (!CRYPTO_ReadyStatus()) {}
800060b4:	0001                	nop
800060b6:	38d5                	jal	800059aa <CRYPTO_ReadyStatus>
800060b8:	87aa                	mv	a5,a0
800060ba:	dff5                	beqz	a5,800060b6 <CRYPTO_CryptWithDMA+0xae>

	CRPYTO_ProcessData(&dma_init);
800060bc:	fc840793          	addi	a5,s0,-56
800060c0:	853e                	mv	a0,a5
800060c2:	312d                	jal	80005cec <CRPYTO_ProcessData>

	while (CRYPTO_DMA_ActiveStatus()) {}
800060c4:	0001                	nop
800060c6:	3279                	jal	80005a54 <CRYPTO_DMA_ActiveStatus>
800060c8:	87aa                	mv	a5,a0
800060ca:	fff5                	bnez	a5,800060c6 <CRYPTO_CryptWithDMA+0xbe>
	while (!CRYPTO_ReadyStatus()) {}
800060cc:	0001                	nop
800060ce:	38f1                	jal	800059aa <CRYPTO_ReadyStatus>
800060d0:	87aa                	mv	a5,a0
800060d2:	dff5                	beqz	a5,800060ce <CRYPTO_CryptWithDMA+0xc6>
}
800060d4:	0001                	nop
800060d6:	0001                	nop
800060d8:	50be                	lw	ra,236(sp)
800060da:	542e                	lw	s0,232(sp)
800060dc:	549e                	lw	s1,228(sp)
800060de:	616d                	addi	sp,sp,240
800060e0:	8082                	ret

800060e2 <CRYPTO_SetIVBytes>:
  * @brief	Установка инициализационного вектора в байтовой форме
  *	@param 	iv Инициализационный вектор текущей операции
  * @retval void
  */
void CRYPTO_SetIVBytes(const unsigned char *iv)
{
800060e2:	7179                	addi	sp,sp,-48
800060e4:	d606                	sw	ra,44(sp)
800060e6:	d422                	sw	s0,40(sp)
800060e8:	1800                	addi	s0,sp,48
800060ea:	fca42e23          	sw	a0,-36(s0)
	for(int i = 0; i < 4; i++)
800060ee:	fe042623          	sw	zero,-20(s0)
800060f2:	a899                	j	80006148 <CRYPTO_SetIVBytes+0x66>
	{
		CRYPTO_SetInitVector(i, iv[3] + (iv[2] << 8) + (iv[1] << 16) + (iv[0] << 24));
800060f4:	fec42683          	lw	a3,-20(s0)
800060f8:	fdc42783          	lw	a5,-36(s0)
800060fc:	078d                	addi	a5,a5,3
800060fe:	0007c783          	lbu	a5,0(a5)
80006102:	873e                	mv	a4,a5
80006104:	fdc42783          	lw	a5,-36(s0)
80006108:	0789                	addi	a5,a5,2
8000610a:	0007c783          	lbu	a5,0(a5)
8000610e:	07a2                	slli	a5,a5,0x8
80006110:	973e                	add	a4,a4,a5
80006112:	fdc42783          	lw	a5,-36(s0)
80006116:	0785                	addi	a5,a5,1
80006118:	0007c783          	lbu	a5,0(a5)
8000611c:	07c2                	slli	a5,a5,0x10
8000611e:	973e                	add	a4,a4,a5
80006120:	fdc42783          	lw	a5,-36(s0)
80006124:	0007c783          	lbu	a5,0(a5)
80006128:	07e2                	slli	a5,a5,0x18
8000612a:	97ba                	add	a5,a5,a4
8000612c:	85be                	mv	a1,a5
8000612e:	8536                	mv	a0,a3
80006130:	fb8ff0ef          	jal	ra,800058e8 <CRYPTO_SetInitVector>
		iv += sizeof(uint32_t);
80006134:	fdc42783          	lw	a5,-36(s0)
80006138:	0791                	addi	a5,a5,4
8000613a:	fcf42e23          	sw	a5,-36(s0)
	for(int i = 0; i < 4; i++)
8000613e:	fec42783          	lw	a5,-20(s0)
80006142:	0785                	addi	a5,a5,1
80006144:	fef42623          	sw	a5,-20(s0)
80006148:	fec42703          	lw	a4,-20(s0)
8000614c:	478d                	li	a5,3
8000614e:	fae7d3e3          	bge	a5,a4,800060f4 <CRYPTO_SetIVBytes+0x12>
	}
}
80006152:	0001                	nop
80006154:	0001                	nop
80006156:	50b2                	lw	ra,44(sp)
80006158:	5422                	lw	s0,40(sp)
8000615a:	6145                	addi	sp,sp,48
8000615c:	8082                	ret

8000615e <CRYPTO_InitCryptoStructGCM>:
  *	@param	crypto Заполненная структура - источник данных для первого параметра
  *	@param	phase Фаза режима GCM
  * @retval void
  */
static void CRYPTO_InitCryptoStructGCM(CRYPTO_Init_TypeDef* descriptor_crypto, CRYPTO_Init_TypeDef* crypto, CRYPTO_GCM_PHASE_TypeDef phase)
{
8000615e:	1101                	addi	sp,sp,-32
80006160:	ce06                	sw	ra,28(sp)
80006162:	cc22                	sw	s0,24(sp)
80006164:	1000                	addi	s0,sp,32
80006166:	fea42623          	sw	a0,-20(s0)
8000616a:	feb42423          	sw	a1,-24(s0)
8000616e:	fec42223          	sw	a2,-28(s0)
	CRYPTO_StructInit(descriptor_crypto);
80006172:	fec42503          	lw	a0,-20(s0)
80006176:	3a85                	jal	80005ae6 <CRYPTO_StructInit>

	descriptor_crypto->Algorithm = crypto->Algorithm;
80006178:	fe842783          	lw	a5,-24(s0)
8000617c:	43d8                	lw	a4,4(a5)
8000617e:	fec42783          	lw	a5,-20(s0)
80006182:	c3d8                	sw	a4,4(a5)
	descriptor_crypto->Direction = crypto->Direction;
80006184:	fe842783          	lw	a5,-24(s0)
80006188:	4398                	lw	a4,0(a5)
8000618a:	fec42783          	lw	a5,-20(s0)
8000618e:	c398                	sw	a4,0(a5)
	descriptor_crypto->Mode = CRYPTO_Mode_GCM;
80006190:	fec42783          	lw	a5,-20(s0)
80006194:	470d                	li	a4,3
80006196:	c798                	sw	a4,8(a5)
	descriptor_crypto->GCMPhase = phase;
80006198:	fec42783          	lw	a5,-20(s0)
8000619c:	fe442703          	lw	a4,-28(s0)
800061a0:	cbd8                	sw	a4,20(a5)
}
800061a2:	0001                	nop
800061a4:	40f2                	lw	ra,28(sp)
800061a6:	4462                	lw	s0,24(sp)
800061a8:	6105                	addi	sp,sp,32
800061aa:	8082                	ret

800061ac <CRYPTO_InitDescriptor>:
  *	@param	answer Массив размещения итоговых данных
  * @retval void
  */
static void CRYPTO_InitDescriptor(CRYPTO_DMAInit_TypeDef* base, CRYPTO_Init_TypeDef* crypto, CRYPTO_DMAInit_TypeDef* next,
						CRYPTO_DMA_DESCR_TypeDef* dma_data, const uint32_t* src, uint32_t src_size, uint32_t* answer)
{
800061ac:	7179                	addi	sp,sp,-48
800061ae:	d606                	sw	ra,44(sp)
800061b0:	d422                	sw	s0,40(sp)
800061b2:	1800                	addi	s0,sp,48
800061b4:	fea42623          	sw	a0,-20(s0)
800061b8:	feb42423          	sw	a1,-24(s0)
800061bc:	fec42223          	sw	a2,-28(s0)
800061c0:	fed42023          	sw	a3,-32(s0)
800061c4:	fce42e23          	sw	a4,-36(s0)
800061c8:	fcf42c23          	sw	a5,-40(s0)
800061cc:	fd042a23          	sw	a6,-44(s0)
	CRYPTO_DMAStructInit(base, crypto);
800061d0:	fe842583          	lw	a1,-24(s0)
800061d4:	fec42503          	lw	a0,-20(s0)
800061d8:	3a81                	jal	80005b28 <CRYPTO_DMAStructInit>
	base->DescriptorPtr = dma_data;
800061da:	fec42783          	lw	a5,-20(s0)
800061de:	fe042703          	lw	a4,-32(s0)
800061e2:	d3d8                	sw	a4,36(a5)
	base->SourceAddress = (void*) src;
800061e4:	fec42783          	lw	a5,-20(s0)
800061e8:	fdc42703          	lw	a4,-36(s0)
800061ec:	cfd8                	sw	a4,28(a5)
	base->DestinationAddress = (void*) answer;
800061ee:	fec42783          	lw	a5,-20(s0)
800061f2:	fd442703          	lw	a4,-44(s0)
800061f6:	d398                	sw	a4,32(a5)

	base->ByteSwap = ENABLE;
800061f8:	fec42783          	lw	a5,-20(s0)
800061fc:	4705                	li	a4,1
800061fe:	c398                	sw	a4,0(a5)
	base->BlocksCount = (src_size != 0) ? (src_size >> 4) - 1: 0;
80006200:	fd842783          	lw	a5,-40(s0)
80006204:	c791                	beqz	a5,80006210 <CRYPTO_InitDescriptor+0x64>
80006206:	fd842783          	lw	a5,-40(s0)
8000620a:	8391                	srli	a5,a5,0x4
8000620c:	17fd                	addi	a5,a5,-1
8000620e:	a011                	j	80006212 <CRYPTO_InitDescriptor+0x66>
80006210:	4781                	li	a5,0
80006212:	fec42703          	lw	a4,-20(s0)
80006216:	cb1c                	sw	a5,16(a4)
	base->LastDescriptor = (next == NULL) ? ENABLE : DISABLE;
80006218:	fe442783          	lw	a5,-28(s0)
8000621c:	0017b793          	seqz	a5,a5
80006220:	0ff7f793          	zext.b	a5,a5
80006224:	873e                	mv	a4,a5
80006226:	fec42783          	lw	a5,-20(s0)
8000622a:	c798                	sw	a4,8(a5)

	base->NextDescriptor = next;
8000622c:	fec42783          	lw	a5,-20(s0)
80006230:	fe442703          	lw	a4,-28(s0)
80006234:	cf98                	sw	a4,24(a5)
}
80006236:	0001                	nop
80006238:	50b2                	lw	ra,44(sp)
8000623a:	5422                	lw	s0,40(sp)
8000623c:	6145                	addi	sp,sp,48
8000623e:	8082                	ret

80006240 <CRYPTO_CryptGCMWithDMA>:
  *	@param	tag Аутентификационный тэг, полученный после шифрования
  * @retval uint32_t Код завершения операции
  */
uint32_t CRYPTO_CryptGCMWithDMA(CRYPTO_Init_TypeDef* crypto, const unsigned char *key, const uint32_t *data_in, uint32_t data_in_size,
									const unsigned char* iv, const uint32_t *additional, uint32_t additional_size, uint32_t *data_out, uint32_t *tag)
{
80006240:	c9010113          	addi	sp,sp,-880
80006244:	36112623          	sw	ra,876(sp)
80006248:	36812423          	sw	s0,872(sp)
8000624c:	36912223          	sw	s1,868(sp)
80006250:	1e80                	addi	s0,sp,880
80006252:	caa42e23          	sw	a0,-836(s0)
80006256:	cab42c23          	sw	a1,-840(s0)
8000625a:	cac42a23          	sw	a2,-844(s0)
8000625e:	cad42823          	sw	a3,-848(s0)
80006262:	cae42623          	sw	a4,-852(s0)
80006266:	caf42423          	sw	a5,-856(s0)
8000626a:	cb042223          	sw	a6,-860(s0)
8000626e:	cb142023          	sw	a7,-864(s0)
80006272:	ff040793          	addi	a5,s0,-16
80006276:	c8f42e23          	sw	a5,-868(s0)
8000627a:	c9c42783          	lw	a5,-868(s0)
8000627e:	cd078793          	addi	a5,a5,-816
80006282:	07f78793          	addi	a5,a5,127
80006286:	839d                	srli	a5,a5,0x7
80006288:	00779493          	slli	s1,a5,0x7
	// cant use algorithm with 64 bit block size in GCM mode
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
8000628c:	cbc42783          	lw	a5,-836(s0)
80006290:	43d8                	lw	a4,4(a5)
80006292:	4789                	li	a5,2
80006294:	00f71463          	bne	a4,a5,8000629c <CRYPTO_CryptGCMWithDMA+0x5c>
		return 1;
80006298:	4785                	li	a5,1
8000629a:	a25d                	j	80006440 <CRYPTO_CryptGCMWithDMA+0x200>

	CRYPTO_DMA_DESCR_TypeDef dma_init_data __attribute__((aligned (0x80)));
	CRYPTO_DMA_DESCR_TypeDef dma_payload_data __attribute__((aligned (0x80)));
	CRYPTO_DMA_DESCR_TypeDef dma_last_data __attribute__((aligned (0x80)));
	dma_init_data.CONTROL = 0;
8000629c:	1804a023          	sw	zero,384(s1)
	dma_payload_data.CONTROL = 0;
800062a0:	1004a023          	sw	zero,256(s1)
	dma_last_data.CONTROL = 0;
800062a4:	0804a023          	sw	zero,128(s1)

	CRYPTO_Init_TypeDef crypto_init, crypto_header, crypto_payload, crypto_last_block;

	crypto->InitVectorAutoUpdate = ENABLE;	// should be used for correct operation result
800062a8:	cbc42783          	lw	a5,-836(s0)
800062ac:	4705                	li	a4,1
800062ae:	c7d8                	sw	a4,12(a5)
	CRYPTO_InitCryptoStructGCM(&crypto_init, crypto, CRYPTO_GCM_PHASE_INIT);
800062b0:	fd040793          	addi	a5,s0,-48
800062b4:	4601                	li	a2,0
800062b6:	cbc42583          	lw	a1,-836(s0)
800062ba:	853e                	mv	a0,a5
800062bc:	354d                	jal	8000615e <CRYPTO_InitCryptoStructGCM>
	CRYPTO_InitCryptoStructGCM(&crypto_payload, crypto, CRYPTO_GCM_PHASE_PAYLOAD);
800062be:	fa040793          	addi	a5,s0,-96
800062c2:	4609                	li	a2,2
800062c4:	cbc42583          	lw	a1,-836(s0)
800062c8:	853e                	mv	a0,a5
800062ca:	3d51                	jal	8000615e <CRYPTO_InitCryptoStructGCM>
	CRYPTO_InitCryptoStructGCM(&crypto_last_block, crypto, CRYPTO_GCM_PHASE_LAST_BLOCK);
800062cc:	f8840793          	addi	a5,s0,-120
800062d0:	460d                	li	a2,3
800062d2:	cbc42583          	lw	a1,-836(s0)
800062d6:	853e                	mv	a0,a5
800062d8:	3559                	jal	8000615e <CRYPTO_InitCryptoStructGCM>

	CRYPTO_DMAInit_TypeDef dma_init, dma_header, dma_payload, dma_last;

	if (key != NULL)
800062da:	cb842783          	lw	a5,-840(s0)
800062de:	c791                	beqz	a5,800062ea <CRYPTO_CryptGCMWithDMA+0xaa>
		CRYPTO_SetKeyBytes(crypto, key);
800062e0:	cb842583          	lw	a1,-840(s0)
800062e4:	cbc42503          	lw	a0,-836(s0)
800062e8:	3621                	jal	80005df0 <CRYPTO_SetKeyBytes>
	if (iv != NULL)
800062ea:	cac42783          	lw	a5,-852(s0)
800062ee:	c781                	beqz	a5,800062f6 <CRYPTO_CryptGCMWithDMA+0xb6>
		CRYPTO_SetIVBytes(iv);
800062f0:	cac42503          	lw	a0,-852(s0)
800062f4:	33fd                	jal	800060e2 <CRYPTO_SetIVBytes>

	uint32_t add_size_bits = additional_size << 3;
800062f6:	ca442783          	lw	a5,-860(s0)
800062fa:	078e                	slli	a5,a5,0x3
800062fc:	fef42623          	sw	a5,-20(s0)
	uint32_t data_size_bits = data_in_size << 3;
80006300:	cb042783          	lw	a5,-848(s0)
80006304:	078e                	slli	a5,a5,0x3
80006306:	fef42423          	sw	a5,-24(s0)
	const uint32_t tagger[] = {
8000630a:	ec042c23          	sw	zero,-296(s0)
		0,
		((add_size_bits & 0x000000FF) << 24) + ((add_size_bits & 0x0000FF00) << 8) + ((add_size_bits & 0x00FF0000) >> 8) + ((add_size_bits & 0xFF000000) >> 24),
8000630e:	fec42783          	lw	a5,-20(s0)
80006312:	01879713          	slli	a4,a5,0x18
80006316:	fec42783          	lw	a5,-20(s0)
8000631a:	00879693          	slli	a3,a5,0x8
8000631e:	00ff07b7          	lui	a5,0xff0
80006322:	8ff5                	and	a5,a5,a3
80006324:	973e                	add	a4,a4,a5
80006326:	fec42783          	lw	a5,-20(s0)
8000632a:	0087d693          	srli	a3,a5,0x8
8000632e:	67c1                	lui	a5,0x10
80006330:	f0078793          	addi	a5,a5,-256 # ff00 <STACK_SIZE+0xf700>
80006334:	8ff5                	and	a5,a5,a3
80006336:	973e                	add	a4,a4,a5
80006338:	fec42783          	lw	a5,-20(s0)
8000633c:	83e1                	srli	a5,a5,0x18
8000633e:	97ba                	add	a5,a5,a4
	const uint32_t tagger[] = {
80006340:	ecf42e23          	sw	a5,-292(s0)
80006344:	ee042023          	sw	zero,-288(s0)
		0,
		((data_size_bits & 0x000000FF) << 24) + ((data_size_bits & 0x0000FF00) << 8) + ((data_size_bits & 0x00FF0000) >> 8) + ((data_size_bits & 0xFF000000) >> 24),
80006348:	fe842783          	lw	a5,-24(s0)
8000634c:	01879713          	slli	a4,a5,0x18
80006350:	fe842783          	lw	a5,-24(s0)
80006354:	00879693          	slli	a3,a5,0x8
80006358:	00ff07b7          	lui	a5,0xff0
8000635c:	8ff5                	and	a5,a5,a3
8000635e:	973e                	add	a4,a4,a5
80006360:	fe842783          	lw	a5,-24(s0)
80006364:	0087d693          	srli	a3,a5,0x8
80006368:	67c1                	lui	a5,0x10
8000636a:	f0078793          	addi	a5,a5,-256 # ff00 <STACK_SIZE+0xf700>
8000636e:	8ff5                	and	a5,a5,a3
80006370:	973e                	add	a4,a4,a5
80006372:	fe842783          	lw	a5,-24(s0)
80006376:	83e1                	srli	a5,a5,0x18
80006378:	97ba                	add	a5,a5,a4
	const uint32_t tagger[] = {
8000637a:	eef42223          	sw	a5,-284(s0)
	};

	CRYPTO_InitDescriptor(&dma_init, &crypto_init, (additional_size != 0 && additional != NULL) ? &dma_header : &dma_payload, &dma_init_data, NULL, 0, NULL);
8000637e:	ca442783          	lw	a5,-860(s0)
80006382:	c799                	beqz	a5,80006390 <CRYPTO_CryptGCMWithDMA+0x150>
80006384:	ca842783          	lw	a5,-856(s0)
80006388:	c781                	beqz	a5,80006390 <CRYPTO_CryptGCMWithDMA+0x150>
8000638a:	f3840613          	addi	a2,s0,-200
8000638e:	a019                	j	80006394 <CRYPTO_CryptGCMWithDMA+0x154>
80006390:	f1040613          	addi	a2,s0,-240
80006394:	18048693          	addi	a3,s1,384
80006398:	fd040593          	addi	a1,s0,-48
8000639c:	f6040513          	addi	a0,s0,-160
800063a0:	4801                	li	a6,0
800063a2:	4781                	li	a5,0
800063a4:	4701                	li	a4,0
800063a6:	3519                	jal	800061ac <CRYPTO_InitDescriptor>
	if (additional_size != 0 && additional != NULL)
800063a8:	ca442783          	lw	a5,-860(s0)
800063ac:	cb95                	beqz	a5,800063e0 <CRYPTO_CryptGCMWithDMA+0x1a0>
800063ae:	ca842783          	lw	a5,-856(s0)
800063b2:	c79d                	beqz	a5,800063e0 <CRYPTO_CryptGCMWithDMA+0x1a0>
	{
		CRYPTO_DMA_DESCR_TypeDef dma_header_data __attribute__((aligned (0x80)));
		dma_header_data.CONTROL = 0;
800063b4:	0004a023          	sw	zero,0(s1)
		CRYPTO_InitCryptoStructGCM(&crypto_header, crypto, CRYPTO_GCM_PHASE_HEADER);
800063b8:	fb840793          	addi	a5,s0,-72
800063bc:	4605                	li	a2,1
800063be:	cbc42583          	lw	a1,-836(s0)
800063c2:	853e                	mv	a0,a5
800063c4:	3b69                	jal	8000615e <CRYPTO_InitCryptoStructGCM>
		CRYPTO_InitDescriptor(&dma_header, &crypto_header, &dma_payload, &dma_header_data, additional, additional_size, NULL);
800063c6:	f1040613          	addi	a2,s0,-240
800063ca:	fb840593          	addi	a1,s0,-72
800063ce:	f3840513          	addi	a0,s0,-200
800063d2:	4801                	li	a6,0
800063d4:	ca442783          	lw	a5,-860(s0)
800063d8:	ca842703          	lw	a4,-856(s0)
800063dc:	86a6                	mv	a3,s1
800063de:	33f9                	jal	800061ac <CRYPTO_InitDescriptor>
	}
	CRYPTO_InitDescriptor(&dma_payload, &crypto_payload, &dma_last, &dma_payload_data, data_in, data_in_size, data_out);
800063e0:	10048693          	addi	a3,s1,256
800063e4:	ee840613          	addi	a2,s0,-280
800063e8:	fa040593          	addi	a1,s0,-96
800063ec:	f1040513          	addi	a0,s0,-240
800063f0:	ca042803          	lw	a6,-864(s0)
800063f4:	cb042783          	lw	a5,-848(s0)
800063f8:	cb442703          	lw	a4,-844(s0)
800063fc:	3b45                	jal	800061ac <CRYPTO_InitDescriptor>
	CRYPTO_InitDescriptor(&dma_last, &crypto_last_block, NULL, &dma_last_data, tagger, 0, tag);
800063fe:	ed840713          	addi	a4,s0,-296
80006402:	08048693          	addi	a3,s1,128
80006406:	f8840593          	addi	a1,s0,-120
8000640a:	ee840513          	addi	a0,s0,-280
8000640e:	00042803          	lw	a6,0(s0)
80006412:	4781                	li	a5,0
80006414:	4601                	li	a2,0
80006416:	3b59                	jal	800061ac <CRYPTO_InitDescriptor>

	while (!CRYPTO_ReadyStatus()) {}
80006418:	0001                	nop
8000641a:	d90ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
8000641e:	87aa                	mv	a5,a0
80006420:	dfed                	beqz	a5,8000641a <CRYPTO_CryptGCMWithDMA+0x1da>

	CRPYTO_ProcessData(&dma_init);
80006422:	f6040793          	addi	a5,s0,-160
80006426:	853e                	mv	a0,a5
80006428:	30d1                	jal	80005cec <CRPYTO_ProcessData>

	while (CRYPTO_DMA_ActiveStatus()) {}
8000642a:	0001                	nop
8000642c:	e28ff0ef          	jal	ra,80005a54 <CRYPTO_DMA_ActiveStatus>
80006430:	87aa                	mv	a5,a0
80006432:	ffed                	bnez	a5,8000642c <CRYPTO_CryptGCMWithDMA+0x1ec>
	while (!CRYPTO_ReadyStatus()) {}
80006434:	0001                	nop
80006436:	d74ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
8000643a:	87aa                	mv	a5,a0
8000643c:	dfed                	beqz	a5,80006436 <CRYPTO_CryptGCMWithDMA+0x1f6>

	return 0;
8000643e:	4781                	li	a5,0
}
80006440:	853e                	mv	a0,a5
80006442:	36c12083          	lw	ra,876(sp)
80006446:	36812403          	lw	s0,872(sp)
8000644a:	36412483          	lw	s1,868(sp)
8000644e:	37010113          	addi	sp,sp,880
80006452:	8082                	ret

80006454 <CRYPTO_GCMInitPhase>:
  * @param	crypto Ссылка на струткуру типа @ref CREYPTO_Init_TypeDef, содержащая параметры операции
  *	@param 	iv Инициализационный вектор текущей операции
  * @retval uint32_t Код завершения операции
  */
uint32_t CRYPTO_GCMInitPhase(CRYPTO_Init_TypeDef* crypto, const unsigned char *iv)
{
80006454:	1101                	addi	sp,sp,-32
80006456:	ce06                	sw	ra,28(sp)
80006458:	cc22                	sw	s0,24(sp)
8000645a:	1000                	addi	s0,sp,32
8000645c:	fea42623          	sw	a0,-20(s0)
80006460:	feb42423          	sw	a1,-24(s0)
	// cant use algorithm with 64 bit block size in GCM mode
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
80006464:	fec42783          	lw	a5,-20(s0)
80006468:	43d8                	lw	a4,4(a5)
8000646a:	4789                	li	a5,2
8000646c:	00f71463          	bne	a4,a5,80006474 <CRYPTO_GCMInitPhase+0x20>
		return 1;
80006470:	4785                	li	a5,1
80006472:	a82d                	j	800064ac <CRYPTO_GCMInitPhase+0x58>

	CRYPTO_SetIVBytes(iv);
80006474:	fe842503          	lw	a0,-24(s0)
80006478:	31ad                	jal	800060e2 <CRYPTO_SetIVBytes>

	crypto->GCMPhase = CRYPTO_GCM_PHASE_INIT;
8000647a:	fec42783          	lw	a5,-20(s0)
8000647e:	0007aa23          	sw	zero,20(a5)
	crypto->InitVectorAutoUpdate = ENABLE;
80006482:	fec42783          	lw	a5,-20(s0)
80006486:	4705                	li	a4,1
80006488:	c7d8                	sw	a4,12(a5)

	CRYPTO_Init(crypto);
8000648a:	fec42503          	lw	a0,-20(s0)
8000648e:	e06ff0ef          	jal	ra,80005a94 <CRYPTO_Init>

	while (!CRYPTO_ReadyStatus()) {}
80006492:	0001                	nop
80006494:	d16ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
80006498:	87aa                	mv	a5,a0
8000649a:	dfed                	beqz	a5,80006494 <CRYPTO_GCMInitPhase+0x40>
	CRYPTO_StartCmd();
8000649c:	b52ff0ef          	jal	ra,800057ee <CRYPTO_StartCmd>
	while (!CRYPTO_ReadyStatus()) {}
800064a0:	0001                	nop
800064a2:	d08ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
800064a6:	87aa                	mv	a5,a0
800064a8:	dfed                	beqz	a5,800064a2 <CRYPTO_GCMInitPhase+0x4e>

	return 0;
800064aa:	4781                	li	a5,0
}
800064ac:	853e                	mv	a0,a5
800064ae:	40f2                	lw	ra,28(sp)
800064b0:	4462                	lw	s0,24(sp)
800064b2:	6105                	addi	sp,sp,32
800064b4:	8082                	ret

800064b6 <CRYPTO_GCMHeaderPhase>:
  *	@param 	additional Байтовый массив дополнительных аутентифицированных данных
  *	@param	additional_size Размер дополнительных аутентифицированных данных
  * @retval uint32_t Код завершения операции
  */
uint32_t CRYPTO_GCMHeaderPhase(CRYPTO_Init_TypeDef* crypto, const unsigned char *additional, uint32_t additional_size)
{
800064b6:	7179                	addi	sp,sp,-48
800064b8:	d606                	sw	ra,44(sp)
800064ba:	d422                	sw	s0,40(sp)
800064bc:	1800                	addi	s0,sp,48
800064be:	fca42e23          	sw	a0,-36(s0)
800064c2:	fcb42c23          	sw	a1,-40(s0)
800064c6:	fcc42a23          	sw	a2,-44(s0)
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
800064ca:	fdc42783          	lw	a5,-36(s0)
800064ce:	43d8                	lw	a4,4(a5)
800064d0:	4789                	li	a5,2
800064d2:	00f71463          	bne	a4,a5,800064da <CRYPTO_GCMHeaderPhase+0x24>
		return 1;
800064d6:	4785                	li	a5,1
800064d8:	a0b9                	j	80006526 <CRYPTO_GCMHeaderPhase+0x70>

	CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_HEADER);
800064da:	4505                	li	a0,1
800064dc:	bb4ff0ef          	jal	ra,80005890 <CRYPTO_GCMPhaseConfig>

	for(uint32_t i = 0; i < additional_size; i += 16)
800064e0:	fe042623          	sw	zero,-20(s0)
800064e4:	a815                	j	80006518 <CRYPTO_GCMHeaderPhase+0x62>
	{
		CRYPTO_SetDataInBytes(additional + i, 4);
800064e6:	fd842703          	lw	a4,-40(s0)
800064ea:	fec42783          	lw	a5,-20(s0)
800064ee:	97ba                	add	a5,a5,a4
800064f0:	4591                	li	a1,4
800064f2:	853e                	mv	a0,a5
800064f4:	38bd                	jal	80005d72 <CRYPTO_SetDataInBytes>

		while (!CRYPTO_ReadyStatus()) {}
800064f6:	0001                	nop
800064f8:	cb2ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
800064fc:	87aa                	mv	a5,a0
800064fe:	dfed                	beqz	a5,800064f8 <CRYPTO_GCMHeaderPhase+0x42>
		CRYPTO_StartCmd();
80006500:	aeeff0ef          	jal	ra,800057ee <CRYPTO_StartCmd>
		while (!CRYPTO_ReadyStatus()) {}
80006504:	0001                	nop
80006506:	ca4ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
8000650a:	87aa                	mv	a5,a0
8000650c:	dfed                	beqz	a5,80006506 <CRYPTO_GCMHeaderPhase+0x50>
	for(uint32_t i = 0; i < additional_size; i += 16)
8000650e:	fec42783          	lw	a5,-20(s0)
80006512:	07c1                	addi	a5,a5,16
80006514:	fef42623          	sw	a5,-20(s0)
80006518:	fec42703          	lw	a4,-20(s0)
8000651c:	fd442783          	lw	a5,-44(s0)
80006520:	fcf763e3          	bltu	a4,a5,800064e6 <CRYPTO_GCMHeaderPhase+0x30>
	}

	return 0;
80006524:	4781                	li	a5,0
}
80006526:	853e                	mv	a0,a5
80006528:	50b2                	lw	ra,44(sp)
8000652a:	5422                	lw	s0,40(sp)
8000652c:	6145                	addi	sp,sp,48
8000652e:	8082                	ret

80006530 <CRYPTO_GCMPayloadPhase>:
  *	@param	input_length размер входных данных
  *	@param	output Выходные зашифрованные данные
  * @retval uint32_t Код завершения операции
  */
uint32_t CRYPTO_GCMPayloadPhase(CRYPTO_Init_TypeDef* crypto, const unsigned char *input, uint32_t input_length, unsigned char *output)
{
80006530:	7179                	addi	sp,sp,-48
80006532:	d606                	sw	ra,44(sp)
80006534:	d422                	sw	s0,40(sp)
80006536:	1800                	addi	s0,sp,48
80006538:	fca42e23          	sw	a0,-36(s0)
8000653c:	fcb42c23          	sw	a1,-40(s0)
80006540:	fcc42a23          	sw	a2,-44(s0)
80006544:	fcd42823          	sw	a3,-48(s0)
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
80006548:	fdc42783          	lw	a5,-36(s0)
8000654c:	43d8                	lw	a4,4(a5)
8000654e:	4789                	li	a5,2
80006550:	00f71463          	bne	a4,a5,80006558 <CRYPTO_GCMPayloadPhase+0x28>
		return 1;
80006554:	4785                	li	a5,1
80006556:	a221                	j	8000665e <CRYPTO_GCMPayloadPhase+0x12e>

	CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_PAYLOAD);
80006558:	4509                	li	a0,2
8000655a:	b36ff0ef          	jal	ra,80005890 <CRYPTO_GCMPhaseConfig>

	for(uint32_t i = 0; i < input_length; i += 16)
8000655e:	fe042623          	sw	zero,-20(s0)
80006562:	a0fd                	j	80006650 <CRYPTO_GCMPayloadPhase+0x120>
	{
		CRYPTO_SetDataInBytes(input + i, 4);
80006564:	fd842703          	lw	a4,-40(s0)
80006568:	fec42783          	lw	a5,-20(s0)
8000656c:	97ba                	add	a5,a5,a4
8000656e:	4591                	li	a1,4
80006570:	853e                	mv	a0,a5
80006572:	801ff0ef          	jal	ra,80005d72 <CRYPTO_SetDataInBytes>

		while (!CRYPTO_ReadyStatus()) {}
80006576:	0001                	nop
80006578:	c32ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
8000657c:	87aa                	mv	a5,a0
8000657e:	dfed                	beqz	a5,80006578 <CRYPTO_GCMPayloadPhase+0x48>
		CRYPTO_StartCmd();
80006580:	a6eff0ef          	jal	ra,800057ee <CRYPTO_StartCmd>
		while (!CRYPTO_ReadyStatus()) {}
80006584:	0001                	nop
80006586:	c24ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
8000658a:	87aa                	mv	a5,a0
8000658c:	dfed                	beqz	a5,80006586 <CRYPTO_GCMPayloadPhase+0x56>

		for(uint32_t j = 0; j < 4; j++)
8000658e:	fe042423          	sw	zero,-24(s0)
80006592:	a06d                	j	8000663c <CRYPTO_GCMPayloadPhase+0x10c>
		{
			uint32_t output_word = CRYPTO_GetTextOutput(j);
80006594:	fe842503          	lw	a0,-24(s0)
80006598:	bccff0ef          	jal	ra,80005964 <CRYPTO_GetTextOutput>
8000659c:	fea42223          	sw	a0,-28(s0)

			output[i + (j << 2)    ] = (output_word & 0x000000FF);
800065a0:	fe842783          	lw	a5,-24(s0)
800065a4:	00279713          	slli	a4,a5,0x2
800065a8:	fec42783          	lw	a5,-20(s0)
800065ac:	97ba                	add	a5,a5,a4
800065ae:	fd042703          	lw	a4,-48(s0)
800065b2:	97ba                	add	a5,a5,a4
800065b4:	fe442703          	lw	a4,-28(s0)
800065b8:	0ff77713          	zext.b	a4,a4
800065bc:	00e78023          	sb	a4,0(a5)
			output[i + (j << 2) + 1] = (output_word & 0x0000FF00) >> 8;
800065c0:	fe442783          	lw	a5,-28(s0)
800065c4:	0087d693          	srli	a3,a5,0x8
800065c8:	fe842783          	lw	a5,-24(s0)
800065cc:	00279713          	slli	a4,a5,0x2
800065d0:	fec42783          	lw	a5,-20(s0)
800065d4:	97ba                	add	a5,a5,a4
800065d6:	0785                	addi	a5,a5,1
800065d8:	fd042703          	lw	a4,-48(s0)
800065dc:	97ba                	add	a5,a5,a4
800065de:	0ff6f713          	zext.b	a4,a3
800065e2:	00e78023          	sb	a4,0(a5)
			output[i + (j << 2) + 2] = (output_word & 0x00FF0000) >> 16;
800065e6:	fe442783          	lw	a5,-28(s0)
800065ea:	0107d693          	srli	a3,a5,0x10
800065ee:	fe842783          	lw	a5,-24(s0)
800065f2:	00279713          	slli	a4,a5,0x2
800065f6:	fec42783          	lw	a5,-20(s0)
800065fa:	97ba                	add	a5,a5,a4
800065fc:	0789                	addi	a5,a5,2
800065fe:	fd042703          	lw	a4,-48(s0)
80006602:	97ba                	add	a5,a5,a4
80006604:	0ff6f713          	zext.b	a4,a3
80006608:	00e78023          	sb	a4,0(a5)
			output[i + (j << 2) + 3] = (output_word & 0xFF000000) >> 24;
8000660c:	fe442783          	lw	a5,-28(s0)
80006610:	0187d693          	srli	a3,a5,0x18
80006614:	fe842783          	lw	a5,-24(s0)
80006618:	00279713          	slli	a4,a5,0x2
8000661c:	fec42783          	lw	a5,-20(s0)
80006620:	97ba                	add	a5,a5,a4
80006622:	078d                	addi	a5,a5,3
80006624:	fd042703          	lw	a4,-48(s0)
80006628:	97ba                	add	a5,a5,a4
8000662a:	0ff6f713          	zext.b	a4,a3
8000662e:	00e78023          	sb	a4,0(a5)
		for(uint32_t j = 0; j < 4; j++)
80006632:	fe842783          	lw	a5,-24(s0)
80006636:	0785                	addi	a5,a5,1
80006638:	fef42423          	sw	a5,-24(s0)
8000663c:	fe842703          	lw	a4,-24(s0)
80006640:	478d                	li	a5,3
80006642:	f4e7f9e3          	bgeu	a5,a4,80006594 <CRYPTO_GCMPayloadPhase+0x64>
	for(uint32_t i = 0; i < input_length; i += 16)
80006646:	fec42783          	lw	a5,-20(s0)
8000664a:	07c1                	addi	a5,a5,16
8000664c:	fef42623          	sw	a5,-20(s0)
80006650:	fec42703          	lw	a4,-20(s0)
80006654:	fd442783          	lw	a5,-44(s0)
80006658:	f0f766e3          	bltu	a4,a5,80006564 <CRYPTO_GCMPayloadPhase+0x34>
		}
	}

	return 0;
8000665c:	4781                	li	a5,0
}
8000665e:	853e                	mv	a0,a5
80006660:	50b2                	lw	ra,44(sp)
80006662:	5422                	lw	s0,40(sp)
80006664:	6145                	addi	sp,sp,48
80006666:	8082                	ret

80006668 <CRYPTO_GCMLastBlockPhase>:
  *	@param	payload_size Размер данных, в байтах, загруженных в основной фазе шифрования
  *	@param	tag	Аутентификационный тэг сообщения, имеющий размерность 16 байт
  * @retval uint32_t Код завершения операции
  */
uint32_t CRYPTO_GCMLastBlockPhase(CRYPTO_Init_TypeDef* crypto, uint32_t additional_size, uint32_t payload_size, unsigned char *tag)
{
80006668:	7179                	addi	sp,sp,-48
8000666a:	d606                	sw	ra,44(sp)
8000666c:	d422                	sw	s0,40(sp)
8000666e:	1800                	addi	s0,sp,48
80006670:	fca42e23          	sw	a0,-36(s0)
80006674:	fcb42c23          	sw	a1,-40(s0)
80006678:	fcc42a23          	sw	a2,-44(s0)
8000667c:	fcd42823          	sw	a3,-48(s0)
	if (crypto->Algorithm == CRYPTO_Algo_MAGMA)
80006680:	fdc42783          	lw	a5,-36(s0)
80006684:	43d8                	lw	a4,4(a5)
80006686:	4789                	li	a5,2
80006688:	00f71463          	bne	a4,a5,80006690 <CRYPTO_GCMLastBlockPhase+0x28>
		return 1;
8000668c:	4785                	li	a5,1
8000668e:	a0cd                	j	80006770 <CRYPTO_GCMLastBlockPhase+0x108>

	CRYPTO_GCMPhaseConfig(CRYPTO_GCM_PHASE_LAST_BLOCK);
80006690:	450d                	li	a0,3
80006692:	9feff0ef          	jal	ra,80005890 <CRYPTO_GCMPhaseConfig>

	CRYPTO_SetTextInput(0, 0);
80006696:	4581                	li	a1,0
80006698:	4501                	li	a0,0
8000669a:	a76ff0ef          	jal	ra,80005910 <CRYPTO_SetTextInput>
	CRYPTO_SetTextInput(2, 0);
8000669e:	4581                	li	a1,0
800066a0:	4509                	li	a0,2
800066a2:	a6eff0ef          	jal	ra,80005910 <CRYPTO_SetTextInput>
	CRYPTO_SetTextInput(1, additional_size << 3);
800066a6:	fd842783          	lw	a5,-40(s0)
800066aa:	078e                	slli	a5,a5,0x3
800066ac:	85be                	mv	a1,a5
800066ae:	4505                	li	a0,1
800066b0:	a60ff0ef          	jal	ra,80005910 <CRYPTO_SetTextInput>
	CRYPTO_SetTextInput(3, payload_size << 3);
800066b4:	fd442783          	lw	a5,-44(s0)
800066b8:	078e                	slli	a5,a5,0x3
800066ba:	85be                	mv	a1,a5
800066bc:	450d                	li	a0,3
800066be:	a52ff0ef          	jal	ra,80005910 <CRYPTO_SetTextInput>

	while (!CRYPTO_ReadyStatus()) {}
800066c2:	0001                	nop
800066c4:	ae6ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
800066c8:	87aa                	mv	a5,a0
800066ca:	dfed                	beqz	a5,800066c4 <CRYPTO_GCMLastBlockPhase+0x5c>
	CRYPTO_StartCmd();
800066cc:	922ff0ef          	jal	ra,800057ee <CRYPTO_StartCmd>
	while (!CRYPTO_ReadyStatus()) {}
800066d0:	0001                	nop
800066d2:	ad8ff0ef          	jal	ra,800059aa <CRYPTO_ReadyStatus>
800066d6:	87aa                	mv	a5,a0
800066d8:	dfed                	beqz	a5,800066d2 <CRYPTO_GCMLastBlockPhase+0x6a>

	for(uint32_t i = 0; i < 16; i += 4)
800066da:	fe042623          	sw	zero,-20(s0)
800066de:	a059                	j	80006764 <CRYPTO_GCMLastBlockPhase+0xfc>
	{
		uint32_t output_word = CRYPTO_GetGCMTag(i >> 2);
800066e0:	fec42783          	lw	a5,-20(s0)
800066e4:	8389                	srli	a5,a5,0x2
800066e6:	853e                	mv	a0,a5
800066e8:	a9eff0ef          	jal	ra,80005986 <CRYPTO_GetGCMTag>
800066ec:	fea42423          	sw	a0,-24(s0)

		tag[i    ] = (output_word & 0x000000FF);
800066f0:	fd042703          	lw	a4,-48(s0)
800066f4:	fec42783          	lw	a5,-20(s0)
800066f8:	97ba                	add	a5,a5,a4
800066fa:	fe842703          	lw	a4,-24(s0)
800066fe:	0ff77713          	zext.b	a4,a4
80006702:	00e78023          	sb	a4,0(a5)
		tag[i + 1] = (output_word & 0x0000FF00) >> 8;
80006706:	fe842783          	lw	a5,-24(s0)
8000670a:	0087d693          	srli	a3,a5,0x8
8000670e:	fec42783          	lw	a5,-20(s0)
80006712:	0785                	addi	a5,a5,1
80006714:	fd042703          	lw	a4,-48(s0)
80006718:	97ba                	add	a5,a5,a4
8000671a:	0ff6f713          	zext.b	a4,a3
8000671e:	00e78023          	sb	a4,0(a5)
		tag[i + 2] = (output_word & 0x00FF0000) >> 16;
80006722:	fe842783          	lw	a5,-24(s0)
80006726:	0107d693          	srli	a3,a5,0x10
8000672a:	fec42783          	lw	a5,-20(s0)
8000672e:	0789                	addi	a5,a5,2
80006730:	fd042703          	lw	a4,-48(s0)
80006734:	97ba                	add	a5,a5,a4
80006736:	0ff6f713          	zext.b	a4,a3
8000673a:	00e78023          	sb	a4,0(a5)
		tag[i + 3] = (output_word & 0xFF000000) >> 24;
8000673e:	fe842783          	lw	a5,-24(s0)
80006742:	0187d693          	srli	a3,a5,0x18
80006746:	fec42783          	lw	a5,-20(s0)
8000674a:	078d                	addi	a5,a5,3
8000674c:	fd042703          	lw	a4,-48(s0)
80006750:	97ba                	add	a5,a5,a4
80006752:	0ff6f713          	zext.b	a4,a3
80006756:	00e78023          	sb	a4,0(a5)
	for(uint32_t i = 0; i < 16; i += 4)
8000675a:	fec42783          	lw	a5,-20(s0)
8000675e:	0791                	addi	a5,a5,4
80006760:	fef42623          	sw	a5,-20(s0)
80006764:	fec42703          	lw	a4,-20(s0)
80006768:	47bd                	li	a5,15
8000676a:	f6e7fbe3          	bgeu	a5,a4,800066e0 <CRYPTO_GCMLastBlockPhase+0x78>
	}

	return 0;
8000676e:	4781                	li	a5,0
}
80006770:	853e                	mv	a0,a5
80006772:	50b2                	lw	ra,44(sp)
80006774:	5422                	lw	s0,40(sp)
80006776:	6145                	addi	sp,sp,48
80006778:	8082                	ret

8000677a <DMA_ProtectConfig>:
  * @brief   Управление защитой шины при обращении контроллера DMA к управляющим данным
  * @param   CtrlProtect  Структура, содержащая конфигурацию защиты
  * @retval  void
  */
__STATIC_INLINE void DMA_ProtectConfig(DMA_Protect_TypeDef* CtrlProtect)
{
8000677a:	1101                	addi	sp,sp,-32
8000677c:	ce22                	sw	s0,28(sp)
8000677e:	1000                	addi	s0,sp,32
80006780:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Bufferable));
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Cacheable));
    assert_param(IS_FUNCTIONAL_STATE(CtrlProtect->Priveleged));

    MODIFY_REG(DMA->CFG, DMA_CFG_CHPROT_Msk, ((CtrlProtect->Priveleged << (DMA_CFG_CHPROT_Pos + 0)) |
80006784:	3000c7b7          	lui	a5,0x3000c
80006788:	43dc                	lw	a5,4(a5)
8000678a:	ff87f693          	andi	a3,a5,-8
8000678e:	fec42783          	lw	a5,-20(s0)
80006792:	4398                	lw	a4,0(a5)
80006794:	fec42783          	lw	a5,-20(s0)
80006798:	43dc                	lw	a5,4(a5)
8000679a:	0786                	slli	a5,a5,0x1
8000679c:	8f5d                	or	a4,a4,a5
8000679e:	fec42783          	lw	a5,-20(s0)
800067a2:	479c                	lw	a5,8(a5)
800067a4:	078a                	slli	a5,a5,0x2
800067a6:	8f5d                	or	a4,a4,a5
800067a8:	3000c7b7          	lui	a5,0x3000c
800067ac:	8f55                	or	a4,a4,a3
800067ae:	c3d8                	sw	a4,4(a5)
                                              (CtrlProtect->Bufferable << (DMA_CFG_CHPROT_Pos + 1)) |
                                              (CtrlProtect->Cacheable << (DMA_CFG_CHPROT_Pos + 2))));
}
800067b0:	0001                	nop
800067b2:	4472                	lw	s0,28(sp)
800067b4:	6105                	addi	sp,sp,32
800067b6:	8082                	ret

800067b8 <DMA_UseBurstCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_UseBurstCmd(uint32_t Channel, FunctionalState State)
{
800067b8:	1101                	addi	sp,sp,-32
800067ba:	ce22                	sw	s0,28(sp)
800067bc:	1000                	addi	s0,sp,32
800067be:	fea42623          	sw	a0,-20(s0)
800067c2:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800067c6:	fe842703          	lw	a4,-24(s0)
800067ca:	4785                	li	a5,1
800067cc:	00f71863          	bne	a4,a5,800067dc <DMA_UseBurstCmd+0x24>
        WRITE_REG(DMA->USEBURSTSET, Channel);
800067d0:	3000c7b7          	lui	a5,0x3000c
800067d4:	fec42703          	lw	a4,-20(s0)
800067d8:	cf98                	sw	a4,24(a5)
    else
        WRITE_REG(DMA->USEBURSTCLR, Channel);
}
800067da:	a031                	j	800067e6 <DMA_UseBurstCmd+0x2e>
        WRITE_REG(DMA->USEBURSTCLR, Channel);
800067dc:	3000c7b7          	lui	a5,0x3000c
800067e0:	fec42703          	lw	a4,-20(s0)
800067e4:	cfd8                	sw	a4,28(a5)
}
800067e6:	0001                	nop
800067e8:	4472                	lw	s0,28(sp)
800067ea:	6105                	addi	sp,sp,32
800067ec:	8082                	ret

800067ee <DMA_ReqMaskCmd>:
  *                      Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param      State  Выбор состояния
  * @retval     void
  */
__STATIC_INLINE void DMA_ReqMaskCmd(uint32_t Channel, FunctionalState State)
{
800067ee:	1101                	addi	sp,sp,-32
800067f0:	ce22                	sw	s0,28(sp)
800067f2:	1000                	addi	s0,sp,32
800067f4:	fea42623          	sw	a0,-20(s0)
800067f8:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
800067fc:	fe842703          	lw	a4,-24(s0)
80006800:	4785                	li	a5,1
80006802:	00f71863          	bne	a4,a5,80006812 <DMA_ReqMaskCmd+0x24>
        WRITE_REG(DMA->REQMASKSET, Channel);
80006806:	3000c7b7          	lui	a5,0x3000c
8000680a:	fec42703          	lw	a4,-20(s0)
8000680e:	d398                	sw	a4,32(a5)
    else
        WRITE_REG(DMA->REQMASKCLR, Channel);
}
80006810:	a031                	j	8000681c <DMA_ReqMaskCmd+0x2e>
        WRITE_REG(DMA->REQMASKCLR, Channel);
80006812:	3000c7b7          	lui	a5,0x3000c
80006816:	fec42703          	lw	a4,-20(s0)
8000681a:	d3d8                	sw	a4,36(a5)
}
8000681c:	0001                	nop
8000681e:	4472                	lw	s0,28(sp)
80006820:	6105                	addi	sp,sp,32
80006822:	8082                	ret

80006824 <DMA_ChannelEnableCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_ChannelEnableCmd(uint32_t Channel, FunctionalState State)
{
80006824:	1101                	addi	sp,sp,-32
80006826:	ce22                	sw	s0,28(sp)
80006828:	1000                	addi	s0,sp,32
8000682a:	fea42623          	sw	a0,-20(s0)
8000682e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80006832:	fe842703          	lw	a4,-24(s0)
80006836:	4785                	li	a5,1
80006838:	00f71863          	bne	a4,a5,80006848 <DMA_ChannelEnableCmd+0x24>
        WRITE_REG(DMA->ENSET, Channel);
8000683c:	3000c7b7          	lui	a5,0x3000c
80006840:	fec42703          	lw	a4,-20(s0)
80006844:	d798                	sw	a4,40(a5)
    else
        WRITE_REG(DMA->ENCLR, Channel);
}
80006846:	a031                	j	80006852 <DMA_ChannelEnableCmd+0x2e>
        WRITE_REG(DMA->ENCLR, Channel);
80006848:	3000c7b7          	lui	a5,0x3000c
8000684c:	fec42703          	lw	a4,-20(s0)
80006850:	d7d8                	sw	a4,44(a5)
}
80006852:	0001                	nop
80006854:	4472                	lw	s0,28(sp)
80006856:	6105                	addi	sp,sp,32
80006858:	8082                	ret

8000685a <DMA_AltCtrlCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_AltCtrlCmd(uint32_t Channel, FunctionalState State)
{
8000685a:	1101                	addi	sp,sp,-32
8000685c:	ce22                	sw	s0,28(sp)
8000685e:	1000                	addi	s0,sp,32
80006860:	fea42623          	sw	a0,-20(s0)
80006864:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80006868:	fe842703          	lw	a4,-24(s0)
8000686c:	4785                	li	a5,1
8000686e:	00f71863          	bne	a4,a5,8000687e <DMA_AltCtrlCmd+0x24>
        WRITE_REG(DMA->PRIALTSET, Channel);
80006872:	3000c7b7          	lui	a5,0x3000c
80006876:	fec42703          	lw	a4,-20(s0)
8000687a:	db98                	sw	a4,48(a5)
    else
        WRITE_REG(DMA->PRIALTCLR, Channel);
}
8000687c:	a031                	j	80006888 <DMA_AltCtrlCmd+0x2e>
        WRITE_REG(DMA->PRIALTCLR, Channel);
8000687e:	3000c7b7          	lui	a5,0x3000c
80006882:	fec42703          	lw	a4,-20(s0)
80006886:	dbd8                	sw	a4,52(a5)
}
80006888:	0001                	nop
8000688a:	4472                	lw	s0,28(sp)
8000688c:	6105                	addi	sp,sp,32
8000688e:	8082                	ret

80006890 <DMA_HighPriorityCmd>:
  *                   Параметр принимает любую комбинацию масок DMA_Channel_x из @ref DMA_Channel_Define.
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void DMA_HighPriorityCmd(uint32_t Channel, FunctionalState State)
{
80006890:	1101                	addi	sp,sp,-32
80006892:	ce22                	sw	s0,28(sp)
80006894:	1000                	addi	s0,sp,32
80006896:	fea42623          	sw	a0,-20(s0)
8000689a:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_DMA_CHANNEL(Channel));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
8000689e:	fe842703          	lw	a4,-24(s0)
800068a2:	4785                	li	a5,1
800068a4:	00f71863          	bne	a4,a5,800068b4 <DMA_HighPriorityCmd+0x24>
        WRITE_REG(DMA->PRIORITYSET, Channel);
800068a8:	3000c7b7          	lui	a5,0x3000c
800068ac:	fec42703          	lw	a4,-20(s0)
800068b0:	df98                	sw	a4,56(a5)
    else
        WRITE_REG(DMA->PRIORITYCLR, Channel);
}
800068b2:	a031                	j	800068be <DMA_HighPriorityCmd+0x2e>
        WRITE_REG(DMA->PRIORITYCLR, Channel);
800068b4:	3000c7b7          	lui	a5,0x3000c
800068b8:	fec42703          	lw	a4,-20(s0)
800068bc:	dfd8                	sw	a4,60(a5)
}
800068be:	0001                	nop
800068c0:	4472                	lw	s0,28(sp)
800068c2:	6105                	addi	sp,sp,32
800068c4:	8082                	ret

800068c6 <DMA_ChannelDeInit>:
  * @param   ChannelStruct  Указатель на структуру типа @ref DMA_Channel_TypeDef,
  *                         которая содержит конфигурационную информацию канала
  * @retval  void
  */
void DMA_ChannelDeInit(DMA_Channel_TypeDef* ChannelStruct)
{
800068c6:	1101                	addi	sp,sp,-32
800068c8:	ce22                	sw	s0,28(sp)
800068ca:	1000                	addi	s0,sp,32
800068cc:	fea42623          	sw	a0,-20(s0)
    ChannelStruct->SRC_DATA_END_PTR = 0;
800068d0:	fec42783          	lw	a5,-20(s0)
800068d4:	0007a023          	sw	zero,0(a5) # 3000c000 <STACK_SIZE+0x3000b800>
    ChannelStruct->DST_DATA_END_PTR = 0;
800068d8:	fec42783          	lw	a5,-20(s0)
800068dc:	0007a223          	sw	zero,4(a5)
    ChannelStruct->CHANNEL_CFG = 0;
800068e0:	fec42783          	lw	a5,-20(s0)
800068e4:	0007a423          	sw	zero,8(a5)
}
800068e8:	0001                	nop
800068ea:	4472                	lw	s0,28(sp)
800068ec:	6105                	addi	sp,sp,32
800068ee:	8082                	ret

800068f0 <DMA_ChannelInit>:
  * @param   ChannelInitStruct  Указатель на структуру типа @ref DMA_ChannelInit_TypeDef,
  *                             которая содержит конфигурационную информацию канала
  * @retval  void
  */
void DMA_ChannelInit(DMA_Channel_TypeDef* ChannelStruct, DMA_ChannelInit_TypeDef* ChannelInitStruct)
{
800068f0:	1101                	addi	sp,sp,-32
800068f2:	ce22                	sw	s0,28(sp)
800068f4:	1000                	addi	s0,sp,32
800068f6:	fea42623          	sw	a0,-20(s0)
800068fa:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Bufferable));
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Cacheable));
    assert_param(IS_FUNCTIONAL_STATE(ChannelInitStruct->SrcProtect.Priveleged));

    /* источник */
    ChannelStruct->SRC_DATA_END_PTR = (uint32_t)ChannelInitStruct->SrcDataEndPtr;
800068fe:	fe842783          	lw	a5,-24(s0)
80006902:	439c                	lw	a5,0(a5)
80006904:	873e                	mv	a4,a5
80006906:	fec42783          	lw	a5,-20(s0)
8000690a:	c398                	sw	a4,0(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_SIZE = ChannelInitStruct->SrcDataSize;
8000690c:	fe842783          	lw	a5,-24(s0)
80006910:	5b9c                	lw	a5,48(a5)
80006912:	8b8d                	andi	a5,a5,3
80006914:	0ff7f713          	zext.b	a4,a5
80006918:	fec42783          	lw	a5,-20(s0)
8000691c:	8b0d                	andi	a4,a4,3
8000691e:	0746                	slli	a4,a4,0x11
80006920:	4790                	lw	a2,8(a5)
80006922:	fffa06b7          	lui	a3,0xfffa0
80006926:	16fd                	addi	a3,a3,-1 # fff9ffff <__data_source_start+0x7ff971ab>
80006928:	8ef1                	and	a3,a3,a2
8000692a:	8f55                	or	a4,a4,a3
8000692c:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_INC = ChannelInitStruct->SrcDataInc;
8000692e:	fe842783          	lw	a5,-24(s0)
80006932:	5f9c                	lw	a5,56(a5)
80006934:	8b8d                	andi	a5,a5,3
80006936:	0ff7f713          	zext.b	a4,a5
8000693a:	fec42783          	lw	a5,-20(s0)
8000693e:	8b0d                	andi	a4,a4,3
80006940:	073e                	slli	a4,a4,0xf
80006942:	4790                	lw	a2,8(a5)
80006944:	76a1                	lui	a3,0xfffe8
80006946:	16fd                	addi	a3,a3,-1 # fffe7fff <__data_source_start+0x7ffdf1ab>
80006948:	8ef1                	and	a3,a3,a2
8000694a:	8f55                	or	a4,a4,a3
8000694c:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_BUFF = ChannelInitStruct->SrcProtect.Bufferable;
8000694e:	fe842783          	lw	a5,-24(s0)
80006952:	4fdc                	lw	a5,28(a5)
80006954:	8b85                	andi	a5,a5,1
80006956:	0ff7f713          	zext.b	a4,a5
8000695a:	fec42783          	lw	a5,-20(s0)
8000695e:	8b05                	andi	a4,a4,1
80006960:	076e                	slli	a4,a4,0x1b
80006962:	4790                	lw	a2,8(a5)
80006964:	f80006b7          	lui	a3,0xf8000
80006968:	16fd                	addi	a3,a3,-1 # f7ffffff <__data_source_start+0x77ff71ab>
8000696a:	8ef1                	and	a3,a3,a2
8000696c:	8f55                	or	a4,a4,a3
8000696e:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_PRIV = ChannelInitStruct->SrcProtect.Priveleged;
80006970:	fe842783          	lw	a5,-24(s0)
80006974:	4f9c                	lw	a5,24(a5)
80006976:	8b85                	andi	a5,a5,1
80006978:	0ff7f713          	zext.b	a4,a5
8000697c:	fec42783          	lw	a5,-20(s0)
80006980:	8b05                	andi	a4,a4,1
80006982:	076a                	slli	a4,a4,0x1a
80006984:	4790                	lw	a2,8(a5)
80006986:	fc0006b7          	lui	a3,0xfc000
8000698a:	16fd                	addi	a3,a3,-1 # fbffffff <__data_source_start+0x7bff71ab>
8000698c:	8ef1                	and	a3,a3,a2
8000698e:	8f55                	or	a4,a4,a3
80006990:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.SRC_PROT_CACHE = ChannelInitStruct->SrcProtect.Cacheable;
80006992:	fe842783          	lw	a5,-24(s0)
80006996:	539c                	lw	a5,32(a5)
80006998:	8b85                	andi	a5,a5,1
8000699a:	0ff7f713          	zext.b	a4,a5
8000699e:	fec42783          	lw	a5,-20(s0)
800069a2:	8b05                	andi	a4,a4,1
800069a4:	0772                	slli	a4,a4,0x1c
800069a6:	4790                	lw	a2,8(a5)
800069a8:	f00006b7          	lui	a3,0xf0000
800069ac:	16fd                	addi	a3,a3,-1 # efffffff <__data_source_start+0x6fff71ab>
800069ae:	8ef1                	and	a3,a3,a2
800069b0:	8f55                	or	a4,a4,a3
800069b2:	c798                	sw	a4,8(a5)
    /* приемник */
    ChannelStruct->DST_DATA_END_PTR = (uint32_t)ChannelInitStruct->DstDataEndPtr;
800069b4:	fe842783          	lw	a5,-24(s0)
800069b8:	43dc                	lw	a5,4(a5)
800069ba:	873e                	mv	a4,a5
800069bc:	fec42783          	lw	a5,-20(s0)
800069c0:	c3d8                	sw	a4,4(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_SIZE = ChannelInitStruct->DstDataSize;
800069c2:	fe842783          	lw	a5,-24(s0)
800069c6:	5bdc                	lw	a5,52(a5)
800069c8:	8b8d                	andi	a5,a5,3
800069ca:	0ff7f713          	zext.b	a4,a5
800069ce:	fec42783          	lw	a5,-20(s0)
800069d2:	8b0d                	andi	a4,a4,3
800069d4:	0756                	slli	a4,a4,0x15
800069d6:	4790                	lw	a2,8(a5)
800069d8:	ffa006b7          	lui	a3,0xffa00
800069dc:	16fd                	addi	a3,a3,-1 # ff9fffff <__data_source_start+0x7f9f71ab>
800069de:	8ef1                	and	a3,a3,a2
800069e0:	8f55                	or	a4,a4,a3
800069e2:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_INC = ChannelInitStruct->DstDataInc;
800069e4:	fe842783          	lw	a5,-24(s0)
800069e8:	5fdc                	lw	a5,60(a5)
800069ea:	8b8d                	andi	a5,a5,3
800069ec:	0ff7f713          	zext.b	a4,a5
800069f0:	fec42783          	lw	a5,-20(s0)
800069f4:	8b0d                	andi	a4,a4,3
800069f6:	074e                	slli	a4,a4,0x13
800069f8:	4790                	lw	a2,8(a5)
800069fa:	ffe806b7          	lui	a3,0xffe80
800069fe:	16fd                	addi	a3,a3,-1 # ffe7ffff <__data_source_start+0x7fe771ab>
80006a00:	8ef1                	and	a3,a3,a2
80006a02:	8f55                	or	a4,a4,a3
80006a04:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_BUFF = ChannelInitStruct->DstProtect.Bufferable;
80006a06:	fe842783          	lw	a5,-24(s0)
80006a0a:	579c                	lw	a5,40(a5)
80006a0c:	8b85                	andi	a5,a5,1
80006a0e:	0ff7f713          	zext.b	a4,a5
80006a12:	fec42783          	lw	a5,-20(s0)
80006a16:	8b05                	andi	a4,a4,1
80006a18:	0762                	slli	a4,a4,0x18
80006a1a:	4790                	lw	a2,8(a5)
80006a1c:	ff0006b7          	lui	a3,0xff000
80006a20:	16fd                	addi	a3,a3,-1 # feffffff <__data_source_start+0x7eff71ab>
80006a22:	8ef1                	and	a3,a3,a2
80006a24:	8f55                	or	a4,a4,a3
80006a26:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_PRIV = ChannelInitStruct->DstProtect.Priveleged;
80006a28:	fe842783          	lw	a5,-24(s0)
80006a2c:	53dc                	lw	a5,36(a5)
80006a2e:	8b85                	andi	a5,a5,1
80006a30:	0ff7f713          	zext.b	a4,a5
80006a34:	fec42783          	lw	a5,-20(s0)
80006a38:	8b05                	andi	a4,a4,1
80006a3a:	075e                	slli	a4,a4,0x17
80006a3c:	4790                	lw	a2,8(a5)
80006a3e:	ff8006b7          	lui	a3,0xff800
80006a42:	16fd                	addi	a3,a3,-1 # ff7fffff <__data_source_start+0x7f7f71ab>
80006a44:	8ef1                	and	a3,a3,a2
80006a46:	8f55                	or	a4,a4,a3
80006a48:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.DST_PROT_CACHE = ChannelInitStruct->DstProtect.Cacheable;
80006a4a:	fe842783          	lw	a5,-24(s0)
80006a4e:	57dc                	lw	a5,44(a5)
80006a50:	8b85                	andi	a5,a5,1
80006a52:	0ff7f713          	zext.b	a4,a5
80006a56:	fec42783          	lw	a5,-20(s0)
80006a5a:	8b05                	andi	a4,a4,1
80006a5c:	0766                	slli	a4,a4,0x19
80006a5e:	4790                	lw	a2,8(a5)
80006a60:	fe0006b7          	lui	a3,0xfe000
80006a64:	16fd                	addi	a3,a3,-1 # fdffffff <__data_source_start+0x7dff71ab>
80006a66:	8ef1                	and	a3,a3,a2
80006a68:	8f55                	or	a4,a4,a3
80006a6a:	c798                	sw	a4,8(a5)
    /* общее */
    ChannelStruct->CHANNEL_CFG_bit.NEXT_USEBURST = ChannelInitStruct->NextUseburst;
80006a6c:	fe842783          	lw	a5,-24(s0)
80006a70:	47dc                	lw	a5,12(a5)
80006a72:	8b85                	andi	a5,a5,1
80006a74:	0ff7f713          	zext.b	a4,a5
80006a78:	fec42783          	lw	a5,-20(s0)
80006a7c:	8b05                	andi	a4,a4,1
80006a7e:	4794                	lw	a3,8(a5)
80006a80:	9af9                	andi	a3,a3,-2
80006a82:	8f55                	or	a4,a4,a3
80006a84:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.R_POWER = ChannelInitStruct->ArbitrationRate;
80006a86:	fe842783          	lw	a5,-24(s0)
80006a8a:	4bdc                	lw	a5,20(a5)
80006a8c:	8bbd                	andi	a5,a5,15
80006a8e:	0ff7f713          	zext.b	a4,a5
80006a92:	fec42783          	lw	a5,-20(s0)
80006a96:	8b3d                	andi	a4,a4,15
80006a98:	0706                	slli	a4,a4,0x1
80006a9a:	4794                	lw	a3,8(a5)
80006a9c:	9a85                	andi	a3,a3,-31
80006a9e:	8f55                	or	a4,a4,a3
80006aa0:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.N_MINUS_1 = ChannelInitStruct->TransfersTotal - 1;
80006aa2:	fe842783          	lw	a5,-24(s0)
80006aa6:	4b9c                	lw	a5,16(a5)
80006aa8:	07c2                	slli	a5,a5,0x10
80006aaa:	83c1                	srli	a5,a5,0x10
80006aac:	17fd                	addi	a5,a5,-1
80006aae:	07c2                	slli	a5,a5,0x10
80006ab0:	83c1                	srli	a5,a5,0x10
80006ab2:	3ff7f793          	andi	a5,a5,1023
80006ab6:	01079713          	slli	a4,a5,0x10
80006aba:	8341                	srli	a4,a4,0x10
80006abc:	fec42783          	lw	a5,-20(s0)
80006ac0:	3ff77713          	andi	a4,a4,1023
80006ac4:	0716                	slli	a4,a4,0x5
80006ac6:	4790                	lw	a2,8(a5)
80006ac8:	76e1                	lui	a3,0xffff8
80006aca:	06fd                	addi	a3,a3,31 # ffff801f <__data_source_start+0x7ffef1cb>
80006acc:	8ef1                	and	a3,a3,a2
80006ace:	8f55                	or	a4,a4,a3
80006ad0:	c798                	sw	a4,8(a5)
    ChannelStruct->CHANNEL_CFG_bit.CYCLE_CTRL = ChannelInitStruct->Mode;
80006ad2:	fe842783          	lw	a5,-24(s0)
80006ad6:	479c                	lw	a5,8(a5)
80006ad8:	8b9d                	andi	a5,a5,7
80006ada:	0ff7f713          	zext.b	a4,a5
80006ade:	fec42783          	lw	a5,-20(s0)
80006ae2:	0776                	slli	a4,a4,0x1d
80006ae4:	4790                	lw	a2,8(a5)
80006ae6:	200006b7          	lui	a3,0x20000
80006aea:	16fd                	addi	a3,a3,-1 # 1fffffff <STACK_SIZE+0x1ffff7ff>
80006aec:	8ef1                	and	a3,a3,a2
80006aee:	8f55                	or	a4,a4,a3
80006af0:	c798                	sw	a4,8(a5)
}
80006af2:	0001                	nop
80006af4:	4472                	lw	s0,28(sp)
80006af6:	6105                	addi	sp,sp,32
80006af8:	8082                	ret

80006afa <DMA_ChannelStructInit>:
  * @param   ChannelInitStruct  Указатель на структуру типа @ref DMA_ChannelInit_TypeDef,
  *                             которую необходимо проинициализировать
  * @retval  void
  */
void DMA_ChannelStructInit(DMA_ChannelInit_TypeDef* ChannelInitStruct)
{
80006afa:	1101                	addi	sp,sp,-32
80006afc:	ce22                	sw	s0,28(sp)
80006afe:	1000                	addi	s0,sp,32
80006b00:	fea42623          	sw	a0,-20(s0)
    /* источник */
    ChannelInitStruct->SrcDataEndPtr = (uint32_t*)0x00000000;
80006b04:	fec42783          	lw	a5,-20(s0)
80006b08:	0007a023          	sw	zero,0(a5)
    ChannelInitStruct->SrcDataSize = DMA_DataSize_8;
80006b0c:	fec42783          	lw	a5,-20(s0)
80006b10:	0207a823          	sw	zero,48(a5)
    ChannelInitStruct->SrcDataInc = DMA_DataInc_Disable;
80006b14:	fec42783          	lw	a5,-20(s0)
80006b18:	470d                	li	a4,3
80006b1a:	df98                	sw	a4,56(a5)
    ChannelInitStruct->SrcProtect.Bufferable = DISABLE;
80006b1c:	fec42783          	lw	a5,-20(s0)
80006b20:	0007ae23          	sw	zero,28(a5)
    ChannelInitStruct->SrcProtect.Priveleged = DISABLE;
80006b24:	fec42783          	lw	a5,-20(s0)
80006b28:	0007ac23          	sw	zero,24(a5)
    ChannelInitStruct->SrcProtect.Cacheable = DISABLE;
80006b2c:	fec42783          	lw	a5,-20(s0)
80006b30:	0207a023          	sw	zero,32(a5)
    /* приемник */
    ChannelInitStruct->DstDataEndPtr = (uint32_t*)0x00000000;
80006b34:	fec42783          	lw	a5,-20(s0)
80006b38:	0007a223          	sw	zero,4(a5)
    ChannelInitStruct->DstDataSize = DMA_DataSize_8;
80006b3c:	fec42783          	lw	a5,-20(s0)
80006b40:	0207aa23          	sw	zero,52(a5)
    ChannelInitStruct->DstDataInc = DMA_DataInc_Disable;
80006b44:	fec42783          	lw	a5,-20(s0)
80006b48:	470d                	li	a4,3
80006b4a:	dfd8                	sw	a4,60(a5)
    ChannelInitStruct->DstProtect.Bufferable = DISABLE;
80006b4c:	fec42783          	lw	a5,-20(s0)
80006b50:	0207a423          	sw	zero,40(a5)
    ChannelInitStruct->DstProtect.Priveleged = DISABLE;
80006b54:	fec42783          	lw	a5,-20(s0)
80006b58:	0207a223          	sw	zero,36(a5)
    ChannelInitStruct->DstProtect.Cacheable = DISABLE;
80006b5c:	fec42783          	lw	a5,-20(s0)
80006b60:	0207a623          	sw	zero,44(a5)
    /* общее */
    ChannelInitStruct->NextUseburst = DISABLE;
80006b64:	fec42783          	lw	a5,-20(s0)
80006b68:	0007a623          	sw	zero,12(a5)
    ChannelInitStruct->ArbitrationRate = DMA_ArbitrationRate_1;
80006b6c:	fec42783          	lw	a5,-20(s0)
80006b70:	0007aa23          	sw	zero,20(a5)
    ChannelInitStruct->TransfersTotal = 1;
80006b74:	fec42783          	lw	a5,-20(s0)
80006b78:	4705                	li	a4,1
80006b7a:	cb98                	sw	a4,16(a5)
    ChannelInitStruct->Mode = DMA_Mode_Disable;
80006b7c:	fec42783          	lw	a5,-20(s0)
80006b80:	0007a423          	sw	zero,8(a5)
}
80006b84:	0001                	nop
80006b86:	4472                	lw	s0,28(sp)
80006b88:	6105                	addi	sp,sp,32
80006b8a:	8082                	ret

80006b8c <DMA_DeInit>:
/**
  * @brief   Деинициализация контроллера DMA
  * @retval  void
  */
void DMA_DeInit()
{
80006b8c:	1141                	addi	sp,sp,-16
80006b8e:	c622                	sw	s0,12(sp)
80006b90:	0800                	addi	s0,sp,16
    CLEAR_REG(DMA->CFG);
80006b92:	3000c7b7          	lui	a5,0x3000c
80006b96:	0007a223          	sw	zero,4(a5) # 3000c004 <STACK_SIZE+0x3000b804>
    CLEAR_REG(DMA->BASEPTR);
80006b9a:	3000c7b7          	lui	a5,0x3000c
80006b9e:	0007a423          	sw	zero,8(a5) # 3000c008 <STACK_SIZE+0x3000b808>
    WRITE_REG(DMA->ENCLR, DMA_Channel_All);
80006ba2:	3000c7b7          	lui	a5,0x3000c
80006ba6:	01000737          	lui	a4,0x1000
80006baa:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006bac:	d7d8                	sw	a4,44(a5)
    WRITE_REG(DMA->PRIORITYCLR, DMA_Channel_All);
80006bae:	3000c7b7          	lui	a5,0x3000c
80006bb2:	01000737          	lui	a4,0x1000
80006bb6:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006bb8:	dfd8                	sw	a4,60(a5)
    WRITE_REG(DMA->PRIALTCLR, DMA_Channel_All);
80006bba:	3000c7b7          	lui	a5,0x3000c
80006bbe:	01000737          	lui	a4,0x1000
80006bc2:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006bc4:	dbd8                	sw	a4,52(a5)
    WRITE_REG(DMA->REQMASKCLR, DMA_Channel_All);
80006bc6:	3000c7b7          	lui	a5,0x3000c
80006bca:	01000737          	lui	a4,0x1000
80006bce:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006bd0:	d3d8                	sw	a4,36(a5)
    WRITE_REG(DMA->USEBURSTCLR, DMA_Channel_All);
80006bd2:	3000c7b7          	lui	a5,0x3000c
80006bd6:	01000737          	lui	a4,0x1000
80006bda:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006bdc:	cfd8                	sw	a4,28(a5)
}
80006bde:	0001                	nop
80006be0:	4432                	lw	s0,12(sp)
80006be2:	0141                	addi	sp,sp,16
80006be4:	8082                	ret

80006be6 <DMA_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref DMA_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void DMA_Init(DMA_Init_TypeDef* InitStruct)
{
80006be6:	1101                	addi	sp,sp,-32
80006be8:	ce06                	sw	ra,28(sp)
80006bea:	cc22                	sw	s0,24(sp)
80006bec:	1000                	addi	s0,sp,32
80006bee:	fea42623          	sw	a0,-20(s0)
    DMA_ProtectConfig(&(InitStruct->CtrlProtect));
80006bf2:	fec42783          	lw	a5,-20(s0)
80006bf6:	0791                	addi	a5,a5,4 # 3000c004 <STACK_SIZE+0x3000b804>
80006bf8:	853e                	mv	a0,a5
80006bfa:	3641                	jal	8000677a <DMA_ProtectConfig>
    DMA_UseBurstCmd(InitStruct->Channel, InitStruct->UseBurst);
80006bfc:	fec42783          	lw	a5,-20(s0)
80006c00:	4398                	lw	a4,0(a5)
80006c02:	fec42783          	lw	a5,-20(s0)
80006c06:	4b9c                	lw	a5,16(a5)
80006c08:	85be                	mv	a1,a5
80006c0a:	853a                	mv	a0,a4
80006c0c:	3675                	jal	800067b8 <DMA_UseBurstCmd>
    DMA_AltCtrlCmd(InitStruct->Channel, InitStruct->AltCtrl);
80006c0e:	fec42783          	lw	a5,-20(s0)
80006c12:	4398                	lw	a4,0(a5)
80006c14:	fec42783          	lw	a5,-20(s0)
80006c18:	4f9c                	lw	a5,24(a5)
80006c1a:	85be                	mv	a1,a5
80006c1c:	853a                	mv	a0,a4
80006c1e:	3935                	jal	8000685a <DMA_AltCtrlCmd>
    DMA_HighPriorityCmd(InitStruct->Channel, InitStruct->HighPriority);
80006c20:	fec42783          	lw	a5,-20(s0)
80006c24:	4398                	lw	a4,0(a5)
80006c26:	fec42783          	lw	a5,-20(s0)
80006c2a:	4fdc                	lw	a5,28(a5)
80006c2c:	85be                	mv	a1,a5
80006c2e:	853a                	mv	a0,a4
80006c30:	3185                	jal	80006890 <DMA_HighPriorityCmd>
    DMA_ReqMaskCmd(InitStruct->Channel, InitStruct->ReqMask);
80006c32:	fec42783          	lw	a5,-20(s0)
80006c36:	4398                	lw	a4,0(a5)
80006c38:	fec42783          	lw	a5,-20(s0)
80006c3c:	4bdc                	lw	a5,20(a5)
80006c3e:	85be                	mv	a1,a5
80006c40:	853a                	mv	a0,a4
80006c42:	3675                	jal	800067ee <DMA_ReqMaskCmd>
    DMA_ChannelEnableCmd(InitStruct->Channel, InitStruct->ChannelEnable);
80006c44:	fec42783          	lw	a5,-20(s0)
80006c48:	4398                	lw	a4,0(a5)
80006c4a:	fec42783          	lw	a5,-20(s0)
80006c4e:	539c                	lw	a5,32(a5)
80006c50:	85be                	mv	a1,a5
80006c52:	853a                	mv	a0,a4
80006c54:	3ec1                	jal	80006824 <DMA_ChannelEnableCmd>
}
80006c56:	0001                	nop
80006c58:	40f2                	lw	ra,28(sp)
80006c5a:	4462                	lw	s0,24(sp)
80006c5c:	6105                	addi	sp,sp,32
80006c5e:	8082                	ret

80006c60 <DMA_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref DMA_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void DMA_StructInit(DMA_Init_TypeDef* InitStruct)
{
80006c60:	1101                	addi	sp,sp,-32
80006c62:	ce22                	sw	s0,28(sp)
80006c64:	1000                	addi	s0,sp,32
80006c66:	fea42623          	sw	a0,-20(s0)
    InitStruct->Channel = DMA_Channel_All;
80006c6a:	fec42783          	lw	a5,-20(s0)
80006c6e:	01000737          	lui	a4,0x1000
80006c72:	177d                	addi	a4,a4,-1 # ffffff <STACK_SIZE+0xfff7ff>
80006c74:	c398                	sw	a4,0(a5)
    InitStruct->ChannelEnable = DISABLE;
80006c76:	fec42783          	lw	a5,-20(s0)
80006c7a:	0207a023          	sw	zero,32(a5)
    InitStruct->HighPriority = DISABLE;
80006c7e:	fec42783          	lw	a5,-20(s0)
80006c82:	0007ae23          	sw	zero,28(a5)
    InitStruct->AltCtrl = DISABLE;
80006c86:	fec42783          	lw	a5,-20(s0)
80006c8a:	0007ac23          	sw	zero,24(a5)
    InitStruct->ReqMask = DISABLE;
80006c8e:	fec42783          	lw	a5,-20(s0)
80006c92:	0007aa23          	sw	zero,20(a5)
    InitStruct->UseBurst = DISABLE;
80006c96:	fec42783          	lw	a5,-20(s0)
80006c9a:	0007a823          	sw	zero,16(a5)
    InitStruct->CtrlProtect.Bufferable = DISABLE;
80006c9e:	fec42783          	lw	a5,-20(s0)
80006ca2:	0007a423          	sw	zero,8(a5)
    InitStruct->CtrlProtect.Cacheable = DISABLE;
80006ca6:	fec42783          	lw	a5,-20(s0)
80006caa:	0007a623          	sw	zero,12(a5)
    InitStruct->CtrlProtect.Priveleged = DISABLE;
80006cae:	fec42783          	lw	a5,-20(s0)
80006cb2:	0007a223          	sw	zero,4(a5)
}
80006cb6:	0001                	nop
80006cb8:	4472                	lw	s0,28(sp)
80006cba:	6105                	addi	sp,sp,32
80006cbc:	8082                	ret

80006cbe <RCU_AHBRstCmd>:
{
80006cbe:	1101                	addi	sp,sp,-32
80006cc0:	ce22                	sw	s0,28(sp)
80006cc2:	1000                	addi	s0,sp,32
80006cc4:	fea42623          	sw	a0,-20(s0)
80006cc8:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80006ccc:	3000e7b7          	lui	a5,0x3000e
80006cd0:	4b98                	lw	a4,16(a5)
80006cd2:	fec42783          	lw	a5,-20(s0)
80006cd6:	fff7c793          	not	a5,a5
80006cda:	00f776b3          	and	a3,a4,a5
80006cde:	fe842783          	lw	a5,-24(s0)
80006ce2:	c781                	beqz	a5,80006cea <RCU_AHBRstCmd+0x2c>
80006ce4:	fec42783          	lw	a5,-20(s0)
80006ce8:	a011                	j	80006cec <RCU_AHBRstCmd+0x2e>
80006cea:	4781                	li	a5,0
80006cec:	3000e737          	lui	a4,0x3000e
80006cf0:	8fd5                	or	a5,a5,a3
80006cf2:	cb1c                	sw	a5,16(a4)
}
80006cf4:	0001                	nop
80006cf6:	4472                	lw	s0,28(sp)
80006cf8:	6105                	addi	sp,sp,32
80006cfa:	8082                	ret

80006cfc <GPIO_OutCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_OutCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80006cfc:	1101                	addi	sp,sp,-32
80006cfe:	ce22                	sw	s0,28(sp)
80006d00:	1000                	addi	s0,sp,32
80006d02:	fea42623          	sw	a0,-20(s0)
80006d06:	feb42423          	sw	a1,-24(s0)
80006d0a:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80006d0e:	fe442703          	lw	a4,-28(s0)
80006d12:	4785                	li	a5,1
80006d14:	00f71863          	bne	a4,a5,80006d24 <GPIO_OutCmd+0x28>
        WRITE_REG(GPIOx->OUTENSET, Pin);
80006d18:	fec42783          	lw	a5,-20(s0)
80006d1c:	fe842703          	lw	a4,-24(s0)
80006d20:	d7d8                	sw	a4,44(a5)
    else
        WRITE_REG(GPIOx->OUTENCLR, Pin);
}
80006d22:	a031                	j	80006d2e <GPIO_OutCmd+0x32>
        WRITE_REG(GPIOx->OUTENCLR, Pin);
80006d24:	fec42783          	lw	a5,-20(s0)
80006d28:	fe842703          	lw	a4,-24(s0)
80006d2c:	db98                	sw	a4,48(a5)
}
80006d2e:	0001                	nop
80006d30:	4472                	lw	s0,28(sp)
80006d32:	6105                	addi	sp,sp,32
80006d34:	8082                	ret

80006d36 <GPIO_AltFuncCmd>:
  * @param   Pin  Выбор пинов. Любая совокупность значений значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void GPIO_AltFuncCmd(GPIO_TypeDef* GPIOx, uint32_t Pin, FunctionalState State)
{
80006d36:	1101                	addi	sp,sp,-32
80006d38:	ce22                	sw	s0,28(sp)
80006d3a:	1000                	addi	s0,sp,32
80006d3c:	fea42623          	sw	a0,-20(s0)
80006d40:	feb42423          	sw	a1,-24(s0)
80006d44:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_FUNCTIONAL_STATE(State));

    if (State == ENABLE)
80006d48:	fe442703          	lw	a4,-28(s0)
80006d4c:	4785                	li	a5,1
80006d4e:	00f71863          	bne	a4,a5,80006d5e <GPIO_AltFuncCmd+0x28>
        WRITE_REG(GPIOx->ALTFUNCSET, Pin);
80006d52:	fec42783          	lw	a5,-20(s0)
80006d56:	fe842703          	lw	a4,-24(s0)
80006d5a:	dbd8                	sw	a4,52(a5)
    else
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
}
80006d5c:	a031                	j	80006d68 <GPIO_AltFuncCmd+0x32>
        WRITE_REG(GPIOx->ALTFUNCCLR, Pin);
80006d5e:	fec42783          	lw	a5,-20(s0)
80006d62:	fe842703          	lw	a4,-24(s0)
80006d66:	df98                	sw	a4,56(a5)
}
80006d68:	0001                	nop
80006d6a:	4472                	lw	s0,28(sp)
80006d6c:	6105                	addi	sp,sp,32
80006d6e:	8082                	ret

80006d70 <modeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   Val  Конфигурация пинов (2-битное значение)
  * @retval  void
  */
static void modeConfig(volatile uint32_t* Reg, uint32_t Pin, uint32_t Val)
{
80006d70:	7179                	addi	sp,sp,-48
80006d72:	d622                	sw	s0,44(sp)
80006d74:	1800                	addi	s0,sp,48
80006d76:	fca42e23          	sw	a0,-36(s0)
80006d7a:	fcb42c23          	sw	a1,-40(s0)
80006d7e:	fcc42a23          	sw	a2,-44(s0)
    uint32_t reg_temp = *Reg;
80006d82:	fdc42783          	lw	a5,-36(s0)
80006d86:	439c                	lw	a5,0(a5)
80006d88:	fef42623          	sw	a5,-20(s0)

    for (uint32_t i = 0; i < 16; i++) {
80006d8c:	fe042423          	sw	zero,-24(s0)
80006d90:	a889                	j	80006de2 <modeConfig+0x72>
        if (Pin & (1 << i)) {
80006d92:	fe842783          	lw	a5,-24(s0)
80006d96:	4705                	li	a4,1
80006d98:	00f717b3          	sll	a5,a4,a5
80006d9c:	873e                	mv	a4,a5
80006d9e:	fd842783          	lw	a5,-40(s0)
80006da2:	8ff9                	and	a5,a5,a4
80006da4:	cb95                	beqz	a5,80006dd8 <modeConfig+0x68>
            reg_temp &= ~(0x3UL << i * 0x2UL);
80006da6:	fe842783          	lw	a5,-24(s0)
80006daa:	0786                	slli	a5,a5,0x1
80006dac:	470d                	li	a4,3
80006dae:	00f717b3          	sll	a5,a4,a5
80006db2:	fff7c793          	not	a5,a5
80006db6:	fec42703          	lw	a4,-20(s0)
80006dba:	8ff9                	and	a5,a5,a4
80006dbc:	fef42623          	sw	a5,-20(s0)
            reg_temp |= Val << i * 0x2UL;
80006dc0:	fe842783          	lw	a5,-24(s0)
80006dc4:	0786                	slli	a5,a5,0x1
80006dc6:	fd442703          	lw	a4,-44(s0)
80006dca:	00f717b3          	sll	a5,a4,a5
80006dce:	fec42703          	lw	a4,-20(s0)
80006dd2:	8fd9                	or	a5,a5,a4
80006dd4:	fef42623          	sw	a5,-20(s0)
    for (uint32_t i = 0; i < 16; i++) {
80006dd8:	fe842783          	lw	a5,-24(s0)
80006ddc:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80006dde:	fef42423          	sw	a5,-24(s0)
80006de2:	fe842703          	lw	a4,-24(s0)
80006de6:	47bd                	li	a5,15
80006de8:	fae7f5e3          	bgeu	a5,a4,80006d92 <modeConfig+0x22>
        }
    }

    WRITE_REG(*Reg, reg_temp);
80006dec:	fdc42783          	lw	a5,-36(s0)
80006df0:	fec42703          	lw	a4,-20(s0)
80006df4:	c398                	sw	a4,0(a5)
}
80006df6:	0001                	nop
80006df8:	5432                	lw	s0,44(sp)
80006dfa:	6145                	addi	sp,sp,48
80006dfc:	8082                	ret

80006dfe <GPIO_OutModeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   OutMode  Режим работы
  * @retval  void
  */
void GPIO_OutModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_OutMode_TypeDef OutMode)
{
80006dfe:	1101                	addi	sp,sp,-32
80006e00:	ce06                	sw	ra,28(sp)
80006e02:	cc22                	sw	s0,24(sp)
80006e04:	1000                	addi	s0,sp,32
80006e06:	fea42623          	sw	a0,-20(s0)
80006e0a:	feb42423          	sw	a1,-24(s0)
80006e0e:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_OUT_MODE(OutMode));

    modeConfig(&(GPIOx->OUTMODE), Pin, (uint32_t)OutMode);
80006e12:	fec42783          	lw	a5,-20(s0)
80006e16:	02478793          	addi	a5,a5,36
80006e1a:	fe442603          	lw	a2,-28(s0)
80006e1e:	fe842583          	lw	a1,-24(s0)
80006e22:	853e                	mv	a0,a5
80006e24:	37b1                	jal	80006d70 <modeConfig>
}
80006e26:	0001                	nop
80006e28:	40f2                	lw	ra,28(sp)
80006e2a:	4462                	lw	s0,24(sp)
80006e2c:	6105                	addi	sp,sp,32
80006e2e:	8082                	ret

80006e30 <GPIO_InModeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   InMode  Режим работы
  * @retval  void
  */
void GPIO_InModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_InMode_TypeDef InMode)
{
80006e30:	1101                	addi	sp,sp,-32
80006e32:	ce06                	sw	ra,28(sp)
80006e34:	cc22                	sw	s0,24(sp)
80006e36:	1000                	addi	s0,sp,32
80006e38:	fea42623          	sw	a0,-20(s0)
80006e3c:	feb42423          	sw	a1,-24(s0)
80006e40:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_IN_MODE(InMode));

    modeConfig(&(GPIOx->INMODE), Pin, (uint32_t)InMode);
80006e44:	fec42783          	lw	a5,-20(s0)
80006e48:	07f1                	addi	a5,a5,28
80006e4a:	fe442603          	lw	a2,-28(s0)
80006e4e:	fe842583          	lw	a1,-24(s0)
80006e52:	853e                	mv	a0,a5
80006e54:	3f31                	jal	80006d70 <modeConfig>
}
80006e56:	0001                	nop
80006e58:	40f2                	lw	ra,28(sp)
80006e5a:	4462                	lw	s0,24(sp)
80006e5c:	6105                	addi	sp,sp,32
80006e5e:	8082                	ret

80006e60 <GPIO_PullModeConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   PullMode  Режим работы
  * @retval  void
  */
void GPIO_PullModeConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_PullMode_TypeDef PullMode)
{
80006e60:	7179                	addi	sp,sp,-48
80006e62:	d622                	sw	s0,44(sp)
80006e64:	1800                	addi	s0,sp,48
80006e66:	fca42e23          	sw	a0,-36(s0)
80006e6a:	fcb42c23          	sw	a1,-40(s0)
80006e6e:	fcc42a23          	sw	a2,-44(s0)
    assert_param(IS_GPIO_PERIPH(GPIOx));
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_PULL_MODE(PullMode));

    // PULLMODE использует 1 бит на пин (не 2 бита как другие регистры INMODE, OUTMODE, ALTFUNCNUM)
    uint32_t temp = GPIOx->PULLMODE;
80006e72:	fdc42783          	lw	a5,-36(s0)
80006e76:	539c                	lw	a5,32(a5)
80006e78:	fef42623          	sw	a5,-20(s0)
    
    for (uint32_t i = 0; i < 16; i++) {
80006e7c:	fe042423          	sw	zero,-24(s0)
80006e80:	a889                	j	80006ed2 <GPIO_PullModeConfig+0x72>
        if (Pin & (1 << i)) {
80006e82:	fe842783          	lw	a5,-24(s0)
80006e86:	4705                	li	a4,1
80006e88:	00f717b3          	sll	a5,a4,a5
80006e8c:	873e                	mv	a4,a5
80006e8e:	fd842783          	lw	a5,-40(s0)
80006e92:	8ff9                	and	a5,a5,a4
80006e94:	cb95                	beqz	a5,80006ec8 <GPIO_PullModeConfig+0x68>
            // Очищаем 1 бит для пина i
            temp &= ~(0x1UL << i);
80006e96:	fe842783          	lw	a5,-24(s0)
80006e9a:	4705                	li	a4,1
80006e9c:	00f717b3          	sll	a5,a4,a5
80006ea0:	fff7c793          	not	a5,a5
80006ea4:	fec42703          	lw	a4,-20(s0)
80006ea8:	8ff9                	and	a5,a5,a4
80006eaa:	fef42623          	sw	a5,-20(s0)
            // Устанавливаем значение (0 или 1) в бит i
            temp |= ((uint32_t)PullMode & 0x1UL) << i;
80006eae:	fd442783          	lw	a5,-44(s0)
80006eb2:	0017f713          	andi	a4,a5,1
80006eb6:	fe842783          	lw	a5,-24(s0)
80006eba:	00f717b3          	sll	a5,a4,a5
80006ebe:	fec42703          	lw	a4,-20(s0)
80006ec2:	8fd9                	or	a5,a5,a4
80006ec4:	fef42623          	sw	a5,-20(s0)
    for (uint32_t i = 0; i < 16; i++) {
80006ec8:	fe842783          	lw	a5,-24(s0)
80006ecc:	0785                	addi	a5,a5,1
80006ece:	fef42423          	sw	a5,-24(s0)
80006ed2:	fe842703          	lw	a4,-24(s0)
80006ed6:	47bd                	li	a5,15
80006ed8:	fae7f5e3          	bgeu	a5,a4,80006e82 <GPIO_PullModeConfig+0x22>
        }
    }
    
    WRITE_REG(GPIOx->PULLMODE, temp);
80006edc:	fdc42783          	lw	a5,-36(s0)
80006ee0:	fec42703          	lw	a4,-20(s0)
80006ee4:	d398                	sw	a4,32(a5)
}
80006ee6:	0001                	nop
80006ee8:	5432                	lw	s0,44(sp)
80006eea:	6145                	addi	sp,sp,48
80006eec:	8082                	ret

80006eee <GPIO_AltFuncNumConfig>:
  * @param   Pin  Выбор пинов. Любая совокупность значений GPIO_Pin_x (@ref GPIO_Pin_Define).
  * @param   AltFuncNum  Номер функции
  * @retval  void
  */
void GPIO_AltFuncNumConfig(GPIO_TypeDef* GPIOx, uint32_t Pin, GPIO_AltFuncNum_TypeDef AltFuncNum)
{
80006eee:	7179                	addi	sp,sp,-48
80006ef0:	d622                	sw	s0,44(sp)
80006ef2:	1800                	addi	s0,sp,48
80006ef4:	fca42e23          	sw	a0,-36(s0)
80006ef8:	fcb42c23          	sw	a1,-40(s0)
80006efc:	fcc42a23          	sw	a2,-44(s0)
    assert_param(IS_GPIO_PIN(Pin));
    assert_param(IS_GPIO_ALT_FUNC_NUM(AltFuncNum));

    uint32_t temp;

    temp = GPIOx->ALTFUNCNUM;
80006f00:	fdc42783          	lw	a5,-36(s0)
80006f04:	5fdc                	lw	a5,60(a5)
80006f06:	fef42623          	sw	a5,-20(s0)

    for (uint32_t i = 0; i < 16; i++) {
80006f0a:	fe042423          	sw	zero,-24(s0)
80006f0e:	a889                	j	80006f60 <GPIO_AltFuncNumConfig+0x72>
    	if (Pin & (1 << i))
80006f10:	fe842783          	lw	a5,-24(s0)
80006f14:	4705                	li	a4,1
80006f16:	00f717b3          	sll	a5,a4,a5
80006f1a:	873e                	mv	a4,a5
80006f1c:	fd842783          	lw	a5,-40(s0)
80006f20:	8ff9                	and	a5,a5,a4
80006f22:	cb95                	beqz	a5,80006f56 <GPIO_AltFuncNumConfig+0x68>
    	{
    		temp &= ~(0x3UL << i * 0x2UL);
80006f24:	fe842783          	lw	a5,-24(s0)
80006f28:	0786                	slli	a5,a5,0x1
80006f2a:	470d                	li	a4,3
80006f2c:	00f717b3          	sll	a5,a4,a5
80006f30:	fff7c793          	not	a5,a5
80006f34:	fec42703          	lw	a4,-20(s0)
80006f38:	8ff9                	and	a5,a5,a4
80006f3a:	fef42623          	sw	a5,-20(s0)
    		temp |= (uint32_t)AltFuncNum << i * 0x2UL;
80006f3e:	fe842783          	lw	a5,-24(s0)
80006f42:	0786                	slli	a5,a5,0x1
80006f44:	fd442703          	lw	a4,-44(s0)
80006f48:	00f717b3          	sll	a5,a4,a5
80006f4c:	fec42703          	lw	a4,-20(s0)
80006f50:	8fd9                	or	a5,a5,a4
80006f52:	fef42623          	sw	a5,-20(s0)
    for (uint32_t i = 0; i < 16; i++) {
80006f56:	fe842783          	lw	a5,-24(s0)
80006f5a:	0785                	addi	a5,a5,1
80006f5c:	fef42423          	sw	a5,-24(s0)
80006f60:	fe842703          	lw	a4,-24(s0)
80006f64:	47bd                	li	a5,15
80006f66:	fae7f5e3          	bgeu	a5,a4,80006f10 <GPIO_AltFuncNumConfig+0x22>
//                temp1 |= (uint32_t)AltFuncNum << (i - 8) * 0x4UL;
//            }
//        }
    }

    GPIOx->ALTFUNCNUM = temp;
80006f6a:	fdc42783          	lw	a5,-36(s0)
80006f6e:	fec42703          	lw	a4,-20(s0)
80006f72:	dfd8                	sw	a4,60(a5)
}
80006f74:	0001                	nop
80006f76:	5432                	lw	s0,44(sp)
80006f78:	6145                	addi	sp,sp,48
80006f7a:	8082                	ret

80006f7c <GPIO_DeInit>:
  * @brief   Устанавливает все регистры выбранного GPIOx значениями по умолчанию
  * @param   GPIOx  Выбор порта, где x=A|B|C
  * @retval  void
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
80006f7c:	7179                	addi	sp,sp,-48
80006f7e:	d606                	sw	ra,44(sp)
80006f80:	d422                	sw	s0,40(sp)
80006f82:	1800                	addi	s0,sp,48
80006f84:	fca42e23          	sw	a0,-36(s0)
    uint32_t GPIO_rst;

    assert_param(IS_GPIO_PERIPH(GPIOx));

    if (GPIOx == GPIOA)
80006f88:	fdc42703          	lw	a4,-36(s0)
80006f8c:	280007b7          	lui	a5,0x28000
80006f90:	00f71763          	bne	a4,a5,80006f9e <GPIO_DeInit+0x22>
        GPIO_rst = RCU_AHBRst_GPIOA;
80006f94:	10000793          	li	a5,256
80006f98:	fef42623          	sw	a5,-20(s0)
80006f9c:	a035                	j	80006fc8 <GPIO_DeInit+0x4c>
    else if (GPIOx == GPIOB)
80006f9e:	fdc42703          	lw	a4,-36(s0)
80006fa2:	280017b7          	lui	a5,0x28001
80006fa6:	00f71763          	bne	a4,a5,80006fb4 <GPIO_DeInit+0x38>
        GPIO_rst = RCU_AHBRst_GPIOB;
80006faa:	20000793          	li	a5,512
80006fae:	fef42623          	sw	a5,-20(s0)
80006fb2:	a819                	j	80006fc8 <GPIO_DeInit+0x4c>
    else  if (GPIOx == GPIOC)
80006fb4:	fdc42703          	lw	a4,-36(s0)
80006fb8:	280027b7          	lui	a5,0x28002
80006fbc:	00f71663          	bne	a4,a5,80006fc8 <GPIO_DeInit+0x4c>
        GPIO_rst = RCU_AHBRst_GPIOC;
80006fc0:	40000793          	li	a5,1024
80006fc4:	fef42623          	sw	a5,-20(s0)

    RCU_AHBRstCmd(GPIO_rst, DISABLE);
80006fc8:	4581                	li	a1,0
80006fca:	fec42503          	lw	a0,-20(s0)
80006fce:	39c5                	jal	80006cbe <RCU_AHBRstCmd>
    RCU_AHBRstCmd(GPIO_rst, ENABLE);
80006fd0:	4585                	li	a1,1
80006fd2:	fec42503          	lw	a0,-20(s0)
80006fd6:	31e5                	jal	80006cbe <RCU_AHBRstCmd>
}
80006fd8:	0001                	nop
80006fda:	50b2                	lw	ra,44(sp)
80006fdc:	5422                	lw	s0,40(sp)
80006fde:	6145                	addi	sp,sp,48
80006fe0:	8082                	ret

80006fe2 <GPIO_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref GPIO_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_Init_TypeDef* InitStruct)
{
80006fe2:	1101                	addi	sp,sp,-32
80006fe4:	ce06                	sw	ra,28(sp)
80006fe6:	cc22                	sw	s0,24(sp)
80006fe8:	1000                	addi	s0,sp,32
80006fea:	fea42623          	sw	a0,-20(s0)
80006fee:	feb42423          	sw	a1,-24(s0)
    GPIO_OutCmd(GPIOx, InitStruct->Pin, InitStruct->Out);
80006ff2:	fe842783          	lw	a5,-24(s0)
80006ff6:	4398                	lw	a4,0(a5)
80006ff8:	fe842783          	lw	a5,-24(s0)
80006ffc:	43dc                	lw	a5,4(a5)
80006ffe:	863e                	mv	a2,a5
80007000:	85ba                	mv	a1,a4
80007002:	fec42503          	lw	a0,-20(s0)
80007006:	39dd                	jal	80006cfc <GPIO_OutCmd>
    GPIO_AltFuncNumConfig(GPIOx, InitStruct->Pin, InitStruct->AltFuncNum);
80007008:	fe842783          	lw	a5,-24(s0)
8000700c:	4398                	lw	a4,0(a5)
8000700e:	fe842783          	lw	a5,-24(s0)
80007012:	47dc                	lw	a5,12(a5)
80007014:	863e                	mv	a2,a5
80007016:	85ba                	mv	a1,a4
80007018:	fec42503          	lw	a0,-20(s0)
8000701c:	3dc9                	jal	80006eee <GPIO_AltFuncNumConfig>
    GPIO_AltFuncCmd(GPIOx, InitStruct->Pin, InitStruct->AltFunc);
8000701e:	fe842783          	lw	a5,-24(s0)
80007022:	4398                	lw	a4,0(a5)
80007024:	fe842783          	lw	a5,-24(s0)
80007028:	479c                	lw	a5,8(a5)
8000702a:	863e                	mv	a2,a5
8000702c:	85ba                	mv	a1,a4
8000702e:	fec42503          	lw	a0,-20(s0)
80007032:	3311                	jal	80006d36 <GPIO_AltFuncCmd>
    GPIO_OutModeConfig(GPIOx, InitStruct->Pin, InitStruct->OutMode);
80007034:	fe842783          	lw	a5,-24(s0)
80007038:	4398                	lw	a4,0(a5)
8000703a:	fe842783          	lw	a5,-24(s0)
8000703e:	4bdc                	lw	a5,20(a5)
80007040:	863e                	mv	a2,a5
80007042:	85ba                	mv	a1,a4
80007044:	fec42503          	lw	a0,-20(s0)
80007048:	3b5d                	jal	80006dfe <GPIO_OutModeConfig>
    GPIO_InModeConfig(GPIOx, InitStruct->Pin, InitStruct->InMode);
8000704a:	fe842783          	lw	a5,-24(s0)
8000704e:	4398                	lw	a4,0(a5)
80007050:	fe842783          	lw	a5,-24(s0)
80007054:	4f9c                	lw	a5,24(a5)
80007056:	863e                	mv	a2,a5
80007058:	85ba                	mv	a1,a4
8000705a:	fec42503          	lw	a0,-20(s0)
8000705e:	3bc9                	jal	80006e30 <GPIO_InModeConfig>
    GPIO_PullModeConfig(GPIOx, InitStruct->Pin, InitStruct->PullMode);
80007060:	fe842783          	lw	a5,-24(s0)
80007064:	4398                	lw	a4,0(a5)
80007066:	fe842783          	lw	a5,-24(s0)
8000706a:	4fdc                	lw	a5,28(a5)
8000706c:	863e                	mv	a2,a5
8000706e:	85ba                	mv	a1,a4
80007070:	fec42503          	lw	a0,-20(s0)
80007074:	33f5                	jal	80006e60 <GPIO_PullModeConfig>
    //GPIO_DigitalCmd(GPIOx, InitStruct->Pin, InitStruct->Digital);
}
80007076:	0001                	nop
80007078:	40f2                	lw	ra,28(sp)
8000707a:	4462                	lw	s0,24(sp)
8000707c:	6105                	addi	sp,sp,32
8000707e:	8082                	ret

80007080 <GPIO_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref GPIO_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void GPIO_StructInit(GPIO_Init_TypeDef* InitStruct)
{
80007080:	1101                	addi	sp,sp,-32
80007082:	ce22                	sw	s0,28(sp)
80007084:	1000                	addi	s0,sp,32
80007086:	fea42623          	sw	a0,-20(s0)
    InitStruct->Pin = GPIO_Pin_All;
8000708a:	fec42783          	lw	a5,-20(s0)
8000708e:	6741                	lui	a4,0x10
80007090:	177d                	addi	a4,a4,-1 # ffff <STACK_SIZE+0xf7ff>
80007092:	c398                	sw	a4,0(a5)
    InitStruct->Out = DISABLE;
80007094:	fec42783          	lw	a5,-20(s0)
80007098:	0007a223          	sw	zero,4(a5) # 28002004 <STACK_SIZE+0x28001804>
    InitStruct->AltFuncNum = GPIO_AltFuncNum_None;
8000709c:	fec42783          	lw	a5,-20(s0)
800070a0:	0007a623          	sw	zero,12(a5)
    InitStruct->AltFunc = DISABLE;
800070a4:	fec42783          	lw	a5,-20(s0)
800070a8:	0007a423          	sw	zero,8(a5)
    InitStruct->OutMode = GPIO_OutMode_PP;
800070ac:	fec42783          	lw	a5,-20(s0)
800070b0:	0007aa23          	sw	zero,20(a5)
    InitStruct->InMode = GPIO_InMode_Schmitt;
800070b4:	fec42783          	lw	a5,-20(s0)
800070b8:	0007ac23          	sw	zero,24(a5)
    InitStruct->PullMode = GPIO_PullMode_Disable;
800070bc:	fec42783          	lw	a5,-20(s0)
800070c0:	0007ae23          	sw	zero,28(a5)
    InitStruct->Digital = DISABLE;
800070c4:	fec42783          	lw	a5,-20(s0)
800070c8:	0007a823          	sw	zero,16(a5)
}
800070cc:	0001                	nop
800070ce:	4472                	lw	s0,28(sp)
800070d0:	6105                	addi	sp,sp,32
800070d2:	8082                	ret

800070d4 <RCU_AHBClkCmd>:
{
800070d4:	1101                	addi	sp,sp,-32
800070d6:	ce22                	sw	s0,28(sp)
800070d8:	1000                	addi	s0,sp,32
800070da:	fea42623          	sw	a0,-20(s0)
800070de:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->CGCFGAHB, AHBClk, State ? AHBClk : 0);
800070e2:	3000e7b7          	lui	a5,0x3000e
800070e6:	4398                	lw	a4,0(a5)
800070e8:	fec42783          	lw	a5,-20(s0)
800070ec:	fff7c793          	not	a5,a5
800070f0:	00f776b3          	and	a3,a4,a5
800070f4:	fe842783          	lw	a5,-24(s0)
800070f8:	c781                	beqz	a5,80007100 <RCU_AHBClkCmd+0x2c>
800070fa:	fec42783          	lw	a5,-20(s0)
800070fe:	a011                	j	80007102 <RCU_AHBClkCmd+0x2e>
80007100:	4781                	li	a5,0
80007102:	3000e737          	lui	a4,0x3000e
80007106:	8fd5                	or	a5,a5,a3
80007108:	c31c                	sw	a5,0(a4)
}
8000710a:	0001                	nop
8000710c:	4472                	lw	s0,28(sp)
8000710e:	6105                	addi	sp,sp,32
80007110:	8082                	ret

80007112 <RCU_AHBRstCmd>:
{
80007112:	1101                	addi	sp,sp,-32
80007114:	ce22                	sw	s0,28(sp)
80007116:	1000                	addi	s0,sp,32
80007118:	fea42623          	sw	a0,-20(s0)
8000711c:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80007120:	3000e7b7          	lui	a5,0x3000e
80007124:	4b98                	lw	a4,16(a5)
80007126:	fec42783          	lw	a5,-20(s0)
8000712a:	fff7c793          	not	a5,a5
8000712e:	00f776b3          	and	a3,a4,a5
80007132:	fe842783          	lw	a5,-24(s0)
80007136:	c781                	beqz	a5,8000713e <RCU_AHBRstCmd+0x2c>
80007138:	fec42783          	lw	a5,-20(s0)
8000713c:	a011                	j	80007140 <RCU_AHBRstCmd+0x2e>
8000713e:	4781                	li	a5,0
80007140:	3000e737          	lui	a4,0x3000e
80007144:	8fd5                	or	a5,a5,a3
80007146:	cb1c                	sw	a5,16(a4)
}
80007148:	0001                	nop
8000714a:	4472                	lw	s0,28(sp)
8000714c:	6105                	addi	sp,sp,32
8000714e:	8082                	ret

80007150 <HASH_InitCmd>:
  * @brief   Инициализация хеш-процессора
  * @param   state Состояние инициализации
  * @retval  void
  */
__STATIC_INLINE void HASH_InitCmd(FunctionalState state)
{
80007150:	1101                	addi	sp,sp,-32
80007152:	ce22                	sw	s0,28(sp)
80007154:	1000                	addi	s0,sp,32
80007156:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_INIT_Msk, state << HASH_CR_INIT_Pos);
8000715a:	200327b7          	lui	a5,0x20032
8000715e:	439c                	lw	a5,0(a5)
80007160:	ffe7f693          	andi	a3,a5,-2
80007164:	200327b7          	lui	a5,0x20032
80007168:	fec42703          	lw	a4,-20(s0)
8000716c:	8f55                	or	a4,a4,a3
8000716e:	c398                	sw	a4,0(a5)
}
80007170:	0001                	nop
80007172:	4472                	lw	s0,28(sp)
80007174:	6105                	addi	sp,sp,32
80007176:	8082                	ret

80007178 <HASH_ModeCmd>:
  * @brief   Выбор режима алгоритма
  * @param   state Режим алгоритма
  * @retval  void
  */
__STATIC_INLINE void HASH_ModeCmd(HASH_MODE_TypeDef mode)
{
80007178:	1101                	addi	sp,sp,-32
8000717a:	ce22                	sw	s0,28(sp)
8000717c:	1000                	addi	s0,sp,32
8000717e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_MODE(mode));

	MODIFY_REG(HASH->CR, HASH_CR_MODE_Msk, mode << HASH_CR_MODE_Pos);
80007182:	200327b7          	lui	a5,0x20032
80007186:	439c                	lw	a5,0(a5)
80007188:	ffd7f693          	andi	a3,a5,-3
8000718c:	fec42783          	lw	a5,-20(s0)
80007190:	00179713          	slli	a4,a5,0x1
80007194:	200327b7          	lui	a5,0x20032
80007198:	8f55                	or	a4,a4,a3
8000719a:	c398                	sw	a4,0(a5)
}
8000719c:	0001                	nop
8000719e:	4472                	lw	s0,28(sp)
800071a0:	6105                	addi	sp,sp,32
800071a2:	8082                	ret

800071a4 <HASH_KeyLengthCmd>:
  * @brief   Выбор длинного ключа
  * @param   length Длина ключа
  * @retval  void
  */
__STATIC_INLINE void HASH_KeyLengthCmd(HASH_LKEY_TypeDef length)
{
800071a4:	1101                	addi	sp,sp,-32
800071a6:	ce22                	sw	s0,28(sp)
800071a8:	1000                	addi	s0,sp,32
800071aa:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_LKEY(length));

	MODIFY_REG(HASH->CR, HASH_CR_LKEY_Msk, length << HASH_CR_LKEY_Pos);
800071ae:	200327b7          	lui	a5,0x20032
800071b2:	439c                	lw	a5,0(a5)
800071b4:	ffb7f693          	andi	a3,a5,-5
800071b8:	fec42783          	lw	a5,-20(s0)
800071bc:	00279713          	slli	a4,a5,0x2
800071c0:	200327b7          	lui	a5,0x20032
800071c4:	8f55                	or	a4,a4,a3
800071c6:	c398                	sw	a4,0(a5)
}
800071c8:	0001                	nop
800071ca:	4472                	lw	s0,28(sp)
800071cc:	6105                	addi	sp,sp,32
800071ce:	8082                	ret

800071d0 <HASH_SameKeyCmd>:
  * @brief   Использование одинаковыч внешних и внутренних ключей
  * @param   state Разрешение использования одинакового ключа
  * @retval  void
  */
__STATIC_INLINE void HASH_SameKeyCmd(FunctionalState state)
{
800071d0:	1101                	addi	sp,sp,-32
800071d2:	ce22                	sw	s0,28(sp)
800071d4:	1000                	addi	s0,sp,32
800071d6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_SAMK_Msk, state << HASH_CR_SAMK_Pos);
800071da:	200327b7          	lui	a5,0x20032
800071de:	439c                	lw	a5,0(a5)
800071e0:	ff77f693          	andi	a3,a5,-9
800071e4:	fec42783          	lw	a5,-20(s0)
800071e8:	00379713          	slli	a4,a5,0x3
800071ec:	200327b7          	lui	a5,0x20032
800071f0:	8f55                	or	a4,a4,a3
800071f2:	c398                	sw	a4,0(a5)
}
800071f4:	0001                	nop
800071f6:	4472                	lw	s0,28(sp)
800071f8:	6105                	addi	sp,sp,32
800071fa:	8082                	ret

800071fc <HASH_DataTypeConfig>:
  * @brief   Выбор формата данных
  * @param   dt формат данных
  * @retval  void
  */
__STATIC_INLINE void HASH_DataTypeConfig(HASH_DATATYPE_TypeDef dt)
{
800071fc:	1101                	addi	sp,sp,-32
800071fe:	ce22                	sw	s0,28(sp)
80007200:	1000                	addi	s0,sp,32
80007202:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_DATATYPE(dt));

	MODIFY_REG(HASH->CR, HASH_CR_DATATYPE_Msk, dt << HASH_CR_DATATYPE_Pos);
80007206:	200327b7          	lui	a5,0x20032
8000720a:	439c                	lw	a5,0(a5)
8000720c:	fcf7f693          	andi	a3,a5,-49
80007210:	fec42783          	lw	a5,-20(s0)
80007214:	00479713          	slli	a4,a5,0x4
80007218:	200327b7          	lui	a5,0x20032
8000721c:	8f55                	or	a4,a4,a3
8000721e:	c398                	sw	a4,0(a5)
}
80007220:	0001                	nop
80007222:	4472                	lw	s0,28(sp)
80007224:	6105                	addi	sp,sp,32
80007226:	8082                	ret

80007228 <HASH_DMACmd>:
  * @brief   Включение механизма DMA
  * @param   state Состояние передач DMA
  * @retval  void
  */
__STATIC_INLINE void HASH_DMACmd(FunctionalState state)
{
80007228:	1101                	addi	sp,sp,-32
8000722a:	ce22                	sw	s0,28(sp)
8000722c:	1000                	addi	s0,sp,32
8000722e:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_DMAE_Msk, state << HASH_CR_DMAE_Pos);
80007232:	200327b7          	lui	a5,0x20032
80007236:	439c                	lw	a5,0(a5)
80007238:	fbf7f693          	andi	a3,a5,-65
8000723c:	fec42783          	lw	a5,-20(s0)
80007240:	00679713          	slli	a4,a5,0x6
80007244:	200327b7          	lui	a5,0x20032
80007248:	8f55                	or	a4,a4,a3
8000724a:	c398                	sw	a4,0(a5)
}
8000724c:	0001                	nop
8000724e:	4472                	lw	s0,28(sp)
80007250:	6105                	addi	sp,sp,32
80007252:	8082                	ret

80007254 <HASH_SetMultyDMATransmit>:
  * @brief   Включение механизма MDMAT
  * @param   state Состояние передачи MDMAT
  * @retval  void
  */
__STATIC_INLINE void HASH_SetMultyDMATransmit(FunctionalState state)
{
80007254:	1101                	addi	sp,sp,-32
80007256:	ce22                	sw	s0,28(sp)
80007258:	1000                	addi	s0,sp,32
8000725a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(HASH->CR, HASH_CR_MDMAT_Msk, state << HASH_CR_MDMAT_Pos);
8000725e:	200327b7          	lui	a5,0x20032
80007262:	439c                	lw	a5,0(a5)
80007264:	f7f7f693          	andi	a3,a5,-129
80007268:	fec42783          	lw	a5,-20(s0)
8000726c:	00779713          	slli	a4,a5,0x7
80007270:	200327b7          	lui	a5,0x20032
80007274:	8f55                	or	a4,a4,a3
80007276:	c398                	sw	a4,0(a5)
}
80007278:	0001                	nop
8000727a:	4472                	lw	s0,28(sp)
8000727c:	6105                	addi	sp,sp,32
8000727e:	8082                	ret

80007280 <HASH_SetAlgo>:
  * @brief   Выбор алгоритма хэш-функции
  * @param   algo алгоритм хем-функции
  * @retval  void
  */
__STATIC_INLINE void HASH_SetAlgo(HASH_ALGO_TypeDef algo)
{
80007280:	1101                	addi	sp,sp,-32
80007282:	ce22                	sw	s0,28(sp)
80007284:	1000                	addi	s0,sp,32
80007286:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_CR_ALGO(algo));

	MODIFY_REG(HASH->CR, HASH_CR_ALGO_Msk, algo << HASH_CR_ALGO_Pos);
8000728a:	200327b7          	lui	a5,0x20032
8000728e:	4398                	lw	a4,0(a5)
80007290:	77d1                	lui	a5,0xffff4
80007292:	17fd                	addi	a5,a5,-1 # ffff3fff <__data_source_start+0x7ffeb1ab>
80007294:	00f776b3          	and	a3,a4,a5
80007298:	fec42783          	lw	a5,-20(s0)
8000729c:	00e79713          	slli	a4,a5,0xe
800072a0:	200327b7          	lui	a5,0x20032
800072a4:	8f55                	or	a4,a4,a3
800072a6:	c398                	sw	a4,0(a5)
}
800072a8:	0001                	nop
800072aa:	4472                	lw	s0,28(sp)
800072ac:	6105                	addi	sp,sp,32
800072ae:	8082                	ret

800072b0 <HASH_GetAlgo>:
/**
  * @brief   Получение выбранного алгоритма хэш-функции
  * @retval  algo алгоритм хем-функции
  */
__STATIC_INLINE HASH_ALGO_TypeDef HASH_GetAlgo()
{
800072b0:	1141                	addi	sp,sp,-16
800072b2:	c622                	sw	s0,12(sp)
800072b4:	0800                	addi	s0,sp,16
	return (HASH_ALGO_TypeDef) ((READ_REG(HASH->CR) & HASH_CR_ALGO_Msk) >> HASH_CR_ALGO_Pos);
800072b6:	200327b7          	lui	a5,0x20032
800072ba:	439c                	lw	a5,0(a5)
800072bc:	83b9                	srli	a5,a5,0xe
800072be:	8b8d                	andi	a5,a5,3
}
800072c0:	853e                	mv	a0,a5
800072c2:	4432                	lw	s0,12(sp)
800072c4:	0141                	addi	sp,sp,16
800072c6:	8082                	ret

800072c8 <HASH_SetData>:
  * @brief   Добавление данных для формирования хеш-суммы
  * @param   data Данные для добавления
  * @retval  void
  */
__STATIC_INLINE void HASH_SetData(uint32_t data)
{
800072c8:	1101                	addi	sp,sp,-32
800072ca:	ce22                	sw	s0,28(sp)
800072cc:	1000                	addi	s0,sp,32
800072ce:	fea42623          	sw	a0,-20(s0)
	WRITE_REG(HASH->DATAIN_bit.VAL, data);
800072d2:	200327b7          	lui	a5,0x20032
800072d6:	fec42703          	lw	a4,-20(s0)
800072da:	c3d8                	sw	a4,4(a5)
}
800072dc:	0001                	nop
800072de:	4472                	lw	s0,28(sp)
800072e0:	6105                	addi	sp,sp,32
800072e2:	8082                	ret

800072e4 <HASH_GetHash>:
/**
  * @brief   Получение последних записанных в регистр данных
  * @retval  data Последние добавленные данные
  */
__STATIC_INLINE uint32_t HASH_GetHash(uint32_t idx)
{
800072e4:	1101                	addi	sp,sp,-32
800072e6:	ce22                	sw	s0,28(sp)
800072e8:	1000                	addi	s0,sp,32
800072ea:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_HASH_HR(idx));

	return (uint32_t) READ_REG(HASH->HR[idx].HR);
800072ee:	20032737          	lui	a4,0x20032
800072f2:	fec42783          	lw	a5,-20(s0)
800072f6:	07c1                	addi	a5,a5,16 # 20032010 <STACK_SIZE+0x20031810>
800072f8:	078a                	slli	a5,a5,0x2
800072fa:	97ba                	add	a5,a5,a4
800072fc:	439c                	lw	a5,0(a5)
}
800072fe:	853e                	mv	a0,a5
80007300:	4472                	lw	s0,28(sp)
80007302:	6105                	addi	sp,sp,32
80007304:	8082                	ret

80007306 <HASH_GetHashLen>:
  * @brief   Устанваливает буфер значениями хеш-суммы
  * @param   buffer ссылка на начало буфера, размер которого должен соответсвовать размерности алгоритма шифрования см. Руководство пользователя Приложение А10 Регистр HR
  * @retval  length длина хеша
  */
uint32_t HASH_GetHashLen(HASH_ALGO_TypeDef algo)
{
80007306:	1101                	addi	sp,sp,-32
80007308:	ce06                	sw	ra,28(sp)
8000730a:	cc22                	sw	s0,24(sp)
8000730c:	1000                	addi	s0,sp,32
8000730e:	fea42623          	sw	a0,-20(s0)
	switch(HASH_GetAlgo()) {
80007312:	3f79                	jal	800072b0 <HASH_GetAlgo>
80007314:	87aa                	mv	a5,a0
80007316:	470d                	li	a4,3
80007318:	02e78663          	beq	a5,a4,80007344 <HASH_GetHashLen+0x3e>
8000731c:	470d                	li	a4,3
8000731e:	02f76563          	bltu	a4,a5,80007348 <HASH_GetHashLen+0x42>
80007322:	4709                	li	a4,2
80007324:	00e78e63          	beq	a5,a4,80007340 <HASH_GetHashLen+0x3a>
80007328:	4709                	li	a4,2
8000732a:	00f76f63          	bltu	a4,a5,80007348 <HASH_GetHashLen+0x42>
8000732e:	c789                	beqz	a5,80007338 <HASH_GetHashLen+0x32>
80007330:	4705                	li	a4,1
80007332:	00e78563          	beq	a5,a4,8000733c <HASH_GetHashLen+0x36>
80007336:	a809                	j	80007348 <HASH_GetHashLen+0x42>
		case HASH_ALGO_SHA1:
			return 5;
80007338:	4795                	li	a5,5
8000733a:	a801                	j	8000734a <HASH_GetHashLen+0x44>
		case HASH_ALGO_MD5:
			return 4;
8000733c:	4791                	li	a5,4
8000733e:	a031                	j	8000734a <HASH_GetHashLen+0x44>
		case HASH_ALGO_SHA224:
			return 7;
80007340:	479d                	li	a5,7
80007342:	a021                	j	8000734a <HASH_GetHashLen+0x44>
		case HASH_ALGO_SHA256:
			return 8;
80007344:	47a1                	li	a5,8
80007346:	a011                	j	8000734a <HASH_GetHashLen+0x44>
		default:
			return 0;
80007348:	4781                	li	a5,0
	}
}
8000734a:	853e                	mv	a0,a5
8000734c:	40f2                	lw	ra,28(sp)
8000734e:	4462                	lw	s0,24(sp)
80007350:	6105                	addi	sp,sp,32
80007352:	8082                	ret

80007354 <HASH_GetHashBuffer>:

uint32_t HASH_GetHashBuffer(uint32_t* buffer)
{
80007354:	7179                	addi	sp,sp,-48
80007356:	d606                	sw	ra,44(sp)
80007358:	d422                	sw	s0,40(sp)
8000735a:	d226                	sw	s1,36(sp)
8000735c:	1800                	addi	s0,sp,48
8000735e:	fca42e23          	sw	a0,-36(s0)
	uint32_t idx = 0, len = 0;
80007362:	fe042623          	sw	zero,-20(s0)
80007366:	fe042423          	sw	zero,-24(s0)
	idx = len = HASH_GetHashLen(HASH_GetAlgo());
8000736a:	3799                	jal	800072b0 <HASH_GetAlgo>
8000736c:	87aa                	mv	a5,a0
8000736e:	853e                	mv	a0,a5
80007370:	3f59                	jal	80007306 <HASH_GetHashLen>
80007372:	fea42423          	sw	a0,-24(s0)
80007376:	fe842783          	lw	a5,-24(s0)
8000737a:	fef42623          	sw	a5,-20(s0)

	while(idx) {
8000737e:	a015                	j	800073a2 <HASH_GetHashBuffer+0x4e>
		buffer[--idx] = HASH_GetHash(idx);
80007380:	fec42783          	lw	a5,-20(s0)
80007384:	17fd                	addi	a5,a5,-1
80007386:	fef42623          	sw	a5,-20(s0)
8000738a:	fec42783          	lw	a5,-20(s0)
8000738e:	078a                	slli	a5,a5,0x2
80007390:	fdc42703          	lw	a4,-36(s0)
80007394:	00f704b3          	add	s1,a4,a5
80007398:	fec42503          	lw	a0,-20(s0)
8000739c:	37a1                	jal	800072e4 <HASH_GetHash>
8000739e:	87aa                	mv	a5,a0
800073a0:	c09c                	sw	a5,0(s1)
	while(idx) {
800073a2:	fec42783          	lw	a5,-20(s0)
800073a6:	ffe9                	bnez	a5,80007380 <HASH_GetHashBuffer+0x2c>
	}

	return len;
800073a8:	fe842783          	lw	a5,-24(s0)
}
800073ac:	853e                	mv	a0,a5
800073ae:	50b2                	lw	ra,44(sp)
800073b0:	5422                	lw	s0,40(sp)
800073b2:	5492                	lw	s1,36(sp)
800073b4:	6145                	addi	sp,sp,48
800073b6:	8082                	ret

800073b8 <HASH_SetHashBuffer>:

void HASH_SetHashBuffer(uint32_t* buffer, uint32_t len)
{
800073b8:	7179                	addi	sp,sp,-48
800073ba:	d606                	sw	ra,44(sp)
800073bc:	d422                	sw	s0,40(sp)
800073be:	1800                	addi	s0,sp,48
800073c0:	fca42e23          	sw	a0,-36(s0)
800073c4:	fcb42c23          	sw	a1,-40(s0)
	for (uint32_t i = 0 ; i < len; i++)
800073c8:	fe042623          	sw	zero,-20(s0)
800073cc:	a839                	j	800073ea <HASH_SetHashBuffer+0x32>
	{
		HASH_SetData(buffer[i]);
800073ce:	fec42783          	lw	a5,-20(s0)
800073d2:	078a                	slli	a5,a5,0x2
800073d4:	fdc42703          	lw	a4,-36(s0)
800073d8:	97ba                	add	a5,a5,a4
800073da:	439c                	lw	a5,0(a5)
800073dc:	853e                	mv	a0,a5
800073de:	35ed                	jal	800072c8 <HASH_SetData>
	for (uint32_t i = 0 ; i < len; i++)
800073e0:	fec42783          	lw	a5,-20(s0)
800073e4:	0785                	addi	a5,a5,1
800073e6:	fef42623          	sw	a5,-20(s0)
800073ea:	fec42703          	lw	a4,-20(s0)
800073ee:	fd842783          	lw	a5,-40(s0)
800073f2:	fcf76ee3          	bltu	a4,a5,800073ce <HASH_SetHashBuffer+0x16>
	}
}
800073f6:	0001                	nop
800073f8:	0001                	nop
800073fa:	50b2                	lw	ra,44(sp)
800073fc:	5422                	lw	s0,40(sp)
800073fe:	6145                	addi	sp,sp,48
80007400:	8082                	ret

80007402 <HASH_DeInit>:
/**
  * @brief   Устанавливает все регистры HASH значениями по умолчанию
  * @retval  void
  */
void HASH_DeInit()
{
80007402:	1141                	addi	sp,sp,-16
80007404:	c606                	sw	ra,12(sp)
80007406:	c422                	sw	s0,8(sp)
80007408:	0800                	addi	s0,sp,16
	HASH_InitCmd(DISABLE);
8000740a:	4501                	li	a0,0
8000740c:	3391                	jal	80007150 <HASH_InitCmd>

    RCU_AHBRstCmd(RCU_AHBRst_HASH, DISABLE);
8000740e:	4581                	li	a1,0
80007410:	4521                	li	a0,8
80007412:	3301                	jal	80007112 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(RCU_AHBRst_HASH, ENABLE);
80007414:	4585                	li	a1,1
80007416:	4521                	li	a0,8
80007418:	39ed                	jal	80007112 <RCU_AHBRstCmd>
}
8000741a:	0001                	nop
8000741c:	40b2                	lw	ra,12(sp)
8000741e:	4422                	lw	s0,8(sp)
80007420:	0141                	addi	sp,sp,16
80007422:	8082                	ret

80007424 <HASH_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref HASH_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void HASH_Init(HASH_Init_TypeDef* InitStruct)
{
80007424:	1101                	addi	sp,sp,-32
80007426:	ce06                	sw	ra,28(sp)
80007428:	cc22                	sw	s0,24(sp)
8000742a:	1000                	addi	s0,sp,32
8000742c:	fea42623          	sw	a0,-20(s0)
	RCU_AHBClkCmd(RCU_AHBClk_HASH, ENABLE);
80007430:	4585                	li	a1,1
80007432:	4521                	li	a0,8
80007434:	3145                	jal	800070d4 <RCU_AHBClkCmd>
    RCU_AHBRstCmd(RCU_AHBRst_HASH, ENABLE);
80007436:	4585                	li	a1,1
80007438:	4521                	li	a0,8
8000743a:	39e1                	jal	80007112 <RCU_AHBRstCmd>

	HASH_DMACmd(InitStruct->DMATransmition);
8000743c:	fec42783          	lw	a5,-20(s0)
80007440:	4b9c                	lw	a5,16(a5)
80007442:	853e                	mv	a0,a5
80007444:	33d5                	jal	80007228 <HASH_DMACmd>
	HASH_KeyLengthCmd(InitStruct->LongKey);
80007446:	fec42783          	lw	a5,-20(s0)
8000744a:	43dc                	lw	a5,4(a5)
8000744c:	853e                	mv	a0,a5
8000744e:	3b99                	jal	800071a4 <HASH_KeyLengthCmd>
	HASH_SetMultyDMATransmit(InitStruct->MultyDMATransmition);
80007450:	fec42783          	lw	a5,-20(s0)
80007454:	4bdc                	lw	a5,20(a5)
80007456:	853e                	mv	a0,a5
80007458:	3bf5                	jal	80007254 <HASH_SetMultyDMATransmit>
	HASH_SetAlgo(InitStruct->Algo);
8000745a:	fec42783          	lw	a5,-20(s0)
8000745e:	4f9c                	lw	a5,24(a5)
80007460:	853e                	mv	a0,a5
80007462:	3d39                	jal	80007280 <HASH_SetAlgo>
	HASH_DataTypeConfig(InitStruct->DataType);
80007464:	fec42783          	lw	a5,-20(s0)
80007468:	47dc                	lw	a5,12(a5)
8000746a:	853e                	mv	a0,a5
8000746c:	3b41                	jal	800071fc <HASH_DataTypeConfig>
	HASH_ModeCmd(InitStruct->Mode);
8000746e:	fec42783          	lw	a5,-20(s0)
80007472:	439c                	lw	a5,0(a5)
80007474:	853e                	mv	a0,a5
80007476:	3309                	jal	80007178 <HASH_ModeCmd>
	HASH_SameKeyCmd(InitStruct->SameKey);
80007478:	fec42783          	lw	a5,-20(s0)
8000747c:	479c                	lw	a5,8(a5)
8000747e:	853e                	mv	a0,a5
80007480:	3b81                	jal	800071d0 <HASH_SameKeyCmd>

	HASH_InitCmd(ENABLE);
80007482:	4505                	li	a0,1
80007484:	31f1                	jal	80007150 <HASH_InitCmd>
}
80007486:	0001                	nop
80007488:	40f2                	lw	ra,28(sp)
8000748a:	4462                	lw	s0,24(sp)
8000748c:	6105                	addi	sp,sp,32
8000748e:	8082                	ret

80007490 <HASH_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref HASH_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void HASH_StructInit(HASH_Init_TypeDef* InitStruct)
{
80007490:	1101                	addi	sp,sp,-32
80007492:	ce22                	sw	s0,28(sp)
80007494:	1000                	addi	s0,sp,32
80007496:	fea42623          	sw	a0,-20(s0)
	InitStruct->DMATransmition = 0x0;
8000749a:	fec42783          	lw	a5,-20(s0)
8000749e:	0007a823          	sw	zero,16(a5)
	InitStruct->LongKey = HASH_LKEY_ShortKey;
800074a2:	fec42783          	lw	a5,-20(s0)
800074a6:	0007a223          	sw	zero,4(a5)
	InitStruct->MultyDMATransmition = 0x0;
800074aa:	fec42783          	lw	a5,-20(s0)
800074ae:	0007aa23          	sw	zero,20(a5)
	InitStruct->Algo = HASH_ALGO_SHA1;
800074b2:	fec42783          	lw	a5,-20(s0)
800074b6:	0007ac23          	sw	zero,24(a5)
	InitStruct->DataType = HASH_DATATYPE_Word;
800074ba:	fec42783          	lw	a5,-20(s0)
800074be:	0007a623          	sw	zero,12(a5)
	InitStruct->Mode = HASH_MODE_Hash;
800074c2:	fec42783          	lw	a5,-20(s0)
800074c6:	0007a023          	sw	zero,0(a5)
	InitStruct->SameKey = 0x0;
800074ca:	fec42783          	lw	a5,-20(s0)
800074ce:	0007a423          	sw	zero,8(a5)
}
800074d2:	0001                	nop
800074d4:	4472                	lw	s0,28(sp)
800074d6:	6105                	addi	sp,sp,32
800074d8:	8082                	ret

800074da <I2C_FSDivLowConfig>:
  *             смещение 4 и, в итоге, в регистре окажется значение 6.
  * @param      DivVal  Значение (биты [6:0])
  * @retval     void
  */
__STATIC_INLINE void I2C_FSDivLowConfig(uint32_t DivVal)
{
800074da:	1101                	addi	sp,sp,-32
800074dc:	ce22                	sw	s0,28(sp)
800074de:	1000                	addi	s0,sp,32
800074e0:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_FS_DIV_LOW_VAL(DivVal));

    WRITE_REG(I2C->CTL1_bit.SCLFRQ, DivVal);
800074e4:	300057b7          	lui	a5,0x30005
800074e8:	fec42703          	lw	a4,-20(s0)
800074ec:	07f77713          	andi	a4,a4,127
800074f0:	0ff77713          	zext.b	a4,a4
800074f4:	0706                	slli	a4,a4,0x1
800074f6:	0147c683          	lbu	a3,20(a5) # 30005014 <STACK_SIZE+0x30004814>
800074fa:	8a85                	andi	a3,a3,1
800074fc:	8f55                	or	a4,a4,a3
800074fe:	00e78a23          	sb	a4,20(a5)
}
80007502:	0001                	nop
80007504:	4472                	lw	s0,28(sp)
80007506:	6105                	addi	sp,sp,32
80007508:	8082                	ret

8000750a <I2C_FSDivHighConfig>:
  * @brief   Установка старшей части делителя частоты в режиме FS мастера
  * @param   DivVal  Значение (биты [7:0])
  * @retval  void
  */
__STATIC_INLINE void I2C_FSDivHighConfig(uint32_t DivVal)
{
8000750a:	1101                	addi	sp,sp,-32
8000750c:	ce22                	sw	s0,28(sp)
8000750e:	1000                	addi	s0,sp,32
80007510:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_FS_DIV_HIGH_VAL(DivVal));

    WRITE_REG(I2C->CTL3_bit.SCLFRQ, DivVal);
80007514:	300057b7          	lui	a5,0x30005
80007518:	fec42703          	lw	a4,-20(s0)
8000751c:	0ff77713          	zext.b	a4,a4
80007520:	02e78023          	sb	a4,32(a5) # 30005020 <STACK_SIZE+0x30004820>
}
80007524:	0001                	nop
80007526:	4472                	lw	s0,28(sp)
80007528:	6105                	addi	sp,sp,32
8000752a:	8082                	ret

8000752c <I2C_HSDivLowConfig>:
  *             смещение 2 и, в итоге, в регистре окажется значение 3.
  * @param      DivVal  Значение (биты [3:0])
  * @retval     void
  */
__STATIC_INLINE void I2C_HSDivLowConfig(uint32_t DivVal)
{
8000752c:	1101                	addi	sp,sp,-32
8000752e:	ce22                	sw	s0,28(sp)
80007530:	1000                	addi	s0,sp,32
80007532:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_HS_DIV_LOW_VAL(DivVal));

    WRITE_REG(I2C->CTL2_bit.HSDIV, DivVal);
80007536:	300057b7          	lui	a5,0x30005
8000753a:	fec42703          	lw	a4,-20(s0)
8000753e:	8b3d                	andi	a4,a4,15
80007540:	0ff77713          	zext.b	a4,a4
80007544:	0712                	slli	a4,a4,0x4
80007546:	01c7c683          	lbu	a3,28(a5) # 3000501c <STACK_SIZE+0x3000481c>
8000754a:	8abd                	andi	a3,a3,15
8000754c:	8f55                	or	a4,a4,a3
8000754e:	00e78e23          	sb	a4,28(a5)
}
80007552:	0001                	nop
80007554:	4472                	lw	s0,28(sp)
80007556:	6105                	addi	sp,sp,32
80007558:	8082                	ret

8000755a <I2C_HSDivHighConfig>:
  * @brief   Установка старшей части делителя частоты в режиме HS мастера
  * @param   DivVal  Значение (биты [7:0])
  * @retval  void
  */
__STATIC_INLINE void I2C_HSDivHighConfig(uint32_t DivVal)
{
8000755a:	1101                	addi	sp,sp,-32
8000755c:	ce22                	sw	s0,28(sp)
8000755e:	1000                	addi	s0,sp,32
80007560:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_I2C_HS_DIV_HIGH_VAL(DivVal));

    WRITE_REG(I2C->CTL4_bit.HSDIV, DivVal);
80007564:	300057b7          	lui	a5,0x30005
80007568:	fec42703          	lw	a4,-20(s0)
8000756c:	0ff77713          	zext.b	a4,a4
80007570:	02e78223          	sb	a4,36(a5) # 30005024 <STACK_SIZE+0x30004824>
}
80007574:	0001                	nop
80007576:	4472                	lw	s0,28(sp)
80007578:	6105                	addi	sp,sp,32
8000757a:	8082                	ret

8000757c <I2C_FSFreqConfig>:
  * @param   FSFreq  Желаемое значение частоты в ГЦ
  * @param   I2CFreq  Значение частоты  тактового сигнала I2C в ГЦ
  * @retval  void
  */
void I2C_FSFreqConfig(uint32_t FSFreq, uint32_t I2CFreq)
{
8000757c:	7179                	addi	sp,sp,-48
8000757e:	d606                	sw	ra,44(sp)
80007580:	d422                	sw	s0,40(sp)
80007582:	1800                	addi	s0,sp,48
80007584:	fca42e23          	sw	a0,-36(s0)
80007588:	fcb42c23          	sw	a1,-40(s0)
    uint32_t freq_calc = I2CFreq / (4 * FSFreq);
8000758c:	fdc42783          	lw	a5,-36(s0)
80007590:	078a                	slli	a5,a5,0x2
80007592:	fd842703          	lw	a4,-40(s0)
80007596:	02f757b3          	divu	a5,a4,a5
8000759a:	fef42623          	sw	a5,-20(s0)

    I2C_FSDivLowConfig(freq_calc & 0x7F);
8000759e:	fec42783          	lw	a5,-20(s0)
800075a2:	07f7f793          	andi	a5,a5,127
800075a6:	853e                	mv	a0,a5
800075a8:	3f0d                	jal	800074da <I2C_FSDivLowConfig>
    I2C_FSDivHighConfig(freq_calc >> 7);
800075aa:	fec42783          	lw	a5,-20(s0)
800075ae:	839d                	srli	a5,a5,0x7
800075b0:	853e                	mv	a0,a5
800075b2:	3fa1                	jal	8000750a <I2C_FSDivHighConfig>
}
800075b4:	0001                	nop
800075b6:	50b2                	lw	ra,44(sp)
800075b8:	5422                	lw	s0,40(sp)
800075ba:	6145                	addi	sp,sp,48
800075bc:	8082                	ret

800075be <I2C_HSFreqConfig>:
  * @param   HSFreq  Желаемое значение частоты в ГЦ
  * @param   I2CFreq  Значение частоты  тактового сигнала I2C в ГЦ
  * @retval  void
  */
void I2C_HSFreqConfig(uint32_t HSFreq, uint32_t I2CFreq)
{
800075be:	7179                	addi	sp,sp,-48
800075c0:	d606                	sw	ra,44(sp)
800075c2:	d422                	sw	s0,40(sp)
800075c4:	1800                	addi	s0,sp,48
800075c6:	fca42e23          	sw	a0,-36(s0)
800075ca:	fcb42c23          	sw	a1,-40(s0)
    uint32_t freq_calc = I2CFreq / (3 * HSFreq);
800075ce:	fdc42703          	lw	a4,-36(s0)
800075d2:	87ba                	mv	a5,a4
800075d4:	0786                	slli	a5,a5,0x1
800075d6:	97ba                	add	a5,a5,a4
800075d8:	fd842703          	lw	a4,-40(s0)
800075dc:	02f757b3          	divu	a5,a4,a5
800075e0:	fef42623          	sw	a5,-20(s0)

    I2C_HSDivLowConfig(freq_calc & 0x0F);
800075e4:	fec42783          	lw	a5,-20(s0)
800075e8:	8bbd                	andi	a5,a5,15
800075ea:	853e                	mv	a0,a5
800075ec:	3781                	jal	8000752c <I2C_HSDivLowConfig>
    I2C_HSDivHighConfig(freq_calc >> 4);
800075ee:	fec42783          	lw	a5,-20(s0)
800075f2:	8391                	srli	a5,a5,0x4
800075f4:	853e                	mv	a0,a5
800075f6:	3795                	jal	8000755a <I2C_HSDivHighConfig>
}
800075f8:	0001                	nop
800075fa:	50b2                	lw	ra,44(sp)
800075fc:	5422                	lw	s0,40(sp)
800075fe:	6145                	addi	sp,sp,48
80007600:	8082                	ret

80007602 <RCU_AHBRstCmd>:
{
80007602:	1101                	addi	sp,sp,-32
80007604:	ce22                	sw	s0,28(sp)
80007606:	1000                	addi	s0,sp,32
80007608:	fea42623          	sw	a0,-20(s0)
8000760c:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAHB, AHBRst, State ? AHBRst : 0);
80007610:	3000e7b7          	lui	a5,0x3000e
80007614:	4b98                	lw	a4,16(a5)
80007616:	fec42783          	lw	a5,-20(s0)
8000761a:	fff7c793          	not	a5,a5
8000761e:	00f776b3          	and	a3,a4,a5
80007622:	fe842783          	lw	a5,-24(s0)
80007626:	c781                	beqz	a5,8000762e <RCU_AHBRstCmd+0x2c>
80007628:	fec42783          	lw	a5,-20(s0)
8000762c:	a011                	j	80007630 <RCU_AHBRstCmd+0x2e>
8000762e:	4781                	li	a5,0
80007630:	3000e737          	lui	a4,0x3000e
80007634:	8fd5                	or	a5,a5,a3
80007636:	cb1c                	sw	a5,16(a4)
}
80007638:	0001                	nop
8000763a:	4472                	lw	s0,28(sp)
8000763c:	6105                	addi	sp,sp,32
8000763e:	8082                	ret

80007640 <QSPI_ModeConfig>:
  * @brief   Выбор режима работы
  * @param   mode Режим работы
  * @retval  void
  */
__STATIC_INLINE void QSPI_ModeConfig(QSPI_Mode_TypeDef mode)
{
80007640:	1101                	addi	sp,sp,-32
80007642:	ce22                	sw	s0,28(sp)
80007644:	1000                	addi	s0,sp,32
80007646:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_QSPI_MODE(mode));

    WRITE_REG(QSPI->DCR_bit.FMOD, mode);
8000764a:	200407b7          	lui	a5,0x20040
8000764e:	fec42703          	lw	a4,-20(s0)
80007652:	8b1d                	andi	a4,a4,7
80007654:	0ff77713          	zext.b	a4,a4
80007658:	8b1d                	andi	a4,a4,7
8000765a:	0742                	slli	a4,a4,0x10
8000765c:	43d0                	lw	a2,4(a5)
8000765e:	fff906b7          	lui	a3,0xfff90
80007662:	16fd                	addi	a3,a3,-1 # fff8ffff <__data_source_start+0x7ff871ab>
80007664:	8ef1                	and	a3,a3,a2
80007666:	8f55                	or	a4,a4,a3
80007668:	c3d8                	sw	a4,4(a5)
}
8000766a:	0001                	nop
8000766c:	4472                	lw	s0,28(sp)
8000766e:	6105                	addi	sp,sp,32
80007670:	8082                	ret

80007672 <QSPI_SCKDivConfig>:
  * @param   div	 Основной делитель.
  *                  Параметр принимает любое значение из диапазона 0-255.
  * @retval  void
  */
__STATIC_INLINE void QSPI_SCKDivConfig(uint32_t div)
{
80007672:	1101                	addi	sp,sp,-32
80007674:	ce22                	sw	s0,28(sp)
80007676:	1000                	addi	s0,sp,32
80007678:	fea42623          	sw	a0,-20(s0)
    assert_param(IS_QSPI_CDIV(div));

    WRITE_REG(QSPI->DCR_bit.CDIV, div);
8000767c:	200407b7          	lui	a5,0x20040
80007680:	fec42703          	lw	a4,-20(s0)
80007684:	0ff77713          	zext.b	a4,a4
80007688:	00e782a3          	sb	a4,5(a5) # 20040005 <STACK_SIZE+0x2003f805>
}
8000768c:	0001                	nop
8000768e:	4472                	lw	s0,28(sp)
80007690:	6105                	addi	sp,sp,32
80007692:	8082                	ret

80007694 <QSPI_SetWordLength>:
  * @brief   Установка размера слова данных
  * @param   length длина слова, значение от 1 до 32
  * @retval  void
  */
__STATIC_INLINE void QSPI_SetWordLength(uint32_t length)
{
80007694:	1101                	addi	sp,sp,-32
80007696:	ce22                	sw	s0,28(sp)
80007698:	1000                	addi	s0,sp,32
8000769a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_WORD(length));

	WRITE_REG(QSPI->TCR_bit.LEN, length);
8000769e:	200407b7          	lui	a5,0x20040
800076a2:	fec42703          	lw	a4,-20(s0)
800076a6:	03f77713          	andi	a4,a4,63
800076aa:	0ff77713          	zext.b	a4,a4
800076ae:	03f77713          	andi	a4,a4,63
800076b2:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
800076b6:	fc06f693          	andi	a3,a3,-64
800076ba:	8f55                	or	a4,a4,a3
800076bc:	00e79623          	sh	a4,12(a5)
}
800076c0:	0001                	nop
800076c2:	4472                	lw	s0,28(sp)
800076c4:	6105                	addi	sp,sp,32
800076c6:	8082                	ret

800076c8 <QSPI_SPIDataRateConfig>:
  * @brief   Установка скорости передачи данных
  * @param   dataRate скорость передачи данных типа @ref QSPI_DR_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_SPIDataRateConfig(QSPI_SPI_DataRate_TypeDef dataRate)
{
800076c8:	1101                	addi	sp,sp,-32
800076ca:	ce22                	sw	s0,28(sp)
800076cc:	1000                	addi	s0,sp,32
800076ce:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_SPI_DR(dataRate));

	WRITE_REG(QSPI->TCR_bit.DDR, dataRate);
800076d2:	200407b7          	lui	a5,0x20040
800076d6:	fec42703          	lw	a4,-20(s0)
800076da:	8b05                	andi	a4,a4,1
800076dc:	0ff77713          	zext.b	a4,a4
800076e0:	8b05                	andi	a4,a4,1
800076e2:	071e                	slli	a4,a4,0x7
800076e4:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
800076e8:	f7f6f693          	andi	a3,a3,-129
800076ec:	8f55                	or	a4,a4,a3
800076ee:	00e79623          	sh	a4,12(a5)
}
800076f2:	0001                	nop
800076f4:	4472                	lw	s0,28(sp)
800076f6:	6105                	addi	sp,sp,32
800076f8:	8082                	ret

800076fa <QSPI_TxCmd>:
  * @brief   Разрешение передачи
  * @param   state Флаг разрешения
  * @retval  void
  */
__STATIC_INLINE void QSPI_TxCmd(FunctionalState state)
{
800076fa:	1101                	addi	sp,sp,-32
800076fc:	ce22                	sw	s0,28(sp)
800076fe:	1000                	addi	s0,sp,32
80007700:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	WRITE_REG(QSPI->TCR_bit.TXE, state);
80007704:	200407b7          	lui	a5,0x20040
80007708:	fec42703          	lw	a4,-20(s0)
8000770c:	8b05                	andi	a4,a4,1
8000770e:	0ff77713          	zext.b	a4,a4
80007712:	8b05                	andi	a4,a4,1
80007714:	0722                	slli	a4,a4,0x8
80007716:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
8000771a:	eff6f693          	andi	a3,a3,-257
8000771e:	8f55                	or	a4,a4,a3
80007720:	00e79623          	sh	a4,12(a5)
}
80007724:	0001                	nop
80007726:	4472                	lw	s0,28(sp)
80007728:	6105                	addi	sp,sp,32
8000772a:	8082                	ret

8000772c <QSPI_RxCmd>:
  * @brief   Разрешение приема
  * @param   state Флаг разрешения
  * @retval  void
  */
__STATIC_INLINE void QSPI_RxCmd(FunctionalState state)
{
8000772c:	1101                	addi	sp,sp,-32
8000772e:	ce22                	sw	s0,28(sp)
80007730:	1000                	addi	s0,sp,32
80007732:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	WRITE_REG(QSPI->TCR_bit.RXE, state);
80007736:	200407b7          	lui	a5,0x20040
8000773a:	fec42703          	lw	a4,-20(s0)
8000773e:	8b05                	andi	a4,a4,1
80007740:	0ff77713          	zext.b	a4,a4
80007744:	8b05                	andi	a4,a4,1
80007746:	0726                	slli	a4,a4,0x9
80007748:	00c7d683          	lhu	a3,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
8000774c:	dff6f693          	andi	a3,a3,-513
80007750:	8f55                	or	a4,a4,a3
80007752:	00e79623          	sh	a4,12(a5)
}
80007756:	0001                	nop
80007758:	4472                	lw	s0,28(sp)
8000775a:	6105                	addi	sp,sp,32
8000775c:	8082                	ret

8000775e <QSPI_SPITransactionModeConfig>:
  * @brief   Выбор количества линий данных
  * @param   mode Количество линий типа @ref QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_SPITransactionModeConfig(QSPI_SPI_IOMode_TypeDef mode)
{
8000775e:	1101                	addi	sp,sp,-32
80007760:	ce22                	sw	s0,28(sp)
80007762:	1000                	addi	s0,sp,32
80007764:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_SPI_IOMODE(mode));

	WRITE_REG(QSPI->TCR_bit.IOM, mode);
80007768:	200407b7          	lui	a5,0x20040
8000776c:	fec42703          	lw	a4,-20(s0)
80007770:	8b0d                	andi	a4,a4,3
80007772:	0ff77713          	zext.b	a4,a4
80007776:	8b0d                	andi	a4,a4,3
80007778:	00a71613          	slli	a2,a4,0xa
8000777c:	00c7d703          	lhu	a4,12(a5) # 2004000c <STACK_SIZE+0x2003f80c>
80007780:	86ba                	mv	a3,a4
80007782:	777d                	lui	a4,0xfffff
80007784:	3ff70713          	addi	a4,a4,1023 # fffff3ff <__data_source_start+0x7fff65ab>
80007788:	8f75                	and	a4,a4,a3
8000778a:	86ba                	mv	a3,a4
8000778c:	8732                	mv	a4,a2
8000778e:	8f55                	or	a4,a4,a3
80007790:	00e79623          	sh	a4,12(a5)
}
80007794:	0001                	nop
80007796:	4472                	lw	s0,28(sp)
80007798:	6105                	addi	sp,sp,32
8000779a:	8082                	ret

8000779c <QSPI_InstructionConfig>:
  * @brief   Установка кода инструкции для внешнего устройства
  * @param   instruction Код инструкции, отправляемый во внешнее устройство по QuadSPI
  * @retval  void
  */
__STATIC_INLINE void QSPI_InstructionConfig(uint8_t instruction)
{
8000779c:	1101                	addi	sp,sp,-32
8000779e:	ce22                	sw	s0,28(sp)
800077a0:	1000                	addi	s0,sp,32
800077a2:	87aa                	mv	a5,a0
800077a4:	fef407a3          	sb	a5,-17(s0)
	WRITE_REG(QSPI->QCC_bit.INST, instruction);
800077a8:	200407b7          	lui	a5,0x20040
800077ac:	fef44703          	lbu	a4,-17(s0)
800077b0:	00e78c23          	sb	a4,24(a5) # 20040018 <STACK_SIZE+0x2003f818>
}
800077b4:	0001                	nop
800077b6:	4472                	lw	s0,28(sp)
800077b8:	6105                	addi	sp,sp,32
800077ba:	8082                	ret

800077bc <QSPI_InstructionModeConfig>:
  * @brief   Установка режима фазы инструкции для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_InstructionModeConfig(QSPI_IOMode_TypeDef mode)
{
800077bc:	1101                	addi	sp,sp,-32
800077be:	ce22                	sw	s0,28(sp)
800077c0:	1000                	addi	s0,sp,32
800077c2:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.IMOD, mode);
800077c6:	200407b7          	lui	a5,0x20040
800077ca:	fec42703          	lw	a4,-20(s0)
800077ce:	8b0d                	andi	a4,a4,3
800077d0:	0ff77713          	zext.b	a4,a4
800077d4:	8b0d                	andi	a4,a4,3
800077d6:	0722                	slli	a4,a4,0x8
800077d8:	4f94                	lw	a3,24(a5)
800077da:	cff6f693          	andi	a3,a3,-769
800077de:	8f55                	or	a4,a4,a3
800077e0:	cf98                	sw	a4,24(a5)
}
800077e2:	0001                	nop
800077e4:	4472                	lw	s0,28(sp)
800077e6:	6105                	addi	sp,sp,32
800077e8:	8082                	ret

800077ea <QSPI_AddressModeConfig>:
  * @brief   Установка режима фазы адреса для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AddressModeConfig(QSPI_IOMode_TypeDef mode)
{
800077ea:	1101                	addi	sp,sp,-32
800077ec:	ce22                	sw	s0,28(sp)
800077ee:	1000                	addi	s0,sp,32
800077f0:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.ADMOD, mode);
800077f4:	200407b7          	lui	a5,0x20040
800077f8:	fec42703          	lw	a4,-20(s0)
800077fc:	8b0d                	andi	a4,a4,3
800077fe:	0ff77713          	zext.b	a4,a4
80007802:	8b0d                	andi	a4,a4,3
80007804:	072a                	slli	a4,a4,0xa
80007806:	4f90                	lw	a2,24(a5)
80007808:	76fd                	lui	a3,0xfffff
8000780a:	3ff68693          	addi	a3,a3,1023 # fffff3ff <__data_source_start+0x7fff65ab>
8000780e:	8ef1                	and	a3,a3,a2
80007810:	8f55                	or	a4,a4,a3
80007812:	cf98                	sw	a4,24(a5)
}
80007814:	0001                	nop
80007816:	4472                	lw	s0,28(sp)
80007818:	6105                	addi	sp,sp,32
8000781a:	8082                	ret

8000781c <QSPI_AddressSizeConfig>:
  * @brief   Установка размера адреса для QuadSPI
  * @param   size размер типа @ref QSPI_QSPI_DataSize_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AddressSizeConfig(QSPI_DataSize_TypeDef size)
{
8000781c:	1101                	addi	sp,sp,-32
8000781e:	ce22                	sw	s0,28(sp)
80007820:	1000                	addi	s0,sp,32
80007822:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATASIZE(size));

	WRITE_REG(QSPI->QCC_bit.ADSIZ, size);
80007826:	200407b7          	lui	a5,0x20040
8000782a:	fec42703          	lw	a4,-20(s0)
8000782e:	8b0d                	andi	a4,a4,3
80007830:	0ff77713          	zext.b	a4,a4
80007834:	8b0d                	andi	a4,a4,3
80007836:	0732                	slli	a4,a4,0xc
80007838:	4f90                	lw	a2,24(a5)
8000783a:	76f5                	lui	a3,0xffffd
8000783c:	16fd                	addi	a3,a3,-1 # ffffcfff <__data_source_start+0x7fff41ab>
8000783e:	8ef1                	and	a3,a3,a2
80007840:	8f55                	or	a4,a4,a3
80007842:	cf98                	sw	a4,24(a5)
}
80007844:	0001                	nop
80007846:	4472                	lw	s0,28(sp)
80007848:	6105                	addi	sp,sp,32
8000784a:	8082                	ret

8000784c <QSPI_AdditionalModeConfig>:
  * @brief   Установка режима фазы дополнительных данных для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AdditionalModeConfig(QSPI_IOMode_TypeDef mode)
{
8000784c:	1101                	addi	sp,sp,-32
8000784e:	ce22                	sw	s0,28(sp)
80007850:	1000                	addi	s0,sp,32
80007852:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.ABMOD, mode);
80007856:	200407b7          	lui	a5,0x20040
8000785a:	fec42703          	lw	a4,-20(s0)
8000785e:	8b0d                	andi	a4,a4,3
80007860:	0ff77713          	zext.b	a4,a4
80007864:	8b0d                	andi	a4,a4,3
80007866:	073a                	slli	a4,a4,0xe
80007868:	4f90                	lw	a2,24(a5)
8000786a:	76d1                	lui	a3,0xffff4
8000786c:	16fd                	addi	a3,a3,-1 # ffff3fff <__data_source_start+0x7ffeb1ab>
8000786e:	8ef1                	and	a3,a3,a2
80007870:	8f55                	or	a4,a4,a3
80007872:	cf98                	sw	a4,24(a5)
}
80007874:	0001                	nop
80007876:	4472                	lw	s0,28(sp)
80007878:	6105                	addi	sp,sp,32
8000787a:	8082                	ret

8000787c <QSPI_AdditionalSizeConfig>:
  * @brief   Установка размера дополнительных данных для QuadSPI
  * @param   size размер типа @ref QSPI_QSPI_DataSize_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_AdditionalSizeConfig(QSPI_DataSize_TypeDef size)
{
8000787c:	1101                	addi	sp,sp,-32
8000787e:	ce22                	sw	s0,28(sp)
80007880:	1000                	addi	s0,sp,32
80007882:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATASIZE(size));

	WRITE_REG(QSPI->QCC_bit.ABSIZ, size);
80007886:	200407b7          	lui	a5,0x20040
8000788a:	fec42703          	lw	a4,-20(s0)
8000788e:	8b0d                	andi	a4,a4,3
80007890:	0ff77713          	zext.b	a4,a4
80007894:	8b0d                	andi	a4,a4,3
80007896:	0742                	slli	a4,a4,0x10
80007898:	4f90                	lw	a2,24(a5)
8000789a:	fffd06b7          	lui	a3,0xfffd0
8000789e:	16fd                	addi	a3,a3,-1 # fffcffff <__data_source_start+0x7ffc71ab>
800078a0:	8ef1                	and	a3,a3,a2
800078a2:	8f55                	or	a4,a4,a3
800078a4:	cf98                	sw	a4,24(a5)
}
800078a6:	0001                	nop
800078a8:	4472                	lw	s0,28(sp)
800078aa:	6105                	addi	sp,sp,32
800078ac:	8082                	ret

800078ae <QSPI_WaitCyclesConfig>:
  * @brief   Установка количества циклов ожидания для QuadSPI
  * @param   waitCycles количество циклов ожидания принимает значения от 0 до 31
  * @retval  void
  */
__STATIC_INLINE void QSPI_WaitCyclesConfig(uint32_t waitCycles)
{
800078ae:	1101                	addi	sp,sp,-32
800078b0:	ce22                	sw	s0,28(sp)
800078b2:	1000                	addi	s0,sp,32
800078b4:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DCYCS(waitCycles));

	WRITE_REG(QSPI->QCC_bit.DCYCS, waitCycles);
800078b8:	200407b7          	lui	a5,0x20040
800078bc:	fec42703          	lw	a4,-20(s0)
800078c0:	8b7d                	andi	a4,a4,31
800078c2:	0ff77713          	zext.b	a4,a4
800078c6:	8b7d                	andi	a4,a4,31
800078c8:	074a                	slli	a4,a4,0x12
800078ca:	4f90                	lw	a2,24(a5)
800078cc:	ff8406b7          	lui	a3,0xff840
800078d0:	16fd                	addi	a3,a3,-1 # ff83ffff <__data_source_start+0x7f8371ab>
800078d2:	8ef1                	and	a3,a3,a2
800078d4:	8f55                	or	a4,a4,a3
800078d6:	cf98                	sw	a4,24(a5)
}
800078d8:	0001                	nop
800078da:	4472                	lw	s0,28(sp)
800078dc:	6105                	addi	sp,sp,32
800078de:	8082                	ret

800078e0 <QSPI_DataModeConfig>:
  * @brief   Установка режима фазы данных для QuadSPI
  * @param   mode режим передачи типа @ref QSPI_QSPI_IOMode_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataModeConfig(QSPI_IOMode_TypeDef mode)
{
800078e0:	1101                	addi	sp,sp,-32
800078e2:	ce22                	sw	s0,28(sp)
800078e4:	1000                	addi	s0,sp,32
800078e6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_IOMODE(mode));

	WRITE_REG(QSPI->QCC_bit.DMOD, mode);
800078ea:	200407b7          	lui	a5,0x20040
800078ee:	fec42703          	lw	a4,-20(s0)
800078f2:	8b0d                	andi	a4,a4,3
800078f4:	0ff77713          	zext.b	a4,a4
800078f8:	8b0d                	andi	a4,a4,3
800078fa:	0762                	slli	a4,a4,0x18
800078fc:	4f90                	lw	a2,24(a5)
800078fe:	fd0006b7          	lui	a3,0xfd000
80007902:	16fd                	addi	a3,a3,-1 # fcffffff <__data_source_start+0x7cff71ab>
80007904:	8ef1                	and	a3,a3,a2
80007906:	8f55                	or	a4,a4,a3
80007908:	cf98                	sw	a4,24(a5)
}
8000790a:	0001                	nop
8000790c:	4472                	lw	s0,28(sp)
8000790e:	6105                	addi	sp,sp,32
80007910:	8082                	ret

80007912 <QSPI_DataDirectionConfig>:
  * @brief   Установка направления передачи данных для QuadSPI
  * @param   dir напавление передачи данных типа @ref QSPI_QSPI_Direction_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataDirectionConfig(QSPI_Direction_TypeDef dir)
{
80007912:	1101                	addi	sp,sp,-32
80007914:	ce22                	sw	s0,28(sp)
80007916:	1000                	addi	s0,sp,32
80007918:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DIR(dir));

	WRITE_REG(QSPI->QCC_bit.DIOD, dir);
8000791c:	200407b7          	lui	a5,0x20040
80007920:	fec42703          	lw	a4,-20(s0)
80007924:	8b0d                	andi	a4,a4,3
80007926:	0ff77713          	zext.b	a4,a4
8000792a:	8b0d                	andi	a4,a4,3
8000792c:	076a                	slli	a4,a4,0x1a
8000792e:	4f90                	lw	a2,24(a5)
80007930:	f40006b7          	lui	a3,0xf4000
80007934:	16fd                	addi	a3,a3,-1 # f3ffffff <__data_source_start+0x73ff71ab>
80007936:	8ef1                	and	a3,a3,a2
80007938:	8f55                	or	a4,a4,a3
8000793a:	cf98                	sw	a4,24(a5)
}
8000793c:	0001                	nop
8000793e:	4472                	lw	s0,28(sp)
80007940:	6105                	addi	sp,sp,32
80007942:	8082                	ret

80007944 <QSPI_DataRateConfig>:
  * @brief   Установка скорости передачи данных
  * @param   dataRate скорость передачи данных типа @ref QSPI_QSPI_DataRate_TypeDef
  * @retval  void
  */
__STATIC_INLINE void QSPI_DataRateConfig(QSPI_DataRate_TypeDef dataRate)
{
80007944:	1101                	addi	sp,sp,-32
80007946:	ce22                	sw	s0,28(sp)
80007948:	1000                	addi	s0,sp,32
8000794a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_QSPI_DATARATE(dataRate));

	WRITE_REG(QSPI->QCC_bit.DDRM, dataRate);
8000794e:	200407b7          	lui	a5,0x20040
80007952:	fec42703          	lw	a4,-20(s0)
80007956:	8b05                	andi	a4,a4,1
80007958:	0ff77713          	zext.b	a4,a4
8000795c:	077e                	slli	a4,a4,0x1f
8000795e:	4f90                	lw	a2,24(a5)
80007960:	800006b7          	lui	a3,0x80000
80007964:	fff6c693          	not	a3,a3
80007968:	8ef1                	and	a3,a3,a2
8000796a:	8f55                	or	a4,a4,a3
8000796c:	cf98                	sw	a4,24(a5)
}
8000796e:	0001                	nop
80007970:	4472                	lw	s0,28(sp)
80007972:	6105                	addi	sp,sp,32
80007974:	8082                	ret

80007976 <QSPI_DeInit>:
/**
  * @brief   Устанавливает все регистры QSPI значениями по умолчанию
  * @retval  void
  */
void QSPI_DeInit()
{
80007976:	1141                	addi	sp,sp,-16
80007978:	c606                	sw	ra,12(sp)
8000797a:	c422                	sw	s0,8(sp)
8000797c:	0800                	addi	s0,sp,16
	RCU_AHBRstCmd(RCU_AHBClk_QSPI, DISABLE);
8000797e:	4581                	li	a1,0
80007980:	4541                	li	a0,16
80007982:	3141                	jal	80007602 <RCU_AHBRstCmd>
    RCU_AHBRstCmd(RCU_AHBClk_QSPI, ENABLE);
80007984:	4585                	li	a1,1
80007986:	4541                	li	a0,16
80007988:	39ad                	jal	80007602 <RCU_AHBRstCmd>
}
8000798a:	0001                	nop
8000798c:	40b2                	lw	ra,12(sp)
8000798e:	4422                	lw	s0,8(sp)
80007990:	0141                	addi	sp,sp,16
80007992:	8082                	ret

80007994 <QSPI_SPI_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_SPI_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void QSPI_SPI_Init(QSPI_SPI_Init_TypeDef* InitStruct)
{
80007994:	1101                	addi	sp,sp,-32
80007996:	ce06                	sw	ra,28(sp)
80007998:	cc22                	sw	s0,24(sp)
8000799a:	1000                	addi	s0,sp,32
8000799c:	fea42623          	sw	a0,-20(s0)
	QSPI_ModeConfig(QSPI_Mode_SPI);
800079a0:	4501                	li	a0,0
800079a2:	3979                	jal	80007640 <QSPI_ModeConfig>
	QSPI_SPITransactionModeConfig(InitStruct->IOMode);
800079a4:	fec42783          	lw	a5,-20(s0)
800079a8:	439c                	lw	a5,0(a5)
800079aa:	853e                	mv	a0,a5
800079ac:	3b4d                	jal	8000775e <QSPI_SPITransactionModeConfig>
	QSPI_SPIDataRateConfig(InitStruct->dataRate);
800079ae:	fec42783          	lw	a5,-20(s0)
800079b2:	43dc                	lw	a5,4(a5)
800079b4:	853e                	mv	a0,a5
800079b6:	3b09                	jal	800076c8 <QSPI_SPIDataRateConfig>
	QSPI_SetWordLength(InitStruct->dataWidth);
800079b8:	fec42783          	lw	a5,-20(s0)
800079bc:	479c                	lw	a5,8(a5)
800079be:	853e                	mv	a0,a5
800079c0:	39d1                	jal	80007694 <QSPI_SetWordLength>
	QSPI_TxCmd(InitStruct->TxEnable);
800079c2:	fec42783          	lw	a5,-20(s0)
800079c6:	47dc                	lw	a5,12(a5)
800079c8:	853e                	mv	a0,a5
800079ca:	3b05                	jal	800076fa <QSPI_TxCmd>
	QSPI_RxCmd(InitStruct->RxEnable);
800079cc:	fec42783          	lw	a5,-20(s0)
800079d0:	4b9c                	lw	a5,16(a5)
800079d2:	853e                	mv	a0,a5
800079d4:	3ba1                	jal	8000772c <QSPI_RxCmd>
	QSPI_SCKDivConfig(InitStruct->SCKDiv);
800079d6:	fec42783          	lw	a5,-20(s0)
800079da:	4bdc                	lw	a5,20(a5)
800079dc:	853e                	mv	a0,a5
800079de:	3951                	jal	80007672 <QSPI_SCKDivConfig>
}
800079e0:	0001                	nop
800079e2:	40f2                	lw	ra,28(sp)
800079e4:	4462                	lw	s0,24(sp)
800079e6:	6105                	addi	sp,sp,32
800079e8:	8082                	ret

800079ea <QSPI_SPI_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_SPI_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void QSPI_SPI_StructInit(QSPI_SPI_Init_TypeDef* InitStruct)
{
800079ea:	1101                	addi	sp,sp,-32
800079ec:	ce22                	sw	s0,28(sp)
800079ee:	1000                	addi	s0,sp,32
800079f0:	fea42623          	sw	a0,-20(s0)
    InitStruct->IOMode = QSPI_SPI_IOMode_Single;
800079f4:	fec42783          	lw	a5,-20(s0)
800079f8:	0007a023          	sw	zero,0(a5) # 20040000 <STACK_SIZE+0x2003f800>
    InitStruct->dataRate = QSPI_SPI_DataRate_Single;
800079fc:	fec42783          	lw	a5,-20(s0)
80007a00:	0007a223          	sw	zero,4(a5)
    InitStruct->dataWidth = 0x1;
80007a04:	fec42783          	lw	a5,-20(s0)
80007a08:	4705                	li	a4,1
80007a0a:	c798                	sw	a4,8(a5)
    InitStruct->TxEnable = DISABLE;
80007a0c:	fec42783          	lw	a5,-20(s0)
80007a10:	0007a623          	sw	zero,12(a5)
    InitStruct->RxEnable = DISABLE;
80007a14:	fec42783          	lw	a5,-20(s0)
80007a18:	0007a823          	sw	zero,16(a5)
    InitStruct->SCKDiv = 0x0;
80007a1c:	fec42783          	lw	a5,-20(s0)
80007a20:	0007aa23          	sw	zero,20(a5)
}
80007a24:	0001                	nop
80007a26:	4472                	lw	s0,28(sp)
80007a28:	6105                	addi	sp,sp,32
80007a2a:	8082                	ret

80007a2c <QSPI_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void QSPI_Init(QSPI_Init_TypeDef* InitStruct)
{
80007a2c:	1101                	addi	sp,sp,-32
80007a2e:	ce06                	sw	ra,28(sp)
80007a30:	cc22                	sw	s0,24(sp)
80007a32:	1000                	addi	s0,sp,32
80007a34:	fea42623          	sw	a0,-20(s0)
    QSPI_ModeConfig(QSPI_Mode_QSPI);
80007a38:	4509                	li	a0,2
80007a3a:	3119                	jal	80007640 <QSPI_ModeConfig>

	QSPI_InstructionConfig(InitStruct->instruction);
80007a3c:	fec42783          	lw	a5,-20(s0)
80007a40:	0007c783          	lbu	a5,0(a5)
80007a44:	853e                	mv	a0,a5
80007a46:	3b99                	jal	8000779c <QSPI_InstructionConfig>
	QSPI_InstructionModeConfig(InitStruct->instructionMode);
80007a48:	fec42783          	lw	a5,-20(s0)
80007a4c:	43dc                	lw	a5,4(a5)
80007a4e:	853e                	mv	a0,a5
80007a50:	33b5                	jal	800077bc <QSPI_InstructionModeConfig>
	QSPI_AddressModeConfig(InitStruct->addressMode);
80007a52:	fec42783          	lw	a5,-20(s0)
80007a56:	479c                	lw	a5,8(a5)
80007a58:	853e                	mv	a0,a5
80007a5a:	3b41                	jal	800077ea <QSPI_AddressModeConfig>
	QSPI_AddressSizeConfig(InitStruct->addressSize);
80007a5c:	fec42783          	lw	a5,-20(s0)
80007a60:	47dc                	lw	a5,12(a5)
80007a62:	853e                	mv	a0,a5
80007a64:	3b65                	jal	8000781c <QSPI_AddressSizeConfig>
	QSPI_AdditionalModeConfig(InitStruct->additionalMode);
80007a66:	fec42783          	lw	a5,-20(s0)
80007a6a:	4b9c                	lw	a5,16(a5)
80007a6c:	853e                	mv	a0,a5
80007a6e:	3bf9                	jal	8000784c <QSPI_AdditionalModeConfig>
	QSPI_AdditionalSizeConfig(InitStruct->additionalSize);
80007a70:	fec42783          	lw	a5,-20(s0)
80007a74:	4bdc                	lw	a5,20(a5)
80007a76:	853e                	mv	a0,a5
80007a78:	3511                	jal	8000787c <QSPI_AdditionalSizeConfig>
	QSPI_WaitCyclesConfig(InitStruct->waitCycles);
80007a7a:	fec42783          	lw	a5,-20(s0)
80007a7e:	4f9c                	lw	a5,24(a5)
80007a80:	853e                	mv	a0,a5
80007a82:	3535                	jal	800078ae <QSPI_WaitCyclesConfig>
	QSPI_DataModeConfig(InitStruct->dataMode);
80007a84:	fec42783          	lw	a5,-20(s0)
80007a88:	4fdc                	lw	a5,28(a5)
80007a8a:	853e                	mv	a0,a5
80007a8c:	3d91                	jal	800078e0 <QSPI_DataModeConfig>
	QSPI_DataDirectionConfig(InitStruct->dataDirection);
80007a8e:	fec42783          	lw	a5,-20(s0)
80007a92:	539c                	lw	a5,32(a5)
80007a94:	853e                	mv	a0,a5
80007a96:	3db5                	jal	80007912 <QSPI_DataDirectionConfig>
	QSPI_DataRateConfig(InitStruct->dataRate);
80007a98:	fec42783          	lw	a5,-20(s0)
80007a9c:	53dc                	lw	a5,36(a5)
80007a9e:	853e                	mv	a0,a5
80007aa0:	3555                	jal	80007944 <QSPI_DataRateConfig>
	QSPI_SCKDivConfig(InitStruct->SCKDiv);
80007aa2:	fec42783          	lw	a5,-20(s0)
80007aa6:	579c                	lw	a5,40(a5)
80007aa8:	853e                	mv	a0,a5
80007aaa:	36e1                	jal	80007672 <QSPI_SCKDivConfig>
}
80007aac:	0001                	nop
80007aae:	40f2                	lw	ra,28(sp)
80007ab0:	4462                	lw	s0,24(sp)
80007ab2:	6105                	addi	sp,sp,32
80007ab4:	8082                	ret

80007ab6 <QSPI_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref QSPI_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void QSPI_StructInit(QSPI_Init_TypeDef* InitStruct)
{
80007ab6:	1101                	addi	sp,sp,-32
80007ab8:	ce22                	sw	s0,28(sp)
80007aba:	1000                	addi	s0,sp,32
80007abc:	fea42623          	sw	a0,-20(s0)
	InitStruct->instruction = 0x0;
80007ac0:	fec42783          	lw	a5,-20(s0)
80007ac4:	00078023          	sb	zero,0(a5)
	InitStruct->instructionMode = QSPI_Lines_No;
80007ac8:	fec42783          	lw	a5,-20(s0)
80007acc:	0007a223          	sw	zero,4(a5)
	InitStruct->addressMode = QSPI_Lines_No;
80007ad0:	fec42783          	lw	a5,-20(s0)
80007ad4:	0007a423          	sw	zero,8(a5)
	InitStruct->addressSize = QSPI_DataSize_8;
80007ad8:	fec42783          	lw	a5,-20(s0)
80007adc:	0007a623          	sw	zero,12(a5)
	InitStruct->additionalMode = QSPI_Lines_No;
80007ae0:	fec42783          	lw	a5,-20(s0)
80007ae4:	0007a823          	sw	zero,16(a5)
	InitStruct->additionalSize = QSPI_DataSize_8;
80007ae8:	fec42783          	lw	a5,-20(s0)
80007aec:	0007aa23          	sw	zero,20(a5)
	InitStruct->waitCycles = 0x0;
80007af0:	fec42783          	lw	a5,-20(s0)
80007af4:	0007ac23          	sw	zero,24(a5)
	InitStruct->dataMode = QSPI_Lines_No;
80007af8:	fec42783          	lw	a5,-20(s0)
80007afc:	0007ae23          	sw	zero,28(a5)
	InitStruct->dataDirection = QSPI_Direction_Write;
80007b00:	fec42783          	lw	a5,-20(s0)
80007b04:	0207a023          	sw	zero,32(a5)
	InitStruct->dataRate = QSPI_DataRate_Single;
80007b08:	fec42783          	lw	a5,-20(s0)
80007b0c:	0207a223          	sw	zero,36(a5)
	InitStruct->SCKDiv = 0x0;
80007b10:	fec42783          	lw	a5,-20(s0)
80007b14:	0207a423          	sw	zero,40(a5)
}
80007b18:	0001                	nop
80007b1a:	4472                	lw	s0,28(sp)
80007b1c:	6105                	addi	sp,sp,32
80007b1e:	8082                	ret

80007b20 <RCU_SysClkConfig>:
{
80007b20:	1101                	addi	sp,sp,-32
80007b22:	ce22                	sw	s0,28(sp)
80007b24:	1000                	addi	s0,sp,32
80007b26:	fea42623          	sw	a0,-20(s0)
    WRITE_REG(RCU->SYSCLKCFG_bit.SRC, SysClk);
80007b2a:	3000e7b7          	lui	a5,0x3000e
80007b2e:	fec42703          	lw	a4,-20(s0)
80007b32:	8b0d                	andi	a4,a4,3
80007b34:	0ff77713          	zext.b	a4,a4
80007b38:	8b0d                	andi	a4,a4,3
80007b3a:	5b94                	lw	a3,48(a5)
80007b3c:	9af1                	andi	a3,a3,-4
80007b3e:	8f55                	or	a4,a4,a3
80007b40:	db98                	sw	a4,48(a5)
}
80007b42:	0001                	nop
80007b44:	4472                	lw	s0,28(sp)
80007b46:	6105                	addi	sp,sp,32
80007b48:	8082                	ret

80007b4a <RCU_SysClkStatus>:
{
80007b4a:	1141                	addi	sp,sp,-16
80007b4c:	c622                	sw	s0,12(sp)
80007b4e:	0800                	addi	s0,sp,16
    return (RCU_SysClk_TypeDef)READ_REG(RCU->CLKSTAT_bit.SRC);
80007b50:	3000e7b7          	lui	a5,0x3000e
80007b54:	5fdc                	lw	a5,60(a5)
80007b56:	8b8d                	andi	a5,a5,3
80007b58:	0ff7f793          	zext.b	a5,a5
}
80007b5c:	853e                	mv	a0,a5
80007b5e:	4432                	lw	s0,12(sp)
80007b60:	0141                	addi	sp,sp,16
80007b62:	8082                	ret

80007b64 <getSysClkFreq>:
  * @brief   Получение значения частоты генерации выбранного источника
  * @param   Clk  Выбор тактового сигнала
  * @retval  Val  Значение Гц
  */
static uint32_t getSysClkFreq(RCU_SysClk_TypeDef Clk)
{
80007b64:	7179                	addi	sp,sp,-48
80007b66:	d622                	sw	s0,44(sp)
80007b68:	1800                	addi	s0,sp,48
80007b6a:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80007b6e:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80007b72:	fdc42703          	lw	a4,-36(s0)
80007b76:	478d                	li	a5,3
80007b78:	02f70063          	beq	a4,a5,80007b98 <getSysClkFreq+0x34>
80007b7c:	fdc42703          	lw	a4,-36(s0)
80007b80:	478d                	li	a5,3
80007b82:	00e7ee63          	bltu	a5,a4,80007b9e <getSysClkFreq+0x3a>
80007b86:	fdc42703          	lw	a4,-36(s0)
80007b8a:	4789                	li	a5,2
80007b8c:	00f70863          	beq	a4,a5,80007b9c <getSysClkFreq+0x38>
80007b90:	fdc42703          	lw	a4,-36(s0)
80007b94:	4789                	li	a5,2
80007b96:	a021                	j	80007b9e <getSysClkFreq+0x3a>
    case RCU_SysClk_SysPLL0Clk:
        //clk_freq = RCU_GetSysPLL0ClkFreq();
        break;
    case RCU_SysClk_LsiClk:
        //clk_freq = RCU_GetLsiClkFreq();
        break;
80007b98:	0001                	nop
80007b9a:	a011                	j	80007b9e <getSysClkFreq+0x3a>
        break;
80007b9c:	0001                	nop
    }

    return clk_freq;
80007b9e:	fec42783          	lw	a5,-20(s0)
}
80007ba2:	853e                	mv	a0,a5
80007ba4:	5432                	lw	s0,44(sp)
80007ba6:	6145                	addi	sp,sp,48
80007ba8:	8082                	ret

80007baa <getPeriphClkFreq>:
  * @brief   Получение значения частоты генерации выбранного источника
  * @param   Clk  Выбор тактового сигнала
  * @retval  Val  Значение Гц
  */
static uint32_t getPeriphClkFreq(RCU_PeriphClk_TypeDef Clk)
{
80007baa:	7179                	addi	sp,sp,-48
80007bac:	d622                	sw	s0,44(sp)
80007bae:	1800                	addi	s0,sp,48
80007bb0:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80007bb4:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80007bb8:	fdc42703          	lw	a4,-36(s0)
80007bbc:	478d                	li	a5,3
80007bbe:	02f70063          	beq	a4,a5,80007bde <getPeriphClkFreq+0x34>
80007bc2:	fdc42703          	lw	a4,-36(s0)
80007bc6:	478d                	li	a5,3
80007bc8:	00e7ee63          	bltu	a5,a4,80007be4 <getPeriphClkFreq+0x3a>
80007bcc:	fdc42703          	lw	a4,-36(s0)
80007bd0:	4789                	li	a5,2
80007bd2:	00f70863          	beq	a4,a5,80007be2 <getPeriphClkFreq+0x38>
80007bd6:	fdc42703          	lw	a4,-36(s0)
80007bda:	4789                	li	a5,2
80007bdc:	a021                	j	80007be4 <getPeriphClkFreq+0x3a>
    case RCU_PeriphClk_SysPLL0Clk:
        //clk_freq = RCU_GetPLLDivClkFreq();
        break;
    case RCU_PeriphClk_SysPLL1Clk:
        //clk_freq = RCU_GetPLLExtClkFreq();
        break;
80007bde:	0001                	nop
80007be0:	a011                	j	80007be4 <getPeriphClkFreq+0x3a>
        break;
80007be2:	0001                	nop
    }

    return clk_freq;
80007be4:	fec42783          	lw	a5,-20(s0)
}
80007be8:	853e                	mv	a0,a5
80007bea:	5432                	lw	s0,44(sp)
80007bec:	6145                	addi	sp,sp,48
80007bee:	8082                	ret

80007bf0 <getSysPeriphClkFreq>:
  * @brief   Получение значения частоты генерации выбранного источника
  * @param   Clk  Выбор тактового сигнала
  * @retval  Val  Значение Гц
  */
static uint32_t getSysPeriphClkFreq(RCU_PeriphClk_TypeDef Clk)
{
80007bf0:	7179                	addi	sp,sp,-48
80007bf2:	d622                	sw	s0,44(sp)
80007bf4:	1800                	addi	s0,sp,48
80007bf6:	fca42e23          	sw	a0,-36(s0)
    uint32_t clk_freq = 0;
80007bfa:	fe042623          	sw	zero,-20(s0)

    switch (Clk) {
80007bfe:	fdc42703          	lw	a4,-36(s0)
80007c02:	478d                	li	a5,3
80007c04:	02f70063          	beq	a4,a5,80007c24 <getSysPeriphClkFreq+0x34>
80007c08:	fdc42703          	lw	a4,-36(s0)
80007c0c:	478d                	li	a5,3
80007c0e:	00e7ee63          	bltu	a5,a4,80007c2a <getSysPeriphClkFreq+0x3a>
80007c12:	fdc42703          	lw	a4,-36(s0)
80007c16:	4789                	li	a5,2
80007c18:	00f70863          	beq	a4,a5,80007c28 <getSysPeriphClkFreq+0x38>
80007c1c:	fdc42703          	lw	a4,-36(s0)
80007c20:	4789                	li	a5,2
80007c22:	a021                	j	80007c2a <getSysPeriphClkFreq+0x3a>
    case RCU_PeriphClk_SysPLL0Clk:
        //clk_freq = RCU_GetSysClkFreq();
        break;
    case RCU_PeriphClk_SysPLL1Clk:
        //clk_freq = RCU_GetPLLClkFreq();
        break;
80007c24:	0001                	nop
80007c26:	a011                	j	80007c2a <getSysPeriphClkFreq+0x3a>
        break;
80007c28:	0001                	nop
    }

    return clk_freq;
80007c2a:	fec42783          	lw	a5,-20(s0)
}
80007c2e:	853e                	mv	a0,a5
80007c30:	5432                	lw	s0,44(sp)
80007c32:	6145                	addi	sp,sp,48
80007c34:	8082                	ret

80007c36 <RCU_GetHSIClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала HSICLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetHSIClkFreq()
{
80007c36:	1141                	addi	sp,sp,-16
80007c38:	c622                	sw	s0,12(sp)
80007c3a:	0800                	addi	s0,sp,16
    return HSICLK_VAL;
80007c3c:	000f47b7          	lui	a5,0xf4
80007c40:	24078793          	addi	a5,a5,576 # f4240 <STACK_SIZE+0xf3a40>
}
80007c44:	853e                	mv	a0,a5
80007c46:	4432                	lw	s0,12(sp)
80007c48:	0141                	addi	sp,sp,16
80007c4a:	8082                	ret

80007c4c <RCU_GetHSEClkFreq>:
/**
  * @brief   Получение значения частоты тактового сигнала HSECLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetHSEClkFreq()
{
80007c4c:	1141                	addi	sp,sp,-16
80007c4e:	c622                	sw	s0,12(sp)
80007c50:	0800                	addi	s0,sp,16
    return HSECLK_VAL;
80007c52:	00f427b7          	lui	a5,0xf42
80007c56:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
}
80007c5a:	853e                	mv	a0,a5
80007c5c:	4432                	lw	s0,12(sp)
80007c5e:	0141                	addi	sp,sp,16
80007c60:	8082                	ret

80007c62 <RCU_GetLsiClkFreq1>:
/**
  * @brief   Получение значения частоты тактового сигнала LSICLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetLsiClkFreq1()
{
80007c62:	1141                	addi	sp,sp,-16
80007c64:	c622                	sw	s0,12(sp)
80007c66:	0800                	addi	s0,sp,16
    return (uint32_t)LSICLK_VAL;
80007c68:	67a1                	lui	a5,0x8
80007c6a:	d0078793          	addi	a5,a5,-768 # 7d00 <STACK_SIZE+0x7500>
}
80007c6e:	853e                	mv	a0,a5
80007c70:	4432                	lw	s0,12(sp)
80007c72:	0141                	addi	sp,sp,16
80007c74:	8082                	ret

80007c76 <RCU_GetSysPLL0ClkFreq1>:
/**
  * @brief   Получение значения частоты тактового сигнала SYSPLL0CLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetSysPLL0ClkFreq1()
{
80007c76:	7179                	addi	sp,sp,-48
80007c78:	d622                	sw	s0,44(sp)
80007c7a:	1800                	addi	s0,sp,48
    uint32_t pll_div0a, pll_div0b, pll_div1a, pll_div1b , pll_fracdiv, pll_fbdiv, pll_refdiv, pll_refclk;

    pll_div0a = READ_REG(RCU->PLLSYSCFG0_bit.PD0A)+1;
80007c7c:	3000e7b7          	lui	a5,0x3000e
80007c80:	4bbc                	lw	a5,80(a5)
80007c82:	83b5                	srli	a5,a5,0xd
80007c84:	8b9d                	andi	a5,a5,7
80007c86:	0ff7f793          	zext.b	a5,a5
80007c8a:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80007c8c:	fef42623          	sw	a5,-20(s0)
    pll_div0b = READ_REG(RCU->PLLSYSCFG0_bit.PD0B)+1;
80007c90:	3000e7b7          	lui	a5,0x3000e
80007c94:	4bbc                	lw	a5,80(a5)
80007c96:	83c1                	srli	a5,a5,0x10
80007c98:	03f7f793          	andi	a5,a5,63
80007c9c:	0ff7f793          	zext.b	a5,a5
80007ca0:	0785                	addi	a5,a5,1 # 3000e001 <STACK_SIZE+0x3000d801>
80007ca2:	fef42423          	sw	a5,-24(s0)
    pll_fbdiv = READ_REG(RCU->PLLSYSCFG2_bit.FBDIV);
80007ca6:	3000e7b7          	lui	a5,0x3000e
80007caa:	4fbc                	lw	a5,88(a5)
80007cac:	873e                	mv	a4,a5
80007cae:	6785                	lui	a5,0x1
80007cb0:	17fd                	addi	a5,a5,-1 # fff <STACK_SIZE+0x7ff>
80007cb2:	8ff9                	and	a5,a5,a4
80007cb4:	07c2                	slli	a5,a5,0x10
80007cb6:	83c1                	srli	a5,a5,0x10
80007cb8:	fef42223          	sw	a5,-28(s0)
    pll_refdiv = READ_REG(RCU->PLLSYSCFG0_bit.REFDIV);
80007cbc:	3000e7b7          	lui	a5,0x3000e
80007cc0:	4bbc                	lw	a5,80(a5)
80007cc2:	839d                	srli	a5,a5,0x7
80007cc4:	03f7f793          	andi	a5,a5,63
80007cc8:	0ff7f793          	zext.b	a5,a5
80007ccc:	fef42023          	sw	a5,-32(s0)
    pll_refclk = HSECLK_VAL;
80007cd0:	00f427b7          	lui	a5,0xf42
80007cd4:	40078793          	addi	a5,a5,1024 # f42400 <STACK_SIZE+0xf41c00>
80007cd8:	fcf42e23          	sw	a5,-36(s0)

    return (uint32_t)((pll_refclk * pll_fbdiv) / (pll_refdiv * pll_div0a * pll_div0b));
80007cdc:	fdc42703          	lw	a4,-36(s0)
80007ce0:	fe442783          	lw	a5,-28(s0)
80007ce4:	02f70733          	mul	a4,a4,a5
80007ce8:	fe042683          	lw	a3,-32(s0)
80007cec:	fec42783          	lw	a5,-20(s0)
80007cf0:	02f686b3          	mul	a3,a3,a5
80007cf4:	fe842783          	lw	a5,-24(s0)
80007cf8:	02f687b3          	mul	a5,a3,a5
80007cfc:	02f757b3          	divu	a5,a4,a5
}
80007d00:	853e                	mv	a0,a5
80007d02:	5432                	lw	s0,44(sp)
80007d04:	6145                	addi	sp,sp,48
80007d06:	8082                	ret

80007d08 <RCU_GetSysClkFreq>:
/**
  * @brief   Получение значения частоты SYSCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetSysClkFreq()
{
80007d08:	1101                	addi	sp,sp,-32
80007d0a:	ce06                	sw	ra,28(sp)
80007d0c:	cc22                	sw	s0,24(sp)
80007d0e:	1000                	addi	s0,sp,32
    RCU_SysClk_TypeDef sys_clk;

    sys_clk = RCU_SysClkStatus();
80007d10:	3d2d                	jal	80007b4a <RCU_SysClkStatus>
80007d12:	fea42623          	sw	a0,-20(s0)

    return getSysClkFreq(sys_clk);
80007d16:	fec42503          	lw	a0,-20(s0)
80007d1a:	35a9                	jal	80007b64 <getSysClkFreq>
80007d1c:	87aa                	mv	a5,a0
}
80007d1e:	853e                	mv	a0,a5
80007d20:	40f2                	lw	ra,28(sp)
80007d22:	4462                	lw	s0,24(sp)
80007d24:	6105                	addi	sp,sp,32
80007d26:	8082                	ret

80007d28 <RCU_GetUARTClkFreq>:
  * @brief   Получение значения частоты UARTCLK
  * @param   UARTx_Num  Порядковый номер блока UART
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetUARTClkFreq(UART_Num_TypeDef UARTx_Num)
{
80007d28:	7179                	addi	sp,sp,-48
80007d2a:	d606                	sw	ra,44(sp)
80007d2c:	d422                	sw	s0,40(sp)
80007d2e:	1800                	addi	s0,sp,48
80007d30:	fca42e23          	sw	a0,-36(s0)
    RCU_PeriphClk_TypeDef uart_clk;
    uint32_t div_val;

    uart_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.CLKSEL);
80007d34:	3000e737          	lui	a4,0x3000e
80007d38:	fdc42783          	lw	a5,-36(s0)
80007d3c:	07f1                	addi	a5,a5,28
80007d3e:	078a                	slli	a5,a5,0x2
80007d40:	97ba                	add	a5,a5,a4
80007d42:	439c                	lw	a5,0(a5)
80007d44:	83c1                	srli	a5,a5,0x10
80007d46:	8b8d                	andi	a5,a5,3
80007d48:	0ff7f793          	zext.b	a5,a5
80007d4c:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.DIVEN))
80007d50:	3000e737          	lui	a4,0x3000e
80007d54:	fdc42783          	lw	a5,-36(s0)
80007d58:	07f1                	addi	a5,a5,28
80007d5a:	078a                	slli	a5,a5,0x2
80007d5c:	97ba                	add	a5,a5,a4
80007d5e:	439c                	lw	a5,0(a5)
80007d60:	83d1                	srli	a5,a5,0x14
80007d62:	8b85                	andi	a5,a5,1
80007d64:	0ff7f793          	zext.b	a5,a5
80007d68:	c39d                	beqz	a5,80007d8e <RCU_GetUARTClkFreq+0x66>
        div_val = 2 * (READ_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.DIVN) + 1);
80007d6a:	3000e737          	lui	a4,0x3000e
80007d6e:	fdc42783          	lw	a5,-36(s0)
80007d72:	07f1                	addi	a5,a5,28
80007d74:	078a                	slli	a5,a5,0x2
80007d76:	97ba                	add	a5,a5,a4
80007d78:	439c                	lw	a5,0(a5)
80007d7a:	83e1                	srli	a5,a5,0x18
80007d7c:	03f7f793          	andi	a5,a5,63
80007d80:	0ff7f793          	zext.b	a5,a5
80007d84:	0785                	addi	a5,a5,1
80007d86:	0786                	slli	a5,a5,0x1
80007d88:	fef42623          	sw	a5,-20(s0)
80007d8c:	a021                	j	80007d94 <RCU_GetUARTClkFreq+0x6c>
    else
        div_val = 1;
80007d8e:	4785                	li	a5,1
80007d90:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(uart_clk) / div_val;
80007d94:	fe842503          	lw	a0,-24(s0)
80007d98:	3d09                	jal	80007baa <getPeriphClkFreq>
80007d9a:	872a                	mv	a4,a0
80007d9c:	fec42783          	lw	a5,-20(s0)
80007da0:	02f757b3          	divu	a5,a4,a5
}
80007da4:	853e                	mv	a0,a5
80007da6:	50b2                	lw	ra,44(sp)
80007da8:	5422                	lw	s0,40(sp)
80007daa:	6145                	addi	sp,sp,48
80007dac:	8082                	ret

80007dae <RCU_GetSPIClkFreq>:
  * @brief   Получение значения частоты SPICLK
  * @param   SPIx_Num  Порядковый номер блока SPI
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetSPIClkFreq(SPI_Num_TypeDef SPIx_Num)
{
80007dae:	7179                	addi	sp,sp,-48
80007db0:	d606                	sw	ra,44(sp)
80007db2:	d422                	sw	s0,40(sp)
80007db4:	1800                	addi	s0,sp,48
80007db6:	fca42e23          	sw	a0,-36(s0)
    RCU_PeriphClk_TypeDef spi_clk;
    uint32_t div_val;

    spi_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.CLKSEL);
80007dba:	3000e737          	lui	a4,0x3000e
80007dbe:	fdc42783          	lw	a5,-36(s0)
80007dc2:	02478793          	addi	a5,a5,36
80007dc6:	078a                	slli	a5,a5,0x2
80007dc8:	97ba                	add	a5,a5,a4
80007dca:	43dc                	lw	a5,4(a5)
80007dcc:	83c1                	srli	a5,a5,0x10
80007dce:	8b8d                	andi	a5,a5,3
80007dd0:	0ff7f793          	zext.b	a5,a5
80007dd4:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.DIVEN))
80007dd8:	3000e737          	lui	a4,0x3000e
80007ddc:	fdc42783          	lw	a5,-36(s0)
80007de0:	02478793          	addi	a5,a5,36
80007de4:	078a                	slli	a5,a5,0x2
80007de6:	97ba                	add	a5,a5,a4
80007de8:	43dc                	lw	a5,4(a5)
80007dea:	83d1                	srli	a5,a5,0x14
80007dec:	8b85                	andi	a5,a5,1
80007dee:	0ff7f793          	zext.b	a5,a5
80007df2:	c785                	beqz	a5,80007e1a <RCU_GetSPIClkFreq+0x6c>
        div_val = 2 * (READ_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.DIVN) + 1);
80007df4:	3000e737          	lui	a4,0x3000e
80007df8:	fdc42783          	lw	a5,-36(s0)
80007dfc:	02478793          	addi	a5,a5,36
80007e00:	078a                	slli	a5,a5,0x2
80007e02:	97ba                	add	a5,a5,a4
80007e04:	43dc                	lw	a5,4(a5)
80007e06:	83e1                	srli	a5,a5,0x18
80007e08:	03f7f793          	andi	a5,a5,63
80007e0c:	0ff7f793          	zext.b	a5,a5
80007e10:	0785                	addi	a5,a5,1
80007e12:	0786                	slli	a5,a5,0x1
80007e14:	fef42623          	sw	a5,-20(s0)
80007e18:	a021                	j	80007e20 <RCU_GetSPIClkFreq+0x72>
    else
        div_val = 1;
80007e1a:	4785                	li	a5,1
80007e1c:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(spi_clk) / div_val;
80007e20:	fe842503          	lw	a0,-24(s0)
80007e24:	3359                	jal	80007baa <getPeriphClkFreq>
80007e26:	872a                	mv	a4,a0
80007e28:	fec42783          	lw	a5,-20(s0)
80007e2c:	02f757b3          	divu	a5,a4,a5
}
80007e30:	853e                	mv	a0,a5
80007e32:	50b2                	lw	ra,44(sp)
80007e34:	5422                	lw	s0,40(sp)
80007e36:	6145                	addi	sp,sp,48
80007e38:	8082                	ret

80007e3a <RCU_GetADCSARClkFreq>:
/**
  * @brief   Получение значения частоты ADCCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetADCSARClkFreq()
{
80007e3a:	1101                	addi	sp,sp,-32
80007e3c:	ce06                	sw	ra,28(sp)
80007e3e:	cc22                	sw	s0,24(sp)
80007e40:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef adc_clk;
    uint32_t div_val;

    adc_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->ADCSARCLKCFG_bit.CLKSEL);
80007e42:	3000e7b7          	lui	a5,0x3000e
80007e46:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80007e4a:	83c1                	srli	a5,a5,0x10
80007e4c:	8b8d                	andi	a5,a5,3
80007e4e:	0ff7f793          	zext.b	a5,a5
80007e52:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->ADCSARCLKCFG_bit.DIVEN))
80007e56:	3000e7b7          	lui	a5,0x3000e
80007e5a:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80007e5e:	83d1                	srli	a5,a5,0x14
80007e60:	8b85                	andi	a5,a5,1
80007e62:	0ff7f793          	zext.b	a5,a5
80007e66:	cf99                	beqz	a5,80007e84 <RCU_GetADCSARClkFreq+0x4a>
        div_val = 2 * (READ_REG(RCU->ADCSARCLKCFG_bit.DIVN) + 1);
80007e68:	3000e7b7          	lui	a5,0x3000e
80007e6c:	0b07a783          	lw	a5,176(a5) # 3000e0b0 <STACK_SIZE+0x3000d8b0>
80007e70:	83e1                	srli	a5,a5,0x18
80007e72:	03f7f793          	andi	a5,a5,63
80007e76:	0ff7f793          	zext.b	a5,a5
80007e7a:	0785                	addi	a5,a5,1
80007e7c:	0786                	slli	a5,a5,0x1
80007e7e:	fef42623          	sw	a5,-20(s0)
80007e82:	a021                	j	80007e8a <RCU_GetADCSARClkFreq+0x50>
    else
        div_val = 1;
80007e84:	4785                	li	a5,1
80007e86:	fef42623          	sw	a5,-20(s0)

    return getPeriphClkFreq(adc_clk) / div_val;
80007e8a:	fe842503          	lw	a0,-24(s0)
80007e8e:	3b31                	jal	80007baa <getPeriphClkFreq>
80007e90:	872a                	mv	a4,a0
80007e92:	fec42783          	lw	a5,-20(s0)
80007e96:	02f757b3          	divu	a5,a4,a5
}
80007e9a:	853e                	mv	a0,a5
80007e9c:	40f2                	lw	ra,28(sp)
80007e9e:	4462                	lw	s0,24(sp)
80007ea0:	6105                	addi	sp,sp,32
80007ea2:	8082                	ret

80007ea4 <RCU_GetWDTClkFreq>:
/**
  * @brief   Получение значения частоты WDTCLK
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetWDTClkFreq()
{
80007ea4:	1101                	addi	sp,sp,-32
80007ea6:	ce06                	sw	ra,28(sp)
80007ea8:	cc22                	sw	s0,24(sp)
80007eaa:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef wdt_clk;
    uint32_t div_val;

    wdt_clk = (RCU_PeriphClk_TypeDef)READ_REG(RCU->WDOGCLKCFG_bit.CLKSEL);
80007eac:	3000e7b7          	lui	a5,0x3000e
80007eb0:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
80007eb4:	83c1                	srli	a5,a5,0x10
80007eb6:	8b8d                	andi	a5,a5,3
80007eb8:	0ff7f793          	zext.b	a5,a5
80007ebc:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->WDOGCLKCFG_bit.DIVEN))
80007ec0:	3000e7b7          	lui	a5,0x3000e
80007ec4:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
80007ec8:	83d1                	srli	a5,a5,0x14
80007eca:	8b85                	andi	a5,a5,1
80007ecc:	0ff7f793          	zext.b	a5,a5
80007ed0:	cf99                	beqz	a5,80007eee <RCU_GetWDTClkFreq+0x4a>
        div_val = 2 * (READ_REG(RCU->WDOGCLKCFG_bit.DIVN) + 1);
80007ed2:	3000e7b7          	lui	a5,0x3000e
80007ed6:	0b87a783          	lw	a5,184(a5) # 3000e0b8 <STACK_SIZE+0x3000d8b8>
80007eda:	83e1                	srli	a5,a5,0x18
80007edc:	03f7f793          	andi	a5,a5,63
80007ee0:	0ff7f793          	zext.b	a5,a5
80007ee4:	0785                	addi	a5,a5,1
80007ee6:	0786                	slli	a5,a5,0x1
80007ee8:	fef42623          	sw	a5,-20(s0)
80007eec:	a021                	j	80007ef4 <RCU_GetWDTClkFreq+0x50>
    else
        div_val = 1;
80007eee:	4785                	li	a5,1
80007ef0:	fef42623          	sw	a5,-20(s0)

    return getSysPeriphClkFreq(wdt_clk) / div_val;
80007ef4:	fe842503          	lw	a0,-24(s0)
80007ef8:	39e5                	jal	80007bf0 <getSysPeriphClkFreq>
80007efa:	872a                	mv	a4,a0
80007efc:	fec42783          	lw	a5,-20(s0)
80007f00:	02f757b3          	divu	a5,a4,a5
}
80007f04:	853e                	mv	a0,a5
80007f06:	40f2                	lw	ra,28(sp)
80007f08:	4462                	lw	s0,24(sp)
80007f0a:	6105                	addi	sp,sp,32
80007f0c:	8082                	ret

80007f0e <RCU_GetClkOutFreq>:
/**
  * @brief   Получение значения частоты CLKOUT
  * @retval  Val  Значение Гц
  */
uint32_t RCU_GetClkOutFreq()
{
80007f0e:	1101                	addi	sp,sp,-32
80007f10:	ce06                	sw	ra,28(sp)
80007f12:	cc22                	sw	s0,24(sp)
80007f14:	1000                	addi	s0,sp,32
    RCU_PeriphClk_TypeDef clkout;
    uint32_t div_val;

    clkout = (RCU_PeriphClk_TypeDef)READ_REG(RCU->CLKOUTCFG_bit.CLKSEL);
80007f16:	3000e7b7          	lui	a5,0x3000e
80007f1a:	0bc7a783          	lw	a5,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
80007f1e:	8391                	srli	a5,a5,0x4
80007f20:	8b8d                	andi	a5,a5,3
80007f22:	0ff7f793          	zext.b	a5,a5
80007f26:	fef42423          	sw	a5,-24(s0)
    if (READ_REG(RCU->CLKOUTCFG_bit.DIVEN))
80007f2a:	3000e7b7          	lui	a5,0x3000e
80007f2e:	0bc7a783          	lw	a5,188(a5) # 3000e0bc <STACK_SIZE+0x3000d8bc>
80007f32:	83b1                	srli	a5,a5,0xc
80007f34:	8b85                	andi	a5,a5,1
80007f36:	0ff7f793          	zext.b	a5,a5
80007f3a:	cf81                	beqz	a5,80007f52 <RCU_GetClkOutFreq+0x44>
        div_val = 2 * (READ_REG(RCU->CLKOUTCFG_bit.DIVN) + 1);
80007f3c:	3000e7b7          	lui	a5,0x3000e
80007f40:	0be7d783          	lhu	a5,190(a5) # 3000e0be <STACK_SIZE+0x3000d8be>
80007f44:	07c2                	slli	a5,a5,0x10
80007f46:	83c1                	srli	a5,a5,0x10
80007f48:	0785                	addi	a5,a5,1
80007f4a:	0786                	slli	a5,a5,0x1
80007f4c:	fef42623          	sw	a5,-20(s0)
80007f50:	a021                	j	80007f58 <RCU_GetClkOutFreq+0x4a>
    else
        div_val = 1;
80007f52:	4785                	li	a5,1
80007f54:	fef42623          	sw	a5,-20(s0)

    return getSysPeriphClkFreq(clkout) / div_val;
80007f58:	fe842503          	lw	a0,-24(s0)
80007f5c:	3951                	jal	80007bf0 <getSysPeriphClkFreq>
80007f5e:	872a                	mv	a4,a0
80007f60:	fec42783          	lw	a5,-20(s0)
80007f64:	02f757b3          	divu	a5,a4,a5
}
80007f68:	853e                	mv	a0,a5
80007f6a:	40f2                	lw	ra,28(sp)
80007f6c:	4462                	lw	s0,24(sp)
80007f6e:	6105                	addi	sp,sp,32
80007f70:	8082                	ret

80007f72 <RCU_PLL_Init>:
  * @param      InitStruct  Указатель на структуру типа @ref RCU_PLL_Init_TypeDef,
  *                         которая содержит конфигурационную информацию
  * @retval     Status
  */
OperationStatus RCU_PLL_Init(RCU_PLL_Init_TypeDef* InitStruct)
{
80007f72:	7179                	addi	sp,sp,-48
80007f74:	d622                	sw	s0,44(sp)
80007f76:	1800                	addi	s0,sp,48
80007f78:	fca42e23          	sw	a0,-36(s0)
    uint32_t timeout = RCU_PLLCLK_LOCK_TIMEOUT;
80007f7c:	6789                	lui	a5,0x2
80007f7e:	71078793          	addi	a5,a5,1808 # 2710 <STACK_SIZE+0x1f10>
80007f82:	fef42423          	sw	a5,-24(s0)
    OperationStatus status = OK;
80007f86:	fe042623          	sw	zero,-20(s0)
    assert_param(IS_RCU_PLL_REF_DIV(InitStruct->RefDiv));
    assert_param(IS_RCU_PLL_REF(InitStruct->Ref));
    assert_param(IS_RCU_PLL_DIV1(InitStruct->Div1));
    assert_param(IS_RCU_PLL_DIV2(InitStruct->Div2));

    CLEAR_BIT(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_BYP_Msk | RCU_PLLSYSCFG0_PLLEN_Msk);
80007f8a:	3000e7b7          	lui	a5,0x3000e
80007f8e:	4bb8                	lw	a4,80(a5)
80007f90:	3000e7b7          	lui	a5,0x3000e
80007f94:	9b61                	andi	a4,a4,-8
80007f96:	cbb8                	sw	a4,80(a5)
    MODIFY_REG(RCU->PLLSYSCFG0, (RCU_PLLSYSCFG0_REFDIV_Msk | RCU_PLLSYSCFG0_PD0A_Msk | RCU_PLLSYSCFG0_PD0B_Msk),
80007f98:	3000e7b7          	lui	a5,0x3000e
80007f9c:	4bb8                	lw	a4,80(a5)
80007f9e:	ffc007b7          	lui	a5,0xffc00
80007fa2:	07f78793          	addi	a5,a5,127 # ffc0007f <__data_source_start+0x7fbf722b>
80007fa6:	00f776b3          	and	a3,a4,a5
80007faa:	fdc42783          	lw	a5,-36(s0)
80007fae:	43dc                	lw	a5,4(a5)
80007fb0:	00779713          	slli	a4,a5,0x7
80007fb4:	fdc42783          	lw	a5,-36(s0)
80007fb8:	4b9c                	lw	a5,16(a5)
80007fba:	07b6                	slli	a5,a5,0xd
80007fbc:	8f5d                	or	a4,a4,a5
80007fbe:	fdc42783          	lw	a5,-36(s0)
80007fc2:	4bdc                	lw	a5,20(a5)
80007fc4:	07c2                	slli	a5,a5,0x10
80007fc6:	8f5d                	or	a4,a4,a5
80007fc8:	3000e7b7          	lui	a5,0x3000e
80007fcc:	8f55                	or	a4,a4,a3
80007fce:	cbb8                	sw	a4,80(a5)
               (InitStruct->RefDiv << RCU_PLLSYSCFG0_REFDIV_Pos |
                InitStruct->Div0A << RCU_PLLSYSCFG0_PD0A_Pos |
                InitStruct->Div0B << RCU_PLLSYSCFG0_PD0B_Pos));
    MODIFY_REG(RCU->PLLSYSCFG2, (RCU_PLLSYSCFG2_FBDIV_Msk),
80007fd0:	3000e7b7          	lui	a5,0x3000e
80007fd4:	4fb8                	lw	a4,88(a5)
80007fd6:	77fd                	lui	a5,0xfffff
80007fd8:	00f776b3          	and	a3,a4,a5
80007fdc:	fdc42783          	lw	a5,-36(s0)
80007fe0:	4798                	lw	a4,8(a5)
80007fe2:	3000e7b7          	lui	a5,0x3000e
80007fe6:	8f55                	or	a4,a4,a3
80007fe8:	cfb8                	sw	a4,88(a5)
               (InitStruct->FbDiv << RCU_PLLSYSCFG2_FBDIV_Pos));

    //RCU_PLL_OutCmd(ENABLE);
    while (timeout) {
80007fea:	0001                	nop
80007fec:	fe842783          	lw	a5,-24(s0)
80007ff0:	fff5                	bnez	a5,80007fec <RCU_PLL_Init+0x7a>
        //     break;
        // } else {
        //     timeout--;
        // }
    }
    if (!timeout) {
80007ff2:	fe842783          	lw	a5,-24(s0)
80007ff6:	e781                	bnez	a5,80007ffe <RCU_PLL_Init+0x8c>
        status = ERROR;
80007ff8:	4785                	li	a5,1
80007ffa:	fef42623          	sw	a5,-20(s0)
    }

    return status;
80007ffe:	fec42783          	lw	a5,-20(s0)
}
80008002:	853e                	mv	a0,a5
80008004:	5432                	lw	s0,44(sp)
80008006:	6145                	addi	sp,sp,48
80008008:	8082                	ret

8000800a <RCU_PLL_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref RCU_PLL_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void RCU_PLL_StructInit(RCU_PLL_Init_TypeDef* InitStruct)
{
8000800a:	1101                	addi	sp,sp,-32
8000800c:	ce22                	sw	s0,28(sp)
8000800e:	1000                	addi	s0,sp,32
80008010:	fea42623          	sw	a0,-20(s0)
    InitStruct->FbDiv = 16;
80008014:	fec42783          	lw	a5,-20(s0)
80008018:	4741                	li	a4,16
8000801a:	c798                	sw	a4,8(a5)
    InitStruct->RefDiv = 1;
8000801c:	fec42783          	lw	a5,-20(s0)
80008020:	4705                	li	a4,1
80008022:	c3d8                	sw	a4,4(a5)
    InitStruct->Div0A = 1;
80008024:	fec42783          	lw	a5,-20(s0)
80008028:	4705                	li	a4,1
8000802a:	cb98                	sw	a4,16(a5)
    InitStruct->Div0B = 1;
8000802c:	fec42783          	lw	a5,-20(s0)
80008030:	4705                	li	a4,1
80008032:	cbd8                	sw	a4,20(a5)
    InitStruct->Div1A = 1;
80008034:	fec42783          	lw	a5,-20(s0)
80008038:	4705                	li	a4,1
8000803a:	cf98                	sw	a4,24(a5)
    InitStruct->Div1B = 1;
8000803c:	fec42783          	lw	a5,-20(s0)
80008040:	4705                	li	a4,1
80008042:	cfd8                	sw	a4,28(a5)
}
80008044:	0001                	nop
80008046:	4472                	lw	s0,28(sp)
80008048:	6105                	addi	sp,sp,32
8000804a:	8082                	ret

8000804c <RCU_PLL_DeInit>:
/**
  * @brief   Устанавливает все регистры PLL значениями по умолчанию
  * @retval  void
  */
void RCU_PLL_DeInit()
{
8000804c:	1141                	addi	sp,sp,-16
8000804e:	c622                	sw	s0,12(sp)
80008050:	0800                	addi	s0,sp,16
    //RCU_PLL_OutCmd(DISABLE);
    WRITE_REG(RCU->PLLSYSCFG0, RCU_PLLSYSCFG0_RST_VAL);
80008052:	3000e7b7          	lui	a5,0x3000e
80008056:	34111737          	lui	a4,0x34111
8000805a:	10170713          	addi	a4,a4,257 # 34111101 <STACK_SIZE+0x34110901>
8000805e:	cbb8                	sw	a4,80(a5)
}
80008060:	0001                	nop
80008062:	4432                	lw	s0,12(sp)
80008064:	0141                	addi	sp,sp,16
80008066:	8082                	ret

80008068 <RCU_SysClkChangeCmd>:
  * @brief   Переключение источника для системного тактового сигнала
  * @param   SysClk  Выбор источника
  * @retval  void
  */
OperationStatus RCU_SysClkChangeCmd(RCU_SysClk_TypeDef SysClk)
{
80008068:	7179                	addi	sp,sp,-48
8000806a:	d606                	sw	ra,44(sp)
8000806c:	d422                	sw	s0,40(sp)
8000806e:	1800                	addi	s0,sp,48
80008070:	fca42e23          	sw	a0,-36(s0)
    uint32_t timeout = RCU_SYSCLK_CHANGE_TIMEOUT;
80008074:	6789                	lui	a5,0x2
80008076:	71078793          	addi	a5,a5,1808 # 2710 <STACK_SIZE+0x1f10>
8000807a:	fef42423          	sw	a5,-24(s0)
    OperationStatus status = OK;
8000807e:	fe042623          	sw	zero,-20(s0)

    assert_param(IS_RCU_SYS_CLK(SysClk));

    RCU_SysClkConfig(SysClk);
80008082:	fdc42503          	lw	a0,-36(s0)
80008086:	3c69                	jal	80007b20 <RCU_SysClkConfig>

    while (timeout) {
80008088:	0001                	nop
8000808a:	fe842783          	lw	a5,-24(s0)
8000808e:	fff5                	bnez	a5,8000808a <RCU_SysClkChangeCmd+0x22>
        //} else {
        //    break;
       // }
    }

    if (!timeout) {
80008090:	fe842783          	lw	a5,-24(s0)
80008094:	e781                	bnez	a5,8000809c <RCU_SysClkChangeCmd+0x34>
        status = ERROR;
80008096:	4785                	li	a5,1
80008098:	fef42623          	sw	a5,-20(s0)
    }

    return status;
8000809c:	fec42783          	lw	a5,-20(s0)
}
800080a0:	853e                	mv	a0,a5
800080a2:	50b2                	lw	ra,44(sp)
800080a4:	5422                	lw	s0,40(sp)
800080a6:	6145                	addi	sp,sp,48
800080a8:	8082                	ret

800080aa <RCU_SPIRstCmd>:
{
800080aa:	1101                	addi	sp,sp,-32
800080ac:	ce22                	sw	s0,28(sp)
800080ae:	1000                	addi	s0,sp,32
800080b0:	fea42623          	sw	a0,-20(s0)
800080b4:	feb42423          	sw	a1,-24(s0)
    WRITE_REG(RCU->SPICLKCFG[SPIx_Num].SPICLKCFG_bit.RSTDIS, State);
800080b8:	3000e6b7          	lui	a3,0x3000e
800080bc:	fe842783          	lw	a5,-24(s0)
800080c0:	8b85                	andi	a5,a5,1
800080c2:	0ff7f713          	zext.b	a4,a5
800080c6:	fec42783          	lw	a5,-20(s0)
800080ca:	02478793          	addi	a5,a5,36
800080ce:	078a                	slli	a5,a5,0x2
800080d0:	97b6                	add	a5,a5,a3
800080d2:	8b05                	andi	a4,a4,1
800080d4:	0722                	slli	a4,a4,0x8
800080d6:	43d4                	lw	a3,4(a5)
800080d8:	eff6f693          	andi	a3,a3,-257
800080dc:	8f55                	or	a4,a4,a3
800080de:	c3d8                	sw	a4,4(a5)
}
800080e0:	0001                	nop
800080e2:	4472                	lw	s0,28(sp)
800080e4:	6105                	addi	sp,sp,32
800080e6:	8082                	ret

800080e8 <SPI_DataWidthConfig>:
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @param   DataWidth  Значение разрядности слова
  * @retval  void
  */
__STATIC_INLINE void SPI_DataWidthConfig(SPI_TypeDef* SPIx, SPI_DataWidth_TypeDef DataWidth)
{
800080e8:	1101                	addi	sp,sp,-32
800080ea:	ce22                	sw	s0,28(sp)
800080ec:	1000                	addi	s0,sp,32
800080ee:	fea42623          	sw	a0,-20(s0)
800080f2:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_DATA_WIDTH(DataWidth));

    WRITE_REG(SPIx->CR0_bit.DSS, DataWidth);
800080f6:	fe842783          	lw	a5,-24(s0)
800080fa:	8bbd                	andi	a5,a5,15
800080fc:	0ff7f713          	zext.b	a4,a5
80008100:	fec42783          	lw	a5,-20(s0)
80008104:	8b3d                	andi	a4,a4,15
80008106:	0007d683          	lhu	a3,0(a5)
8000810a:	9ac1                	andi	a3,a3,-16
8000810c:	8f55                	or	a4,a4,a3
8000810e:	00e79023          	sh	a4,0(a5)
}
80008112:	0001                	nop
80008114:	4472                	lw	s0,28(sp)
80008116:	6105                	addi	sp,sp,32
80008118:	8082                	ret

8000811a <SPI_ModeConfig>:
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @param   Mode  Выбор режима
  * @retval  void
  */
__STATIC_INLINE void SPI_ModeConfig(SPI_TypeDef* SPIx, SPI_Mode_TypeDef Mode)
{
8000811a:	1101                	addi	sp,sp,-32
8000811c:	ce22                	sw	s0,28(sp)
8000811e:	1000                	addi	s0,sp,32
80008120:	fea42623          	sw	a0,-20(s0)
80008124:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_MODE(Mode));

    WRITE_REG(SPIx->CR1_bit.MS, Mode);
80008128:	fe842783          	lw	a5,-24(s0)
8000812c:	8b85                	andi	a5,a5,1
8000812e:	0ff7f713          	zext.b	a4,a5
80008132:	fec42783          	lw	a5,-20(s0)
80008136:	8b05                	andi	a4,a4,1
80008138:	070a                	slli	a4,a4,0x2
8000813a:	0047d683          	lhu	a3,4(a5)
8000813e:	9aed                	andi	a3,a3,-5
80008140:	8f55                	or	a4,a4,a3
80008142:	00e79223          	sh	a4,4(a5)
}
80008146:	0001                	nop
80008148:	4472                	lw	s0,28(sp)
8000814a:	6105                	addi	sp,sp,32
8000814c:	8082                	ret

8000814e <SPI_FrameFormatConfig>:
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @param   FrameFormat  Выбор формата
  * @retval  void
  */
__STATIC_INLINE void SPI_FrameFormatConfig(SPI_TypeDef* SPIx, SPI_FrameFormat_TypeDef FrameFormat)
{
8000814e:	1101                	addi	sp,sp,-32
80008150:	ce22                	sw	s0,28(sp)
80008152:	1000                	addi	s0,sp,32
80008154:	fea42623          	sw	a0,-20(s0)
80008158:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_FRAME_FORMAT(FrameFormat));

    WRITE_REG(SPIx->CR0_bit.FRF, FrameFormat);
8000815c:	fe842783          	lw	a5,-24(s0)
80008160:	8b8d                	andi	a5,a5,3
80008162:	0ff7f713          	zext.b	a4,a5
80008166:	fec42783          	lw	a5,-20(s0)
8000816a:	8b0d                	andi	a4,a4,3
8000816c:	0712                	slli	a4,a4,0x4
8000816e:	0007d683          	lhu	a3,0(a5)
80008172:	fcf6f693          	andi	a3,a3,-49
80008176:	8f55                	or	a4,a4,a3
80008178:	00e79023          	sh	a4,0(a5)
}
8000817c:	0001                	nop
8000817e:	4472                	lw	s0,28(sp)
80008180:	6105                	addi	sp,sp,32
80008182:	8082                	ret

80008184 <SPI_SCKDivConfig>:
                          Параметр может принимать любые четные значения из диапазона: 2-254.

  * @retval  void
  */
__STATIC_INLINE void SPI_SCKDivConfig(SPI_TypeDef* SPIx, uint32_t SCKDiv, uint32_t SCKDivExtra)
{
80008184:	1101                	addi	sp,sp,-32
80008186:	ce22                	sw	s0,28(sp)
80008188:	1000                	addi	s0,sp,32
8000818a:	fea42623          	sw	a0,-20(s0)
8000818e:	feb42423          	sw	a1,-24(s0)
80008192:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_SPI_PERIPH(SPIx));
    assert_param(IS_SPI_SCK_DIV(SCKDiv));
    assert_param(IS_SPI_SCK_DIV_EXTRA(SCKDivExtra));

    WRITE_REG(SPIx->CR0_bit.SCR, SCKDiv);
80008196:	fe842783          	lw	a5,-24(s0)
8000819a:	0ff7f713          	zext.b	a4,a5
8000819e:	fec42783          	lw	a5,-20(s0)
800081a2:	00e780a3          	sb	a4,1(a5)
    WRITE_REG(SPIx->CPSR, SCKDivExtra);
800081a6:	fec42783          	lw	a5,-20(s0)
800081aa:	fe442703          	lw	a4,-28(s0)
800081ae:	cb98                	sw	a4,16(a5)
}
800081b0:	0001                	nop
800081b2:	4472                	lw	s0,28(sp)
800081b4:	6105                	addi	sp,sp,32
800081b6:	8082                	ret

800081b8 <SPI_DeInit>:
  * @brief   Устанавливает все регистры SPI значениями по умолчанию
  * @param   SPIx  Выбор модуля SPI, где x=0|1
  * @retval  void
  */
void SPI_DeInit(SPI_TypeDef* SPIx)
{
800081b8:	7179                	addi	sp,sp,-48
800081ba:	d606                	sw	ra,44(sp)
800081bc:	d422                	sw	s0,40(sp)
800081be:	1800                	addi	s0,sp,48
800081c0:	fca42e23          	sw	a0,-36(s0)
    SPI_Num_TypeDef SPIx_Num;
    assert_param(IS_SPI_PERIPH(SPIx));

    if (SPIx == SPI0) {
800081c4:	fdc42703          	lw	a4,-36(s0)
800081c8:	200507b7          	lui	a5,0x20050
800081cc:	00f71563          	bne	a4,a5,800081d6 <SPI_DeInit+0x1e>
        SPIx_Num = SPI0_Num;
800081d0:	fe042623          	sw	zero,-20(s0)
800081d4:	a811                	j	800081e8 <SPI_DeInit+0x30>
    } else if (SPIx == SPI1) {
800081d6:	fdc42703          	lw	a4,-36(s0)
800081da:	200607b7          	lui	a5,0x20060
800081de:	00f71563          	bne	a4,a5,800081e8 <SPI_DeInit+0x30>
        SPIx_Num = SPI1_Num;
800081e2:	4785                	li	a5,1
800081e4:	fef42623          	sw	a5,-20(s0)
    }

    RCU_SPIRstCmd(SPIx_Num, DISABLE);
800081e8:	4581                	li	a1,0
800081ea:	fec42503          	lw	a0,-20(s0)
800081ee:	3d75                	jal	800080aa <RCU_SPIRstCmd>
    RCU_SPIRstCmd(SPIx_Num, ENABLE);
800081f0:	4585                	li	a1,1
800081f2:	fec42503          	lw	a0,-20(s0)
800081f6:	3d55                	jal	800080aa <RCU_SPIRstCmd>
}
800081f8:	0001                	nop
800081fa:	50b2                	lw	ra,44(sp)
800081fc:	5422                	lw	s0,40(sp)
800081fe:	6145                	addi	sp,sp,48
80008200:	8082                	ret

80008202 <SPI_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref SPI_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_Init_TypeDef* InitStruct)
{
80008202:	1101                	addi	sp,sp,-32
80008204:	ce06                	sw	ra,28(sp)
80008206:	cc22                	sw	s0,24(sp)
80008208:	1000                	addi	s0,sp,32
8000820a:	fea42623          	sw	a0,-20(s0)
8000820e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_SPI_PERIPH(SPIx));

    SPI_SCKDivConfig(SPIx, InitStruct->SCKDiv, InitStruct->SCKDivExtra);
80008212:	fe842783          	lw	a5,-24(s0)
80008216:	47d8                	lw	a4,12(a5)
80008218:	fe842783          	lw	a5,-24(s0)
8000821c:	4b9c                	lw	a5,16(a5)
8000821e:	863e                	mv	a2,a5
80008220:	85ba                	mv	a1,a4
80008222:	fec42503          	lw	a0,-20(s0)
80008226:	3fb9                	jal	80008184 <SPI_SCKDivConfig>
    SPI_DataWidthConfig(SPIx, InitStruct->DataWidth);
80008228:	fe842783          	lw	a5,-24(s0)
8000822c:	479c                	lw	a5,8(a5)
8000822e:	85be                	mv	a1,a5
80008230:	fec42503          	lw	a0,-20(s0)
80008234:	3d55                	jal	800080e8 <SPI_DataWidthConfig>
    SPI_FrameFormatConfig(SPIx, InitStruct->FrameFormat);
80008236:	fe842783          	lw	a5,-24(s0)
8000823a:	43dc                	lw	a5,4(a5)
8000823c:	85be                	mv	a1,a5
8000823e:	fec42503          	lw	a0,-20(s0)
80008242:	3731                	jal	8000814e <SPI_FrameFormatConfig>
    SPI_ModeConfig(SPIx, InitStruct->Mode);
80008244:	fe842783          	lw	a5,-24(s0)
80008248:	439c                	lw	a5,0(a5)
8000824a:	85be                	mv	a1,a5
8000824c:	fec42503          	lw	a0,-20(s0)
80008250:	35e9                	jal	8000811a <SPI_ModeConfig>
}
80008252:	0001                	nop
80008254:	40f2                	lw	ra,28(sp)
80008256:	4462                	lw	s0,24(sp)
80008258:	6105                	addi	sp,sp,32
8000825a:	8082                	ret

8000825c <SPI_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref SPI_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void SPI_StructInit(SPI_Init_TypeDef* InitStruct)
{
8000825c:	1101                	addi	sp,sp,-32
8000825e:	ce22                	sw	s0,28(sp)
80008260:	1000                	addi	s0,sp,32
80008262:	fea42623          	sw	a0,-20(s0)
    InitStruct->SCKDiv = 0;
80008266:	fec42783          	lw	a5,-20(s0)
8000826a:	0007a623          	sw	zero,12(a5) # 2006000c <STACK_SIZE+0x2005f80c>
    InitStruct->SCKDivExtra = 2;
8000826e:	fec42783          	lw	a5,-20(s0)
80008272:	4709                	li	a4,2
80008274:	cb98                	sw	a4,16(a5)
    InitStruct->DataWidth = SPI_DataWidth_8;
80008276:	fec42783          	lw	a5,-20(s0)
8000827a:	471d                	li	a4,7
8000827c:	c798                	sw	a4,8(a5)
    InitStruct->FrameFormat = SPI_FrameFormat_SPI;
8000827e:	fec42783          	lw	a5,-20(s0)
80008282:	0007a223          	sw	zero,4(a5)
    InitStruct->Mode = SPI_Mode_Master;
80008286:	fec42783          	lw	a5,-20(s0)
8000828a:	0007a023          	sw	zero,0(a5)
}
8000828e:	0001                	nop
80008290:	4472                	lw	s0,28(sp)
80008292:	6105                	addi	sp,sp,32
80008294:	8082                	ret

80008296 <RCU_APBClkCmd>:
{
80008296:	1101                	addi	sp,sp,-32
80008298:	ce22                	sw	s0,28(sp)
8000829a:	1000                	addi	s0,sp,32
8000829c:	fea42623          	sw	a0,-20(s0)
800082a0:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->CGCFGAPB, APBClk, State ? APBClk : 0);
800082a4:	3000e7b7          	lui	a5,0x3000e
800082a8:	4798                	lw	a4,8(a5)
800082aa:	fec42783          	lw	a5,-20(s0)
800082ae:	fff7c793          	not	a5,a5
800082b2:	00f776b3          	and	a3,a4,a5
800082b6:	fe842783          	lw	a5,-24(s0)
800082ba:	c781                	beqz	a5,800082c2 <RCU_APBClkCmd+0x2c>
800082bc:	fec42783          	lw	a5,-20(s0)
800082c0:	a011                	j	800082c4 <RCU_APBClkCmd+0x2e>
800082c2:	4781                	li	a5,0
800082c4:	3000e737          	lui	a4,0x3000e
800082c8:	8fd5                	or	a5,a5,a3
800082ca:	c71c                	sw	a5,8(a4)
}
800082cc:	0001                	nop
800082ce:	4472                	lw	s0,28(sp)
800082d0:	6105                	addi	sp,sp,32
800082d2:	8082                	ret

800082d4 <RCU_APBRstCmd>:
{
800082d4:	1101                	addi	sp,sp,-32
800082d6:	ce22                	sw	s0,28(sp)
800082d8:	1000                	addi	s0,sp,32
800082da:	fea42623          	sw	a0,-20(s0)
800082de:	feb42423          	sw	a1,-24(s0)
    MODIFY_REG(RCU->RSTDISAPB, APBRst, State ? APBRst : 0);
800082e2:	3000e7b7          	lui	a5,0x3000e
800082e6:	4f98                	lw	a4,24(a5)
800082e8:	fec42783          	lw	a5,-20(s0)
800082ec:	fff7c793          	not	a5,a5
800082f0:	00f776b3          	and	a3,a4,a5
800082f4:	fe842783          	lw	a5,-24(s0)
800082f8:	c781                	beqz	a5,80008300 <RCU_APBRstCmd+0x2c>
800082fa:	fec42783          	lw	a5,-20(s0)
800082fe:	a011                	j	80008302 <RCU_APBRstCmd+0x2e>
80008300:	4781                	li	a5,0
80008302:	3000e737          	lui	a4,0x3000e
80008306:	8fd5                	or	a5,a5,a3
80008308:	cf1c                	sw	a5,24(a4)
}
8000830a:	0001                	nop
8000830c:	4472                	lw	s0,28(sp)
8000830e:	6105                	addi	sp,sp,32
80008310:	8082                	ret

80008312 <TRNG_StartCmd>:
  * @brief   Запуск ИГСЧ
  * @param   state Состояние запуска ИГСЧ
  * @retval  void
  */
__STATIC_INLINE void TRNG_StartCmd(FunctionalState state)
{
80008312:	1101                	addi	sp,sp,-32
80008314:	ce22                	sw	s0,28(sp)
80008316:	1000                	addi	s0,sp,32
80008318:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_START_Msk, state << TRNG_CR_START_Pos);
8000831c:	300047b7          	lui	a5,0x30004
80008320:	439c                	lw	a5,0(a5)
80008322:	ffe7f693          	andi	a3,a5,-2
80008326:	300047b7          	lui	a5,0x30004
8000832a:	fec42703          	lw	a4,-20(s0)
8000832e:	8f55                	or	a4,a4,a3
80008330:	c398                	sw	a4,0(a5)
}
80008332:	0001                	nop
80008334:	4472                	lw	s0,28(sp)
80008336:	6105                	addi	sp,sp,32
80008338:	8082                	ret

8000833a <TRNG_PseudorandomGeneratorCmd>:
  * @brief   Выбор между ИГСЧ и псевдослучайным генератором
  * @param   state Выбор режима 0 - ИГСЧ асинхронный независимый генератор, 1 - псевдослучайный генератор
  * @retval  void
  */
__STATIC_INLINE void TRNG_PseudorandomGeneratorCmd(FunctionalState state)
{
8000833a:	1101                	addi	sp,sp,-32
8000833c:	ce22                	sw	s0,28(sp)
8000833e:	1000                	addi	s0,sp,32
80008340:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_LFSR_Msk, state << TRNG_CR_LFSR_Pos);
80008344:	300047b7          	lui	a5,0x30004
80008348:	439c                	lw	a5,0(a5)
8000834a:	ffd7f693          	andi	a3,a5,-3
8000834e:	fec42783          	lw	a5,-20(s0)
80008352:	00179713          	slli	a4,a5,0x1
80008356:	300047b7          	lui	a5,0x30004
8000835a:	8f55                	or	a4,a4,a3
8000835c:	c398                	sw	a4,0(a5)
}
8000835e:	0001                	nop
80008360:	4472                	lw	s0,28(sp)
80008362:	6105                	addi	sp,sp,32
80008364:	8082                	ret

80008366 <TRNG_BypassHandlerCmd>:
  * @brief   Пропуск функции обработки
  * @param   state Флаг использования функции обработки 0 - использование функции обработки, 1 - пропуск функции обработки
  * @retval  void
  */
__STATIC_INLINE void TRNG_BypassHandlerCmd(FunctionalState state)
{
80008366:	1101                	addi	sp,sp,-32
80008368:	ce22                	sw	s0,28(sp)
8000836a:	1000                	addi	s0,sp,32
8000836c:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_CONDBYPASS_Msk, state << TRNG_CR_CONDBYPASS_Pos);
80008370:	300047b7          	lui	a5,0x30004
80008374:	439c                	lw	a5,0(a5)
80008376:	ff77f693          	andi	a3,a5,-9
8000837a:	fec42783          	lw	a5,-20(s0)
8000837e:	00379713          	slli	a4,a5,0x3
80008382:	300047b7          	lui	a5,0x30004
80008386:	8f55                	or	a4,a4,a3
80008388:	c398                	sw	a4,0(a5)
}
8000838a:	0001                	nop
8000838c:	4472                	lw	s0,28(sp)
8000838e:	6105                	addi	sp,sp,32
80008390:	8082                	ret

80008392 <TRNG_SwResetCmd>:
  * 		 Этот бит не очищается автоматически!
  * @param   state Флаг включения сброса
  * @retval  void
  */
__STATIC_INLINE void TRNG_SwResetCmd(FunctionalState state)
{
80008392:	1101                	addi	sp,sp,-32
80008394:	ce22                	sw	s0,28(sp)
80008396:	1000                	addi	s0,sp,32
80008398:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_SOFTRST_Msk, state << TRNG_CR_SOFTRST_Pos);
8000839c:	300047b7          	lui	a5,0x30004
800083a0:	439c                	lw	a5,0(a5)
800083a2:	eff7f693          	andi	a3,a5,-257
800083a6:	fec42783          	lw	a5,-20(s0)
800083aa:	00879713          	slli	a4,a5,0x8
800083ae:	300047b7          	lui	a5,0x30004
800083b2:	8f55                	or	a4,a4,a3
800083b4:	c398                	sw	a4,0(a5)
}
800083b6:	0001                	nop
800083b8:	4472                	lw	s0,28(sp)
800083ba:	6105                	addi	sp,sp,32
800083bc:	8082                	ret

800083be <TRNG_ForceGeneratorCmd>:
  * @brief   Принудительный запуск генераторов, когда FIFO заполнен
  * @param   state Флаг принудительного запуска генераторов
  * @retval  void
  */
__STATIC_INLINE void TRNG_ForceGeneratorCmd(FunctionalState state)
{
800083be:	1101                	addi	sp,sp,-32
800083c0:	ce22                	sw	s0,28(sp)
800083c2:	1000                	addi	s0,sp,32
800083c4:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_FORCEROS_Msk, state << TRNG_CR_FORCEROS_Pos);
800083c8:	300047b7          	lui	a5,0x30004
800083cc:	4398                	lw	a4,0(a5)
800083ce:	77fd                	lui	a5,0xfffff
800083d0:	7ff78793          	addi	a5,a5,2047 # fffff7ff <__data_source_start+0x7fff69ab>
800083d4:	00f776b3          	and	a3,a4,a5
800083d8:	fec42783          	lw	a5,-20(s0)
800083dc:	00b79713          	slli	a4,a5,0xb
800083e0:	300047b7          	lui	a5,0x30004
800083e4:	8f55                	or	a4,a4,a3
800083e6:	c398                	sw	a4,0(a5)
}
800083e8:	0001                	nop
800083ea:	4472                	lw	s0,28(sp)
800083ec:	6105                	addi	sp,sp,32
800083ee:	8082                	ret

800083f0 <TRNG_SetBlockAmountForHandler>:
  * @param   countBlock Количество блоков для функции обработки
  * 		 Нулевое значение не допускается
  * @retval  void
  */
__STATIC_INLINE void TRNG_SetBlockAmountForHandler(uint32_t countBlock)
{
800083f0:	1101                	addi	sp,sp,-32
800083f2:	ce22                	sw	s0,28(sp)
800083f4:	1000                	addi	s0,sp,32
800083f6:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TRNG_COUNTBLOCK(countBlock));

	MODIFY_REG(TRNG->CR, TRNG_CR_COUNTBLOCK_Msk, countBlock << TRNG_CR_COUNTBLOCK_Pos);
800083fa:	300047b7          	lui	a5,0x30004
800083fe:	4398                	lw	a4,0(a5)
80008400:	fff107b7          	lui	a5,0xfff10
80008404:	17fd                	addi	a5,a5,-1 # fff0ffff <__data_source_start+0x7ff071ab>
80008406:	00f776b3          	and	a3,a4,a5
8000840a:	fec42783          	lw	a5,-20(s0)
8000840e:	01079713          	slli	a4,a5,0x10
80008412:	300047b7          	lui	a5,0x30004
80008416:	8f55                	or	a4,a4,a3
80008418:	c398                	sw	a4,0(a5)
}
8000841a:	0001                	nop
8000841c:	4472                	lw	s0,28(sp)
8000841e:	6105                	addi	sp,sp,32
80008420:	8082                	ret

80008422 <TRNG_FIFOfillOnStartCmd>:
  * @brief   Разрешение записи выборок в FIFO во время запуска
  * @param   state Флаг разрешения записи
  * @retval  void
  */
__STATIC_INLINE void TRNG_FIFOfillOnStartCmd(FunctionalState state)
{
80008422:	1101                	addi	sp,sp,-32
80008424:	ce22                	sw	s0,28(sp)
80008426:	1000                	addi	s0,sp,32
80008428:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_FUNCTIONAL_STATE(state));

	MODIFY_REG(TRNG->CR, TRNG_CR_FIFOFILLST_Msk, state << TRNG_CR_FIFOFILLST_Pos);
8000842c:	300047b7          	lui	a5,0x30004
80008430:	4398                	lw	a4,0(a5)
80008432:	fff007b7          	lui	a5,0xfff00
80008436:	17fd                	addi	a5,a5,-1 # ffefffff <__data_source_start+0x7fef71ab>
80008438:	00f776b3          	and	a3,a4,a5
8000843c:	fec42783          	lw	a5,-20(s0)
80008440:	01479713          	slli	a4,a5,0x14
80008444:	300047b7          	lui	a5,0x30004
80008448:	8f55                	or	a4,a4,a3
8000844a:	c398                	sw	a4,0(a5)
}
8000844c:	0001                	nop
8000844e:	4472                	lw	s0,28(sp)
80008450:	6105                	addi	sp,sp,32
80008452:	8082                	ret

80008454 <TRNG_BlendMethodConfig>:
  * @brief   Выбор метода смешивания
  * @param   method метод смешнивания
  * @retval  void
  */
__STATIC_INLINE void TRNG_BlendMethodConfig(TRNG_BLENDMETHOD_TypeDef method)
{
80008454:	1101                	addi	sp,sp,-32
80008456:	ce22                	sw	s0,28(sp)
80008458:	1000                	addi	s0,sp,32
8000845a:	fea42623          	sw	a0,-20(s0)
	assert_param(IS_TRNG_BLENDMETHOD(method));

	MODIFY_REG(TRNG->CR, TRNG_CR_BLENDMETHOD_Msk, method << TRNG_CR_BLENDMETHOD_Pos);
8000845e:	300047b7          	lui	a5,0x30004
80008462:	4398                	lw	a4,0(a5)
80008464:	400007b7          	lui	a5,0x40000
80008468:	17fd                	addi	a5,a5,-1 # 3fffffff <STACK_SIZE+0x3ffff7ff>
8000846a:	00f776b3          	and	a3,a4,a5
8000846e:	fec42783          	lw	a5,-20(s0)
80008472:	01e79713          	slli	a4,a5,0x1e
80008476:	300047b7          	lui	a5,0x30004
8000847a:	8f55                	or	a4,a4,a3
8000847c:	c398                	sw	a4,0(a5)
}
8000847e:	0001                	nop
80008480:	4472                	lw	s0,28(sp)
80008482:	6105                	addi	sp,sp,32
80008484:	8082                	ret

80008486 <TRNG_GetFIFOlength>:
/**
  * @brief   Получение количества доступных 32-битных слов в буфере FIFO
  * @retval  length количество доступных 32-битных слов в буфере FIFO
  */
__STATIC_INLINE uint32_t TRNG_GetFIFOlength()
{
80008486:	1141                	addi	sp,sp,-16
80008488:	c622                	sw	s0,12(sp)
8000848a:	0800                	addi	s0,sp,16
	return (uint32_t) READ_REG(TRNG->FIFOLEV);
8000848c:	300047b7          	lui	a5,0x30004
80008490:	43dc                	lw	a5,4(a5)
}
80008492:	853e                	mv	a0,a5
80008494:	4432                	lw	s0,12(sp)
80008496:	0141                	addi	sp,sp,16
80008498:	8082                	ret

8000849a <TRNG_GetFIFOValue>:
/**
  * @brief   Получение значение в FIFO буфере
  * @retval  Val значение ячейки в FIFO
  */
__STATIC_INLINE uint32_t TRNG_GetFIFOValue()
{
8000849a:	1141                	addi	sp,sp,-16
8000849c:	c622                	sw	s0,12(sp)
8000849e:	0800                	addi	s0,sp,16
	return (uint32_t) READ_REG(TRNG->FIFO[0].FIFO);
800084a0:	300047b7          	lui	a5,0x30004
800084a4:	0807a783          	lw	a5,128(a5) # 30004080 <STACK_SIZE+0x30003880>
}
800084a8:	853e                	mv	a0,a5
800084aa:	4432                	lw	s0,12(sp)
800084ac:	0141                	addi	sp,sp,16
800084ae:	8082                	ret

800084b0 <TRNG_DeInit>:
/**
  * @brief   Устанавливает все регистры TRNG значениями по умолчанию
  * @retval  void
  */
void TRNG_DeInit()
{
800084b0:	1141                	addi	sp,sp,-16
800084b2:	c606                	sw	ra,12(sp)
800084b4:	c422                	sw	s0,8(sp)
800084b6:	0800                	addi	s0,sp,16
	TRNG_SwResetCmd(ENABLE);
800084b8:	4505                	li	a0,1
800084ba:	3de1                	jal	80008392 <TRNG_SwResetCmd>

    RCU_APBRstCmd(RCU_APBRst_TRNG, DISABLE);
800084bc:	4581                	li	a1,0
800084be:	4541                	li	a0,16
800084c0:	3d11                	jal	800082d4 <RCU_APBRstCmd>
    RCU_APBRstCmd(RCU_APBRst_TRNG, ENABLE);
800084c2:	4585                	li	a1,1
800084c4:	4541                	li	a0,16
800084c6:	3539                	jal	800082d4 <RCU_APBRstCmd>

    TRNG_SwResetCmd(DISABLE);
800084c8:	4501                	li	a0,0
800084ca:	35e1                	jal	80008392 <TRNG_SwResetCmd>
}
800084cc:	0001                	nop
800084ce:	40b2                	lw	ra,12(sp)
800084d0:	4422                	lw	s0,8(sp)
800084d2:	0141                	addi	sp,sp,16
800084d4:	8082                	ret

800084d6 <TRNG_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref TRNG_Init_TypeDef,
  *                      которая содержит конфигурационную информацию
  * @retval  void
  */
void TRNG_Init(TRNG_Init_TypeDef* InitStruct)
{
800084d6:	1101                	addi	sp,sp,-32
800084d8:	ce06                	sw	ra,28(sp)
800084da:	cc22                	sw	s0,24(sp)
800084dc:	1000                	addi	s0,sp,32
800084de:	fea42623          	sw	a0,-20(s0)
	TRNG_PseudorandomGeneratorCmd(InitStruct->PseudoRandomEnable);
800084e2:	fec42783          	lw	a5,-20(s0)
800084e6:	439c                	lw	a5,0(a5)
800084e8:	853e                	mv	a0,a5
800084ea:	3d81                	jal	8000833a <TRNG_PseudorandomGeneratorCmd>
//	TRNG_TestSourceCmd(InitStruct->TestSourceEnable);
	TRNG_BypassHandlerCmd(InitStruct->BypassHandler);
800084ec:	fec42783          	lw	a5,-20(s0)
800084f0:	43dc                	lw	a5,4(a5)
800084f2:	853e                	mv	a0,a5
800084f4:	3d8d                	jal	80008366 <TRNG_BypassHandlerCmd>
//	TRNG_ITTestFailCmd(InitStruct->ITOnAnyTestFail);
//	TRNG_ITFIFOfullCmd(InitStruct->ITOnFIFOfull);
	TRNG_ForceGeneratorCmd(InitStruct->ForceGenerator);
800084f6:	fec42783          	lw	a5,-20(s0)
800084fa:	479c                	lw	a5,8(a5)
800084fc:	853e                	mv	a0,a5
800084fe:	35c1                	jal	800083be <TRNG_ForceGeneratorCmd>
//	TRNG_IgnoreHardwareTestsCmd(InitStruct->IgnoreHardwareTests);
	TRNG_SetBlockAmountForHandler(InitStruct->AmountBlocksForHandler);
80008500:	fec42783          	lw	a5,-20(s0)
80008504:	47dc                	lw	a5,12(a5)
80008506:	853e                	mv	a0,a5
80008508:	35e5                	jal	800083f0 <TRNG_SetBlockAmountForHandler>
	TRNG_FIFOfillOnStartCmd(InitStruct->FIFOfillOnStart);
8000850a:	fec42783          	lw	a5,-20(s0)
8000850e:	4b9c                	lw	a5,16(a5)
80008510:	853e                	mv	a0,a5
80008512:	3f01                	jal	80008422 <TRNG_FIFOfillOnStartCmd>
//	TRNG_RepeatTestDisableCmd(InitStruct->RepeatTestDisable);
//	TRNG_ProportionTestDisableCmd(InitStruct->ProportionTestDisable);
//	TRNG_AutoCorrelationTestDisableConfig(InitStruct->AutocorrelationTestDisable);
//	TRNG_CorrelationTestDisableConfig(InitStruct->CorrelationTestDisable);
	TRNG_BlendMethodConfig(InitStruct->BlendMethod);
80008514:	fec42783          	lw	a5,-20(s0)
80008518:	4bdc                	lw	a5,20(a5)
8000851a:	853e                	mv	a0,a5
8000851c:	3f25                	jal	80008454 <TRNG_BlendMethodConfig>
	TRNG_SwResetCmd(DISABLE);
8000851e:	4501                	li	a0,0
80008520:	3d8d                	jal	80008392 <TRNG_SwResetCmd>
}
80008522:	0001                	nop
80008524:	40f2                	lw	ra,28(sp)
80008526:	4462                	lw	s0,24(sp)
80008528:	6105                	addi	sp,sp,32
8000852a:	8082                	ret

8000852c <TRNG_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref TRNG_Init_TypeDef,
  *                      которую необходимо проинициализировать
  * @retval  void
  */
void TRNG_StructInit(TRNG_Init_TypeDef* InitStruct)
{
8000852c:	1101                	addi	sp,sp,-32
8000852e:	ce22                	sw	s0,28(sp)
80008530:	1000                	addi	s0,sp,32
80008532:	fea42623          	sw	a0,-20(s0)
	InitStruct->PseudoRandomEnable = DISABLE;
80008536:	fec42783          	lw	a5,-20(s0)
8000853a:	0007a023          	sw	zero,0(a5)
//	InitStruct->TestSourceEnable = DISABLE;
	InitStruct->BypassHandler = DISABLE;
8000853e:	fec42783          	lw	a5,-20(s0)
80008542:	0007a223          	sw	zero,4(a5)
//	InitStruct->ITOnAnyTestFail = DISABLE;
//	InitStruct->ITOnFIFOfull = DISABLE;
	InitStruct->ForceGenerator = DISABLE;
80008546:	fec42783          	lw	a5,-20(s0)
8000854a:	0007a423          	sw	zero,8(a5)
//	InitStruct->IgnoreHardwareTests = DISABLE;
	InitStruct->AmountBlocksForHandler = 0x0;
8000854e:	fec42783          	lw	a5,-20(s0)
80008552:	0007a623          	sw	zero,12(a5)
	InitStruct->FIFOfillOnStart = DISABLE;
80008556:	fec42783          	lw	a5,-20(s0)
8000855a:	0007a823          	sw	zero,16(a5)
//	InitStruct->RepeatTestDisable = DISABLE;
//	InitStruct->ProportionTestDisable = DISABLE;
//	InitStruct->AutocorrelationTestDisable = TRNG_AUTOCORRELATIONDISABLE_Nothing;
//	InitStruct->CorrelationTestDisable = TRNG_CORRELATIONDISABLE_Nothing;
	InitStruct->BlendMethod = TRNG_BLENDMETHOD_Concatenation;
8000855e:	fec42783          	lw	a5,-20(s0)
80008562:	0007aa23          	sw	zero,20(a5)
	InitStruct->WarmPeriod = 0x00000200;
80008566:	fec42783          	lw	a5,-20(s0)
8000856a:	20000713          	li	a4,512
8000856e:	cf98                	sw	a4,24(a5)
	InitStruct->CoolPeriod = 0x00000000;
80008570:	fec42783          	lw	a5,-20(s0)
80008574:	0007ae23          	sw	zero,28(a5)
	InitStruct->SamplePeriod = 0x0000001E;
80008578:	fec42783          	lw	a5,-20(s0)
8000857c:	4779                	li	a4,30
8000857e:	d398                	sw	a4,32(a5)
}
80008580:	0001                	nop
80008582:	4472                	lw	s0,28(sp)
80008584:	6105                	addi	sp,sp,32
80008586:	8082                	ret

80008588 <TRNG_GenerateKey>:
  * @param   key Ссылка на память, куда будет сохранен ключ размерности keyLength
  * @param   keyLength Размерность ключа в 32-битных словах
  * @retval  void
  */
void TRNG_GenerateKey(uint32_t *key, uint32_t keyLength)
{
80008588:	715d                	addi	sp,sp,-80
8000858a:	c686                	sw	ra,76(sp)
8000858c:	c4a2                	sw	s0,72(sp)
8000858e:	c2a6                	sw	s1,68(sp)
80008590:	0880                	addi	s0,sp,80
80008592:	faa42e23          	sw	a0,-68(s0)
80008596:	fab42c23          	sw	a1,-72(s0)
	TRNG_DeInit();
8000859a:	3f19                	jal	800084b0 <TRNG_DeInit>
	RCU_APBClkCmd(RCU_APBClk_TRNG, ENABLE);
8000859c:	4585                	li	a1,1
8000859e:	4541                	li	a0,16
800085a0:	39dd                	jal	80008296 <RCU_APBClkCmd>
	RCU_APBRstCmd(RCU_APBRst_TRNG, ENABLE);
800085a2:	4585                	li	a1,1
800085a4:	4541                	li	a0,16
800085a6:	333d                	jal	800082d4 <RCU_APBRstCmd>
	TRNG_SwResetCmd(ENABLE);
800085a8:	4505                	li	a0,1
800085aa:	33e5                	jal	80008392 <TRNG_SwResetCmd>
	TRNG_Init_TypeDef trngInit;
	TRNG_StructInit(&trngInit);
800085ac:	fcc40793          	addi	a5,s0,-52
800085b0:	853e                	mv	a0,a5
800085b2:	3fad                	jal	8000852c <TRNG_StructInit>

	// Start filling FIFO with noise source, with conditioning, all start-up tests and wait until interrupt triggers
	trngInit.WarmPeriod       = 0x00000200; //
800085b4:	20000793          	li	a5,512
800085b8:	fef42223          	sw	a5,-28(s0)
	trngInit.SamplePeriod     = 0x00000020;
800085bc:	02000793          	li	a5,32
800085c0:	fef42623          	sw	a5,-20(s0)
	trngInit.CoolPeriod       = 0x00000000;
800085c4:	fe042423          	sw	zero,-24(s0)
	trngInit.AmountBlocksForHandler = 0x4;
800085c8:	4791                	li	a5,4
800085ca:	fcf42c23          	sw	a5,-40(s0)
	trngInit.BypassHandler    = DISABLE;
800085ce:	fc042823          	sw	zero,-48(s0)

	TRNG_Init(&trngInit);
800085d2:	fcc40793          	addi	a5,s0,-52
800085d6:	853e                	mv	a0,a5
800085d8:	3dfd                	jal	800084d6 <TRNG_Init>

	TRNG_StartCmd(ENABLE);
800085da:	4505                	li	a0,1
800085dc:	3b1d                	jal	80008312 <TRNG_StartCmd>

	while (TRNG_GetFIFOlength() != keyLength) {}
800085de:	0001                	nop
800085e0:	355d                	jal	80008486 <TRNG_GetFIFOlength>
800085e2:	872a                	mv	a4,a0
800085e4:	fb842783          	lw	a5,-72(s0)
800085e8:	fee79ce3          	bne	a5,a4,800085e0 <TRNG_GenerateKey+0x58>

	TRNG_StartCmd(DISABLE);
800085ec:	4501                	li	a0,0
800085ee:	3315                	jal	80008312 <TRNG_StartCmd>

	while (keyLength--)
800085f0:	a811                	j	80008604 <TRNG_GenerateKey+0x7c>
	{
		*key++ = TRNG_GetFIFOValue();
800085f2:	fbc42483          	lw	s1,-68(s0)
800085f6:	00448793          	addi	a5,s1,4
800085fa:	faf42e23          	sw	a5,-68(s0)
800085fe:	3d71                	jal	8000849a <TRNG_GetFIFOValue>
80008600:	87aa                	mv	a5,a0
80008602:	c09c                	sw	a5,0(s1)
	while (keyLength--)
80008604:	fb842783          	lw	a5,-72(s0)
80008608:	fff78713          	addi	a4,a5,-1
8000860c:	fae42c23          	sw	a4,-72(s0)
80008610:	f3ed                	bnez	a5,800085f2 <TRNG_GenerateKey+0x6a>
	}

	TRNG_SwResetCmd(ENABLE);
80008612:	4505                	li	a0,1
80008614:	3bbd                	jal	80008392 <TRNG_SwResetCmd>
}
80008616:	0001                	nop
80008618:	40b6                	lw	ra,76(sp)
8000861a:	4426                	lw	s0,72(sp)
8000861c:	4496                	lw	s1,68(sp)
8000861e:	6161                	addi	sp,sp,80
80008620:	8082                	ret

80008622 <RCU_UARTRstCmd>:
{
80008622:	1101                	addi	sp,sp,-32
80008624:	ce22                	sw	s0,28(sp)
80008626:	1000                	addi	s0,sp,32
80008628:	fea42623          	sw	a0,-20(s0)
8000862c:	feb42423          	sw	a1,-24(s0)
    WRITE_REG(RCU->UARTCLKCFG[UARTx_Num].UARTCLKCFG_bit.RSTDIS, State);
80008630:	3000e6b7          	lui	a3,0x3000e
80008634:	fe842783          	lw	a5,-24(s0)
80008638:	8b85                	andi	a5,a5,1
8000863a:	0ff7f713          	zext.b	a4,a5
8000863e:	fec42783          	lw	a5,-20(s0)
80008642:	07f1                	addi	a5,a5,28
80008644:	078a                	slli	a5,a5,0x2
80008646:	97b6                	add	a5,a5,a3
80008648:	8b05                	andi	a4,a4,1
8000864a:	0722                	slli	a4,a4,0x8
8000864c:	4394                	lw	a3,0(a5)
8000864e:	eff6f693          	andi	a3,a3,-257
80008652:	8f55                	or	a4,a4,a3
80008654:	c398                	sw	a4,0(a5)
}
80008656:	0001                	nop
80008658:	4472                	lw	s0,28(sp)
8000865a:	6105                	addi	sp,sp,32
8000865c:	8082                	ret

8000865e <UART_DataWidthConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3
  * @param   DataWidth  Значение разрядности слова
  * @retval  void
  */
__STATIC_INLINE void UART_DataWidthConfig(UART_TypeDef* UARTx, UART_DataWidth_TypeDef DataWidth)
{
8000865e:	1101                	addi	sp,sp,-32
80008660:	ce22                	sw	s0,28(sp)
80008662:	1000                	addi	s0,sp,32
80008664:	fea42623          	sw	a0,-20(s0)
80008668:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_DATA_WIDTH(DataWidth));

    WRITE_REG(UARTx->LCRH_bit.WLEN, DataWidth);
8000866c:	fe842783          	lw	a5,-24(s0)
80008670:	8b8d                	andi	a5,a5,3
80008672:	0ff7f713          	zext.b	a4,a5
80008676:	fec42783          	lw	a5,-20(s0)
8000867a:	8b0d                	andi	a4,a4,3
8000867c:	0716                	slli	a4,a4,0x5
8000867e:	02c7c683          	lbu	a3,44(a5)
80008682:	f9f6f693          	andi	a3,a3,-97
80008686:	8f55                	or	a4,a4,a3
80008688:	02e78623          	sb	a4,44(a5)
}
8000868c:	0001                	nop
8000868e:	4472                	lw	s0,28(sp)
80008690:	6105                	addi	sp,sp,32
80008692:	8082                	ret

80008694 <UART_StopBitConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3
  * @param   StopBit  Количество стоп-бит
  * @retval  void
  */
__STATIC_INLINE void UART_StopBitConfig(UART_TypeDef* UARTx, UART_StopBit_TypeDef StopBit)
{
80008694:	1101                	addi	sp,sp,-32
80008696:	ce22                	sw	s0,28(sp)
80008698:	1000                	addi	s0,sp,32
8000869a:	fea42623          	sw	a0,-20(s0)
8000869e:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_STOP_BIT(StopBit));

    WRITE_REG(UARTx->LCRH_bit.STP2, StopBit);
800086a2:	fe842783          	lw	a5,-24(s0)
800086a6:	8b85                	andi	a5,a5,1
800086a8:	0ff7f713          	zext.b	a4,a5
800086ac:	fec42783          	lw	a5,-20(s0)
800086b0:	8b05                	andi	a4,a4,1
800086b2:	070e                	slli	a4,a4,0x3
800086b4:	02c7c683          	lbu	a3,44(a5)
800086b8:	9add                	andi	a3,a3,-9
800086ba:	8f55                	or	a4,a4,a3
800086bc:	02e78623          	sb	a4,44(a5)
}
800086c0:	0001                	nop
800086c2:	4472                	lw	s0,28(sp)
800086c4:	6105                	addi	sp,sp,32
800086c6:	8082                	ret

800086c8 <UART_ParityBitConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3
  * @param   ParityBit  Режим
  * @retval  void
  */
__STATIC_INLINE void UART_ParityBitConfig(UART_TypeDef* UARTx, UART_ParityBit_TypeDef ParityBit)
{
800086c8:	1101                	addi	sp,sp,-32
800086ca:	ce22                	sw	s0,28(sp)
800086cc:	1000                	addi	s0,sp,32
800086ce:	fea42623          	sw	a0,-20(s0)
800086d2:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_PARITY_BIT(ParityBit));

    MODIFY_REG(UARTx->LCRH, UART_LCRH_PEN_Msk | UART_LCRH_SPS_Msk | UART_LCRH_EPS_Msk, ParityBit);
800086d6:	fec42783          	lw	a5,-20(s0)
800086da:	57dc                	lw	a5,44(a5)
800086dc:	f797f713          	andi	a4,a5,-135
800086e0:	fe842783          	lw	a5,-24(s0)
800086e4:	8f5d                	or	a4,a4,a5
800086e6:	fec42783          	lw	a5,-20(s0)
800086ea:	d7d8                	sw	a4,44(a5)
}
800086ec:	0001                	nop
800086ee:	4472                	lw	s0,28(sp)
800086f0:	6105                	addi	sp,sp,32
800086f2:	8082                	ret

800086f4 <UART_BaudDivConfig>:
  *                   Параметр принимает любое значение из диапазона 0-63. В случае, если IntDiv
  *                   равен 65535, значение FracDiv может быть только 0.
  * @retval  void
  */
__STATIC_INLINE void UART_BaudDivConfig(UART_TypeDef* UARTx, uint32_t IntDiv, uint32_t FracDiv)
{
800086f4:	1101                	addi	sp,sp,-32
800086f6:	ce22                	sw	s0,28(sp)
800086f8:	1000                	addi	s0,sp,32
800086fa:	fea42623          	sw	a0,-20(s0)
800086fe:	feb42423          	sw	a1,-24(s0)
80008702:	fec42223          	sw	a2,-28(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_UART_INT_DIV(IntDiv));
    assert_param(IS_UART_FRAC_DIV(FracDiv));

    WRITE_REG(UARTx->IBRD, IntDiv);
80008706:	fec42783          	lw	a5,-20(s0)
8000870a:	fe842703          	lw	a4,-24(s0)
8000870e:	d3d8                	sw	a4,36(a5)
    WRITE_REG(UARTx->FBRD, FracDiv);
80008710:	fec42783          	lw	a5,-20(s0)
80008714:	fe442703          	lw	a4,-28(s0)
80008718:	d798                	sw	a4,40(a5)
}
8000871a:	0001                	nop
8000871c:	4472                	lw	s0,28(sp)
8000871e:	6105                	addi	sp,sp,32
80008720:	8082                	ret

80008722 <UART_FIFOCmd>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void UART_FIFOCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80008722:	1101                	addi	sp,sp,-32
80008724:	ce22                	sw	s0,28(sp)
80008726:	1000                	addi	s0,sp,32
80008728:	fea42623          	sw	a0,-20(s0)
8000872c:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->LCRH_bit.FEN, State);
80008730:	fe842783          	lw	a5,-24(s0)
80008734:	8b85                	andi	a5,a5,1
80008736:	0ff7f713          	zext.b	a4,a5
8000873a:	fec42783          	lw	a5,-20(s0)
8000873e:	8b05                	andi	a4,a4,1
80008740:	0712                	slli	a4,a4,0x4
80008742:	02c7c683          	lbu	a3,44(a5)
80008746:	9abd                	andi	a3,a3,-17
80008748:	8f55                	or	a4,a4,a3
8000874a:	02e78623          	sb	a4,44(a5)
}
8000874e:	0001                	nop
80008750:	4472                	lw	s0,28(sp)
80008752:	6105                	addi	sp,sp,32
80008754:	8082                	ret

80008756 <UART_RxCmd>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void UART_RxCmd(UART_TypeDef* UARTx, FunctionalState State)
{
80008756:	1101                	addi	sp,sp,-32
80008758:	ce22                	sw	s0,28(sp)
8000875a:	1000                	addi	s0,sp,32
8000875c:	fea42623          	sw	a0,-20(s0)
80008760:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->CR_bit.RXE, State);
80008764:	fe842783          	lw	a5,-24(s0)
80008768:	8b85                	andi	a5,a5,1
8000876a:	0ff7f713          	zext.b	a4,a5
8000876e:	fec42783          	lw	a5,-20(s0)
80008772:	8b05                	andi	a4,a4,1
80008774:	0726                	slli	a4,a4,0x9
80008776:	0307d683          	lhu	a3,48(a5)
8000877a:	dff6f693          	andi	a3,a3,-513
8000877e:	8f55                	or	a4,a4,a3
80008780:	02e79823          	sh	a4,48(a5)
}
80008784:	0001                	nop
80008786:	4472                	lw	s0,28(sp)
80008788:	6105                	addi	sp,sp,32
8000878a:	8082                	ret

8000878c <UART_TxCmd>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3
  * @param   State  Выбор состояния
  * @retval  void
  */
__STATIC_INLINE void UART_TxCmd(UART_TypeDef* UARTx, FunctionalState State)
{
8000878c:	1101                	addi	sp,sp,-32
8000878e:	ce22                	sw	s0,28(sp)
80008790:	1000                	addi	s0,sp,32
80008792:	fea42623          	sw	a0,-20(s0)
80008796:	feb42423          	sw	a1,-24(s0)
    assert_param(IS_UART_PERIPH(UARTx));
    assert_param(IS_FUNCTIONAL_STATE(State));

    WRITE_REG(UARTx->CR_bit.TXE, State);
8000879a:	fe842783          	lw	a5,-24(s0)
8000879e:	8b85                	andi	a5,a5,1
800087a0:	0ff7f713          	zext.b	a4,a5
800087a4:	fec42783          	lw	a5,-20(s0)
800087a8:	8b05                	andi	a4,a4,1
800087aa:	0722                	slli	a4,a4,0x8
800087ac:	0307d683          	lhu	a3,48(a5)
800087b0:	eff6f693          	andi	a3,a3,-257
800087b4:	8f55                	or	a4,a4,a3
800087b6:	02e79823          	sh	a4,48(a5)
}
800087ba:	0001                	nop
800087bc:	4472                	lw	s0,28(sp)
800087be:	6105                	addi	sp,sp,32
800087c0:	8082                	ret

800087c2 <UART_AutoBaudConfig>:
  * @param   UARTx  Выбор модуля UART, где x=0|1|2|3
  * @param   State  Выбор состояния
  * @retval  void
  */
void UART_AutoBaudConfig(UART_TypeDef* UARTx, uint32_t BaudRate)
{
800087c2:	7179                	addi	sp,sp,-48
800087c4:	d606                	sw	ra,44(sp)
800087c6:	d422                	sw	s0,40(sp)
800087c8:	1800                	addi	s0,sp,48
800087ca:	fca42e23          	sw	a0,-36(s0)
800087ce:	fcb42c23          	sw	a1,-40(s0)
    UART_Num_TypeDef UARTx_Num;
    uint32_t uart_clk_freq, int_div, frac_div;

    assert_param(IS_UART_PERIPH(UARTx));

    if (UARTx == UART0) {
800087d2:	fdc42703          	lw	a4,-36(s0)
800087d6:	300067b7          	lui	a5,0x30006
800087da:	00f71563          	bne	a4,a5,800087e4 <UART_AutoBaudConfig+0x22>
        UARTx_Num = UART0_Num;
800087de:	fe042623          	sw	zero,-20(s0)
800087e2:	a805                	j	80008812 <UART_AutoBaudConfig+0x50>
    } else if (UARTx == UART1) {
800087e4:	fdc42703          	lw	a4,-36(s0)
800087e8:	300077b7          	lui	a5,0x30007
800087ec:	00f71663          	bne	a4,a5,800087f8 <UART_AutoBaudConfig+0x36>
        UARTx_Num = UART1_Num;
800087f0:	4785                	li	a5,1
800087f2:	fef42623          	sw	a5,-20(s0)
800087f6:	a831                	j	80008812 <UART_AutoBaudConfig+0x50>
    } else if (UARTx == UART2) {
800087f8:	fdc42703          	lw	a4,-36(s0)
800087fc:	300087b7          	lui	a5,0x30008
80008800:	00f71663          	bne	a4,a5,8000880c <UART_AutoBaudConfig+0x4a>
        UARTx_Num = UART2_Num;
80008804:	4789                	li	a5,2
80008806:	fef42623          	sw	a5,-20(s0)
8000880a:	a021                	j	80008812 <UART_AutoBaudConfig+0x50>
    } else /*if (UARTx == UART3)*/ {
        UARTx_Num = UART3_Num;
8000880c:	478d                	li	a5,3
8000880e:	fef42623          	sw	a5,-20(s0)
    }

    uart_clk_freq = RCU_GetUARTClkFreq(UARTx_Num);
80008812:	fec42503          	lw	a0,-20(s0)
80008816:	d12ff0ef          	jal	ra,80007d28 <RCU_GetUARTClkFreq>
8000881a:	fea42423          	sw	a0,-24(s0)
    int_div = uart_clk_freq / (16 * BaudRate);
8000881e:	fd842783          	lw	a5,-40(s0)
80008822:	0792                	slli	a5,a5,0x4
80008824:	fe842703          	lw	a4,-24(s0)
80008828:	02f757b3          	divu	a5,a4,a5
8000882c:	fef42223          	sw	a5,-28(s0)
    frac_div = (uint32_t)((uart_clk_freq / (16.0f * BaudRate) - int_div) * 64.0f + 0.5f);
80008830:	fe842783          	lw	a5,-24(s0)
80008834:	d017f753          	fcvt.s.wu	fa4,a5
80008838:	fd842783          	lw	a5,-40(s0)
8000883c:	d017f6d3          	fcvt.s.wu	fa3,a5
80008840:	800097b7          	lui	a5,0x80009
80008844:	e307a787          	flw	fa5,-464(a5) # 80008e30 <__data_source_start+0xffffffdc>
80008848:	10f6f7d3          	fmul.s	fa5,fa3,fa5
8000884c:	18f77753          	fdiv.s	fa4,fa4,fa5
80008850:	fe442783          	lw	a5,-28(s0)
80008854:	d017f7d3          	fcvt.s.wu	fa5,a5
80008858:	08f77753          	fsub.s	fa4,fa4,fa5
8000885c:	800097b7          	lui	a5,0x80009
80008860:	e347a787          	flw	fa5,-460(a5) # 80008e34 <__data_source_start+0xffffffe0>
80008864:	10f77753          	fmul.s	fa4,fa4,fa5
80008868:	800097b7          	lui	a5,0x80009
8000886c:	e387a787          	flw	fa5,-456(a5) # 80008e38 <__data_source_start+0xffffffe4>
80008870:	00f777d3          	fadd.s	fa5,fa4,fa5
80008874:	c01797d3          	fcvt.wu.s	a5,fa5,rtz
80008878:	fef42023          	sw	a5,-32(s0)
    UART_BaudDivConfig(UARTx, int_div, frac_div);
8000887c:	fe042603          	lw	a2,-32(s0)
80008880:	fe442583          	lw	a1,-28(s0)
80008884:	fdc42503          	lw	a0,-36(s0)
80008888:	35b5                	jal	800086f4 <UART_BaudDivConfig>
}
8000888a:	0001                	nop
8000888c:	50b2                	lw	ra,44(sp)
8000888e:	5422                	lw	s0,40(sp)
80008890:	6145                	addi	sp,sp,48
80008892:	8082                	ret

80008894 <UART_DeInit>:
  * @brief   Устанавливает все регистры UART значениями по умолчанию
  * @param   UARTx   Выбор модуля UART, где x=0|1|2|3
  * @retval  void
  */
void UART_DeInit(UART_TypeDef* UARTx)
{
80008894:	7179                	addi	sp,sp,-48
80008896:	d606                	sw	ra,44(sp)
80008898:	d422                	sw	s0,40(sp)
8000889a:	1800                	addi	s0,sp,48
8000889c:	fca42e23          	sw	a0,-36(s0)
    UART_Num_TypeDef UARTx_Num;

    assert_param(IS_UART_PERIPH(UARTx));

    if (UARTx == UART0) {
800088a0:	fdc42703          	lw	a4,-36(s0)
800088a4:	300067b7          	lui	a5,0x30006
800088a8:	00f71563          	bne	a4,a5,800088b2 <UART_DeInit+0x1e>
        UARTx_Num = UART0_Num;
800088ac:	fe042623          	sw	zero,-20(s0)
800088b0:	a805                	j	800088e0 <UART_DeInit+0x4c>
    } else if (UARTx == UART1) {
800088b2:	fdc42703          	lw	a4,-36(s0)
800088b6:	300077b7          	lui	a5,0x30007
800088ba:	00f71663          	bne	a4,a5,800088c6 <UART_DeInit+0x32>
        UARTx_Num = UART1_Num;
800088be:	4785                	li	a5,1
800088c0:	fef42623          	sw	a5,-20(s0)
800088c4:	a831                	j	800088e0 <UART_DeInit+0x4c>
    } else if (UARTx == UART2) {
800088c6:	fdc42703          	lw	a4,-36(s0)
800088ca:	300087b7          	lui	a5,0x30008
800088ce:	00f71663          	bne	a4,a5,800088da <UART_DeInit+0x46>
        UARTx_Num = UART2_Num;
800088d2:	4789                	li	a5,2
800088d4:	fef42623          	sw	a5,-20(s0)
800088d8:	a021                	j	800088e0 <UART_DeInit+0x4c>
    } else /*if (UARTx == UART3)*/ {
        UARTx_Num = UART3_Num;
800088da:	478d                	li	a5,3
800088dc:	fef42623          	sw	a5,-20(s0)
    }

    RCU_UARTRstCmd(UARTx_Num, DISABLE);
800088e0:	4581                	li	a1,0
800088e2:	fec42503          	lw	a0,-20(s0)
800088e6:	3b35                	jal	80008622 <RCU_UARTRstCmd>
    RCU_UARTRstCmd(UARTx_Num, ENABLE);
800088e8:	4585                	li	a1,1
800088ea:	fec42503          	lw	a0,-20(s0)
800088ee:	3b15                	jal	80008622 <RCU_UARTRstCmd>
}
800088f0:	0001                	nop
800088f2:	50b2                	lw	ra,44(sp)
800088f4:	5422                	lw	s0,40(sp)
800088f6:	6145                	addi	sp,sp,48
800088f8:	8082                	ret

800088fa <UART_Init>:
  * @param   InitStruct  Указатель на структуру типа @ref UART_Init_TypeDef,
  *                      которая содержит конфигурационную информацию.
  * @retval  Status  Статус результата инициализации
  */
void UART_Init(UART_TypeDef* UARTx, UART_Init_TypeDef* InitStruct)
{
800088fa:	1101                	addi	sp,sp,-32
800088fc:	ce06                	sw	ra,28(sp)
800088fe:	cc22                	sw	s0,24(sp)
80008900:	1000                	addi	s0,sp,32
80008902:	fea42623          	sw	a0,-20(s0)
80008906:	feb42423          	sw	a1,-24(s0)
    UART_AutoBaudConfig(UARTx, InitStruct->BaudRate);
8000890a:	fe842783          	lw	a5,-24(s0)
8000890e:	47dc                	lw	a5,12(a5)
80008910:	85be                	mv	a1,a5
80008912:	fec42503          	lw	a0,-20(s0)
80008916:	3575                	jal	800087c2 <UART_AutoBaudConfig>
    UART_DataWidthConfig(UARTx, InitStruct->DataWidth);
80008918:	fe842783          	lw	a5,-24(s0)
8000891c:	479c                	lw	a5,8(a5)
8000891e:	85be                	mv	a1,a5
80008920:	fec42503          	lw	a0,-20(s0)
80008924:	3b2d                	jal	8000865e <UART_DataWidthConfig>
    UART_StopBitConfig(UARTx, InitStruct->StopBit);
80008926:	fe842783          	lw	a5,-24(s0)
8000892a:	439c                	lw	a5,0(a5)
8000892c:	85be                	mv	a1,a5
8000892e:	fec42503          	lw	a0,-20(s0)
80008932:	338d                	jal	80008694 <UART_StopBitConfig>
    UART_ParityBitConfig(UARTx, InitStruct->ParityBit);
80008934:	fe842783          	lw	a5,-24(s0)
80008938:	43dc                	lw	a5,4(a5)
8000893a:	85be                	mv	a1,a5
8000893c:	fec42503          	lw	a0,-20(s0)
80008940:	3361                	jal	800086c8 <UART_ParityBitConfig>
    UART_FIFOCmd(UARTx, InitStruct->FIFO);
80008942:	fe842783          	lw	a5,-24(s0)
80008946:	4b9c                	lw	a5,16(a5)
80008948:	85be                	mv	a1,a5
8000894a:	fec42503          	lw	a0,-20(s0)
8000894e:	3bd1                	jal	80008722 <UART_FIFOCmd>
    UART_TxCmd(UARTx, InitStruct->Tx);
80008950:	fe842783          	lw	a5,-24(s0)
80008954:	4f9c                	lw	a5,24(a5)
80008956:	85be                	mv	a1,a5
80008958:	fec42503          	lw	a0,-20(s0)
8000895c:	3d05                	jal	8000878c <UART_TxCmd>
    UART_RxCmd(UARTx, InitStruct->Rx);
8000895e:	fe842783          	lw	a5,-24(s0)
80008962:	4bdc                	lw	a5,20(a5)
80008964:	85be                	mv	a1,a5
80008966:	fec42503          	lw	a0,-20(s0)
8000896a:	33f5                	jal	80008756 <UART_RxCmd>
}
8000896c:	0001                	nop
8000896e:	40f2                	lw	ra,28(sp)
80008970:	4462                	lw	s0,24(sp)
80008972:	6105                	addi	sp,sp,32
80008974:	8082                	ret

80008976 <UART_StructInit>:
  * @param   InitStruct  Указатель на структуру типа @ref UART_Init_TypeDef,
  *                      которую необходимо проинициализировать.
  * @retval  void
  */
void UART_StructInit(UART_Init_TypeDef* InitStruct)
{
80008976:	1101                	addi	sp,sp,-32
80008978:	ce22                	sw	s0,28(sp)
8000897a:	1000                	addi	s0,sp,32
8000897c:	fea42623          	sw	a0,-20(s0)
    InitStruct->BaudRate = 9600;
80008980:	fec42783          	lw	a5,-20(s0)
80008984:	6709                	lui	a4,0x2
80008986:	58070713          	addi	a4,a4,1408 # 2580 <STACK_SIZE+0x1d80>
8000898a:	c7d8                	sw	a4,12(a5)
    InitStruct->DataWidth = UART_DataWidth_8;
8000898c:	fec42783          	lw	a5,-20(s0)
80008990:	470d                	li	a4,3
80008992:	c798                	sw	a4,8(a5)
    InitStruct->FIFO = DISABLE;
80008994:	fec42783          	lw	a5,-20(s0)
80008998:	0007a823          	sw	zero,16(a5) # 30008010 <STACK_SIZE+0x30007810>
    InitStruct->ParityBit = UART_ParityBit_Disable;
8000899c:	fec42783          	lw	a5,-20(s0)
800089a0:	0007a223          	sw	zero,4(a5)
    InitStruct->StopBit = UART_StopBit_1;
800089a4:	fec42783          	lw	a5,-20(s0)
800089a8:	0007a023          	sw	zero,0(a5)
    InitStruct->Rx = DISABLE;
800089ac:	fec42783          	lw	a5,-20(s0)
800089b0:	0007aa23          	sw	zero,20(a5)
    InitStruct->Tx = DISABLE;
800089b4:	fec42783          	lw	a5,-20(s0)
800089b8:	0007ac23          	sw	zero,24(a5)
}
800089bc:	0001                	nop
800089be:	4472                	lw	s0,28(sp)
800089c0:	6105                	addi	sp,sp,32
800089c2:	8082                	ret

800089c4 <memcpy>:
800089c4:	832a                	mv	t1,a0
800089c6:	ca09                	beqz	a2,800089d8 <memcpy+0x14>
800089c8:	00058383          	lb	t2,0(a1)
800089cc:	00730023          	sb	t2,0(t1)
800089d0:	167d                	addi	a2,a2,-1 # 3000ffff <STACK_SIZE+0x3000f7ff>
800089d2:	0305                	addi	t1,t1,1
800089d4:	0585                	addi	a1,a1,1
800089d6:	fa6d                	bnez	a2,800089c8 <memcpy+0x4>
800089d8:	8082                	ret

800089da <memset>:
800089da:	832a                	mv	t1,a0
800089dc:	c611                	beqz	a2,800089e8 <memset+0xe>
800089de:	00b30023          	sb	a1,0(t1)
800089e2:	167d                	addi	a2,a2,-1
800089e4:	0305                	addi	t1,t1,1
800089e6:	fe65                	bnez	a2,800089de <memset+0x4>
800089e8:	8082                	ret
