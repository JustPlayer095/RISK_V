## Модуль `driver/eeprom`

Директория `driver` содержит драйвер для внешней EEPROM‑памяти.  
Его задача — предоставить простые функции `eeprom_init()`, `eeprom_write_bytes()` и `eeprom_read_bytes()`, а также минимальный статус‑интерфейс (`eeprom_is_busy()`, `eeprom_had_error()`), скрывая детали конкретной шины и протокола работы с микросхемой.  
**Пользователь проекта может выбрать, работать ли с EEPROM по SPI или по I2C**

### Файлы

- `eeprom.h` — заголовок модуля:
  - определяет команды SPI (`SPI_CMD_WREN`, `SPI_CMD_WRITE`, `SPI_CMD_READ`, `SPI_CMD_RDSR`) и бит «занятости» в статусе;
  - задаёт базовые параметры EEPROM (размер страницы `EEPROM_PAGE_SIZE`);
  - объявляет функции:
    - `eeprom_init()` — инициализация контроллера шины и линий ввода/вывода;
    - `eeprom_write_bytes(uint16_t addr, const uint8_t* data, size_t len)` — запись блока данных по заданному адресу;
    - `eeprom_read_bytes(uint16_t addr, uint8_t* data, size_t len)` — чтение блока данных;
    - `eeprom_is_busy()` и `eeprom_had_error()` — статус текущей/последней операции.

- `eeprom.c` — реализация драйвера.

  Файл содержит **две альтернативные реализации** драйвера:

  - **SPI‑вариант**:
    - активируется, если при сборке определён макрос `EEPROM_USE_SPI` (по умолчанию он включается в самом `eeprom.c`, если явно не выбран I2C);
    - инициализирует контроллер SPI0, настраивает частоту, режим и выводы (SCK, MISO, MOSI, CS);
    - использует пины порта GPIOB, при этом вывод CS (PB1) управляется как обычный GPIO;
    - регистрирует обработчик прерываний SPI0 в PLIC, который очищает флаги прерываний;
    - хранит статус в простых флагах `g_eeprom_spi_busy` и `g_eeprom_spi_error`.

  - **I2C‑вариант**:
    - активируется, если при сборке определён макрос `EEPROM_USE_I2C` (и не определён `EEPROM_USE_SPI`);
    - настраивает аппаратный I2C‑контроллер, пины на порту GPIOC (SCL/SDA) и прерывания I2C;
    - реализует неблокирующее состояние автомата `eeprom_transaction_t` и обработчик `I2C_IRQHandler`;
    - поддерживает побайтную запись/чтение и ACK‑polling EEPROM с контролем таймаутов.

  **Выбор интерфейса**:
  - чтобы использовать SPI (вариант по умолчанию), можно ничего не задавать явно, либо определить при сборке макрос `EEPROM_USE_SPI`;
  - чтобы перейти на I2C, нужно при сборке задать макрос `EEPROM_USE_I2C` (например, через `DEFINES+=-DEEPROM_USE_I2C` в `make` или соответствующий аргумент в `tasks.json`);
  - внешний интерфейс (`eeprom_init`, `eeprom_write_bytes`, `eeprom_read_bytes`, `eeprom_is_busy`, `eeprom_had_error`) при этом **не меняется**, поэтому остальной код проекта не нужно править.

  Основные функции:

  - `eeprom_init()`  
    Выполняет инициализацию выбранного интерфейса (SPI или I2C): настраивает тактирование, режим работы, выводы и прерывания через внутренние функции (`spi0_init()` или `I2C_Master_Init()`).

  - `eeprom_write_bytes(uint16_t addr, const uint8_t* data, size_t len)`  
    Записывает произвольный буфер в EEPROM с учётом ограничений конкретной микросхемы:
    - не допускает параллельных транзакций (использует внутренний флаг «занятости»);
    - при необходимости разбивает операцию на участки внутри страницы EEPROM (`EEPROM_PAGE_SIZE`);
    - инициирует цикл записи и ждёт, пока микросхема завершит внутреннюю запись (через опрос статуса — либо регистра SPI, либо подтверждения ACK по I2C);
    - при превышении таймаута или ошибке помечает состояние «ошибка».

  - `eeprom_read_bytes(uint16_t addr, uint8_t* data, size_t len)`  
    Читает блок данных:
    - формирует запрос чтения по выбранному интерфейсу (SPI или I2C) с нужным адресом;
    - считывает запрошенное количество байт в буфер;
    - помечает состояние «занятости» только на время активной операции.

  - `eeprom_is_busy()` / `eeprom_had_error()`  
    Возвращают, соответственно, признак того, что в данный момент идёт операция с EEPROM, и флаг ошибки последней операции.  
    Эти функции используются, например, модулем `config` для организации таймаутов и проверки успешности чтения/записи конфига независимо от того, выбран SPI или I2C.

### Как это используется в проекте

- Модуль `config`:
  - вызывает `eeprom_init()` один раз при старте системы (через `periph_init()` в `main.c`);
  - использует `eeprom_write_bytes()` и `eeprom_read_bytes()` для записи и чтения структуры `config_storage_t`;
  - контролирует завершение операций, вызывая `eeprom_is_busy()` и `eeprom_had_error()` с таймаутами по `ms_ticks`.

Таким образом, остальная прошивка видит EEPROM как простое «постоянное хранилище по адресам», а не как конкретную SPI/I2C микросхему с протоколом и статусными регистрами.

