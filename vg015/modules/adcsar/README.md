## Модуль `adcsar`

Директория `adcsar` содержит код работы с АЦП ADCSAR микроконтроллера К1921ВГ015. Модуль:
- инициализирует АЦП и настраивает последовательность выборки одного канала;
- запускает непрерывные преобразования;
- по результатам измерения относит сигнал к одному из логических состояний (короткое замыкание, тревога, норма, тампер);
- предоставляет удобную структуру выборки для использования в основном цикле.

### Файлы

- `adcsar.h` — заголовок модуля:
  - определяет пороговые значения АЦП (`ADCSAR_THR_SHORT_MAX`, `ADCSAR_THR_ALARM_MIN` и т.д.), с помощью которых код АЦП разделяется на зоны;
  - задаёт перечисление `adcsar_state_t` (состояния: `UNDEF`, `SHORT`, `ALARM`, `NORMAL`, `TAMPER`);
  - описывает структуру `adcsar_sample_t` с полями:
    - `raw_code` — сырой код АЦП (8‑бит в текущей конфигурации);
    - `state` — состояние в виде перечисления;
    - `state_char` — компактное символьное представление состояния (`'T'`, `'A'`, `'N'`, `'S'`, `'U'`);
  - объявляет функции: `adcsar_init()`, `adcsar_start()`, `adcsar_poll()`, `adcsar_classify_code()`.
- `adcsar.c` — реализация:
  - настраивает питание АЦП и тактирование (через регистры `PMUSYS` и `RCU`);
  - включает АЦП и калибровку, настраивает последовательность `SEQ0` на один канал и запускает её по программному запросу;
  - регистрирует обработчик прерывания АЦП в PLIC (`ADC_IRQHandler`) и включает прерывания по завершению выборки;
  - в обработчике прерываний очищает флаги и выставляет внутренний флаг `s_adc_irq_flag`;
  - в `adcsar_poll()` при наличии нового результата:
    - выбирает последнее значение из FIFO АЦП;
    - классифицирует код по порогам в символ состояния;
    - заполняет структуру `adcsar_sample_t` и перезапускает преобразование.

### Как использовать

1. Однократно вызвать `adcsar_init()` при инициализации периферии (делает `main.c` в `periph_init()`).
2. После инициализации запустить непрерывные измерения `adcsar_start()`.
3. В основном цикле периодически вызывать:
   - `adcsar_sample_t sample;`
   - `if (adcsar_poll(&sample)) { /* есть новая выборка */ }`
4. По полю `sample.state_char` и/или `sample.state` можно реагировать на состояние сигнала либо печатать его в лог (как делается в `main.c`).

Код модуля не знает о конкретном физическом назначении входа — он лишь преобразует аналоговый сигнал в удобное логическое состояние по заданным порогам.

